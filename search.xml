<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[用浏览器也能挖矿！把力量借给我吧]]></title>
      <url>%2Fminer-for-my-website%2F</url>
      <content type="text"><![CDATA[昨天读到了余博伦老师的前端开发者转行挖矿的特别技巧一文，觉得很有意思，于是在 Coinhive 上折腾了几个小时。目前，本博客已通过加了几行 JavaScript 代码开启挖门罗币的功能。这意味着，当你阅读本博客的同时，你电脑的 CPU 在帮我做一些计算。我把浏览器挖矿的线程调整有 50% 的空闲时间（即速度只有满速的一半），因此对你的电脑运行不会有什么大的影响。而手机浏览本博客不会启动挖矿，避免手机因性能较差而导致发热。 并且，由于本博客日均 PV 只有 10 左右，因此实际上基本挖不了多少。不如说，因为暂时没找到申请 Google 账号以开启 Google Analysis 的方法，我把 Coinhive Dashboard 当作一个更好的访问数据统计。 通过这种方式，阅读本博客进行阅读、学习的行为本身，成为一种对博主的赞赏与激励，我认为这是一种很有趣的互惠形式。尽管实质上的影响很小，但是你的帮助会鼓励我更勤奋地写高质量的博客，也为我接触了解现在炙手可热的加密货币提供了途径和动力。 如果你想对浏览器挖矿有个直观的感受的话，你可以通过下面这个最简单的实例来查看每秒钟计算出的 hash 数等数据，还可以调整参数。 Loading… 而如果你想要了解更多有关门罗币、Coinhive、浏览器挖矿的事情，推荐你阅读文章开头提到的那篇文章，即使不是前端开发者也可以轻松阅读。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法一篇通——贪心算法]]></title>
      <url>%2FGreedy-algorithm%2F</url>
      <content type="text"><![CDATA[之前在写算法一篇通——动态规划时，看到不少相关的资料都谈到了贪心算法。原本我对贪心算法的认知比较简单，但是越看越混，尤其是和动态规划的差异，少有文章能说的准确透彻。因此，这几天也对贪心算法加以了解学习。 给出 n 个物体，第 i 个物体重量为 wi，要求选择尽量多的物体，使得总重量不超过 C。对于这个问题，我们很容易想到，因为在对总重量有要求的情况下要选择尽量多的物体，因此挑轻的肯定比挑重的划算。这样，我们将所有物体按重量从小到大排序，依次选择每个物体，直到装不下为止。 这就一种典型的贪心算法，只顾眼前利益，做出局部最优的选择，寄希望于这样的选择能导致全局最优解。 概念理解贪心算法（Greedy Algorithm，又称贪婪算法），指在对问题求解时，不从整体最优上加以考虑，而总是做出在当前看来是最好的选择。也就是说，所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态只与它前面出现的状态有关，而独立于后面的状态。 贪心算法的两个性质是贪心选择性质和最优子结构性质： 贪心选择性质：指所求的问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。 最优子结构（optimal substructure）性质：如果原问题的最优解包含的子问题的最优解，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“全局最优解包含局部最优解”的思想。 贪心算法与动态规划的区别 贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。 贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。 动态规划主要运用于二维或三维问题，而贪心一般是一维问题。 实际上，贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算。 尽管贪心算法和动态规划都有最优子结构性质，我认为这个性质在两种算法中有着不太一样的含义：贪心的局部最优能达成全局最优，而动态规划的全局最优值中不一定全是局部最优，只是求解全局最优时要以局部最优作为基础。或者，我们可以认为，贪心算法通常都是自顶向下进行设计的，而动态规划则自顶向上。 解题思路贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。 例题 菜鸟级这里我选了 LeetCode 的第 122 题 Best Time to Buy and Sell Stock II。题目是这样的：给定一个数组，第 i 个元素代表第 i 天石头的买卖价。找到一种赚取最大利润的方法，你可以进行任意次交易，但是不能同时处于两笔交易中（即必须先将手上的石头卖出去才能再买）。 解答根据贪心选择的性质，只要能赚到钱，我们就卖掉手上的石头。那么，只要后一天的价格比前一天高，我们就做买入卖出这一笔买卖。于是有代码如下： 12345678public int maxProfit(int[] prices) &#123; int total = 0; for (int i = 0; i &lt; prices.length-1; i++) if (prices[i+1] &gt; prices[i]) total += prices[i+1]-prices[i]; return total;&#125; 这样的思路是简单粗暴而有效的，但是可能需要结合多种情况考虑一下，为什么这样做是对的（我们设第 i 天的价格为 s[i]）： s[i] &lt; s[i+1] &lt; s[i+2]：这样的话，按照之前的解法，相当于省略掉中间那一笔卖出买入，只考虑第 i 天和第 i+2 天； s[i] &gt; s[i+1] &lt; s[i+2]：这样的话，我们的算法会当作没有买入过第 i 天的石头。 普通级挑战者级这里我选择的是 LeetCode 的第 135 题，是一道 hard 难度的题目。N 个小朋友排排坐，每个小朋友有一个分值。你需要给小朋友发糖，遵循以下规则： 每个小朋友保底一块糖； 若比左右邻居得分高，则得到的糖更多。 求最少发多少糖。 解答需要拿一个与输入数组同样大小的数组来存储每个孩子的糖果树。 先从 0 开始向右遍历一次：第 0 个孩子先拿一块；i &gt; 0 时，如果 ratings[i] &gt; ratings[i-1]，那么第 i 个孩子在第 i-1 个孩子所拥有的糖果数上多拿一块，否则拿保底的一块。这一次遍历将右边的 rating 比左边大的情况全部搞定。 再从 len-1 开始向左遍历一次：第 len-1 个孩子不变，如果 ratings[i] &lt; ratings[i-1]，那么，除非第 i-1 个孩子本身拥有的糖果数已经比多拿这一块后还要多，否则第 i－1 个孩子在第 i 个孩子所拥有的糖果数上多拿一块。这一次遍历将左边的 rating 比右边大的情况全部搞定，并且不会影响到上一次遍历所完成的工作。 因为每一次发糖都遵循贪心选择性质，最多多给一块，并且没有后效性，因此也是贪心算法的运用。 尽管时间复杂度和空间复杂度都不是最优的，但上述解法能够 AC，并且简洁易懂。当然，这个思路还是比较巧妙的，也很难短时间内想出来。 扩展和动态规划一样，贪心算法也扩展许多衍生的问题与算法。例如，深度学习中的梯度下降算法就是贪心的。更著名的一些如下。 哈夫曼编码我们可以用 01 编码串来代表一个字符，例如 a 为 0，c 为 00，f 为 1100。这样，可能因为其中一个字符的编码是另一个字符的前缀而导致歧义。满足任何一个编码都不是另一个的前缀的编码被称为前缀码（Prefix Code）。 这样，我们很容易想到，给定 n 个字符在文件中的出现频率 ci，求一套总长度（每个字符的频率与编码长度乘积的总和）尽量小的编码。根据一个已知结论：任何一个前缀编码都可以表示成每个非叶结点恰好有两个子结点的二叉树，我们可以通过构造一棵最优的编码树来解决这个问题。 Huffman 算法：把每个字符看作一个单结点子树放在一个树集合中，每棵子树的权值等于对应字符的频率。每次取权值最小的两棵子树合并成一棵新树，并重新放到集合中。新树的权值等于两棵子树权值之和。 从以下结论可以体现 Huffman 算法是一种贪心算法： 设 x 与 y 是频率最小的两个字符，则存在前缀码使得 x 和 y 具有相同码长，且仅有最后一位编码不同。这体现了贪心算法的贪心选择性质。 设 T 是加权字符集 C 的最优编码树，x 和 y 是树 T 中的两个叶子，且互为兄弟结点，z 是它们的父结点。若把 z 看作具有频率 f(z) = f(x) + f(y) 的字符，则树 T’ = T - {x, y} 是字符集 C’ = C - {x, y}U{z} 的一棵最优编码树。这体现了贪心算法的最优子结构性质。 Prim 算法 和 Kruskal 算法Prim 算法 和 Kruskal 算法都是在加权无向图找到最小生成树的算法，它们也都是贪心算法。 Prim 算法：每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加 V-1 条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入树中。 Kruskal 算法：按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有 V-1 条边为止。我们从一片由 V 棵单顶点的树构成的森林开始并不断将两颗树合并（用可以找到的最短边），直到只剩下一棵树，它就是最小生成树。 如果你想要更详细地了解这部分内容，可以查看我《算法》笔记的相关章节：Algorithms-notes/笔记/4.3 最小生成树 。 启发式算法很多的启发式算法（也叫智能算法），例如遗传算法，模拟退火算法，本质上就是贪心算法和随机化算法结合。这样的算法结果虽然也是局部最优解，但是比单纯的贪心算法更佳靠近最优解。 结语随着第二篇算法学习的总结笔记出炉，我发现除开大二上学期《算法与数据结构》课程提到的基础而有限的算法之外，还有很多算法处于我的认知边缘之外。我准备把对这些算法的学习全部汇总到一个系列，取名为“算法一篇通”，希望写作效果能够恰如其名。 贪心算法也不简单。之后我可能还会再做一些这个方面的题，届时再进行补充。 参考资料写作参考 贪心算法_百度百科 《算法竞赛入门经典（第 2 版）》第 8 章 《算法导论》第 16 章 学习参考 大白话解析模拟退火算法 - 苍梧 - 博客园]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Goodbye 2017, hello 2018]]></title>
      <url>%2Fbye2017hello2018%2F</url>
      <content type="text"><![CDATA[2017 年过去了，我很怀念它。 时间匆匆，转眼又到了一年的结尾。现在我坐在图书馆里，周围很多考研的学长学姐明天就要奔赴考场，其中也包括院队的几个老大哥。明年的这时我在哪里？在做什么？没有答案。 这个博客的第一篇文章在去年的 12 月 4 号写下，迄今也有一年有余了。看了看去年的总结和展望，大部分的计划都实现了，大概是因为写的比较保守的缘故。而“早睡早起”、“尽量不翘课”、“在自己真正的兴趣上利用时间”、“每天过得健康、充实、开心”这几点没有做到，尤其是最后一点。 2017 年，尤其是下半年，我时常想要遵从兴趣、学习技术、保持自信、做到更好，但又日复一日地跟懒惰、压力、无所适从、自我怀疑、对未知的未来的恐惧作着斗争。20 岁的路口有了更多的分岔，很多以前从来没有想过的东西不停地折磨着我，而我又不是那种十分豁达开朗的性格，只能尽力不在这些负面情绪中沉沦。也许在新的一年里斗争还会继续下去，我希望最终乐观战胜忧郁，我战胜过去的自己。 总之，无论是论取得的各种成果，还是既有价值观的动荡，2017 年于我个人都是重要的一年。让所有的改变在 2018 年来得更猛烈一些吧，我喜欢这种改变。 2017 年终总结成果到落笔为止，值得一提的成果有： 2017 年更新了博客 45 篇，总访问量达到 2400 余次（估计有一半是自己贡献的，哈哈）。 Github 有 599 次 contributions，9 个 star。 LeetCode 做了 106 道题，还在每日增加中。 砍下了花旗杯的三等奖，这是我第一个含金量比较高的奖，还是很有纪念意义的。 必修绩点保持在 3.52，不算高，但是应该可以保研。 课余学习的技术： 大二下学期自己学习前端，主要是玩 Vue 框架以及相关生态环境； 暑假在花旗杯项目开发的空余时间稍微学了一些 Node.js； 大三上学期在朱老师这里，初步地学了一些机器学习和 Spark 的东西，并有了包括读论文在内的学术研究的意识。 思想我的一些观念和思想在这一年有了很大的变化，其中一些我觉得比较通用的，在这里和大家分享： 敏捷学习：在软件工程领域，有些知识是需要稳扎稳打的：数据结构与算法、Unix、数据库、计算机组织与体系结构、操作系统、计算机网络…但是，在实际开发中，也有很多东西需要快速上手，读一遍官方文档就可以慢慢地开始使用，在实践中加深理解。“工程师的工作大部分就是造轮子与用轮子，而工具的逐渐标准化使得重复造轮子的需求越来越弱，越来越多的工程师核心任务并不是研发，而是整合。”要善于利用各类工具，快速地实现自己的想法。尤其对于轮子满天飞的前端来说，快速地使用各类工具是必备的技能。很多工具可能只用一次，但对于更多比较常用的工具，需要记录自己的使用经验，方便自己下一次迅速上手。这也是为什么要写博客的原因之一。敏捷学习不代表用完就忘，也是要形成自己的知识体系的，我在这方面还有欠缺。 敢于实践：紧接上一条。相信在学习的过程中，我们都会产生很多有意思的想法。对于我个人来言，很多想法都因为不愿投入时间和精力、担心半途而废，或是直接被难度给吓倒而成为空想，相关技术也失去了学习和实践的机会，目前只有 yuki 算是写出来了。但是看到别人很多有意思的东西，又非常眼馋。这个月我创了一个 repo 作为专门记录这些想法的想法库，以提醒自己，希望一步一步地去实现它们。 社交：真正熟悉我的人，应该会知道我是一个大多数时候都喜欢独处的人，性格偏内向，不爱和陌生人打交道。通过这一年的很多经历和体验，我开始发觉社交的重要性。例如，当你想要找一些有技术特长、有时间的队友参加比赛，当你需要了解某方面的消息，当你需要获取一些资源和机会，等等。在新的一年里，我想要鼓励自己去开展更广泛的社交。当然，我还是比较偏爱有效交流以及不受他人打扰的独处时光。这需要一定的功力去保持平衡。 个人品牌（个人影响力）：这一年开始通过 Github、知乎、掘金、微博、个人博客、微信公众号等途径了解一些大牛。他们在分享自身的技术心得、工作经验、生活体验的同时，也在打造自己的个人品牌，辐射自己的个人影响力。良好的个人品牌使得他们拥有更多机会结识同样优秀的业内外人士、在寻找新工作时能收获更多橄榄枝、更方便与人展开交流等优势。从博客和 Github 开始，我试着也去慢慢打造这样一张隐形的名片，也是社交的一种，并锻炼着我包括写作在内的各种能力。想要打造好这张名片，也需要更多技术历练和人生阅历。 财务自由、投资理财：我一直是一个不太重视财务的人，因为我平时除了生活必需外基本不花钱，或者说，比较抠。随着愈发地喜欢这个行业，我也会发现很多时候，你的贫穷确实限制了你的想象力。比如我现在都不舍得掏钱买服务器，更别说买一些有意思的东西或者换电脑了。我希望自己开始培养投资理财的思维，慢慢实现财务自由，至少能够有一些收入来让自己的生活更舒服。 程序员的第二技能（收入）：和上一条有关。这两天中兴技术主管跳楼的事也是沸沸扬扬，都说程序员吃青春饭，被认为是中年危机最严重的一个群体。我认为程序员如何保护自己？这篇文章中有一个观点很棒：程序员一定要根据个人兴趣爱好选择第二技能并加以培养，使其成为特殊时期能够支撑自己的存在。第二技能也有助于树立之前说到的个人品牌。 2018 未来展望 各领域知识的查漏补缺：数据结构与算法、Unix、数据库、计算机组织与体系结构、操作系统、计算机网络等等。因为要找实习和夏令营，这大概会是 2018 上半年的主旋律。 前端 / ML 学习：把这两个主攻方向单独拎出来。机器学习就跟着自己的节奏保持学习进度即可，当然也要重视实践。前端方面跟身边人聊了一下，可能考虑要暂时放一下了，以科研方面的学习为主。 博客：继续保持高质量、较频繁的更新，将自己觉得不错的文章向知乎和掘金转移。其中，一些以前的、比较乱的读书笔记可能会根据知识点进行编排重整。另外，试着做一下 SEO，关注一下各类数据。 学术研究：慢慢培养看论文的习惯。按照标准认真读，做一些简短的笔记。和朱老师经常交流一下，争取一些项目、论文的机会。 社交：可以在在其他社区适当推广自己 Github 上的项目以及博客的文章，和他人保持友好的互动交流。 比赛：到暑假为止可能还要参加一到两个比赛。做好准备工作，到时全身心投入，不后悔即可。 实习：希望能找到行业领先的、氛围良好的、自成文化的公司，去体验，去学习。顺其自然吧。 保研：尽力去追求更好的、更适合自己的。 结语新的一年，博客继续努力更新，欢迎保持关注，经常来逛逛（如果你使用 RSS，也是极好的）。另外，你可以在博客的左边栏中的“站点梗概”找到我的 Github 和知乎账号，在这里我会经常点赞、分享我看到的有价值的 repo 和文章。关注它们可以更详细地了解我最近在学什么、做什么、玩什么，也欢迎在这些地方分享、点赞我的 repo 和文章。 感谢你看到这里。让更好的我们在 2018 相会！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法一篇通——动态规划]]></title>
      <url>%2FDynamic-programming%2F</url>
      <content type="text"><![CDATA[上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。 另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，但是如果抱着只能二选一的心态去学习，只能说明自己不够勤奋。之后的学习目标首先是为读研打好稳固基石，然后也要涉及多方面的知识。 回到正题。这次实习考试的第一题在当时没有思路，出来后同学讨论说要用到动态规划思想。之前有听过几次这个词，但是没有去了解，恰逢这个机会（以及为之后的美赛做准备），查阅了很多资料。在此总结一下我对动态规划的了解，以及用几个例子来说明，希望能尽可能地把动态规划给弄通。 概念理解动态规划（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常用于求解最优化问题（Optimization problem）。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题，我们就称其为原问题的子问题。 动态规划的核心是状态和状态转移方程： 状态：描述该问题的子问题的解，即根据子问题来定义状态。 状态转移方程：状态和状态之间的关系式。大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态（无后效性）。 能使用动态规划思想解决的问题都有最优子结构性质和重叠子问题： 最优子结构（Optimal substructure）性质：如果问题的最优解所包含的子问题的解也是最优的，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“全局最优解包含局部最优解”的思想。 重叠子问题：指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 解题思路动态规划的解题思路如下： 将原问题分解为子问题； 确定状态：状态不是随便定义的，一般定义完就要找到状态转移方程； 确定一些初始状态（边界状态）的值； 确定状态转移方程。 如果问题看起来是个动态规划问题，但是无法定义出状态，那么试着将问题规约到一个已知的 DP 问题。 例题讲了这么多，让我们一起做几道题目来练练手！ 菜鸟级这里我选了 LeetCode 的第 70 题 Climbing Stairs。说来惭愧，我第一次做这个题的时候半天没做出来，还先跳过去了。 题目是这样的：假设你在爬梯子，需要 n 步爬到顶。每一次只能爬 1 或 2 格，爬到顶一共有多少种不同的方法？ 一步步沿着前面提到的解题思路来解题： 将原问题分解为子问题：这里的子问题即“爬到 i 格共有多少种不同的方法（i &lt; n）”； 确定状态：我们通常用一个函数表达式来表示状态。这里我们可以用d(i)来表示“爬到 i 格共有的不同的方法数”； 确定一些初始状态（边界状态）的值：d(1) = 1、d(2) = 2； 确定状态转移方程：当我们得知d(i-2)时，再往上爬一次 2 格即可到达 i 格；当我们得知d(i-1)时，再往上爬一次 1 格即可到达 i 格。因此有d(i) = d(i - 1) + d(i - 2)。没有重叠的解法，因为最后一步要么爬 1 格，要么爬 2 格，我们将这两种自然分开了。 使用递归，我们写出如下代码： 1234567public int climbStairs(int n) &#123; if(n == 1) return 1; if(n == 2) return 2; return climbStairs(n-1) + climbStairs(n-2);&#125; Submit 就可以看到红红的 Time Limit Exceeded。计算时间超了，这是因为对于每一个 i，由于递归调用，我们反复求解相同的子问题，使得所作的工作量爆炸性增长。想要节省这些计算，我们可以采用拿空间换时间的方法，用一个大小为 n 的数组来记录子问题的计算结果： 123456789101112131415public int climbStairs(int n) &#123; int[] arr = new int[n+1]; for(int i = 1; i &lt; n+1; i++) fill(i, arr); return arr[n];&#125; private void fill(int n, int[] arr) &#123; if(n == 1) arr[n] = 1; else if(n == 2) arr[n] = 2; else arr[n] = arr[n-1] + arr[n-2];&#125; AC，Run Time 5ms。 也可以用递推法来解决，本质是一个 fibonacci。这里借 Discuss 里的解法一用： 1234567891011121314151617public int climbStairs(int n) &#123; // base cases if(n &lt;= 0) return 0; if(n == 1) return 1; if(n == 2) return 2; int one_step_before = 2; int two_steps_before = 1; int all_ways = 0; for(int i=2; i&lt;n; i++)&#123; all_ways = one_step_before + two_steps_before; two_steps_before = one_step_before; one_step_before = all_ways; &#125; return all_ways;&#125; 普通级稍微加点难度，来试一下 LeetCode 的第 198 题 House Robber。 题目：你是一个超高校级的小偷，唯一能阻止你的是你同一夜不能偷相邻的两家，否则警报装置会响。给一个全是非负整数的数组来代表每家有的钱，求你在不惊动警报的基础上今晚的最大收获。 还是一步步沿着动态规划的解题思路来解题： 将原问题分解为子问题：假设数组长度为 n，则这里的子问题即“有 i 家可偷时最大收获（i &lt; n）”； 确定状态：用g(i)代表第 i 家有的钱，用d(i)来表示“有 i 家可偷时最大收获”； 确定一些初始状态（边界状态）的值：d(1) = g(1)、d(2) = max(g(1), g(2))； 确定状态转移方程：可以想到，到第 i（i &gt; 2）间屋子时，可能之前偷了第 i-1 间，那这间就不能偷；如果没偷第 i-1 间，那这间可以偷。于是有d(i) = max(d(i-2)+g(i), d(i-1))。 用数组来记录偷过第 i 间屋子时最大收获，代码如下： 123456789101112131415161718public int rob(int[] nums) &#123; int n = nums.length; int[] d = new int[n]; if(n == 0) return 0; for(int i = 0; i &lt; n; i++) fill(d, nums, i); return d[n-1];&#125; private void fill(int[] d, int[] nums, int i) &#123; if(i == 0) d[i] = nums[0]; else if(i == 1) d[i] = Math.max(nums[0], nums[1]); else d[i] = Math.max(d[i-2]+nums[i], d[i-1]);&#125; Run Time 接近 0，非常理想。 也有非常巧妙的递推方案，空间复杂度 O(1)： 12345678910public int rob(int[] num) &#123; int prevNo = 0; int prevYes = 0; for (int n : num) &#123; int temp = prevNo; prevNo = Math.max(prevNo, prevYes); prevYes = n + temp; &#125; return Math.max(prevNo, prevYes);&#125; 挑战者级来试试 LeetCode 的第 646 题 Maximum Length of Pair Chain。这是一道难度为 medium 的题，建议先跳过这一小节，看完“扩展”中的“最长非降子序列（LIS）”再回来，有助于解决和理解这道题。 题目：给定 n 对数，每一对中前一个数总小于后一个数。现在，我们定义当且仅当b &lt; c时(c, d)可以跟在(a, b)后，来形成一条链。给定一系列对，求出用上述方法形成的链条的最大长度。不需要用完所有的给定对，而且可以以任意顺序选取。 可以看到，这题和 LIS 问题比较相似，但又有一些不同。由于可以以任意顺序选取，而非 LIS 问题中选取最长非降子序列的顺序固定，因此需要对一系列数对进行一个从小到大的排序。 状态转移方程为： 1d(i) = max&#123;1, d(j)+1&#125;，其中 j &lt; i，pairs[j][1] &lt; pairs[i][0] 想要求d(i)，就把 i 前面的各个链中，最后一个数对的最大值不大于pairs[i][0]的序列长度加 1，然后取出最大的长度即为d(i)。当然，有可能 i 前面的各个链中最后一个数对的最大值都大于pairs[i][0]，那么d(i)=1，即它自身成为一个长度为 1 的子序列。 代码如下： 123456789101112131415public int findLongestChain(int[][] pairs) &#123; Arrays.sort(pairs, (a, b) -&gt; (a[1] - b[1])); int len = pairs.length; int[] arr = new int[len]; int l = 1; for(int i = 0; i &lt; len; i++) &#123; arr[i] = 1; for(int j = 0; j &lt; i; j++) if(pairs[j][1] &lt; pairs[i][0] &amp;&amp; arr[j] + 1 &gt; arr[i]) arr[i] = arr[j] + 1; if(arr[i] &gt; l) l = arr[i]; &#125; return l;&#125; 时间复杂度是 O(n^2)，不是最佳解法。由于根据数对的最大值排好了序，因此可以直接用下列方法来完成： 12345678910public int findLongestChain(int[][] pairs) &#123; Arrays.sort(pairs, (a,b) -&gt; a[1] - b[1]); int sum = 0, n = pairs.length, i = -1; while (++i &lt; n) &#123; sum++; int curEnd = pairs[i][1]; while (i+1 &lt; n &amp;&amp; pairs[i+1][0] &lt;= curEnd) i++; &#125; return sum;&#125; 具体实现方法总结经过以上三个例题的锻炼，一般难度的动态规划问题应该都能解决了。总结一下，动态规划思想具体实现有以下两种方法： 可以用带备忘的自顶向下法（top-down with memoization）的方法计算状态转移方程。此方法仍然按自然的递归形式编写过程，但是用一个数组或者散列表来存储每个子问题的解，当需要时先检查是否已经保存过此解并取用。 还可以采用递推法自底向上地计算状态转移方程。递推的关键是边界和计算顺序，将子问题按照规模从小到大进行求解，当求解某个子问题时，其所依赖的更小的子问题都已求解完毕。在多数情况下，递推法的时间复杂度是：状态总数 每个状态的决策个数 决策时间。如果不同状态的决策个数不同，需具体问题具体分析。注意递归和递推的区别：一个自顶向下，一个自底向上。 扩展最长非降子序列（LIS）给定一个序列A[1]、A[2]、...、A[n]，求其最长非降子序列（LIS，longest increasing subsequence）的长度。这是讲动态规划时基本都会讲到的一个问题。 其最小子问题即求A[1]、A[2]、...、A[i]的最长非降子序列的长度，其中i &lt; N；而状态则定义有d(i)表示前 i 个数中以A[i]结尾的最长非降子序列。 当要考虑初始状态（边界状态）的值时，最好是以一个实际输入为例。假定要求的序列是：5, 3, 4, 8, 6, 7，则有： 前 1 个数的 LIS 长度d(1) = 1； 前 2 个数的 LIS 长度d(2) = 1（序列：3；3 前面没有比 3 小的）； 前 3 个数的 LIS 长度d(3) = 2（序列：3，4；4 前面有个比它小的 3，所以d(3)=d(2)+1）； 前 4 个数的 LIS 长度d(1) = 1（序列：3，4，8；8 前面比它小的有 3 个数，所以d(4) = max{d(1),d(2),d(3)}+1 = 3）； 由此得到状态转移方程： 1d(i) = max&#123;1, d(j) + 1&#125;，其中 i &gt; j，A[i] &gt;= A[j] 想要求d(i)，就把 i 前面的各个子序列中，最后一个数不大于A[i]的序列长度加 1，然后取出最大的长度即为d(i)。当然，有可能 i 前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1，即它自身成为一个长度为 1 的子序列。 代码实现如下： 12345678910111213int lis(int[] A) &#123; int n = A.length; int len = 1; int[] d = new int[n]; for(int i = 0; i &lt; n; i++) &#123; d[i] = 1; for(int j = 0; j &lt; i; j++) if(A[j] &lt;= A[i]) d[i] = Math.max(d[i], d[j] + 1); len = Math.max(d[i], len); &#125; return len;&#125; 时间复杂度为 O(n^2)，不是最优解法。可以看看最长递增子序列 O(NlogN)算法，有点复杂，这里就不多谈了。 背包问题0-1 背包问题是最广为人知的动态规划问题之一，拥有很多变形。 有 n 种物品，每种只有一个。第 i 种物品的体积为 V[i]，价值为 W[i]。选一些物品装到一个容量为 C 的背包，使得背包内物品在总体积不超过 C 的前提下价值尽量大。1 &lt;= n &lt;= 100，1 &lt;= V[i] &lt;= C &lt;= 10000，1 &lt;= W[i] &lt;= 10^6。 将原问题分解为子问题后，状态还是比较好找的。我们可以用d(i, j)来表示前 i 个物品装到剩余体积为 j 的背包里能达到的最大价值。 对于第 i 个物品，可以装进或不装进背包。不装进背包，则背包中物品最大总价值为d(i-1, j)；而如果装进背包，对于前 i-1 个物品的空间就只有 j-V[i] 了。 由此得到状态转移方程： d(i, j) = max{d(i-1, j), d(i-1, j-V[i]) + W[i]} 得到状态转移方程后，代码也不难写出了。这里就不贴了，有兴趣可以自己试试。 Dijkstra 算法Dijkstra 算法也是以动态规划为基础的。你可以到我《算法》笔记的相关章节对 Dijkstra 算法进行进一步了解：Algorithms-notes/笔记/4.4 最短路径 （Dijkstra 算法相关内容正在添加中）。 结语动态规划有着很强的理论性和实践性，可以考验出算法能力，因此经常在各类算法竞赛、面试题中出现。想要完全掌握，光搞定这一篇博客的几个例题远远不够，只有多做经典题目，才能当再碰到动态规划相关题目的时候做到游刃有余。 参考资料写作参考 动态规划：从新手到专家 教你彻底学会动态规划——入门篇 - CSDN博客 《算法竞赛入门经典（第 2 版）》第 9 章 学习参考 漫画：什么是动态规划？ - 掘金：可以借助这个漫画来理解动态规划，并了解动态规划在某些背包问题的特例上计算速度的局限性。 动态规划之背包问题（一） 什么是动态规划？动态规划的意义是什么？ - 知乎 姊妹篇 算法一篇通——贪心算法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的终点，新的起点]]></title>
      <url>%2Fnew-end-new-start%2F</url>
      <content type="text"><![CDATA[在从成都回武汉的火车上开始写这一篇博客。 历时共七个月的花旗杯终于结束了。作为创队元老，我从头到尾参与了这个项目，从每个组员的奇思妙想中挖掘出我们现在的选题，在一次次的争论中始终坚持它就是最好的选择。我也投入了大量的时间和精力，写完了整个网站前端开发的每一行代码。整个项目也数次从被放弃的边缘拉回来，成员也有一定的变动，可以说历经波折了。 到达成都后，临行前请人算了一卦的浦先生幸运地抽到答辩的最后一位，这让我们可以观摩其他队伍的答辩、对评委的关注点进行揣摩，并有较为充足的准备时间。之后，前往成都的核心队员开始昼夜不分地修改项目计划书、PPT、展示讲稿等各种材料，直到上台答辩的最后一秒。这个过程中，另外四名成员应该比我要更为辛苦，在答辩前一夜，负责算法的曹队和冯大佬更是直到凌晨三点还在讨论评委可能提出的问题（他们也确实命中了绝大部分问题，功居甚伟），而王同学也果断承担起本来属于队长的项目展示的重任。在这样的准备强度下，尽管也有遗憾，我对我们组的答辩表现可以打到 100 分。我也十分感激他们能够用尽全力来准备项目的展示。 最终，我们的“探方网——网络文学 IP 价值评估及预测系统”获得了第十三届“花旗杯”金融创新应用大赛的三等奖。可惜的是，我们是最后一个宣布的三等奖，也就是说离二等奖仅有一步之遥。但能在全国二十强中最终名列第四，也是大赛诸多评委老师对我们项目极大肯定。晚宴上海尔金控的李大鹏先生也表示对我们的项目有持续关注和投资的意向，我个人是比较看好这个项目，希望有机会能够继续完善它。 从比较现实的角度来看，这次参赛经历带给我个人大约 1000 元的奖金，以及大学期间第一个有分量、对保研有加分的奖项。当然，我还有一些对我而言更为重要的东西与看到这篇博文的每一位分享。 参加比赛的经历在成都备战的深夜里，几名核心大佬都表示“再也不参加花旗杯这样的非技术类比赛了”。“非技术类”确实对花旗杯是一个不太正当的评价，但准备花旗的开发周期之长、团队管理之累、准备工作之繁琐，对我们这些软件工程专业的 nerd 来说，是醉心于技术的阻碍。我们花了相当比例的精力在项目的包装上，而在实际技术层面可能没有达到我们想要的高度。 但我还是很享受这个过程，因为比起纯粹的技术人员，我感觉可能我会更多地接触，也更为喜欢这样的项目包装、推广过程。我认为没有任何一个成功的项目能够单纯成长在技术的温室中，项目的包装是项目真正成为产品所不得不经历的工作。通过这样的工作，让技术人的智慧成果被更多人了解、使用和赏识，我认为这是十分有意义的。何况，在花旗的答辩场上，金玉其外、败絮其中的项目都被资深的评委老师们毫不留情地迅速戳破。 整个过程确实很累很苦，尤其是最末期，网站的前端基本上一天加好几个功能，我也很骄傲我坚持了下来。在走出答辩场地后，我们五个人在楼下花旗杯决赛的展牌前合影。在空间 po 出照片时，我配的字是“我感觉毕了业”。因为我在那一刻的感觉大概和《中国有嘻哈》欧阳靖在结束最后一次的表演时一样，如释重负，而又如获新生。 整个前端项目都是我的 commit，哈哈： 这次花旗杯的参赛经历对我来说是一次十分难忘的经历。鉴于国软院有通知渠道并推荐参加的有含金量的比赛确实不多，我十分推荐学弟学妹们参加花旗杯。当然，下一届的学弟学妹如若进入决赛，大概要去东北挨冻了。另外，我也很欢迎有学弟学妹在明年联系我进入团队，作为前端、算法开发人员，或者作为项目方向、团队管理、答辩展示的一个咨询人员。 团队开发的经验这次花旗杯应该就是我本科中第一次，也是最后一次相对来说的大型团队开发项目了。数十人的团队开发在大学里是十分难得的经验，我也学到了很多，尤其是那些我们没有做的很好的环节，例如分工、沟通、日程规划等。 队长应该主动和各部分负责人沟通，确定进度。 工作分配和修改必须要明确到人，并且利用好在线可查看可修改的备忘文件，例如石墨文档等。 作为最初始的成员，我看着团队成员不断增加，也看到有些成员因为各种原因退出了这个项目。对于中途退出的成员，我虽然没有给他们前期的努力以回报，但理解他们并心存感激；但我也看到有极少部分成员对这个项目缺少投入。不论是因为确实身兼数职、分身乏术，还是企图偷懒、不劳而获，我都认为这是缺乏责任心的表现。我理解在接近七个月的项目开发中，感到怠惰、信心不足是正常的表现，我自己也有过这样的心理。但是在整个项目中，如果你所做的努力远远少于其他人，最终却分享同样的荣誉，这不但拖累了项目的进度，对整个项目组的士气更有着极其不良的影响。因此，选择团队成员也是修行的一种。对我自己来说，由于我个人的交际不是很广，没有太多的参与这次项目成员的挑选过程。通过这次经历，我也认识到广交朋友的益处，会努力在保证交友质量的前提去结识更多人。 另外，在以后的项目开发中，我希望在个人技术水平达标的前提下，我能够承担起组长的重任，让整个团队有更好的开发积极性和管理秩序，同时挑战自我，获得进步。 结语在这七个月里，我也对自己的性格缺陷进行了审视。我不太好意思向大家列举这些性格缺陷，但它们使我在包括花旗项目在内的学习过程中，甚至是在大学生涯的为人处事、个人发展等各方面遇到了不少挫折。我对未来我在性格方面的改善和转变有一些期许。我也不是很喜欢我现在的生活方式，希望能让它变得更加多彩。 我走到了花旗杯的终点。但对我来说，还有很多的起点。我希望在未来的日子里，我能够更加坚定、更加拼搏、更加成熟、更加不甘平庸。这很难，我希望我能够做到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据预处理及常用处理方法]]></title>
      <url>%2Fintro-to-data-preprocessing%2F</url>
      <content type="text"><![CDATA[作为互联网上最著名的数据科学竞赛平台之一，Kaggle 无疑是数据从业者和爱好者最喜欢的社区之一。最近，Kaggle 发布了 2017 用户调查报告，共有 16000 余名用户参与的这份调查可以让我们对数据工作者的各类信息有一个了解。 其中，对于“工作中遇到的障碍主要是什么？”这个问题，有 49.4% 的被调查者选择了“脏数据（dirty data）”这一项，占该问题所有选项的第一位。也就是说，数据科学家一般最常见的困扰就是要对手头的数据进行大量的预处理工程。 在业界有一句广泛流传的话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。从这句话可以看出，数据的好坏对于机器学习模型的最终效果有着极大的影响。 然而，现实世界中数据大体上都是不完整、不一致、含噪声的脏数据，无法直接使用，或结果差强人意。为了提高数据的质量，数据预处理技术应运而生。实际上，在一个基于机器学习模型的实际应用中，对于数据的预处理工作所需的时间和精力可能远大于模型和算法的选择和应用。 数据预处理的概念数据预处理是指对所收集数据进行分类或分组前所做的审核、筛选、排序、变换、规约、汇总等必要的处理。 数据预处理针对的问题通过数据获取，我们能够得到未经处理的数据，这时的数据可能存在一些问题。在解决这些问题后，我们才能选择和提取合适的特征进行模型的训练。 这里简述了一部分问题及其解决方法，还有一些问题的解决方案会在下节展开讨论： 不属于同一量纲：特征的规格不同，不能放在一起比较。后文提到的无量纲化可以解决这一问题。 信息不规整：由于数据收集或存储时的错误、技术问题或漏洞，以及软硬件故障等因素，可能存在一些不规整数据。这些不规整的数据需要被过滤掉。 数据点缺失：缺失或不规整的数据需要根据其他数据进行填充，方法包括用零值、全局期望或中值，或是根据相邻或类似的数据点来做插值等。需要根据数据、应用场景和个人经验来选择正确的方式。 异常值问题：异常值的主要问题在于即使它们是极值也不一定就是错的，对错非常难以分辨。异常值可被移除或是填充，但鲁棒回归等统计技术可用于处理异常值或是极值。另外，利用如对数或高斯核对异常值进行转换也有利于降低值跳跃的影响。 数据类型不合要求：对于某些类型的特征，我们可能希望将其转换为另一类型进行使用。比如，我们可以将考试分数这个数值特征转换为是否及格这个二元特征，这个可以通过二值化（设定一个阀值）实现。其他的转换也可以通过自己定义的函数实现。 数据不能直接使用：对于例如文本特征、类别特征等特定类别的特征，机器学习算法和模型不能直接使用，那么需要对其做一些转化。对于文本特征，可以使用词袋（bag-of-word）表示法；而对于类别特征，可以使用 One-hot 编码进行处理。这些方法的核心都是编码，会在下一节再出现。 数据预处理的常用方法除开过滤、填充等方法之外，下列方法在实际问题的数据预处理中也比较常用。 无量纲化无量纲化使不同规格的数据转换到同一规格。常见的无量纲化方法有标准化和归一化。 标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布。 归一化利用了边界值信息，将特征的取值区间缩放到某个特点的范围，例如[0, 1]等。 标准化标准化也叫 z-score 规范化（零均值规范化）。公式如下： 其中 μ 是样本数据的均值（mean）， σ 是样本数据的标准差（std）。 通过标准化，样本数据被变为一个均值为 0，方差为 1 的分布。对于梯度下降，标准化可以达到加速收敛的效果，且不改变原始数据的几何分布。 归一化归一化一般是将数据按比例缩放到指定的范围，用于去除不同维度数据的量纲以及量纲单位。 最常见的归一化方法就是 Min-Max 归一化： 经过归一化处理过后的数据，各个特征维度对目标函数的影响权重是一致的，不会发生某一特征因维度过高而起主导作用，从而遮盖住其他特征的问题。 注意，归一化和标准化的英文都为 Normalization，需要根据其用途（或公式）的不同去理解或翻译。 编码编码将无法作为输入的原始类别特征或文本特征表示为数字形式。其思想为用一个变量的字典来实现变量到索引序号的映射。 编码的方式也有很多，下面介绍两个常用的编码方式－One-hot 编码和哑编码。 One-hot 编码假设变量可取的值有 k 个，如果对这些值用 1 到 k 编序，则可以用长度为 k 的二元向量来表示一个变量的取值。在这个向量里，该取值对应的序号所在的元素为 1，其他元素都为 0。 哑编码哑编码是一种状态编码，前文提到的词袋表示法用的是这种编码方式。将这些文本特征转化为数字时，数字与数字之间是没有大小关系的，纯粹只是分类标记，这时候就需要用哑编码对其进行编码。比如 0 用 0001，1 用 0010，2 用 0100 以此类推。有点类似文本矩阵，最终会构成一个稀疏矩阵。一份文本数据中各种词可能达数百万，因此使用稀疏矩阵表示能够节省内存和磁盘空间，以及计算时间。 补充：稀疏矩阵在矩阵中，若数值为 0 的元素数目远远多于非 0 元素的数目，并且非 0 元素分布没有规律时，则称该矩阵为稀疏矩阵；与之相反，若非 0 元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。 稀疏矩阵算法的最大特点是通过只存储和处理非零元素从而大幅度降低存储空间需求以及计算复杂度，代价则是必须使用专门的稀疏矩阵压缩存储数据结构。 结语以上介绍的只是一些数据预处理中的常用方法。实际上，还有许多根据不同场合选用的效果更好的处理方法。对于这些暂时没有机会使用的处理方法，限于个人水平和文章篇幅，就不一一详谈了。 在进行完数据预处理后，我们还需要选择和提取有意义的特征，将其作为输入来训练机器学习的算法和模型。之后还有选择模型、调整参数、评估、交叉验证等步骤，之后会继续整理这些方面的学习成果。 参考资料 Kaggle发布首份数据科学&amp;机器学习从业者现状调查 特征工程到底是什么？ - 知乎 ML 入门：归一化、标准化和正则化 《Spark 机器学习》第三章：Spark 上数据的获取、处理与准备 关于特征工程入门中的一些基本知识（整理） - CSDN博客 数据标准化/归一化normalization - 皮皮blog - CSDN博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[虎山行]]></title>
      <url>%2Fescorts-over-tiger-hill%2F</url>
      <content type="text"><![CDATA[更新：10 月 26 日我跟朱老师进行了一次时间较长的近期学习成果展示，并且对于接下来的学习方向聊了一会。结合花旗杯进入决赛的事情，将此文做一次更新。 这段时间博客更得不勤，因为实在太忙。解释器构造、系统级程序设计、Spark、公选课作业、算法、英语、大创…每天睁开眼睛就想起这么多学习任务，让人不免感觉身在虎山，危机四伏，战战兢兢。 只有在这种强度的学习压力下，才会发现自己的很多问题，其中最致命的就是自己的学习效率太低了，很难集中注意力去解决手头即时的任务。快速学习和解决问题的能力是程序员必备之一，我在这方面可以说不及格。再就是还有惰性心理，浮躁，不能保持健康的作息，以至于高效学习的时间不足。 同时，每天忙碌的同时也会胡思乱想：我真的适合读研吗？自己学习前端知识的时候还是比较开心的，和现在学习 Spark 的态度可能还是有一些差别，并且也在要不要向机器学习方向深入学习而犹豫。读研以后，不是说完全不可能，但是基本上以后就不会从事前端领域的工作了。确定喜欢的领域和确定喜欢的人一样，难以割舍的感觉似有若无。但是对我来说，父母和老师都给了很大的期望，自己也没有做好找工作的准备，争取保研是箭在弦上，不得不发。我能做的，只有将弦拉的更满，箭一发便是千钧之力，穿越更高的云霄。 现在确实有些迷茫，每天过的感觉不到自己有实打实的进步。希望狮子座的天性能够帮助我顺利度过这段大学最忙碌也最缥缈的时期。 定期任务每天 一道 LeetCode 六级单词 每周 《算法》一节 Coursera 华盛顿大学《机器学习基础：案例研究》课程一节（尽早刷完这个）[已完成] 六级练习题若干（有时间可以做一整套题） 一篇会议论文阅读（abstract 和 introduction）［按照标准认真读，做一些简短的笔记］ 12 月后读薄 CSAPP 系列每周两篇 学期计划给这个最重要的学期列一个总体的学期计划。 课业三门必修课，解释器构造实验以及系统级程序设计的理论和实验课，必须满绩。 花旗一个月的时间，逼自己尽全力去争取最好的结果。 实验室积极完成朱老师布置的任务，并且和他交流。也要关心组里其他同学的工作。 朱老师建议我先学习机器学习的应用。根据这个建议，我把对吴恩达的《机器学习》课程的学习计划暂时改为华盛顿大学《机器学习基础：案例研究》课程的学习。这门课更偏重实际应用，也可以避免我绕到数学内容里。 论文阅读朱老师推荐的会议，积累感觉找方向。多和朱老师交流心得。 每周抽时间细看一篇，也算是练习英语阅读。重点读 abstract 和 introduction。可以参考 [Paper Reading] Efficient Estimation of Word Representations in Vector Space 的格式来做笔记。为了督促自己，可以考虑申请一个新的知乎专栏或者在 PaperWeekly 做笔记。 算法每天一道 LeetCode 加上自己控制页数的《算法》阅读。下学期可以做九度 OJ 和北大 OJ 练手。 英语不要放弃六级，老师们都很看重英语能力。每天还是要抽时间背背单词，有时间练习一下听力、翻译、阅读、作文等。题目重在整理，而非数量。 项目有时间自己做一些开源小项目。没时间就算了，还是以自己参与度较高的科研项目为重。 机器学习暂时考虑按照以下路径，这个学习肯定搞不定，但是要自己把握进度： 学完 Coursera 华盛顿大学《机器学习基础：案例研究》课程并完成所有作业 通过《利用Python进行数据分析》的阅读学习，掌握 sklearn、numpy、pandas、matplotlib 的使用 吴恩达《机器学习》课程：绕不开的必修课 建立大局观的书籍：中文：周志华老师的西瓜书《机器学习》和李航老师的《统计学习方法》；英文：《Patten Recognition and Machine Learning》，《Elements of Statistical Learning》 kaggle、阿里巴巴天池实战 其他 组队参加美赛。抽时间了解一下赛事信息和要求。有时间点一些技能点。 可以考虑申请软件著作权（当然要有比较好的项目）。 坚持把日记给记好。 忙乱时方显修为，管理好自己的时间，专心于自己的事业。自己能走多远，很大程度上取决于这个学期。 那就继续人间游 虽说不太平明知山有虎 偏向虎山行 — GAI / 艾福杰尼 / Kungfu-Pen 《虎山行》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理清 Spark 2.2 的概念－RDD、Dataset、MLlib]]></title>
      <url>%2Fspark2.2-with-old-conceptions%2F</url>
      <content type="text"><![CDATA[根据实验室的要求，现在在啃《Spark 机器学习》。这本书和市面上大多数 Spark 书籍一样，全都基于 Spark 1.x。在 Spark 版本已经升到 2.2 的今天，敲这本书上的代码可以说是遍地是坑了，很多东西都已经变更，而且很难找到正确的解决方案，弄的我很是烦躁。 没办法，问题要一点一点解决。我决定先从理清《Spark 机器学习》提到的某些 Spark 2.2 提供的概念、模块和配合工具下手，主要关心一下几点： RDD 是什么？在升级到 Spark2.2+ 后有什么改动？ Dataset 是什么？DataFrame 又是什么？ MLlib 是什么？在升级到 Spark2.2+ 后有没有变动？如何使用？ IPython 是什么？如何配合 Spark2.2+ 使用？ SparkApache Spark 是一个快速的, 多用途的集群计算系统。 它提供了 Java, Scala, Python 和 R 的高级 API，以及一个支持通用的执行图计算的优化过的引擎. 它还支持一组丰富的高级工具, 包括使用 SQL 处理结构化数据处理的 Spark SQL, 用于机器学习的 MLlib, 用于图形处理的 GraphX, 以及 Spark Streaming。 RDD概念RDD（Resilien Distributed Dataset，弹性分布式数据集）是 Spark 的核心概念之一。一个 RDD 代表一系列的“记录”（严格来说是某种类型的对象）。这些记录被分配或分区到一个集群的多个节点上（在本地模式下，可以类似地理解为单个进程里的多个线程上）。 Spark 中的 RDD 具备容错性，即当某个节点或任务失败时（非用户代码错误引起，如硬件故障、网络连接失败等），RDD 会在余下的节点上自动重建，以便任务最终能够完成。 功能RDD 可以从一个驱动程序中已存在的 Scala 集合创建，也可以基于 Hadoop 的输入源（任何其他 Hadoop 支持的文件系统）创建，以及通过转换（transforming）来创建。 RDD 支持两种类型的操作：转换（transformation）和执行（action）。一般来说，转换操作是对一个数据集里的所有记录执行某种函数，从而使记录发生改变；而执行通常是运行某些计算或聚合操作，并将结果返回给驱动程序。 值得注意的是，Spark 中的转换操作是懒加载的（lazy），即在 RDD 上调用一个转换操作不会立即触发相应的计算，而是会将转换操作链接起来，并在执行操作被调用时才被高效计算。 调用一个 RDD 的cache（或persist）函数将会告诉 Spark 将这个 RDD 缓存在集群的内存中，以加快下一次访问数据集的速度。 更多 RDD 功能及实际编程方法可见 Spark 编程指南 - Spark 2.2.0 中文文档 - ApacheCN里的相关部分。 升级变动在 Spark 2.0 之前，Spark 的主要编程接口是 RDD。而在 Spark 2.0 之后，RDD 被 Dataset（数据集）替换。 Dataset 很像 RDD，也是强类型的，并能够使用强大的 lambda 函数。但 Dataset 在引擎盖（hood）有更好的优化，因此性能要更优于 RDD。RDD 接口仍然受支持，但是建议切换使用 Dataset。 Dataset 和 DataFrameDatasetDataset 是一个分布式的数据集合。一个 Dataset 可以从 JVM 对象来构造并使用转换功能。Dataset API 在 Scala 和 Java 是可用的，遗憾的是，Python 暂不支持 Dataset API。但是由于 Python 的动态特性, 许多 Dataset API 的优点已经可用了。 DataFrame一个 DataFrame 是一个 Dataset 组成的指定列。它的概念与一个关系型数据库中的表或者在 R/Python 中的数据帧（data frame）是相等的，但优化得更好。 DataFrames 可以从结构化的文本文件、Hive中的表、外部数据库，或者已经存在的 RDD 构造而来。DataFrame API 可以在 Scala、Java、Python 和 R 中实现。在 Scala 和 Java 中，一个 DataFrame 所代表的是一个多行的 Dataset。 更多相关信息可见 Spark SQL and DataFrames - Spark 2.2.0 中文文档 - ApacheCN。 MLlib概念MLlib 是 Spark 的机器学习库。其目标是使实用的机器学习具有可扩展性并且变得容易。在较高的水平上，它提供了以下工具： ML Algorithms（ML 算法）：常用的学习算法，如分类，回归，聚类和协同过滤； Featurization（特征）：特征提取，变换，降维和选择； Pipelines（管道）：用于构建，评估和调整 ML Pipelines 的工具； Persistence（持久性）：保存和加载算法，模型和 Pipelines； Utilities（实用）：线性代数，统计学，数据处理等。 升级变动MLlib 包括基于 RDD 的 API 和基于 DataFrame 的 API。从 Spark 2.0 开始，基于 RDD 的 API 处于维护模式，这意味着这些 API 仍然被支持且会修复 bug，但不会再添加新功能。在基于 DataFrame 的 API 能够开发到相同功能时，基于 RDD 的 API 将被弃用，并预计在 Spark 3.0 中删除。 更多相关信息可见 MLlib: 主要指南 - Spark 2.2.0 中文文档 - ApacheCN。 IPython书中的 3.2 节开始也涉及到 IPython 的使用，并且在实际使用中也有一些坑。因此也需要了解一下。 概念IPython 是一个 Python 的高级交互式 shell，基于 BSD 开源，比默认的 Python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，并且内置了许多很有用的功能和函数。IPython 内置的 pylab 包括用于数值计算的 NumPy 和 SciPy，以及用于交互式绘图和可视化的 matplotlib。 升级变动书中想在启动 PySpark 终端时使用 IPython 而非标准的 Python shell。启动时也可以向 IPython 传入其他参数，包括让它启动时也启动 pylab 功能。 但是实际操作时，在 Spark 主目录下输入如下命令： 1IPYTHON=1 IPYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark 会报错，提示信息如下： 12Error in pyspark startup:IPYTHON and IPYTHON_OPTS are removed in Spark 2.0+. Remove these from the environment and set PYSPARK_DRIVER_PYTHON and PYSPARK_DRIVER_PYTHON_OPTS instead. 解决方法： 把输入命令变成： 1PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark 如果要使用 IPython 提供的 Notebook 应用，输入： 1PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&apos;notebook&apos; ./bin/pyspark 参考资料：Starting Ipython with Spark 2 - Stack Overflow 参考资料 《Spark 机器学习》 概述 - Spark 2.2.0 中文文档 - ApacheCN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ANTLR v4 学习笔记（三）－特性拾遗]]></title>
      <url>%2FANTLR-learning-notes-3%2F</url>
      <content type="text"><![CDATA[继续学习解释器构造和 ANTLR。在系列博文的上一篇 ANTLR v4 学习笔记（二）－实现变种计算器，我们用 ANTLR 实现了一个变种计算器，从而对 ANTLR 语法、访问器（Visitor）机制、集成以及 ANLTR 的错误处理机制有了更深的理解。 上篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但没有覆盖整个 Chapter 4 的所有内容。因此这篇博文将介绍一下 Chapter 4 的剩余内容——监听器（Listener）机制、代码片段嵌入语法，以及词法分析的一些很棒的特性。 监听器机制监听器机制和访问器机制有着很多共通的特点，我们也需要通过监听语法分析树遍历器触发的“事件”来完成某些工作。它们之间最大的区别在于，监听器的方法会被 ANTLR 提供的遍历器对象自动调用，而在访问器的方法中，必须显式调用visit方法来访问子节点，否则对应的子树将不会被访问。 ANTLR 会自动生成一个接口 xxListener，它定义了 ANTLR 的运行库中的 ParseTreeWalker 类在遍历语法分析树时能够触发的全部方法。当然，和访问器机制一样，我们无需实现接口中的全部方法。ANTLR 自动生成一个名为 xxBaseListener 的类，我们可以继承这个类并只重写那些我们感兴趣的方法。 代码片段嵌入语法监听器机制和访问器一样，能够使语法分析过程和应用程序本身保持低耦合，也让语法更具有可读性。但有时候，为了满足比较苛刻的需求，我们需要将代码片段（动作）嵌入到语法中，这些动作会被拷贝到 ANTLR 自动生成的递归下降语法分析器的代码中。 将任意动作嵌入语法拿下面这一份用于解析类表格文件的语法为例： 12345678910111213141516171819202122232425grammar Rows;@parser::members &#123; // 在生成的 RowsParser 中添加一些成员 int col; public RowsParser(TokenStream input, int col) &#123; // 自定义的构造器 this(input); this.col = col; &#125;&#125;file: (row NL)+ ;rowlocals [int i=0] : ( STUFF &#123; $i++; if ($i == col) System.out.println($STUFF.text); &#125; )+ ;TAB : '\t' -&gt; skip ; // 匹配但是不将其传递给语法分析器NL : '\r'? '\n' ; // 匹配并将其传递给语法分析器STUFF : ~[\t\r\n]+ ; // 匹配除 tab 符和换行符之外的任何字符 @parser::members表示在生成的 RowsParser 中添加一些成员，即大括号里的所有元素（包括）会原封不动的添加到 RowsParser 类中。我们通过加入的构造器来传入希望提取的列号。 row 规则的(...)+循环放置了一些动作，访问了之前使用 locals 子句定义的局部变量$i。同时 row 规则也使用了$STUFF.text来获得刚刚匹配的 STUFF 词法符号中包含的文本。关于动作的更多内容会在 Chapter 10 深入研究。 用语义判定改变语法分析过程用一个读取一列整数的语法作为例子。首先看一下需求：输入的其中的一部分整数指定了接下来的多少个整数分为一组。例如输入： 12 8 43 3 1 4 6 第一个数字 2 表示匹配接下来的两个数字 8 和 43，数字 3 表示匹配接下来的三个数字。 语法文件如下： 12345678910111213grammar Data;file : group+ ;group: INT sequence[$INT.int] ;sequence[int n]locals [int i = 1;] : ( &#123;$i&lt;=$n&#125;? INT &#123;$i++;&#125; )* // 匹配 n 个整数 ;INT : [0-9]+ ; // 匹配整数WS : [ \t\n\r]+ -&gt; skip ; // 丢弃所有的空白字符 Data 语法的关键在于{$i&lt;=$n}?，这段动作的值是布尔类型的，它被称为一个语义判定。在匹配到 n 个输入整数之前，它的值保持为 true，其中 n 是 sequence 语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 时，(...)*循环终止，从 sequence 规则返回。 词法分析特性ANTLR 有三个与词法符号有关非常棒的特性。 孤岛语法：处理同一文件中的不同格式有很多常见的文件格式包含了多重语言，例如 Java 文件中有注释和 Java 代码，ejs 等模板引擎有模板语言表达式和文本。不同格式的语言需要按照不同的方式进行处理，这样的现象被称为“孤岛语法”。 ANTLR 提供了一个名为词法分析模式（lexical modes）的词法分析器特性，帮助我们方便地处理混合了不同格式数据的文件。它的基本思想是，当遇到特殊的“哨兵”字符序列时，执行不同模式的切换。 我们不妨以 XML 作为例子。一个 XML 解析器会将除标签和实体转义（例如&amp;pound;）之外的内容全部当作普通文本。当看到&lt;时，词法分析器会切换到 “INSIDE” 模式；当看到&gt;或者/&gt;时，它就切换回默认模式。 下面的语法展示了 XML 解析器的工作方式： 1234567891011121314151617181920212223242526/** * Define a lexer grammar called XMLLexer */lexer grammar XMLLexer;// 默认模式：所有在标签之外的东西OPEN : '&lt;' -&gt; pushMode(INSIDE) ;COMMENT : '&lt;!--' .*? '--&gt;' -&gt; skip ;EntityRef : '&amp;' [a-z]+ ';' ;TEXT : ~('&lt;'|'&amp;')+ ; // 匹配任意除 &lt; 和 &amp; 之外的 16 位字符// ---------------------- 所有在标签之内的东西 ----------------------mode INSIDE;CLOSE : '&gt;' -&gt; popMode ; // 回到默认模式SLASH_CLOSE : '/&gt;' -&gt; popMode ;EQUALS : '=' ;STRING : '"' .*? '"' ;SlashName : '/' Name ;Name : ALPHA (ALPHA|DIGIT)* ;S : [ \t\r\n] -&gt; skip ;fragmentALPHA : [a-zA-Z] ;fragmentDIGIT : [0-9] ; 提供一份如下所示的样例输入文件： 123&lt;tools&gt; &lt;tool name="ANTLR"&gt;A parser generator&lt;/tool&gt;&lt;/tools&gt; 测试步骤与结果如下所示： 值得一提的是，在上述启动测试组件的命令行中，使用的参数是 XML tokens，在正常情况下，这里应该是一个语法名加一个起始规则名。如果需要令测试组件只运行词法分析器而不运行语法分析器，我们可以指定参数为语法名加上一个特殊的规则名tokens。 重写输入流我们可以通过 TokenStreamRewriter 对象对输入流进行修改，然后再加以输出，从而实现对源代码插桩或重构。例如，我们可以通过以下代码实现一个监听器，来给每个类定义中加上一行序列化版本标示符（serialVersionUID）： 123456789101112131415import org.antlr.v4.runtime.TokenStream;import org.antlr.v4.runtime.TokenStreamRewriter;public class InsertSerialIDListener extends JavaBaseListener &#123; TokenStreamRewriter rewriter; public InsertSerialIDListener(TokenStream tokens) &#123; rewriter = new TokenStreamRewriter(tokens); &#125; @Override public void enterClassBody(JavaParser.ClassBodyContext ctx) &#123; String field = "\n\tpublic static final long serialVersionUID = 1L;"; rewriter.insertAfter(ctx.start, field); &#125;&#125; 之后，我们在 main 程序中初始化一个 InsertSerialIDListener，并当遍历结束时打印词法符号流： 123456ParseTreeWalker walker = new ParseTreeWalker(); // 新建一个标准的遍历器InsertSerialIDListener extractor = new InsertSerialIDListener(tokens);walker.walk(extractor, tree); // 使用监听器初始化对语法分析树的遍历// 打印出修改后的词法符号流System.out.println(extractor.rewriter.getText()); 注意，TokenStreamRewriter 实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。因此每次我们调用getText()的时候，rewriter 对象都会执行上述队列中的指令。 将 Tokens 送入不同通道语法分析器只处理一个通道，因此当我们想要忽略但保留某些 tokens 时（例如注释和空白字符），我们可以通过在语法文件书写特殊的指令，来将其送入其他通道。 12345COMMENT : '/*' .*? '*/' -&gt; channel(HIDDEN) // 匹配 /* 和 */ 之间的任何东西 ;WS : [ \r\t\u000c\n]+ -&gt; channel(HIDDEN) ; -&gt;channel(HIDDEN)和-&gt;skip类似，也是一个词法分析器指令。在这里，它设置了这些 tokens 的通道号。这样，这些 tokens 就会被语法分析器忽略。token 流中仍然保存着这些原始的 tokens 序列，但在向语法分析器提供数据时忽略了那些处于已关闭通道的 tokens。 结语ANTLR 学习的第三篇笔记到这里就结束了。尽管这一篇笔记很短，但是涵盖了 ANTLR 实践中一些比较现实的问题的解决方式。在了解这三篇笔记所涉及的学习内容后，如果还有兴趣，就可以正式展开对使用 ANTLR 开发语言类应用程序的学习了。 参考资料 《The Definitive ANTLR 4 Reference》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ANTLR v4 学习笔记（二）－实现变种计算器]]></title>
      <url>%2FANTLR-learning-notes-2%2F</url>
      <content type="text"><![CDATA[继续学习解释器构造和 ANTLR。在系列博文的上一篇 ANTLR v4 学习笔记（一）－ANTLR 初体验，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。 我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。 这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。 计算器描述计算器接受四则运算表达式为输入（如下所示）。如果表达式语法正确，则输出计算结果，否则报错，指出错误位置及原因。 例子1: 1Input 1: a=(10.44*356+1.28)/2+1024*1.6; b=a*2-a/2; print(b); print(a); Output 1: 5246.04 3497.36 例子2: 1Input 2: a=(10.44*356+1.28)/2+1024*1.6; b=a*2-c/2; print(b); Output 2: Error(line 2,position 6): undefined identifier. 以上两个示例包含了这个计算器的全部特性： 每个语句需要以“;”结束； 涉及的操作符只要求加减乘除；支持括号； 操作数为整数或浮点数； 变量不需要先声明，可直接赋值，它的类型由右边表达式的类型决定；每个变量在使用之前必须要已经有赋值； 变量名可以是由数字和字母组成，但首字符必须是字母； 输出语句使用print()函数，输出并换行； print()函数不仅可以输出变量，还可以直接输出表达式的值，例如print(1+2)； 尽量考虑周全，顾及corner cases。例如除零； 程序不需要 GUI，接受一个源文件路径为命令行参数。 匹配运算表达式的语法在经过之前的学习后，我们可以比较轻松地写出一份匹配运算表达式的 ANTLR 语法： 123456789101112131415161718192021222324252627282930313233343536/** * Define a grammar called Calculator */grammar Calculator;// 程序起始规则，语法分析的起点program : stat+;stat: define NEWLINE? # defineStat | print NEWLINE? # printStat | NEWLINE # blank ;// 声明define: VAR '=' expr ';';// 计算表达式expr: expr op=('*'|'/') expr # MulDiv | expr op=('+'|'-') expr # AddSub | '('expr')' # parens | NUMBER # number | VAR # var ;// 输出print: 'print''('VAR')'';' # printVAR | 'print''('expr')'';' # printExpr ;// 操作数类别NUMBER: INT|FLOAT;VAR : [a-zA-Z][a-zA-Z0-9]*;INT : [0-9]+;FLOAT : [0-9]+'.'[0-9]+;NEWLINE: '\r'? '\n'? ;WS : [ \t]+ -&gt; skip;MUL : '*' ; DIV : '/' ; ADD : '+' ; SUB : '-' ; 这份语法有一些值得注意的地方： 语法分析器的规则以小写字母开头； 词法分析器的规则以大写字母开头； 我们使用|来分隔同一个语言规则的若干备选分支，并使用圆括号把一些符号组合成子规则； WS 词法规则中，-&gt; skip是一条指令，告诉词法分析器匹配并丢弃空白字符； 你也许会注意到一些#开头的标签。如果备选分支上没有标签，ANTLR 就只为每条规则生成一个方法； 我们为运算符等词法符号定义了一些名字，这样，在之后访问器的编写中，我们可以将这些词法符号的名字当作常量使用，使代码更加清晰。 现在我们已经可以通过 ANTLR 内置的测试组件来进行测试。由于 Eclipse 的最新版本 ANTLR 插件里的 ANTLR 版本仍然是 4.4（官网的 ANTLR 包已到 4.7 版本），所以我们还是自己通过命令行生成 java 文件并编译： 添加的-gui参数使我们可以看到关于输入的语法分析树： ANTLR 语法分析器能够自动报告语法错误并从错误中恢复。例如，我们的输入少一个;，语法分析器会自动输出错误信息： 添加-gui参数生成的可视化语法分析树会将错误节点自动标红： 语法优化这里的“优化”不是指对语法本身，而是对 ANTLR 语法文件，即.g4作为扩展名的文件。ANTLR 允许我们将非常大的语法拆分为多个部分，根据习惯，我们将其分为语法分析器的语法和词法分析器的语法两部分。 这样做的好处是对于两种词法规则或者语法规则相同的语言，我们可以复用这些“模块”来构建语法分析器。 词法规则文件 CalculatorLexerRules.g4： 1234567891011121314// 注意开头是 "lexer grammer"lexer grammar CalculatorLexerRules;// 操作数类别NUMBER: INT|FLOAT;VAR : [a-zA-Z][a-zA-Z0-9]*;INT : [0-9]+;FLOAT : [0-9]+'.'[0-9]+;NEWLINE: '\r'? '\n'? ;WS : [ \t]+ -&gt; skip;MUL : '*' ; DIV : '/' ; ADD : '+' ; SUB : '-' ; 语法规则文件 CalculatorExpr.g4，之前语法中的词法规则全部通过 import 语句导入： 12345678910111213141516171819202122232425262728/** * Define a grammar called CalculatorExpr */// 注意 grammer 要和文件名相同grammar CalculatorExpr;// 引入词法规则import CalculatorLexerRules;// 程序起始规则，语法分析的起点program : stat+;stat: define NEWLINE? # defineStat | print NEWLINE? # printStat | NEWLINE # blank ;// 声明define: VAR '=' expr ';';// 计算表达式expr: expr op=('*'|'/') expr # MulDiv | expr op=('+'|'-') expr # AddSub | '('expr')' # parens | NUMBER # number | VAR # var ;// 输出print: 'print''('VAR')'';' # printVAR | 'print''('expr')'';' # printExpr ; 要生成 java 文件，我们只需要对语法文件使用antlr4命令即可。这样我们就得到了和之前一样的 java 文件（测试就不贴图了）： import 语句赋予我们编写模块化语法的能力，这使得 ANTLR 语法文件的耦合度降低，复用性提高。 使用 Visitor 构建计算器我们最终的目的是将生成的语法分析器集成到程序中，因此我们需要写一些 Java 代码。我们会用 Visitor（访问者模式）来实现我们的变种计算器。 由于我的实现代码基于 Calculator.g4 生成的 java 文件，而非拆分后的 CalculatorExpr.g4，所以之后的文件名、类名和方法名还是会以 Calculator 开头。当然，所有功能都是相同的，使用哪份语法文件生成的 java 文件都不会有影响。 我们通过以下命令来让 ANTLR 生成 Visitor 而非 Listener： 1antlr4 -no-listener -visitor -encoding UTF-8 Calculator.g4 这样，ANTLR 会自动生成一个访问器接口文件 CalculatorVisitor.java，以及该访问器的一个默认实现类 CalculatorBaseVisitor。实现时，我们需要自己写一个 Visitor 的子类，继承CalculatorBaseVisitor（这样表达式的计算结果都是浮点数），并重写其中的方法，以实现变量键值对存储、计算、打印等需求。 以下是我们实现的 Visitor 子类 MainVisitor 的完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.HashMap;import java.util.Map;public class MainVisitor extends CalculatorBaseVisitor&lt;Float&gt; &#123; // 声明一个 map，存放变量与值的键值对 Map&lt;String, Float&gt; memory = new HashMap&lt;String, Float&gt;(); /** * define: VAR '=' expr ';'; */ @Override public Float visitDefine(CalculatorParser.DefineContext ctx) &#123; String var = ctx.VAR().getText(); float value = visit(ctx.expr()); memory.put(var, value); return value; &#125; /** * expr op=('*'|'/') expr */ @Override public Float visitMulDiv(CalculatorParser.MulDivContext ctx) &#123; float left = visit(ctx.expr(0)); float right = visit(ctx.expr(1)); if (ctx.op.getType() == CalculatorParser.MUL) return left * right; return left / right; &#125; /** * expr op=('+'|'-') expr */ @Override public Float visitAddSub(CalculatorParser.AddSubContext ctx) &#123; float left = visit(ctx.expr(0)); float right = visit(ctx.expr(1)); if (ctx.op.getType() == CalculatorParser.ADD) return left + right; return left - right; &#125; /** * NUMBER */ @Override public Float visitNumber(CalculatorParser.NumberContext ctx) &#123; return Float.valueOf(ctx.NUMBER().getText()); &#125; /** * VAR */ @Override public Float visitVar(CalculatorParser.VarContext ctx) &#123; String var = ctx.VAR().getText(); if (memory.containsKey(var)) return memory.get(var); return (float) 0; &#125; /** * '('expr')' */ @Override public Float visitParens(CalculatorParser.ParensContext ctx) &#123; return visit(ctx.expr()); &#125; /** * print: ('print''('VAR')'';'); */ @Override public Float visitPrintVAR(CalculatorParser.PrintVARContext ctx) &#123; String var = ctx.VAR().getText(); if (memory.containsKey(var)) System.out.println(memory.get(var)); else System.err.println("undefined identifier"); return visitChildren(ctx); &#125; /** * print: ('print''('expr')'';'); */ @Override public Float visitPrintExpr(CalculatorParser.PrintExprContext ctx) &#123; System.out.println(visit(ctx.expr())); return visitChildren(ctx); &#125;&#125; 然后，我们需要写一个 Calculator.java 来新建所需要的所有对象，并针对 program 规则启动语法分析器： 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.FileInputStream;import java.io.InputStream;import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;public class Calculator &#123; public static void main(String[] args) throws Exception &#123; String inputFile = null; if (args.length == 0) &#123; System.out.println("Usage:\n\tjava -jar Calculator.jar [sourceFile]"); &#125; else if (args.length == 1) &#123; inputFile = args[0]; &#125; else &#123; System.err.println("The file path cannot be recognized"); &#125; InputStream instream = System.in; if(inputFile != null) instream = new FileInputStream(inputFile); @SuppressWarnings("deprecation") ANTLRInputStream input = new ANTLRInputStream(instream); // 新建词法分析器对象 CalculatorLexer lexer = new CalculatorLexer(input); // 新建词法符号流管道 CommonTokenStream tokens = new CommonTokenStream(lexer); // 新建语法分析器对象 CalculatorParser parser = new CalculatorParser(tokens); // 启动语法分析器，从 program 规则开始进行语法分析 ParseTree tree = parser.program(); MainVisitor cal = new MainVisitor(); cal.visit(tree); &#125;&#125; OK，现在我们的变种计算器就有了一个初步版本。打包成 jar 包后，我们可以看一下效果： 我觉得可以。 继续完善那么这时候，一般就会有人跳出来说：“我觉得不行。我觉得很普通。” 其实我也是这么认为的（阿黄真的很严格！）。 实际上，我们这个计算器还有一些需要继续完善的地方。比如下面这种情况： 可以看到并未赋值的变量 c 被当作 0。然而在我们的要求中，这样的变量应该当作未初始化，使用时要报错。另外，当被除数为 0 时，输出的结果会是 “Infinity”，而我们还是希望这种情况发生时会报错。以上情况说明我们定义的语法没有覆盖到所有设想中的错误。 另外，ANTLR 自带的错误报告采用以下的语句，基本算是直接输出了行号、错误信息等： 1System.err.println("line " + line + ":" + charPositionInLine + " " + msg); 说实话，不是很显眼。我还是喜欢错误报告开头有一些比较明显的标示，比如Error(line 2,position 6): undefined identifier感觉就要好一些。 不幸的是，Chapter 4 尚未涉及到 ANTLR 的错误处理机制。这部分内容在 Chapter 9 Error Reporting and Recovery 中。为了不用麻烦糖糖先记着，我们不妨先对这部分内容进行一些学习。 错误报告格式优化先从错误报告格式优化开始。ANTLR 的错误报告通过 ANTLRErrorListener 接口，由 ConsoleErrorListener 实现，输出信息比较简单。 ANTLRErrorListener 包含四个方法：syntaxError、reportAmbiguity、reportAttemptingFullContext、reportContextSensitivity。其中 syntaxError 顾名思义用于处理语法错误，而后三个用于二义性处理。 ANTLR 也内置了一些 ANTLRErrorListener 的实现。除开默认采用的 ConsoleErrorListener，还有一个空实现 BaseErrorListener。我们可以 new 一个 BaseErrorListener 来自定义一些错误的处理方法，然后通过 addErrorListener 把它添加到语法分析器上。 根据以上思路，我们可以在 Calculator.java 中新建语法分析器对象的语句后加上几行代码，用于移除 ANTLR 默认的错误处理，以及添加一个我们自定义的错误监听器： 12345678910// 移除默认的错误处理parser.removeErrorListeners();// 添加自定义错误监听器parser.addErrorListener(new BaseErrorListener() &#123; //出现语法错误 @Override public void syntaxError(Recognizer&lt;?, ?&gt; recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) &#123; System.err.println("Error(line " + line + ", position " + charPositionInLine + "): " + msg); &#125;&#125;); 现在的错误报告看起来就更加有条理了： 部分错误特例的处理方式不幸的是，读完了 Chapter 9，我仍然没有找到关于调用未初始化变量、被除数为 0 时报错应该怎么写。现在我的权宜之计是直接System.err.println，也就是跳过错误机制。由于上下文对象会记录根据规则识别词组时产生的所有信息，可以通过ctx.start.getLine()获得ctx.start.getCharPositionInLine()错误出现的行数和行内具体位置。 可以看到所显示的位置好像并不是特别准确，个人认为是 ctx 给出的位置会追溯到所在规则开始的地方。也许随着学习更加深入，我会找到比较优雅的实现方法。 计算器运行截图 计算器实现中遇到的问题实现这个变种计算器的过程当然也不是一帆风顺的，尤其我是先动手摸索再看的 Chapter 4。以下几个小坑可能还会有新司机踩上，特此写明： 开始的语法写输出语句为print: (&#39;print&#39;&#39;(&#39;VAR|expr&#39;)&#39;&#39;;&#39;);没有在VAR|expr外加一层括号，导致后续开发匹配错误。当然，我认为现在开两个备选分支的写法应该更好。 第一次实现时，没有给备选分支加上标签，之后实现 Visitor 时很多方法就需要自己写 if 判断，十分麻烦。通过标签来对每种输入都获得一个不同的事件是坠吼的。 开始的语法写的是WS : [ \t\r\n]+ -&gt; skip;。后来测试时感觉直接跳过换行符好像有时对错误定位会有影响，于是改成现在的样子。 我对 ANTLR 的理解那么到现在为止，我已经使用 ANTLR 写了几个示例，并完成了一个小项目。经过实际体验，ANTLR 真的可以使我们开发语言类应用程序时，少做很多繁琐的工作。 只要输入一份合法的语法（当然用户需要自行保证语法的准确性），无论多复杂，ANTLR 的语法分析器都能够自动识别，并在运行时以动态方式对语法执行分析。相比静态分析必须考虑所有可行的输入序列，动态分析使得我们不必为了适应底层的语法分析策略而扭曲我们语法，从而省略了很多不必要的工作。这是 ANTLR 4 相比其他语法分析器的一个很大的优势。 举个例子，选择使用 ANTLR 进行编译相关的开发工作有一个重要的原因，是它能够自动处理直接左递归（间接左递归暂时不能够）。 我们知道，左递归指某个语言规则在某个备选分支的起始位置调用了自身。由于含有左递归的文法必然不是 LL(1) 文法，也就不可能使用确定的自顶向下分析法。然而，允许使用左递归的文法来表示语言规则又要简洁的多。ANTLR 可以将直接左递归规则自动重写为等价的非左递归形式，省却了不少麻烦。 此外，ANLTR 语法文件独立于程序。在生成的所需的语法分析器之后，我们只需要用熟悉的 Java 来实现我们所需要的语法分析树遍历器（重写部分方法），以符合我们的要求即可。不需要自己去写词法分析器、语法分析器，ANLTR 大大降低了语言类应用程序开发的门槛。 当然，无论工具有多方便，终究只能帮助人完成事务、减少工作量，而非完全替代。想要使用好 ANTLR，还是得对编译原理有透彻的理解。 结语ANTLR 学习的第二篇笔记到这里就结束了。在这之后我会继续学习解释器构造，阅读《The Definitive ANTLR 4 Reference》，并博客上持续记录学习过程中的一点心得。敬请期待。 参考资料 《The Definitive ANTLR 4 Reference》 antlr入门实例——计算器 - Yue Xiang - CSDN博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[yuki-目录文档生成工具]]></title>
      <url>%2Fyuki-intro%2F</url>
      <content type="text"><![CDATA[技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。——沃兹基硕德 受到掘金上看到的 yddict：一个命令行查单词的工具 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。 看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 yuki，蕴含了我个人满满的宅趣味。 幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。 这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。 关于 yuki使用 Node.js 开发的项目目录管理工具，能够将项目内文件结构自动映射并生成为 README.md 项目地址bighuang624/yuki 适用场合当一份 README.md 的主体内容是项目目录，而你又厌倦了每次增加、修改、删除项目中文件时都要对 README 进行维护，那么不妨试试 yuki！ 它可以在极短时间内帮你生成符合要求的 README.md 文档。你更可以通过配置一份 yuki.config.json 来满足你的以下需求： 固定文档标题 目录前后增加固定内容 映射时忽略指定文件夹、文件、扩展名 根据指定扩展名选择是否去掉文件名的扩展名或加上书名号 让每个文件都带上 Github 的链接以方便在线跳转查看 你可以用 yuki 帮助你轻松维护 github 上类似博客、笔记、代码汇总等项目！ 效果示例我的《算法》笔记及代码项目的 README.md 完全通过 yuki 生成。你可以点击以查看效果。 使用方法请确认你使用的电脑有 Node 环境，越新越好。 安装 yuki1npm install -g yuki 进入需要生成 README.md 的文件夹12# 请将 &lt;dirname&gt; 换为文件夹路径cd &lt;dirname&gt; 创建 yuki.config.json（可选）1touch yuki.config.json 配置 yuki.config.json（可选）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; // README.md的大标题（h1），默认为所在文件夹名 &quot;title&quot;: &quot;《算法（第4版）》笔记及代码&quot;, // github库地址，如果配置了这项会给每个文件加上超链接 // 如果配置，请保证index填写无误，且所有文件名不含空格（否则链接无法正确表示） // branch默认为master &quot;repository&quot;: &#123; &quot;index&quot;: &quot;https://github.com/bighuang624/Algorithms-notes&quot;, &quot;branch&quot;: &quot;master&quot; &#125;, // 目录开始的标题等级 // 默认为2，即该目录下的文件夹名等级从3开始，随层级深入递减 &quot;startLevel&quot;: 2, // 需要忽略的目录、扩展名和文件，都以数组表示 &quot;ignore&quot;: &#123; &quot;dir&quot;: [&quot;.git&quot;], &quot;extname&quot;: [&quot;.json&quot;], &quot;file&quot;: [ &quot;yuki.config.json&quot;, &quot;.gitignore&quot;, &quot;README.md&quot;, &quot;.DS_Store&quot; ] &#125;, // 根据扩展名选择对展示的文件名做一些处理 // 每个扩展名的配置需要单独一个对象 // 目前支持省略扩展名&quot;withoutExt&quot;: true // 和加上书名号&quot;withBookmark&quot;: true &quot;format&quot;: [ &#123; &quot;extname&quot;: &quot;.md&quot;, &quot;withoutExt&quot;: true, &quot;withBookmark&quot;: true &#125; ], // 在大标题之后，目录之前添加的内容 // 每个对象可选择包含标题、标题等级和内容 // 其中，标题和标题等级需在一个对象中一同填写 &quot;prefix&quot;: [ &#123; &quot;content&quot;: &quot;[![作者](https:\//img.shields.io\/badge/%E4%BD%9C%E8%80%85-KyonHuang-7AD6FD.svg)](http:\//kyonhuang.top)&quot; &#125;, &#123; &quot;title&quot;: &quot;目录&quot;, &quot;level&quot;: &quot;2&quot; &#125; ], // 在README.md末尾添加的内容 // 和prefix相同，每个对象可选择包含标题、标题等级和内容 &quot;append&quot;: [ &#123; &quot;title&quot;: &quot;维护&quot;, &quot;level&quot;: &quot;2&quot;, &quot;content&quot;: &quot;本文档由 [yuki](https://github.com/bighuang624/yuki) 维护&quot; &#125; ]&#125; 因为 JSON 标准中不含注释，请在使用时将注释去掉。项目中也提供一份不带注释、可供修改使用的 yuki.config.json 模版。 不需要的配置选项请全部删除。 创建 README.md1yuki LICENSEApache License 2.0 开发中的那些事Cli 命令工具开发的准备工作我们来了解一下围绕 NPM 开发的准备工作。第一步自然是在文件夹下使用命令npm init生成 package.json 文件。 注册可以通过以下命令在 NPM 资源库中注册用户： 1npm adduser 之后跟着要求填写 Username、Password、Email 就 ok 了。项目发布前可能需要npm login一下。 版本号NPM 使用语义版本号来管理代码。语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新： 如果只是修复 bug，需要更新 Z 位。 如果是新增了功能，但是向下兼容，需要更新 Y 位。 如果有大变动，向下不兼容，需要更新 X 位。 当然我这个小项目比较随便，bug 修的多了次版本号看心情也往上升一次。 你可以用npm view &lt;pkg&gt; version来查看你发布到 NPM 项目的现在版本号。 测试小窍门这两个小窍门可以节省你在一边开发一边测试的时间（没发现之前，3 天的开发时间花在这上面的不少…）。 在 package.json 所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update &lt;pkg&gt; -g可以把全局安装的对应命令行程序更新至最新版。 编写想要在全局使用你编写的 cli 工具，你需要在 package.json 加一个 bin 属性： 123"bin": &#123; "yuki": "./index.js"&#125;, yuki 换做你启动这个程序所要在命令行输入的命令。属性的值是项目的入口文件。添加这个属性后，在命令行执行yuki就等同于执行node ./index.js。 发布项目项目写了一个版本准备发布，先在 package.json 所在目录下用npm version看一下版本号，然后就可以 publish 了。 123cd yukinpm versionnpm publish 之后就可以通过全局安装来使用： 1npm i -g yuki 获得程序运行的路径说实话，一个我很不擅长的东西就是 API，哪怕是那些非常常用的。这次我一开始就遇到了麻烦：如何获得程序开始遍历的“根目录”路径？ 在查找的同时顺便了解了一下获得各种路径的方法，有以下几种： process.cwd()获得 Node.js 进程当前工作的路径（即执行命令行时候的路径，而非代码路径。例如在根目录下执行node ./xxx/xxx/example.js，则process.cwd()返回的是根目录地址）； __dirname: 获得代码存放的位置（例如运行位于/usr/a目录下的example.js文件：node example.js，则__dirname返回/usr/a）； process.execPath: 返回返回启动 Node.js 进程的可执行文件所在的绝对路径（也就是当前执行的 Node 自身的路径，例如：/usr/local/bin/node）。 根据查询结果和实际需求，应该使用process.cwd()（我们要求在 package.json 所在目录下使用 yuki）。不过实际上使用的是path.resolve()。path.resolve()不含参数时，返回返回当前工作目录的绝对路径，也符合要求。 yuki 的编写也帮助我熟悉了 Node 里的很多 API，尤其是和 path 和 fs 相关的。 先遍历文件再深度遍历文件夹开发的过程中发现一个问题：遍历文件夹 a 下的所有文件时，经常先深度遍历了其中的文件夹，导致文件排在这些文件夹深度遍历的结果之后，在生成的 README 中无法看出其准确位置。 解决方法还比较简单，就是在每一次递归的遍历方法中都建立一个队列，遍历到文件夹先推入队列，遍历到文件则展示。所有文件遍历结束后，将队列中的文件夹依次取出并遍历。这样既满足了要求，也没有对深度优先遍历造成影响。 更好的是，JS 的数组原生支持了push方法，使得我不用再写一个队列的实现。 结语尽管只是一个微不足道的小工具，我还是很开心能够根据自己的实际需求开发了 yuki，更开心有机会开发一个能在名字中夹私货的项目（早在看到 vue 的版本名时我就一直心心念念了）。 如果你觉得这个小工具还不错，或者使用时觉得很方便、减轻了重复的工作负担，那么不妨为 yuki 点一个 star，因为我憧憬着能在毕业前拥有一个自己的 100+ star 项目。 当然，我更希望这些 star 是凭借我自己的开发创意和技术所得到的认可的。而我的开发经验确实不太足，所以如果你觉得这个工具不太好使、代码糟糕、发现了 bug，或是有可以增加的功能，也欢迎你开 issue 或者提交 PR 来告知我。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Let's start Python!]]></title>
      <url>%2Flets-start-Python%2F</url>
      <content type="text"><![CDATA[年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！ 今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，Python 这方面的生态环境还是要比 Node 强大不少。当然我也希望不丢掉之前的 JS 和 Node 基础，要时常写点东西或者看看书保持状态。 顺便谈一下，朱老师让我学 Python 2.7，大概是有一些历史遗留问题。但是我在知乎上查了一下，还是决定先看廖雪峰 3.x 版本的 Python 教程。我觉得知乎里一个回答给的建议不错，摘抄一下： 学习 Python 前，先了解在 Python 3 里面已经弃用的 Python 2 语法，对这些部分简单带过不要花太多时间； 使用 Python 2，不要使用 Python 2.7 以前的版本； 使用 Python 3，不要使用 Python 3.4 以前的版本； 多了解 Python 2 的__future__库； 对同一份代码，不要为 Python 2 和 Python 3 分别维护分支，努力在一套代码中兼容 Python 2 和 Python 3。 根据以上建议，我在 Anaconda 配置了 2.7.13 和 3.6.0 的两种版本。当然这份回答里最重要的还有一句话： stop talking, just do it！ 这一篇大概就讲这么些废话。人生苦短，我用 Python，常听到这句话，现在我就来体验啦！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ANTLR v4 学习笔记（一）－ANTLR 初体验]]></title>
      <url>%2FANTLR-learning-notes-1%2F</url>
      <content type="text"><![CDATA[新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。 课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。 ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。 更新记录： 17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布 17.09.11 Chapter 3 阅读完毕，增加动手上路章节。 17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译 我对编译技术的认识在正式进行 ANTLR 的学习前，先让我们聊一聊在经过上学期《编译技术及应用》的学习，以及查阅了有关资料后，我对编译技术和编译工具的一点认识。 说实话，如果单单是谈在《编译技术及应用》这门课上的认识的话，我可能只能像孔乙己一样，接连便是难懂的话，什么“上下文无关文法”，什么“LL(1)”，引得各位都哄笑起来，屏幕内外充满了快活的空气… 尽管经过了计算器和 JSONCompiler 两次实验，但我们可能对编译技术的应用还没有什么认识，觉得编译器的唯一用处就是写一个能把 xx 语言翻译成 xx 然后再运行成功… 基于写这篇博文的契机，我查了一下编译技术的各种应用，才发现其实“编译”这个概念应用还是很广泛的。 比如我的博客是用 hexo 这个博客框架搭建的，而你现在看到的这篇博文是 hexo 将我写的 markdown 文件解析成 html 生成的，这其中自然有编译模块的功劳。 再比如作为一个前端，有不少我使用过或日常接触的工具、框架其实都是编译相关知识的应用：Babel 作为 ES 6 的所有新特性还没有在主流浏览器全面推广的一个暂时的解决方法，将 ES 6 编译成 ES 5 等浏览器能够运行的 JavaScript 代码；在 Vue 中频繁出现的模版引擎、v-for=&quot;item in list&quot;等也有编译的身影。如果真正对编译原理理解透彻，大概可以去摸摸 v8 ，帮助提高一下 Node.js 的运行效率。 编程，本质上是程序员通过语言来控制计算机按照人的意志去进行各种运算和操作。自 20 世纪 50 年代早期，第一个只能进行单目运算的编译程序诞生起，编译技术一直作为人与计算机之间的传声筒，支撑着计算机语言的发展，使其更加系统化、合理化。 在知乎上“编译原理学了有什么用？”这个提问下，有答主贴了一幅《C 编译器解剖》序的照片，其中有一段话： 操作系统和编译器就如武侠小说中的“九阴真经”，没看过“九阴真经”的侠客也可以行走江湖，但看过并练成九阴真经的人最终才更有机会登上华山之巅。 怀着对程序员之巅的心向往之，我也对编译原理更生敬畏。 当然，如何让这门古老的屠龙术落地，而不至于成为学生心中虚无缥缈的空中楼阁。我个人认为可以再开设一些相关的新课题，让学生能够充分了解编译技术的实用性，从而能够自主学习、实践。我也希望《解释器构造实践》能成为一个不错的起点。 初识 ANTLR 对应《The Definitive ANTLR 4 Reference》中 Chapter 1 Meet ANTLR。书里的这一章主要是介绍 ANTLR 的下载安装方法，并运行了一个简单的 demo。 安装 ANTLRANTLR 是用 Java 编写的，所以就算你想使用 C# 或者 C++ 来配合 ANTLR 生成解释器，安装 ANTLR 前也需要有 Java 环境。 之后需要下载 antlr-4.x-complete.jar（越新越好，4.x 指最新版本的版本号）并把它放在你记得住的地方。这个 jar 包包含了运行 ANTLR 工具所需要的所有依赖，还包含两个支持库：一个树状排版库，以及 StringTemplate，一个用于生成代码以及其他结构化文本的模版引擎。 安装的具体步骤请直接看官网的 Quick Start，在此不作展示。 ANTLR 全貌 对应《The Definitive ANTLR 4 Reference》中 Chapter 2 The Big Picture，书中这一章介绍了从字符流到语法分析树的过程、ANTLR 运行流程中的一些重要术语，以及ANTLR 自带的 Listener、Visitor 这两种遍历树的机制。 想要实现一种语言，我们就需要构建读取句子的应用，并对输入的元素做出正确的反应。 如果一个应用可以计算或执行句子，我们就叫它解释器（interpreter）。包括计算器、配置文件读取器、Python 解释器都属于解释器。 而如果一个应用将句子转换成另一种语言，我们就叫它翻译器（translator）。例如 Java 到 C# 的翻译器和编译器都属于翻译器。 不管是解释器还是翻译器，想要正确运行，应用首先都要识别出所有有效的句子、词组、字词组等，识别语言的程序就叫解析器（parser）或语法分析器（syntax analyzer）。 完全 DIY 一个解析器非常麻烦，所以我们需要 ANTLR 的帮助。ANTLR 是一种能写出程序的程序，只需编写 ANTLR 的语法（grammars）文件，描述我们要解析的语言的语法，ANTLR 就能够自动生成用来解析这种语言的解析器。而用来声明我们语言的ANTLR语言的语法，就是元语言（meta-language）。 最基本的解析过程为了简单起见，我们将解析分为两个阶段，第一阶段是词法分析（lexical analysis），对应的分析程序叫做词法分析器（lexer），负责将符号（token）分组成符号类（token class or token type）。而第二阶段就是真正的语法分析，默认 ANTLR 会构建出一棵语法分析树（parse tree / syntax tree）。下图展示了一个简单的赋值表达式的解析过程： 语法树的叶子是输入的 token，而上级结点是包含其孩子结点的词组名（phase），线性的句子其实是语法树的序列化。最终生成语法树的好处是： 树形结构易于遍历和处理，并且容易被程序员理解，方便了应用代码做进一步处理。 多种解释或翻译的应用代码都可以重用一个解析器。但 ANTLR 也支持像传统解析器生成器那样，将应用处理代码直接嵌入到语法中。 对于因为计算依赖而需要多趟处理的翻译器来说，比起多次调用解析器去解析，遍历语法树多次更加高效。 深入 ANTLR 的解析过程ANTLR 生成的解析器叫做递归下降语法分析器（recursive-descent parser），属于自顶向下语法分析器（top-down parser）的一种。 顾名思义，递归下降指的就是解析过程是从语法树的根开始，向叶子（token）递归。还是以前面的赋值表达式解析为例，其递归下降语法分析器的代码大概是下面这个样子： 很酷的一点是stat()、assign()、expr()等方法调用所形成的调用栈能与语法分析树的内部节点一一对应。match()的调用对应树的叶子，而assign()方法直接顺序读取输入字符，而不用做任何选择。相比之下，stat()方法要复杂一些，因为在解析时，它需要向前看（lookahead）一些字符才能确认走哪个代码分支，有时甚至要读取完所有输入才能得出预测结果。 虽然 ANTLR 默默地为我们处理了这整个过程，但对这个选择过程有一个基本的了解会使得对生成的解析器进行 debug 变得更加容易。 用语法分析树构建语言应用在内部，ANTLR 的数据结构会尽可能地共享数据来节约内存。如下图所示，语法分析树的叶子节点指向 token 流中的 token，而 token 中的起止字符索引指向字符流，并不拷贝子字符串。而像空格这种不与任何 token 相关的字符会直接被 Lexer 丢弃掉。 ANTLR 为每条规则都会生成一个 RuleNode，叫做上下文（Context）对象，它会记录根据规则识别词组时产生的所有上下文信息。每一个上下文对象都知道已经识别的短语的起始 token 和结束 token，并且提供了对这些短语的访问。例如，AssignContext提供ID()和expr()方法来访问标识符节点和表达式子树。 语法分析树的 Listener 和 Visitor 机制ANTLR 在其运行库提供了 Listener 和 Visitor 两种语法分析树遍历机制。 ListenerListener 的特点是全自动化，我们不必写一个语法分析树的遍历器，ANTLR 会生成一个 ParseTreeWalker 的子类来主导深度优先遍历过程，我们只需处理各种事件就可以了。例如当遍历器遍历到assign规则的节点时，会触发enterAssign()并向其传递AssignContext参数；而当遍历器遍历完assign节点的所有子节点时，触发exitAssign()。下图展示了 ParseTreeWalker 如何进行深度优先遍历： 而下图展示了 ParseTreeWalker 的完整监听器方法调用队列： Visitor而 Visitor 则提供了可控的遍历方式，我们可以自行决定是否将子结点作为参数调用visit()方法。 在使用 ANTLR 生成时加上参数-visitor，会生成带有默认实现的 Visitor 实现类。我们不必实现接口中的每一个方法，只需要覆盖我们感兴趣的方法。 动手上路 对应《The Definitive ANTLR 4 Reference》中 Chapter 3 A Starter ANTLR Project。 ANTLR 工具，运行时类库和生成代码ANTLR 分为两个重要的部分：ANLTR 工具自身和 ANTLR 运行时（runtime） API。运行 ALTLR 工具会生成能够辨认语法所描述语言的句子的代码（词法分析程序和语法分析程序）；而运行时类库提供了生成代码所需的一系列类与方法，例如 Parser, Lexer 和 token。 我们先对一份语法运行 ANTLR，然后借助 jar 包中的运行时类库（runtime classes in the jar）对生成的代码进行编译。最后，编译得到的应用与运行库结合着运行。 《The Definitive ANTLR 4 Reference》（后文可能简写为《Reference》）给出了一份简单的示例，让我们可以快速了解 ANTLR 所需语法的格式： 123456789101112131415/** Grammers always start with a grammer header. This grammer *//** is called ArrayInit and must match the filename: ArrayInit.g4 */grammar ArrayInit;/** A rule called init that that matches comma-separated values between &#123;...&#125; */init : '&#123;' value (',' value)* '&#125;' ; // must match at least one value/** A value can be either a nested array/struct or a simple integer (INT) */value : init | INT ; // parser rules start with lowercase letters, lexer rules with uppercaseINT : [0-9]+ ; // Define Token INT as one or more digitsWS : [ \t\r\n]+ -&gt; skip ; // Define whitespace rule, toss it out 之后通过命令行运行antlr4 ArrayInit.g4，ANTLR 为我们生成很多一般需要我们自己手写的文件： 这些文件的功能如下： ArrayInitParser.java：包含了专用于 ArrayInit 语法的解析器（parser）类的定义。 ArrayInitLexer.java：包含专用的词法分析程序（lexer）类的定义。 ArrayInit.Tokens：对于我们定义的每个 token，ANTLR 分配了一个 token 类型码（token type number）并将这些值保存在 ArrayInit.tokens。因为这个文件的存在，当我们将较大规模的语法分割为各种小型的语法表达时，ANTLR 能够使同种 token 的类型码保持一致。 ArrayInitListener.java, ArrayInitBaseListener.java：ANTLR 生成的解释器会默认根据输入构建一棵树。通过遍历这棵树，一个遍历器可以将事件（回调函数）传递给我们提供的监听者对象（listener object）。ArrayInitListener 是描述我们可以实现的回调函数的接口，而ArrayInitBaseListener 是默认空实现的集合，使我们可以方便的重写（override）那些我们感兴趣的回调函数。通过-visitor命令行参数，ANTLR 也可以为我们生成树的 visitors。 测试生成的解析器之后，我们通过javac *.java来编译 ANTLR 生成的所有代码。UNIX 系统用户可以将以下代码写入.bash_profile或其他启动脚本，以免每次都要在命令行输入一遍： 123export CLASSPATH=".:/usr/local/lib/antlr-4.7-complete.jar:$CLASSPATH"alias antlr4='java -jar /usr/local/lib/antlr-4.7-complete.jar'alias grun='java org.antlr.v4.gui.TestRig' 之后就可以通过grun命令来测试生成的解析器了。注意输入要以 EOF（Unix 系统 Ctrl + D，Windows 系统 Ctrl + Z）作为结束。加上-tokens命令行参数，输出的每一行会展示一个单独的 token 及其所有信息： -tree会生成一个 Lisp 风格的简单语法分析树： 而-gui会生成一个展示语法分析树的 GUI 界面： 根据我们定义的语法规则，ANTLR 自动生成了这棵语法分析树。之后我们会利用 ANTLR 内置的遍历器触发enterInit()和enterValue()等各种回调函数。 将生成的解析器集成进 Java 程序我们来写一个简单的 Java main()方法来集成生成的解析器，并打印出和使用-tree参数一样的语法分析树。 1234567891011121314151617181920212223// import ANTLR's runtime librariesimport org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;public class Test &#123; public static void main(String[] args) throws Exception &#123; // create a CharStream that reads from standard input ANTLRInputStream input = new ANTLRInputStream(System.in); // create a lexer that feeds off of input CharStream ArrayInitLexer lexer = new ArrayInitLexer(input); // create a buffer of tokens pulled from the lexer CommonTokenStream tokens = new CommonTokenStream(lexer); // create a parser that feeds off the tokens buffer ArrayInitParser parser = new ArrayInitParser(tokens); ParseTree tree = parser.init(); // begin parsing at init rule System.out.println(tree.toStringTree(parser)); // print LISP-style tree &#125;&#125; 测试结果如下。语法错误也可以被报告： 构建语言应用我们的目标不仅仅是识别，还想做一些翻译工作。最简单的方法是利用 ANTLR 内置的语法分析树遍历器，这样我们不需要自己去进行树遍历，大大减少了工作量。 我们给 ArrayInit 加一个新需求：将 short 数组{99, 3, 451}翻译为字符串\u0063\u0003\u01c3。实现这个需求，我们只需要继承ArrayInitBaseListener，来实现其中的一些监听器方法。 我们在 ShortToUnicodeString.java 中实现我们的监听器： 123456789101112131415161718/** Convert short array inits like &#123;1, 2, 3&#125; to "\u0001\u0002\u0003" */public class ShortToUnicodeString extends ArrayInitBaseListener &#123; @Override public void enterInit(ArrayInitParser.InitContext ctx) &#123; System.out.print('"'); &#125; @Override public void exitInit(ArrayInitParser.InitContext ctx) &#123; System.out.print('"'); &#125; @Override public void enterValue(ArrayInitParser.ValueContext ctx) &#123; int value = Integer.valueOf(ctx.INT().getText()); System.out.printf("\\u%04x", value); &#125;&#125; 我们不需要覆盖每一个enter/exit方法，只需要实现我们需要的那些。代码里ctx.INT()代表上下文对象请求已经匹配的整数 INT 的值。记住我们之前提到的，上下文对象会记录根据规则识别词组时产生的所有信息。 接下来，我们要创建一个主程序： 1234567891011121314151617181920212223242526272829// import ANTLR's runtime librariesimport org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;public class Translate &#123; public static void main(String[] args) throws Exception &#123; // create a CharStream that reads from standard input ANTLRInputStream input = new ANTLRInputStream(System.in); // create a lexer that feeds off of input CharStream ArrayInitLexer lexer = new ArrayInitLexer(input); // create a buffer of tokens pulled from the lexer CommonTokenStream tokens = new CommonTokenStream(lexer); // create a parser that feeds off the tokens buffer ArrayInitParser parser = new ArrayInitParser(tokens); ParseTree tree = parser.init(); // begin parsing at init rule // Create a generic parse tree walker that can trigger callbacks ParseTreeWalker walker = new ParseTreeWalker(); // Walk the tree created during the parse, trigger callbacks walker.walk(new ShortToUnicodeString(), tree); System.out.println(); &#125;&#125; 比起上一节的主程序，我们多创建了一个树遍历器（ParseTreeWalker walker），并用它来遍历语法分析器返回的语法分析树，它会触发ShortToUnicodeString中的回调方法。 javac 进行编译后就可以使用了： 我们可以通过传入不同的监听器来产生完全不同的输出。监听器将语法和我们的语言应用很大程度上解耦了，使语法具有了更大的重用性。 结语第一篇笔记到这里就结束了。我们聊了一下我对编译技术的一点看法，并阅读了《The Definitive ANTLR 4 Reference》的前三章。而书的 Part I: Introducing ANTLR and Computer Languages 还剩第四章 A Quick Tour，根据实验课的要求，这一章我会单独写一篇学习笔记，示例与内容也会和书上有一些区别。在这之后我会继续学习解释器构造，并继续写这本书的阅读笔记，敬请期待。 参考资料 《The Definitive ANTLR 4 Reference》 Antlr v4入门教程和实例 - 西代零零发 - CSDN博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node 异步 I/O]]></title>
      <url>%2Fasync-IO-in-Node%2F</url>
      <content type="text"><![CDATA[在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。 Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。 因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。 这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。 选择异步的原因选择异步的原因包括用户体验和资源分配两个方面。 从用户体验的角度分析，浏览器中 JavaScript 在单线程上执行，并且与 UI 渲染共用一个线程。因此采用异步请求将使下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为。 而从资源分配角度来看，当遇到一组互不相关的任务需要完成的场景时，主流选择有以下两种： 单线程串行依次执行：容易导致阻塞，硬件资源难以有效利用； 多线程并行：创建线程和执行期线程上下文切换的开销较大，且经常面临锁、状态同步等问题（但多线程在多核 CPU 上能够有效提升 CPU 的利用率）； 而 Node 给出的解决方案是：利用单线程，远离多线程死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞以更好地利用 CPU。 而为了弥补单线程无法有效利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效利用 CPU 和 I/O。 从操作系统看异步 I/ONode 的异步 I/O 不可否认地受到操作系统中异步 I/O 实现的启发。 要强调的是，从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。 阻塞/非阻塞 I/O在调用阻塞 I/O 时，应用程序需要等待 I/O 完成时才返回结果。特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束，因此造成 CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用。 与阻塞 I/O 完成整个获取数据的过程相比，非阻塞 I/O 则不带数据直接返回，要获取数据还需要通过文件描述符再次读取。非阻塞 I/O 返回之后，CPU 的时间片可以用来处理其他事务。 但由于完整的 I/O 并没有完成，非阻塞 I/O 立即返回的仅仅是当前调用的状态。为了获取完整数据，需要轮询这种重复调用以判断操作是否完成的技术。 现存的轮询技术包括 read（通过重复调用检查 I/O 状态，性能最低，CPU 一直等待）、select（通过对文件描述符上的事件状态进行判断）、poll（比 select 有所改进，但性能仍较低）、epoll（Linux 下效率最高的 I/O 事件通知机制，进入轮询时休眠，直到事件发生将其唤醒）和kqueue（与 epoll 类似，仅在 FreeBSD 系统存在）。 虽然轮询技术能够满足了非阻塞 I/O 确保获取完整数据的需求，但应用程序依旧花费了很多时间来等待 I/O 完全返回。等待期间，CPU 要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。因此，它仍然只能算是一种同步。 补充：在看廖雪峰的 Python 教程的异步 IO 这一章时，在评论区看到一个对于阻塞/非阻塞和同步/异步非常精妙的解释，十分容易理解和记忆，特摘录如下： 老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 3 老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。 所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。 异步 I/O 的实现我们期望的完美异步 I/O 应该是：应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序即可。 Linux 原生提供 AIO 这种符合要求的异步 I/O 方式，但只有 Linux 下有，且其无法利用系统缓存。因此现实情况下，想在单线程场景完美实现异步 I/O 有些难度。 而在多线程，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加载轮询技术来完成数据获取，让一个线程进行计算处理，再通过线程间的通信将 I/O 得到的数据进行传递，可以模拟异步 I/O。 *nix 平台，Node 自行实现了线程池来完成异步 I/O；Windows 平台则采用 IOCP 实现。Node 提供了 libuv 作为抽象封装层，平台兼容性由这一层完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。 Node 在编译期间判断平台条件，选择性编译 unix 目录或 win 目录下的源文件到目标程序中。 我们常说的“Node 是单线程的”里的“单线程”仅指 JavaScript 执行在单线程。而内部完成 I/O 任务的另有线程池，只是 I/O 线程使用的 CPU 较少。 除了用户代码无法并行执行外，所有的 I/O （磁盘 I/O 和网络 I/O 等）可以并行。 Node 的异步 I/O事件循环、观察者、请求对象、I/O 线程池一同构成了 Node 异步 I/O 模型的基本要素。 事件循环每执行一次循环体的过程被称为 Tick，查看是否有事件待处理，若有则取出事件及相关回调函数。如果存在关联的回调函数，就执行它们。直到没有事件，进入下个循环。 观察者每个事件循环中有一个或者多个观察者，判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。 事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求是事件的生产者，事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。观察者相当于事件池。 在 Windows 下，这个循环基于 IOCP 创建，而在 *unix 下基于多线程创建。 请求对象请求对象是从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中的重要中间产物。所有的状态都保存在这个对象中，包括送入 I/O 线程池等待执行以及 I/O 操作完毕后的回调处理。 执行回调组装好请求对象、送入 I/O 线程池等待执行，构成了异步 I/O 的第一部分。而回调通知是第二部分。 线程池中的 I/O 操作调用完毕后，会调用方法向 IOCP 提交执行状态，并将线程归还线程池。 在每次 Tick 的执行中，I/O 观察者会调用方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。 整个异步 I/O 流程图如下： 非 I/O 的异步 APINode 中还存在一些与 I/O 无关的异步 API：setTimeout()、setInterval()、setImmediate()、process.nextTick()。 定时器setTimeout()和setInterval()与浏览器 API 一致，创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件并执行其回调函数。注意：由于事件循环自身特点，定时器并非精确的。 process.nextTick() &amp; setImmediate()两者都可用于将回调函数延迟执行，以异步执行一个任务。两者的区别如下： 优先级：process.nextTick()中回调函数执行优先级要高于setImmediate()，原因在于事件循环对观察者的检查是有先后顺序的，idle 观察者（process.nextTick()） &gt; I/O 观察者 &gt; check 观察者（setImmediate()）。 具体实现：process.nextTick()的回调函数保存在一个数组中，setImmediate()保存在链表中。 行为：process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。这样的设计是为了保证每轮循环能够较快地执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。 事件驱动与高性能服务器事件驱动的实质：通过主循环加事件触发的方式来运行程序。 几种经典的服务器模型各有其优缺点： 同步式：对于同步式的服务，一次只能处理一个请求，并且其他请求都处于等待状态。 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但因为系统资源有限而不具备扩展性。 每线程/每请求：为每个请求启动一个线程来处理。扩展性强于每进程/每请求，但由于每个线程都占用一定内存，大并发到来时内存还是会很快用光。 Apache 目前还采用每线程/每请求，而 Nginx 采用事件驱动。 Nginx 与 Node 比较： Nginx 采用纯 C 写成，性能较高，但仅适合做 Web 服务器，用于反向代理或负载均衡等服务，在处理具体业务方面欠缺； Node 是一套高性能平台，没有 Nginx 在 Web 服务器方面那么专业，但场景更大，可以处理各种具体业务。 参考资料《深入浅出Node.js》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再探前端自动化－持续集成]]></title>
      <url>%2Fstart-CI%2F</url>
      <content type="text"><![CDATA[本篇博文承接前端工程自动化入门系列的第一篇：《初探前端自动化测试–以 Vue 为例》。 传统开发模式中，项目经理等待所有模块都开发完成后再进行集成，出现 bug 则记录并分配责任人进行修改，之后再进行集成，直到通过测试为止持续循环。这个过程可能会出现如下问题： bug 总在最后才被发现（尤其是模块之间的依赖导致的 bug），并且越到项目后期，随着项目规模的膨胀，bug 变得愈发难以修复； 各个环节无效的等待时间较长，加上程序需要经常变更，导致软件交付时机无法保障； 用户无法随时看到项目演示原型，满意度低。 为了解决这些问题，“持续集成”（Continuous Integration）的概念被提出。 相关概念持续集成（CI）是指将所有开发者工作副本频繁地（每天多次）合并到主干，始终保持可发布状态的做法。而持续集成服务器就是能够采用自动化的手段，实现项目持续集成的工具。 持续集成的具体工作流程： 本地开发（developing） 静态代码检查（linting） 单元测试（testing）：代码仓库对 commit 操作配置钩子（hook），只要提交代码或者合并进入主干，就会跑自动化测试。这一轮可以先只跑单元测试。 合并进入主干（merging） 自动构建（building）：将源码经过安装依赖、配置各种资源（CSS、JS、images），转换为可以运行的实际代码。之后会跑全面的测试。 自动发布（publishing）：将可以直接部署的版本打包，发到生产服务器以启动应用。 持续集成之后还有持续交付和持续部署，分别强调代码在任何时候都是可交付和可部署的。 持续集成的优点 自动化部署工作解放了重复性劳动，并减少手工集成的错误； 防止分支大幅偏离主干，而导致以后的集成难度变大，甚至难以集成； 持续集成缩短了开发、集成、测试、部署等各个环节的时间，从而减少等待时间，同时可以更快地发现、定位、修复问题并交付成果，使得产品可以快速迭代； 集成服务器一般都提供 Code review、代码质量检测等功能，帮助开发人员提高产品质量。 持续集成服务平台 - Travis很多 PaaS 平台都提供了持续集成服务。Travis CI 是其中最著名的一个，对于开源项目可以免费使用。 每次跑测试时，Travis 提供的都是一个空白的环境。这个环境只有 Linux 基本的build-essential和wget、git那些依赖。连 Node.js 的运行时都是现跑现安装的。因为 Travis 默认带有的依赖都是每个用户的机器上都会有的，所以一旦应用能在 Travis 上跑通，别的用户就都能安装上。 Travis 的使用方法如下： 首先，在官网 https://travis-ci.org/ 注册后选择需要开启集成测试的仓库。 然后，需要在项目的根目录放一份配置文件.travis.yml来告诉 Travis 需要用什么版本的 Node 跑，以及跑测试的命令等信息。 12345678// 一份简单的 .travis.ymllanguage: node_jsnode_js: - '4.2.5' - '7.5.0'script: npm run test 如果有用到数据库，则.travis.yml还需要添加一些内容。详细内容参考 Setting up Databases - Travis CI。 之后将这份配置文件 push 上 github，Travis 就会被自动触发。下图是正在进行集成测试的 我的简历项目： P.S. e2e 测试需要装 chrome 浏览器这个坑又出现了…简直阴魂不散。是不是要用 PhantomJS 才行啊… 我们先只跑单元测试好了。把.travis.yml更改一下：script: npm run unit，再 push 到 github 上。过一会就看到测试通过了。可以把 BlingBling 的 build 徽章加进项目的 README.md 中，来显示项目的构建状态了（徽章添加方案可见参考资料）： 参考资料写作资料持续集成是什么？ - 阮一峰的网络日志 为什么我们迫切需要持续集成？ 《持续集成平台：travis》 扩展阅读前端开源项目持续集成三剑客 | EFE Tech：添加徽章步骤，可以说是非常具体了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 Vue 撸一份线上简历有哪些坑]]></title>
      <url>%2Fmake-a-resume%2F</url>
      <content type="text"><![CDATA[昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。 项目地址：bighuang624/resume 在线预览地址：http://kyonhuang.top/resume/ 目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。 在 Vue 中使用 sass这个步骤之前已经总结过，现在再在博客上记录一次，方便之后查找。 在 Webpack 中，所有的预处理器需要匹配相应的 loader。因此要使用 sass 或 scss，首先下载依赖： 1npm install sass-loader node-sass --save-dev 然后在单文件组件中的&lt;style&gt;标签中加上lang=&quot;sass&quot;。vue-loader会根据lang属性推断出要使用的 loaders，并将内容交给相应的 loaders 处理： 123&lt;style lang="sass"&gt; /* write sass here */&lt;/style&gt; 与名称相反，sass-loader 默认解析 scss 语法，因此如果想使用 sass 语法，还需要在 build/vue-loader.conf.js 配置 vue-loader 的选项： 这样的修改不会影响 scss 的使用，记得修改&lt;style&gt;标签中为lang=&quot;scss&quot;即可。 项目资源无法加载直接npm run build得到的项目，默认引用资源文件的路径为/static/js/app.js。所以程序若不在根目录下，就会出现资源文件引用错误的情况。 最简单的解决方案就是改动 webpack 的配置文件。将/config文件夹中的 index.js 文件中的assetsPublicPath: &#39;/&#39;改为assetsPublicPath: &#39;./&#39;即可，截图如下： 如果你还使用了 vue-router，你需要在 router 的配置中加上一行base: &#39;/[项目所在文件夹的名字]/&#39;，如下所示： 注意：如果启用了 vue-router 的 history 模式，你需要跟着 vue-router 官方文档的后端配置例子 对服务器进行一定的配置。 这是因为在 history 模式下，router 只是通过 JS 操作 window.history 来改变浏览器地址栏里的路径，并没有发起 http 请求。但是直接在地址栏中输入形如http://www.example.com/example/item/1这样的地址时，就一定先要对服务器发起 http 请求。此目标在服务器上不存在，于是会返回 404。修改服务器的配置，以将所有的请求全部转发到index.html上。 当然，这意味着单纯使用 Github Pages 的在线预览功能没办法进行这样的配置。你也可以关注知乎上的这个问题 怎样为Github pages Hack使用了vue-router history模式的vue应用？ - 知乎 来看别人的解决方法。 iconfont 无法加载字体图标无法正确加载。参考 https://github.com/vuejs-templates/webpack/issues/166 ，得到的解决方法是修改 build/utils.js 文件，增加一行publicPath: &#39;../../&#39;，如截图所示： 保存后，npm run build打包得到的项目中 iconfont 就可以正常显示了。 实现 Github Pages 在线预览参考 Configuring a publishing source for GitHub Pages - User Documentation，实现 Github Pages 在线预览功能有好几种方法，可以设置从master分支、gh-pages分支或者master分支下的/docs文件夹中读取。我就选择了最简单的一种方法，把npm run build打包下来的/dist文件夹改名为/docs。 之后，在 Github 项目主页的 Settings 下的 Github pages 下进行设置 Source 为master branch /docs folder即可。 如果你之前使用过 Github Pages 并绑定了一个域名，那么这个项目的预览地址会像http://kyonhuang.top/resume/这样在这个域名下，看起来很爽。 参考资料预处理器 · vue-loader Vue项目打包上传到github预览 vuejs怎么在服务器部署？ - 知乎 结语撸这份简历，是一个总结，也是一个激励。 真正撸完简历，才发现自己在技术层面上的项目经历少的可怜，而技术也不敢说有什么掌握。以后看到这份简历，会让我非常想写一些拿得出手的开源项目，然后对项目经历进行修改。 读完《你不知道的JavaScript（中卷）》，就给 JS 的技能条涨 5 个百分点；用 Node 开发一个支持登录注册的后台，就给 Node 的技能条涨 5 个百分点；或者再点亮一个新的技能。 随着我的不断学习，希望这份简历越来越吸引人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探前端自动化测试--以 Vue 为例]]></title>
      <url>%2Fstart-front-end-test%2F</url>
      <content type="text"><![CDATA[随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高；但对于稳定、多次复用以及需要长期维护的项目，自动化测试就尤为重要。 现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。 前端的测试类型分为单元测试（unit testing）、集成测试（integration testing）和端到端测试（e2e testing）。 单元测试将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作； 集成测试是针对产品的某个功能的测试，又称功能测试； e2e 测试则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。 开发模式先绕点路，了解一下 TDD、BDD等以测试为导向的开发模式，有助于我们更深入地理解自动化测试。 TDDTDD（Test Driven Development），即测试驱动开发。其先针对每个功能点抽象出接口代码，然后编写单元测试用例代码。之后实现接口，运行单元测试代码进行测试，循环往复直至所有单元测试通过。 TDD 要求测试先于编写功能代码。测试用例不仅是对于代码的验证，更成为对代码的规范与约束，确保在开发以及未来进行修改时能够极大程度地保证该模块行为仍然是正确的。 BDDBDD（Behavior Driven Development），即行为驱动开发。BDD 和 TDD 一样，都要求先写测试，再写代码。可以认为 BDD 是 TDD 的一个子集或分支，是测试驱动开发的扩展。 TDD 基于开发者角度，重点测试函数的输入输出；而 BDD 更侧重于使用者角度，重点测试对用户行为的反应。 BDD 测试中，客户与开发者共同考虑系统该如何运行，然后用通用的语言抽象描述系统的行为，使得双方从技术层面和业务需求都能理解，避免沟通障碍。 测试工具测试管理工具用来组织和运行整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行被测试代码进行测试。 可选择的有 Karma、Selenium、Mocha（Mocha既是测试工具，也是测试框架）。 测试框架测试框架是单元测试的核心，提供了单元测试所需的各种API，并对测试用例分组。测试框架会抓取到代码抛出的 AssertionError 并提供附加信息。 选择较多，有名的有 Mocha、Jasmine等。不过 Mocha 既支持 TDD 也支持 BDD 的测试语法，Jasmine 只支持 BDD。 断言库断言库提供了很多语义化的方法来对值做各种判断。当然也可以不用断言库，Node.js 中也可以直接使用原生 assert 库。 可供选择的断言库也很多，包括 should.js、expect.js、chai.js等。 测试浏览器前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持调用和运行本地浏览器来进行测试，但如果测试仅仅是针对函数和模块的单元测试，则完全可以使用一款无界面的 webkit 内核浏览器：PhantomJS。 测试覆盖率统计工具测试覆盖率工具为代码在语法级分支上打点，之后运行代码，并在运行结束后根据收集到的信息统计出当前测试用例对源码的覆盖情况。 一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。 vue-cli 的配置vue-cli 的 webpack 模版内置了开箱即用的 Karma + Jasmine 单元测试配置，以及 Nightwatch + Selenium E2E 测试配置，npm run test即可测试自带的一个初始测试用例。 有坑请注意： 建议使用 cnpm 对 vue-cli 项目进行依赖安装，否则可能有些东西装不上。 自带的 e2e 测试要求装有 chrome 浏览器，否则报错Error retrieving a new session from the selenium server。我被这个坑折腾了半天… 开始编写测试代码我的简历项目 是我花了一天时间写的一个 vue-cli 初始化、只用了 Vue 的一个小项目，我们拿这个简单的小项目来入门测试代码的编写。我们直接利用 vue-cli 的初始配置，即用 Karma + Jasmine 进行单元测试，Nightwatch + Selenium 进行 E2E 测试。 你可以将我的项目 clone 下来进行测试代码的编写练习，不过项目里的测试代码可能已经因为更新而何下面的示例不一样了。 单元测试/test/unit/index.js中可以看到，单元测试的测试代码是/specs文件夹下以.spec.js结尾的文件。将自带的Hello.spec.js改写为LeftNav.spec.js： 1234567891011121314151617import Vue from 'vue';import LeftNav from '@/components/LeftNav';describe('LeftNav.vue', () =&gt; &#123; const Constructor = Vue.extend(LeftNav); const vm = new Constructor().$mount(); it('should render correct name', () =&gt; &#123; expect(vm.$el.querySelector('.leftNav h1').textContent) .to.equal('Kyon Huang'); &#125;); it('should render correct title', () =&gt; &#123; expect(vm.$el.querySelector('.leftNav h3').textContent) .to.equal('Web 开发工程师'); &#125;);&#125;); E2E 测试同理，将/test/e2e/specs/test.js改写为 12345678910111213141516171819// For authoring Nightwatch tests, see// http://nightwatchjs.org/guide#usagemodule.exports = &#123; 'default e2e tests': function test(browser) &#123; // automatically uses dev Server port from /config.index.js // default: http://localhost:8080 // see nightwatch.conf.js const devServer = browser.globals.devServerURL; browser .url(devServer) .waitForElementVisible('#app', 5000) .assert.elementPresent('.leftNav') .assert.containsText('h1', 'Kyon Huang') .assert.elementCount('img', 1) .end(); &#125;,&#125;; 测试结果： 可以看到，我们的单元测试和 e2e 测试都通过了。不过单元测试的覆盖率有点低，只有 25%。如何写好测试代码，需要进一步的学习。 结语前端工程自动化入门系列下一篇：《再探前端自动化－持续集成》 参考资料写作资料开发人员看测试之TDD和BDD - JackieZheng - 博客园 前端自动化单元测试初探 - 简书 扩展阅读虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发 PhantomJS 基础及示例 - 腾云阁 - 腾讯云]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 的异步操作 - Generator 和 async]]></title>
      <url>%2FGenerator-and-async%2F</url>
      <content type="text"><![CDATA[继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：回调函数、事件监听器模式（发布/订阅模式）、流程控制库和 Promise/Deferred 模式。为了使异步操作更加清晰、简洁、方便，ES6 引入了 Generator 函数，而 ES2017 标准引入了 async 函数作为 Generator 函数的语法糖。 由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。 本博文在 Promise 对象 | 大黄菌的个人博客 之后食用最佳。 注：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。 Generator 函数 Generator 与协程一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程（coroutine）。 Generator 函数是 ES6 对协程的不完全实现，因为只有 Generator 函数的调用者才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 Generator 函数的异步应用Generator 是一个异步操作的容器。想让 Generator 自动执行，即需要当异步操作有结果时能够自动交回执行权。两种方法： 回调函数。将异步操作包装成 Thunk 函数，在回调函数里交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 其中，JavaScript 中的 Thunk 函数指将多参数函数替换成的一个只接受回调函数作为参数的单参数函数。任何参数有回调函数的函数，都能写成 Thunk 函数的形式。 12345678// ES6 版本的简单 Thunk 函数转换器const Thunk = function(fn)&#123; return function(...args)&#123; return function(callback)&#123; return fn.call(this, ...args, callback); &#125; &#125;&#125; 前者的实现可用 Thunkify 模块，后者可用 co 模块。了解更多请看 Generator 函数的异步应用 - ECMAScript 6入门。暂时用不到的工具就不进一步消耗脑细胞了。 实例通过 Generator 函数部署 Ajax 操作1234567891011121314function main () &#123; var result = yield request('http://some.url'); var resp = JSON.parse(result); console.log(resp.value);&#125;function request (url) &#123; makeAjaxCall(url, (response) =&gt; &#123; it.next(response); &#125;);&#125;var it = main();it.next(); 使用 yield* 语句遍历完全二叉树1234567891011121314151617181920212223242526272829303132function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 中序（inorder）遍历函数function* inorder(t) &#123; if(t) &#123; yield* inoreder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 生成二叉树function make(array) &#123; // 判断是否为叶节点 if(array.length === 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for(let node of inoreder(tree))&#123; result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 利用 Generator 函数部署 Iterator 接口12345678910111213141516171819function* iterEntries (obj) &#123; let keys = Object.keys(obj); for(let i = 0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7&#125;;for(let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 async 函数 感觉前面的知识短时间内都消化不了，就没有看处于提案的异步遍历器。 实例异步获取股票报价123456789async function getStockPriceByName (name) &#123; var symbol = await getStockStmbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then((result) =&gt; &#123; console.log(result);&#125;); 并发发出远程请求123456789101112async function logInorder(urls) &#123; // 并发读取远程 URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for(const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 结语经过学习，我感觉 async 函数真的为一组资源依次异步加载等实际开发场景提供了一种非常简便的处理方案。不过想要运用好 async 函数，深究其实现原理，就必须也要对 Generator 函数有清晰的认知。 异步编程不管是在浏览器还是在服务器端的开发都很重要，知识量也很大，一时半会大概消化不过来。在总结完这些知识后，还需要时常复习，并在实际开发过程中探索更好的实践。 补充阅读JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志：帮助加深对同步、异步执行机制的认识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJS 入门笔记]]></title>
      <url>%2Fstart-to-learn-NodeJS%2F</url>
      <content type="text"><![CDATA[上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 七天学会NodeJS 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。 在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。 虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。 更新记录： 17.08.30 根据《深入浅出 Node.js》的笔记，对”NodeJS 应用领域及特点”部分进行文字补充。 17.09.02 根据《深入浅出 Node.js》的笔记，对”模块”部分进行文字补充。 NodeJS 应用领域及特点 设计高性能 Web 服务器的要点：事件驱动、非阻塞 I/O。 Node 从 Ryan Dahl 一开始设想的 Web 服务器，发展成一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施的网络应用平台。 Node 与浏览器的异同Chrome 浏览器除了 V8 作为 JavaScript 引擎外，还有一个 WebKit 布局引擎。 Node 的结构和 Chrome 十分相似，都是基于事件驱动的异步架构。浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。 Node 的特点异步 I/O事件与回调函数事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，各事件之间各自独立，如何协作是一个问题。 单线程保持了 JS 在浏览器中单线程的特点。在 Node 中，JS 与其余线程无法共享状态。 好处： 不用在意状态同步问题； 没有死锁； 没有线程上下文交换带来的性能开销； 弱点： 无法利用多核 CPU； 错误会引起整个应用退出，应用的健壮性值得考验； 大量计算占用 COU 导致无法继续调用异步 I/O。 浏览器端，Web Workers 能够创建工作线程进行计算。为了不阻塞主线程，工作线程采用消息传递的方式来传递运行结果，使得工作线程不能访问主线程的 UI。 Node 采用同样的思路解决单线程中大计算量的问题：child_process。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息传递结果。 子进程的出现，意味着 Node 可以从容应对单线程在健壮性和无法利用多核 CPU 方面的问题。 跨平台操作系统与 Node 上层模块之间构建了一层平台层架构，即libuv。 Node 的应用场景I/O 密集型Node 面向网络且擅长并行 I/O，能够有效组织更多的硬件资源。 I/O 密集的优势在于Node 利用事件循环的处理能力（而非为每一个服务启动一个线程），资源占用极少。 不擅长 CPU 密集型业务？由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将导致 CPU 时间片不能释放，使得后续 I/O 无法发起。适当调整和分解大型运算任务能使运算适时释放，不阻塞 I/O 调用的发起。 与遗留系统和平共处可以将稳定的旧有系统作为后端接口与中间件，而让 Node 将该数据源作为数据接口，发挥异步并行的优势。 分布式应用模块 使用模块的好处 大大提高代码的可维护性； 可以随时引用； 避免函数名和变量名冲突； CommonJS 规范CommonJS 主要是在 Node 服务器端的规范。意义在于将类聚的方法与变量限定在私有的作用域中，使得用户完全不必考虑变量污染。 CommonJS 对模块的定义主要分为模块引用、模块定义、模块标识三个部分： 模块引用一个模块要引用其他模块暴露的变量，用var foo = require(&#39;module_name&#39;)就拿到了引用模块的变量。 模块定义上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一的出口。 在模块中，还存在一个 module 对象，代表模块自身，而 exports 是 module 的属性。 一个模块要对外暴露变量（函数也是变量），可以用module.exports = variable;。 模块标识即传递给require()方法的参数。 模块实现在 Node 中引入模块，需要经历如下三个步骤： 路径分析 文件定位 编译执行 在 Node 中，模块分为 Node 提供的核心模块和用户编写的文件模块。 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就直接加载进内存中。因此可以省略文件定位和编译执行两个步骤，且在路径分析中优先判断，加载速度最快。 文件模块在运动时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。 优先从缓存加载模块加载会有缓存，且其根据绝对路径识别。因此同样的模块名放在不同的路径之中多次 require 不会重新加载。 Node 对引入过的模块都会以编译和执行后的对象的形式进行缓存。核心模块和文件模块都采用缓存优先进行二次加载，核心模块的缓存检查先于文件模块。 路径分析和文件定位模块路径是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。 其生成规则为从当前文件目录下的 node_modules 目录开始，沿路径向上逐级递归，直到根目录下的 node_modules 目录。 Node 在当前目录下查找 package.json，通过JSON.parse()解析出包描述对象，从中取出main属性制定的文件名进行定位。 模块编译 .js 文件。通过 fs 模块同步读取文件后编译执行。 .node 文件。这是用 C/C++ 编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。 .json 文件。通过 fs 模块同步读取文件后，用JSON.parse()解析返回结果。 其余扩展名。它们都被当作 .js 文件载入。 每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能。 如果要达成 require 引入一个类的效果，请赋值给 module.exports 对象。 前后端共用模块浏览器端的 JavaScript 需要经历从同一个服务器端分发到多个客户端执行，瓶颈在于带宽；而服务器端 JavaScript 则是相同的代码需要多次执行，瓶颈在于 CPU 和内存等资源。 CommonJS 是同步加载的，在服务器端模块文件一般存放在本地，再加上有缓存，加载速度很快。而在浏览器端就可能导致“假死”，因此浏览器端采用另一种异步加载方式 - AMD（Asynchronous Module Definition，异步模块定义）规范。 1234567define(function()&#123; var exports = &#123;&#125; exports.sayHello = function() &#123; alert('Hello from module: ' + module.id) &#125; return exports&#125;) 可以看到 AMD 的模块定义与 Node 模块相似，不同之处在于 AMD 模块需要用define来明确定义一个模块，而在 Node 实现中是隐式包装的；以及内容需要通过返回的方式实现导出。 想要进一步了解，可参考 Javascript模块化编程（二）：AMD规范 - 阮一峰的网络日志。 深入了解模块原理Node.js 的“模块”功能利用了 JavaScript 函数式编程的特性，通过闭包实现。 代码的组织和部署 包描述文件中的部分属性 maintainers。包维护者列表，npm 通过该属性进行权限认证。 bin。将包作为命令行工具使用，需配置好 bin 字段，通过npm install package_name -g命令将脚本添加到执行路径中。之后可以在命令行中直接执行。例如：&quot;bin&quot;: { &quot;express&quot;: &quot;./bin/express&quot; } 全局模式安装-g将一个包安装为全局可用的可执行命令。通过全局模式安装的所有模块包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来： 1path.resolve(process.execPath, '..', '..', 'lib', 'node_modules'); 基本模块 Node.js 内置的常用模块是为了实现基本的服务器功能，底层代码是用 C/C++ 在 Node.js 运行环境中实现。 globalNode.js 环境中唯一的全局变量。 process代表当前 Node.js 进程。 判断 JavaScript 执行环境12345if(typeof(window) === 'undefined')&#123; console.log('node.js');&#125; else &#123; console.log('browser');&#125; 文件操作 不同系统下路径的标准化标准化之后的路径里的斜杠在 Windows 系统下是\，而在 Linux 系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &#39;/&#39;)再替换一下标准路径。 遍历目录12345678910111213141516171819202122232425262728293031323334353637// 同步遍历获取某一文件夹下的所有文件，用 callback 处理function travel(dir, callback)&#123; fs.readdirSync(dir).forEach((file) =&gt; &#123; var pathname = path.join(dir, file); if(fs.statSync(pathname).isDirectory())&#123; travel(pathname, callback)； &#125; else &#123; callback(pathname); &#125; &#125;)&#125;// 异步遍历function travel(dir, callback, finish)&#123; fs.readdir(dir, (err, files) =&gt; &#123; (function next(i)&#123; if(i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, (err, stats) =&gt; &#123; if(stats.isDirectory())&#123; travel(pathname, callback, () =&gt; &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, () =&gt; &#123; next(i + 1); &#125;) &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;)(0); &#125;)&#125; 网络操作 监听端口的权限问题在 Linux 系统下，监听 1024 以下端口需要 root 权限。因此，如果想监听 80 或 443 端口的话，需要使用 sudo 命令启动程序。 URL 的完整组成123456789 href ----------------------------------------------------------------- host path --------------- ---------------------------- http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash ----- --------- -------- ---- -------- ------------- -----protocol auth hostname port pathname search hash ------------ query 网络操作常见问题 问： 为什么通过headers对象访问到的 HTTP 请求头或响应头字段不是驼峰的？ 答： 从规范上讲，HTTP 请求头和响应头字段都应该是驼峰的。但现实中不是每个 HTTP 服务端或客户端程序都严格遵循规范，所以 NodeJS 在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如headers[&#39;content-length&#39;]。 问： 为什么http模块创建的 HTTP 服务器返回的响应是chunked传输方式的？ 答： 因为默认情况下，使用.writeHead方法写入响应头后，允许使用.write方法写入任意长度的响应体数据，并使用.end方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了Transfer-Encoding: chunked字段，并采用chunked传输方式。但是当响应体数据长度确定时，可使用.writeHead方法在响应头里加上Content-Length字段，这样做之后 NodeJS 就不会自动添加Transfer-Encoding字段和使用chunked传输方式。 问： 为什么使用http模块发起 HTTP 客户端请求时，有时候会发生socket hang up错误？ 答： 发起客户端 HTTP 请求前需要先创建一个客户端。http模块提供了一个全局客户端http.globalAgent，可以让我们使用.request或.get方法时不用手动创建客户端。但是全局客户端默认只允许5个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生socket hang up错误。解决方法也很简单，通过http.globalAgent.maxSockets属性把这个数字改大些即可。另外，https模块遇到这个问题时也一样通过https.globalAgent.maxSockets属性来处理。 进程操作 降权123456789// 降权http.createServer(callback).listen(80, () =&gt; &#123; var env = process.env, uid = parseInt(env['SUDO_UID'] || process.getuid(), 10); gid = parseInt(env['SUDO_GID'] || process.getgid(), 10); process.setgid(gid); process.setuid(uid);&#125;) 注意点： 如果是通过sudo获取 root 权限的，运行程序的用户的 UID 和 GID 保存在环境变量SUDO_UID和SUDO_GID里边。如果是通过chmod +s方式获取 root 权限的，运行程序的用户的 UID 和 GID 可直接通过process.getuid和process.getgid方法获取。 process.setuid和process.setgid方法只接受number类型的参数。 降权时必须先降 GID 再降 UID，否则顺序反过来的话就没权限更改程序的 GID 了。 进程间通讯如果父子进程都是 NodeJS 进程，就可以通过 IPC（进程间通讯）双向传递数据。 123456789101112131415161718/* parent.js */// 在 options.stdio 字段中通过 ipc 开启一条 IPC 通道var child = child_process.spawn('node', ['child.js'], &#123; stdio: [0, 1, 2, 'ipc']&#125;);child.on('message', (msg) =&gt; &#123; console.log(msg);&#125;)// 给子进程发送消息child.send(&#123; hello: 'hello' &#125;);/* child.js */process.on('message', (msg) =&gt; &#123; msg.hello = msg.hello.toUpperCase(); process.send(msg);&#125;) 数据在传递过程中，会先在发送端使用JSON.stringify方法序列化，再在接收端使用JSON.parse方法反序列化。 守护进程12345678910111213// 守护子进程/* daemon.js */function spawn(mainModule)&#123; var worker = child_process.spawn('node', [mainModule]); worker.on('exit', (code) =&gt; &#123; if(code !== 0)&#123; spawn(mainModule); &#125; &#125;);&#125;spawn('worker.js'); 异步编程 domain 捕获异常1234567891011121314151617181920212223242526272829function async(request, callback)&#123; // Do something asyncA(request, (data) =&gt; &#123; // Do something asyncB(request, (data) =&gt; &#123; // Do something asyncC(request, (data) =&gt; &#123; // Do something callback(data); &#125;) &#125;) &#125;)&#125;http.createServer((request, response) =&gt; &#123; var d = domain.create(); d.on('error', () =&gt; &#123; response.writeHead(500); response.end(); &#125;); d.run(() =&gt; &#123; async(request, (data) =&gt; &#123; response.writeHead(200); response.end(data); &#125;) &#125;)&#125;) 陷阱使用uncaughtException或domain捕获异常，代码执行路径里涉及到了 C/C++ 部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用try语句捕获异常时一般捕获到的都是 JS 本身的异常，不用担心上述问题。 结语NodeJS 的学习其实主要分为三块： JavaScript 语言本身。要学会借助 ECMAScript 规范 加深自己的理解。 NodeJS 的 API。要熟悉官方 API 文档，主要是熟悉 NodeJS 提供的功能以及知道该查询文档的哪块地方。不推荐死记硬背，因为新版本会更改和弃用部分 API。 生态圈中的各种三方库。要学习检索、过滤、去其糟粕取其精华，利用但不迷信。 而在 NodeJS 开发时，首先要有一个全局的设计，再再实现的过程中对之间忽略掉的细节进行设计上的改进，为二次迭代做准备。 参考资料除开文章开头提到的资料，结语部分参考了 当我们学习 Node.js 时，我们在学习什么？。 下一步学习《Node.js 包教不包会》 by alsotang 《深入浅出Node.js》 自己撸个爬虫]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《你不知道的 JavaScript（上卷）》脑图]]></title>
      <url>%2FYou-Dont-Know-JS-notes-1%2F</url>
      <content type="text"><![CDATA[这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。 作用域和闭包 大图：作用域和闭包.png this 和对象原型 大图：this和对象原型.png 原型链补一张来自 JavaScript深入之从原型到原型链 的图，来直观地表现原型链。 图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探人工智能]]></title>
      <url>%2Fstart-to-know-AI%2F</url>
      <content type="text"><![CDATA[一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。 为什么为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？ 发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。 随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。 确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。 何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。 这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。 不要拒绝未来的任何可能性。 相关概念脑图一直感觉纯文字的笔记比较难以记忆，导致自己的学习吸收率不高。看到别人的读书笔记是总结了一张脑图，条理比较清晰。这里也试着用 Xmind 总结一张相关概念的脑图（P.S.使用感觉百度脑图比 Xmind 条理清晰+好用）。 数据学习算法的输入数据，叫“训练数据”。训练数据的每一行称为一个“训练样本”（Training Sample），通常简称“样本”（Sample）。 样本的各种属性称为“特征”（Feature）。而希望学得的模型可以用来预判的信息称为样本的“标注”（Label）。 模型机器学到的模型是一个映射。 映射的输入每个样本 xi 的特征组成一个“特征向量” (Feature Vector)。所有特征向量的集合就是总的输入集合，称为“样本空间” (Sample Space)。 映射的输出第 i 个样本的标注记作 yi。同理有“标注空间”(Label Space)。 映射的表示机器学习模型就是输入空间 X 到输出空间 Y 的一个映射，将映射用符号 g 表示，则模型记作 g: X -&gt; Y。 机器学习学习算法 (Learning Algorithm) 根据训练数据，从假设集合 (Hypothesis Set) 中选出最优的那个映射 g 作为最终学得的模型，使得 g 越接近上帝真相 f 越好。 分类不是所有的机器学习问题都需要标注。根据训练数据是否有标注，机器学习问题大致划分为监督学习（Supervised Learning）和无监督学习（Unsupervised Learning）两大类（还有半监督学习、增强学习等）。 监督学习：每个输入样本都有标注。大致分成两类： 分类（Classification）问题：标注是离散值，比如用户”点击“和”不点击“。如果标注只有两个值，则称为二分类，如果标注有多个值，则称为多分类。 回归（Regression）问题：标注是连续值，比如如果问题是预测北京市房屋的价格，价格作为标注就是一个连续值，属于回归问题。 无监督学习：训练样本不需要标注。这类模型试图学习或是提取数据背后的结构，或从中抽取最为重要的特征。无监督学习解决的典型问题是聚类（clustering）问题，比如对一个网站的用户进行聚类，根据用户特征进行分组，看看这个网站用户的大致构成，分析下每类用户群的特点是什么。 以上总结为脑图： 神经网络把听上去最高端的“神经网络”放到最后介绍。 神经网络一组大致模仿人类大脑构造设计的算法，用于识别模式。神经网络通过机器感知系统解释传感器数据，能够对原始输入进行标记或聚类等操作。 神经网络所能识别的模式是数值形式，因此图像、声音、文本、时间序列等一切现实世界的数据必须转换为数值。 感知器、权重与阈值大家都在高中的生物课上学过，人类大脑思考的基础是神经元（神经细胞）。如果能够人工制造神经元，就能组成人工神经网络来模拟思考。 上世纪六十年代，科学家们提出了最早的“人造神经元”，并将其称为“感知器”（perceptron）。感知器接受一些因素，这些因素根据不同的重要性（决定性因素与次要因素）获得不同的权重（weight）。因素的条件成立为 1，不成立为 0，乘以权重的总和大于指定的阈值（threshold），感知器便输出 11，否则输出 0。 决策模型单个的感知器构成一个简单的决策模型。而实际的决策模型是由多个感知器组成的多层网络。 每一个节点层在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂，因为每一层会整合并重组前一层的特征。 而在“递归神经网络”中，上下层的感知器的输入与输出还可能发生循环传递。 神经网络运作过程一个神经网络的搭建，需要满足三个条件： 输入和输出 权重（w）和阈值（b） 多层感知器的结构 最困难的部分就是确定权重和阈值。我们通过试错法，即保证其他参数不变，对 w 或 b 进行微小变动，然后观察输出的变化。通过不断重复这个过程来得到最精确的那组 w 和 b。这个过程即被称为模型的训练。 因此，神经网络的运作过程如下： 确定输入和输出 找到一种或多种算法，可以从输入得到输出 找到一组已知答案的数据集，用来训练模型，估算 w 和 b 一旦新的数据产生，输入模型，就可以得到结果，同时对 w 和 b 进行校正 整个过程需要海量计算，所以需要使用专门为机器学习定制的 GPU。 输出的连续性为了保证模型的敏感，要将 0、1 输出改造为连续性函数。 12z = wx + bσ(z) = 1 / (1 + e^(-z)) 这样，当 z 趋向正无穷（表示感知器强烈匹配）时，σ(z) → 1；如果 z 趋向负无穷（表示感知器强烈不匹配），σ(z) → 0。 同时，Δσ 满足下面的公式： 即 Δσ 和 Δw 和 Δb 之间是线性关系，变化率是偏导数。这就有利于精确推算出 w 和 b 的值了。 基于 JavaScript 的机器学习尽管确实是第一选择，机器学习不一定要用 Python。为什么不试试神奇的 JavaScript 呢？ JavaScript 开发者们已经开源了不少基于 Node.js 的机器学习库： brain.js (神经网络) Synaptic (神经网络) Natural (自然语言处理) ConvNetJS (卷积神经网络) mljs (一系列具有多个函数方法的 AI 库) Neataptic (神经网络) Webdnn (深度学习) 你可以从 github 的这个项目：abhisheksoni27/machine-learning-with-js 中获得一些实例的源码，目前作者实现了线性规划和 KNN 算法。你也可以在参考资料的对应章节找到翻译版本进行阅读。 结语emmm，如果你看了之后的参考资料中的每一篇，你会发现这篇博文只是一个拙劣的归纳总结。这是因为我确实对相关领域没有什么了解。但我对此兴致勃勃，也已经关注了不少数据挖掘和机器学习的知乎专栏及收藏夹。希望自己将来会有相关方面有价值的产出。 参考资料相关概念部分 简单理解：人工智能、数据挖掘、模式识别、机器学习、深度学习 - feichizhongwu888的博客 - CSDN博客 一篇文章讲清楚人工智能、机器学习和深度学习的区别 数据、模型部分 写给大家看的机器学习书（第二篇） - 知乎专栏 神经网络部分 神经网络入门 - 阮一峰的网络日志 写给大家看的机器学习书（第三篇） 基于 JavaScript 的机器学习 JavaScript机器学习之线性回归 JavaScript机器学习之KNN算法 扩展学习 神经网络浅讲：从神经元到深度学习 机器学习算法的基本知识（使用Python和R代码）：带有 Python 和 R 语言代码实例 Deep Learning 中文翻译 [机器学习]机器学习笔记整理全解 DT新纪元 - 知乎专栏]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[暑假计划进行中]]></title>
      <url>%2Fsummer-plan%2F</url>
      <content type="text"><![CDATA[出征前內心忐忑鋒利的匕首反握準備殺死對手前先讓我來殺死懶惰 — 艾福杰尼 / Killa4nia《酒精》 简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感兴趣的知识，并且认真做学习笔记和总结。 07.20 更新：暑假已经过去了半个月。对暑期计划进行一些变更使其更加合理。最重要的是提高效率。 08.06 更新：暑假快过了 2/3 了，对计划进行一些修正。 读书计划（脑图整理知识点）[Finished] 7月23日为 deadline，看完《你不知道的 JavaScript（上卷）》。 8月8日为deadline， 看完《你不知道的 JavaScript（中卷）》。 8月读《Node.js 深入浅出》。 争取暑假读完《JavaScript 设计模式与开发实践》。 整个暑假： 每天 12 点前睡觉，8 点前起床。 前端各类练习题。每天 2 - 3 道原生 js 实例题。学累了刷刷 牛客网。 每天 2 面六级单词。 想做的练习： 谈谈一些有趣的CSS题目 原生JavaScript学习-实例索引 百度前端技术学院［可缓］ 七月： 写花旗杯项目前端。 Vue 全家桶及相关技术实践。 八月： Node.js学习。首先是廖雪峰的入门教程，争取一天看完 [08.06：koa 有点难理解…先从 express 学习好了]。接下来选一本书看看（据说朴灵的《Node.js 深入浅出》不错…） 完成一个类似 带你用 Vue 全家桶和 Node.js 完成一个聚合应用 的 demo。 如果还有时间，试试 Electron 或者 Lavas 天下武功，唯勤不破！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise 对象]]></title>
      <url>%2Fpromise%2F</url>
      <content type="text"><![CDATA[Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。 特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Fulfilled（已完成，又称 Resolved）和Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变只有两种可能：从Pending变为Fulfilled和从Pending变为Rejected。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 缺点： 无法取消Promise，一旦新建就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误不会反映到外部。 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。 基本用法一个栗子🌰，用Promise对象实现 Ajax 操作： 1234567891011121314151617181920212223242526272829var getJSON = function(url)&#123; var promise = new Promise((resolve, reject) =&gt; &#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystagechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if(this.readyState !== 4)&#123; return; &#125; if(this.status === 200)&#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;); return promise;&#125;;getJSON("/post.json").then( json =&gt; console.log('Contents: ' + json), error =&gt; console.error('出错了', error)); resolve和reject函数由 JavaScript 引擎提供，不用自己部署。两者在改变 Promise对象的状态的同时，将异步操作的结果或报出的错误作为参数传递出去。 then方法可以接受两个回调函数作为参数（可以说是处理 result 和 err 的回调）。第一个在Promise对象状态变为Fulfilled时调用，第二个（可省）在Promise对象状态变为Rejected时调用，都接受Promise对象传出的值作为参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例（决定前一个Promise对象的状态），表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。 注意点1then方法会返回一个 Promise 实例： 1234var outputPromise = promise.then( (fulfilled) =&gt; &#123;...&#125;, (rejected) =&gt; &#123;...&#125;,) 这时，outputPromise变成了受function(fulfilled)或者 function(rejected)控制状态的 Promise 实例了： 若function(fulfilled)或者 function(rejected)返回一个值（字符串、数组、对象等），那么outputPromise的状态变为Resolved； 若function(fulfilled)或者 function(rejected)抛出异常（throw new Error(...)），那么outputPromise的状态变为Rejected； 若function(fulfilled)或者 function(rejected)返回一个 Promise 实例，那么outputPromise就成为这个新的 Promise 实例。 可以看 promise的传递 的例子（使用了 q）加深理解： 123456789101112131415161718192021222324252627282930313233var Q = require('q');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfilled时，调用function(fulfilled) * 当inputPromise状态由未完成变成rejected时，调用function(rejected) * 将then返回的promise赋给outputPromise * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由 * 未完成改变为fulfilled * @private */var outputPromise = getInputPromise().then(function(fulfilled)&#123; return 'fulfilled';&#125;,function(rejected)&#123; return 'rejected';&#125;);outputPromise.then(function(fulfilled)&#123; console.log('fulfilled: ' + fulfilled);&#125;,function(rejected)&#123; console.log('rejected: ' + rejected);&#125;);defer.reject(); // 输出 fulfilled: rejected// defer.resolve(); // 输出 fulfilled: fulfilled 2在创建新的 Promise 时，作为 Promise 参数传入的函数是会被立即执行的（而不是调用 then 时才执行），只是其中执行的代码可以是异步代码。 虽然 Promise 作为参数接收的函数是同步执行的，但是then方法的回调函数执行是异步的。 🌰： 12345678910var p = new Promise(function(resolve, reject)&#123; console.log("create a promise"); resolve("success");&#125;);console.log("after new Promise");p.then(function(value)&#123; console.log(value);&#125;); 控制台输出： 123"create a promise""after new Promise""success" 方法Promise.prototype.then()then方法返回一个新的Promise实例。链式写法调用then方法时，前一个回调函数将返回结果作为参数，传入第二个回调函数（前一个回调函数没有用return返回结果时，默认返回 undefined）。 Promise.prototype.catch()reject方法的作用，等同于抛出错误。如果Promise状态已经变成Fulfilled，在resolve语句后再抛出错误是无效的，因为状态不会再改变了。 一般来说，不要在then方法中定义Reject状态的回调函数，总是使用catch方法。因为catch可以捕获之前所有then方法执行中的错误，也更接近同步的try/catch写法。 catch方法返回的也是一个Promise对象。 Promise.all()Promise.all方法用于将多个Promise实例（否则调用Promise.resolve方法再处理），包装成一个新的Promise实例。接受一个具有Iterator接口，且返回的每个成员都是Promise实例的参数（一般为数组）。 1var p = Promise.all([p1, p2, p3]); 只有每个成员的状态都为Fulfilled，p 的状态才为Fulfilled，所有返回值组成一个参数传递给 p 的回调函数；否则只要有一个成员被rejected，p 的状态为Rejected，第一个被reject的实例的返回值被传递给 p 的回调函数。 如果作为参数的Promise实例自身定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 Promise.race()1var p = Promise.race([p1, p2, p3]); p 的状态随第一个改变状态的成员而做相同改变，该成员返回值传递给 p 的回调函数。其他与Promise.all方法一致。 Promise.resolve()将现有对象转为Promise对象。根据参数分为四种情况： Promise实例：不作任何修改，直接返回该实例； thenable对象（具有then方法的对象）：转为Promise对象，然后在立即调用其then方法的同时状态变为Resolved； 不符合以上情况的任何参数：返回状态为Fulfilled的Promise对象，参数传给回调函数； 不带有任何参数：返回状态为Fulfilled的Promise对象。 注意：当Promise.resolve()的参数是Promise实例时，resolve会“拆箱”获取这个 Promise 实例的状态和值，但这个过程是异步的。 Promise.reject()返回一个新的Promise实例，状态为Rejected。方法的参数会作为reject的理由，变成后续方法的参数。 reject不具备“拆箱”能力。 应用 加载图片：加载完成时Promise的状态发生变化。 Generator 函数与 Promise 的结合：使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 参考资料写作： Promise 对象 - ECMAScript 6入门 八段代码彻底掌握 Promise 进阶（之后阅读）： JavaScript Promise迷你书（中文版）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何给终端安上炫酷的皮神黄皮肤？]]></title>
      <url>%2Fpikachu-iterm%2F</url>
      <content type="text"><![CDATA[昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西： 给终端安上超几把炫酷的皮神黄皮肤！作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？ 一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！ 如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。 从零开始的项目安装打开 Pokemon-Terminal 项目的 github 主页，我发现安装前有两个要求： 3.5及以上版本的 python； 已安装 iTerm2。 巧了，这两个要求我都不符合！ iTerm2 我从来没有接触过，根本不知道是什么。而比较久远的时候，我在试图将 OS X 系统自带的 python 2.+ 升级为 3.+ 时，跟着网上不知道靠不靠谱的教程误操作，以致 2.+ 删掉了 3.+ 却没安好，依赖于 python 的以 Xcode 为首的一系列软件全部罢工（而且过了一周左右才查出来是这个原因），最后灰溜溜地又下了一遍 2.+，从此留下了对 python 的心理阴影（但是我们这篇教程还是很靠谱的）。 没关系，作为（准）程序员，要勇于折腾！我们一步一步的搞起。 iTerm2我是先下载的 iTerm2，官网在此，下载即可。 iTerm2 是 OS X 系统下很好用的一款命令行工具，至于具体怎么好用，敬请百度了解。因为我现在只是为了皮神黄皮肤。当然之后我也会进一步学习使用。 python 3.5+昨晚吃瘪后的我心有不甘，发了一条说说。然后幸得初中同学救驾： 这个允许用户方便地安装不同版本的 python 并可以快速切换的 anaconda 帮助我解决了问题。官网提供了图形化安装和命令行安装两种方式，根据自己的专业程度选择下载即可。 这个 anaconda 据说也是 python 开发的利器之一，不过我也不会 python。也许之后机缘巧合会深入学习（想了解可以参照这篇文章Anaconda使用总结）。说实话为了给终端换个皮肤，让我本不宽裕的存储空间又少了 1G 左右，有些心疼。但是折腾还是给了我很多乐趣，也许之后有用呢。 那么要求都满足了。按照项目 README 要求，在 iTerm 2 中输入以下三条语句： 1234# Pokemon Installationgit clone https://github.com/LazoCoder/Pokemon-Terminal $HOME/.Pokemon-Terminalecho PATH=&quot;$HOME/.Pokemon-Terminal:$&#123;PATH&#125;&quot; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 安装完毕，皮神我来了！ 1$ pokemon pikachu 然后…出现以下报错提示： 1.Pokemon-Terminal/./Scripts/background.scpt:39:46: script error: Expected end of line but found identifier. (-2741) 翻越最后一座 bug 高山想去给作者提一个 issue，就发现作者对于这个 bug 已经给出了解决方法。 按照解决方法，我们需要对 .Pokemon-Terminal/scripter.py 文件进行一些修改（当然，不一定每个人都碰上了这个 bug）。其实我也不太会用 vim，所以以下操作参照了这篇文章修改文件内容 vi命令。 用以下命令在终端打开： 1vi .Pokemon-Terminal/scripter.py 然后按一下 i，从命令行模式进入插入模式。找到函数__terminal_script（在比较靠上的位置），将： 1content = &quot;tell application \&quot;iTerm\&quot;\n&quot; 修改为：1content = &quot;tell application \&quot;iTerm2\&quot;\n&quot; 按 Esc 键进入命令行模式，再按:wq保存退出。大功告成！ 再在 iTerm2 中输入pokemon pikachu，就会发现黑漆漆（或者白晃晃）的背景变成了皮神黄！ 深度使用123456789101112131415161718192021222324Usage: pokemon [parameter]Parameters: [name] - Change the terminal background to the specified Pokemon. [index] - Change the terminal background to a Pokemon by its index. [region] - List all the Pokemon of the specified region. [one letter] - List all Pokemon who&apos;s names begin with a particular letter. [two letters] - List all Pokemon who&apos;s names begin with those two letters.Other Parameters: pokemon all - List all the Pokemon supported. pokemon regions - List all the available regions. pokemon extra - List all the Pokemon from the &apos;Extra&apos; folder. pokemon random - Change the terminal background to a random Pokemon. pokemon random-kanto - Change the terminal background to a random Pokemon from the specified region. pokemon ? - Identify the current Pokemon in the terminal. pokemon _pikachu - Change the wallpaper to the specified Pokemon. pokemon _random - Change the wallpaper to a random Pokemon. pokemon _random-kanto - Change the wallpaper to a random Pokemon from the specified region. pokemon _? - Identify the current Pokemon in the wallpaper. pokemon slideshow - Iterate through each Pokemon. pokemon slideshow-kanto - Iterate through each Pokemon in the specified region. pokemon help - Display this menu. 以上是作者提供的用法。可以通过口袋妖怪的英文名或者编号切换皮肤，或者用pokemon random来切换成随机的皮肤。 我们现在还得每次打开 iTerm 后输入命令来切换皮肤。作者同样提供了点开就换的方法，只用在 iTerm 的 Preferences 里做一点配置： 想一想，通过配置为pokemon random，每次打开都是不同皮肤说不定更爽到。 最后作者建议你改变一下透明度之类的，使皮神看起来更酷炫有范： 我的配置是这样的： 结语其实一个皮肤也没有那么重要（还是有那么一点爽的啦），重要的是通过这一番折腾，接触到了很多常规学习中可能不会接触的东西，包括 iTerm 和 anaconda。这也是我第一次有目的性地去看项目的 issue。希望自己以后能多一点这样地非常规学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端学习之路上的暂歇思考]]></title>
      <url>%2Frelax-and-think%2F</url>
      <content type="text"><![CDATA[又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。 到现在为止，我的前端学习之路大概插了这些旗帜： 对前端生态有了一个大致的了解，对例如 Webpack、Babel 等常用的工具有使用经验或者大概知道是干什么的。 在知乎和微博上关注了前端大佬，养成每天在掘金上看技术文章以及不时逛一些较为优秀的技术博客的习惯。 看了一些前端书籍，大多是 JavaScript 相关。 大致啃完了 Vue.js 的文档，正在学习 Vue-router。同时也对 i-View 等相关项目有一些了解。 在之前的前端学习中也有一些问题： 最大的问题是不太重视基础。看张鑫旭对前端的要求中，光是“掌握 JS 中的字符串、函数、对象、数组、字面量等基本概念，熟记所有内置的方法（包括参数和返回值）”这一条就足够我汗颜了。看的书籍虽然有笔记，但也感觉是没有过心。之后会将博客中的读书笔记再按照知识点，辅以自己的进一步学习成果拆分细化。虽然这是一个比较大的工程，但我觉得这是一个很有必要的工作。 经典书籍读的不够多。像《你不知道的 JavaScript》、《JavaScript 设计模式与开发实践》等书都没有看。 某些时候还是有些懒惰，没有抽出空余时间来学习。或者是在学习过程中在知乎、贴吧、空间、微博耗费了注意力，导致学习效率不高。 包括博文和项目在内的学习产出还是不多，博文也没有特别有价值的内容。毕业前要在 github 上有一个 100+ star 的项目，还要部署到 npm 上。博客考虑备案和 SEO，以激励自己写出更有价值的文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单页面程序及组件化相关笔记]]></title>
      <url>%2FSPA-learning-notes%2F</url>
      <content type="text"><![CDATA[随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 xufei 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。 提高开发效率的两个主要途径： 加快开发速度：少造轮子。 减少变更代价：清理模块之间的关系，合理分层。 单页面程序SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。 优越性高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。 实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。 代码合并与加载策略典型特征：部分加载。 一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的异步加载机制去运行时加载。 因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。 需要考虑的点路由与状态的管理界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。 缓存与本地存储动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。 在本地存储一些临时数据可以用 localStorage。 服务器通信WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。 例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。 困难与缺陷SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。 缺陷：不利于 SEO；要注意内存管理。 样式规划基准样式的分离包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。 组件样式的划分组件样式应当尽量减少相互依赖，各组件的样式允许冗余。 堆叠次序的管理在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。 组件化整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。 职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。 HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。 JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。 CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。 开发框架jQuery 轻量、灵活，但对代码缺乏约束。 需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。 因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。 AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。 React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。 依赖注入： 核心理念：通过配置来实例化所依赖的组件。 缺点：性能以及跟踪调试的便利性上的损失。 优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。 应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。 MV*框架的基本原理充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在配置文件（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动： 初始化自身（bootstrap） 异步加载可能尚未引入的 JavaScript 代码（require） 解析定义在 HTML 上的规则（template parser） 实例化模型（scopr） 创建模型和 DOM 的关联关系（binding, injection） 这些是主线流程，还有一些支线，比如： 解析 url 的 search 字符串，恢复状态（route） 加载 HTML 部件模板（template url） 部件模板和模型的关联（binding） 业务模型指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。 Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。 参考资料博文参考资料： Web应用的组件化（一）——基本思路 构建单页Web应用 关于新框架的学习 延伸阅读资料： Web应用的组件化（二）——管控平台]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最近在干以及打算干些什么]]></title>
      <url>%2Frecent-and-will%2F</url>
      <content type="text"><![CDATA[这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。 在干什么： 写花旗杯项目前端第一版。 开始看 Vue.js 的文档。 看一些关于前端工程化的博文。 打算干什么： 继续看完 Vue.js 的文档并且找一个 Demo 做一做。 尽早看完 ES 6 新特性。 看一看 Grid。 最近看的优秀文章： CSS Modules 入门及 React 中实践 玩转 npm：介绍了常用的 npm 命令。 构建单页Web应用：理解单页 Web 应用。我想这篇文章我还会再看至少两遍。 HTML5 高级系列：web Storage：了解如何通过 localStorage 和 sessionStorage 存储一些数据。 [译] 人人须知的 jQuery 技巧：介绍了一些 jQuery 代码片段，包括预加载图片、禁用输入字段、简单的手风琴效果等。建议自己整理一份类似的代码片段库。 FIGlet初识：了解一下 FIGlet，不实用，但还有点意思。 如何处理CSS3属性前缀：介绍了 Autoprefixer，用于处理 CSS 3 属性前缀的问题。 JavaScript Modularization Journey：JS 模块化发展史。还得再看几遍…等我到了该接触 Webpack 的时候。 看到的好玩意： Awesomes - Web前端开发资源库：全是前端的开源项目，遍地的轮子啊。关键是文档很多都翻译成中文了。 pkg：帮助你将你的 Node.js 程序打包成即使在没有 node 环境的设备上也能运行。 一个有趣的 CSS 按钮效果 Hover.css：Hover.css 是一个 CSS3 的鼠标悬停效果集合，可用于超链接，按钮，logo，SVG，推荐图片等等。能够很简单地运用到我们的元素中。 之后想做的练习（时间好少QAQ）： 谈谈一些有趣的CSS题目 原生JavaScript学习-实例索引 百度前端技术学院]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《ECMAScript 6 入门》读书笔记(二)]]></title>
      <url>%2Fes6-2-notes%2F</url>
      <content type="text"><![CDATA[说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《ECMAScript 6 入门》。希望能早日啃完，想去看 Vue.js 了… 此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。 函数的扩展函数参数的默认值1.ES 6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 12345678910111213141516171819202122232425262728293031323334353637function log(x, y = 'World')&#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'Kyon') // Hello Kyonlog('Hello', '') // Hello// 与解构赋值默认值结合使用function foo(&#123;x, y = 5&#125;)&#123; console.log(x, y);&#125;foo(&#123;x: 1&#125;) // 1, 5foo() // TypeeError: Cannot read property 'x' of undefined// 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x有值，y无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x和y都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined] 参数变量是默认声明的，所以不能用let或const再次声明；使用参数默认值时，函数不能有同名参数。 定义了默认值的参数通常应该为函数的尾参数。 2.函数的length属性：将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，后面的参数也不会被计入。 3.作用域：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，作用域消失。 12345678910// 函数foo内部声明的内部变量与参数不是同一个作用域var x = 1;function foo(x, y = function()&#123; x = 2; &#125;)&#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 123456789var x = 1;function foo(x, y = function()&#123; x = 2; &#125;)&#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 4.函数参数默认值的应用：可以指定某一个参数不得省略，如果省略就抛出一个错误。 123456789101112function throwIfMissing()&#123; throw new Error('Missing parameter');&#125;function foo(mustBeprovided = throwIfMissing())&#123; return mustBeProvided;&#125;// throwIfMissing函数名之后有一对圆括号// 表明参数的默认值不是在定义时执行，而是在运行时执行// 即如果参数已经赋值，默认值中的函数就不会运行foo() // Error: Missing parameter 可以将参数默认值设为undefined，表明这个参数是可以省略的。 5.rest 参数：形式为”…变量名”，用于获取函数的多余参数。rest 参数中的变量代表一个数组。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1const sortNumbers = (...numbers) =&gt; numbers.sort(); 函数的length属性，不包括 rest 参数。 1(function(a,...b)&#123;&#125;).length // 1 函数参数的默认值6.扩展运算符：...，将一个数组转为用逗号分隔的参数序列。 123456789console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5var numbers = [4, 35];add(...numbers) // 39// 不再需要 apply 方法将数组转为函数参数function f(x, y, z)&#123;&#125;f(...args); 7.扩展运算符的应用： 合并数组：提供了新写法。 123456var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];arr1.concat(arr2, arr3); // ES 5[...arr1, ...arr2, ...arr3] // ES 6 与解构赋值结合：用于生成数组（只能放在参数最后一位）。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = ["foo"];first // "foo"rest // [] 函数的返回值：为函数提供一种返回多个值的方法。 1234// 从数据库取出一行数据，通过扩展运算符，直接传入构造函数Datevar dateFields = readDateFields(database);var d = newDate(...dateFields); 字符串：扩展运算符还可以将字符串转为真正的数组。 1234567let str = 'x\uD83D\uDE80y';str.split('').reverse().join('')// 'y\uDE80\uD83Dx'[...str].reverse().join('')// 'y\uD83D\uDE80x' 实现了 Iterator 接口的对象：可以通过扩展运算符转为真正的数组。 12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符。Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567891011121314151617// Map结构let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3]// Generator 函数var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 8.函数内部严格模式：ES 5 时函数内部可以设定为严格模式；ES 6 规定只要函数参数使用了默认值、解构赋值或者扩展运算符，则函数内部不能显式设定为严格模式，否则报错。 原因：只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。 两种规避方法：全局性严格模式，将函数包在一个无参数的立即执行函数里。 9.name 属性：返回该函数的函数名。 如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。 1234const bar = function baz()&#123;&#125;;// ES 5、ES 6bar.name // "baz" Function构造函数返回的函数实例，name 属性的值为 anonymous。 1(new Function).name // "anonymous" bind返回的函数，name属性值会加上bound前缀。 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // "bound foo"(function()&#123;&#125;).bind(&#123;&#125;).name // "bound " 箭头函数10.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 12345678910111213141516// 箭头函数与变量解构结合使用const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person)&#123; return person.first + ' ' + person.last;&#125;// 简化回调函数[1, 2, 3].map(x =&gt; x * x);// 等同于[1, 2, 3].map(function(x)&#123; return x * x;&#125;); 11.箭头函数使用注意点： 函数体内的this对象就是定义时所在对象，而不是使用时所在对象。 不可当作构造函数（即不可使用new命令），否则抛出错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。也正因如此，箭头函数不能用作构造函数，也不能用call()、apply()、bind()这些方法去改变this的指向。 除了this，arguments、super、new.target在箭头函数中也是不存在的，指向外层函数的对应变量。 12.嵌套的箭头函数： 12345678910111213141516171819// ES 5function insert(value) &#123; return &#123;into: function(array) &#123; return &#123;after: function(afterValue) &#123; array.splice(array.indexOf(afterValue)+1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); // [1, 2, 3]// ES 6let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue)+1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); // [1, 2, 3] 13.函数绑定运算符：::，左边为对象，右边为函数。该运算符自动将左边的对象作为上下文环境（即 this 对象），绑定到右边的函数上。用来取代call、apply、bind调用。 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;var log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 12345let &#123; find, html &#125; = jake;document.querySelectorAll("div.myClass")::find("p")::html("hahaha"); 该语法为已被 Babel 转码器支持的一个 ES 7 提案。 14.尾调用：某个函数的最后一步是调用另一个函数。 To be continued… 对象的扩展1.属性的简洁表示法：ES 6 允许直接写入变量和函数，作为对象的属性和方法。这时，属性名为变量名，属性值为变量值。 1234567891011121314151617181920var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于var baz = &#123;foo: foo&#125;;var o = &#123; method()&#123; return "Hello!"; &#125;&#125;;// 等同于var o = &#123; method: function()&#123; return "Hello!"; &#125;&#125;; 如果某个方法的值是一个 Generator 函数，前面需要加上星号。 12345var obj = &#123; * m()&#123; yield 'hello world'; &#125;&#125;; 2.属性名表达式：ES 6 允许字面量定义对象时，把表达式放在方括号内。表达式也可用于定义方法名。 123456789101112131415let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;;// 表达式用于定义方法名let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 但属性名表达式与简洁表达式不能同时使用。 12345678// 报错var foo = 'bar';var bar = 'abc';var baz = &#123; [foo] &#125;;// 正确var foo = 'bar';var baz = &#123; [foo]: 'abc'&#125;; 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]（即不要这么用）。 3.方法的 name 属性：返回函数名。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 4.Object.is()：比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致（不同之处为+0不等于-0，以及NaN等于自身）。 5.Object.assign()：用于对象的合并，将源对象的所有可枚举属性复制到目标对象。第一个参数是目标对象，其他参数是源对象。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果多个对象有同名属性，后面的属性会覆盖前面的。 如果只有一个参数将直接返回（参数不是对象会先转成对象）。无法转成对象的源对象将被跳过。undefined和null无法转成对象，所以不能作为目标对象（否则报错）。其他相关注意事项见文档。 实行浅拷贝，即源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。对于嵌套对象，一旦遇到同名属性会被替换。 1234var target = &#123; a: &#123; b: 'c', d: 'e'&#125; &#125;;var source = &#123; a: &#123; b: 'hello' &#125; &#125;;Object.assign(target, source); // &#123;a: &#123; b: 'hello' &#125;&#125; Object.assign()有很多用处，其中包括为对象添加属性和方法。 1234567891011121314151617// 添加属性class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125;// 添加方法Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2)&#123; ... &#125;, anotherMethod()&#123; ... &#125;&#125;);// 等同于SomeClass.prototype.someMethod = function(arg1, arg2) &#123; ... &#125;;SomeClass.prototype.anotherMethod = function()&#123; ... &#125;; 属性的可枚举性与遍历6.Object.getOwnPropertyDescriptor：对象的每个属性都有一个描述对象，用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获得该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo');// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; ES 7 引入Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。 1234567891011121314151617181920const obj = &#123; foo: 123, get bar() &#123; return 'abc'; &#125;&#125;;Object.getOwnPropertyDescriptors(obj);// &#123;// foo: &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125;,// bar: &#123;// get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true// &#125;// &#125; 7.属性的可枚举性：描述对象的enumerable属性，成为“可枚举性”。ES 5 有三个操作会忽略enumerable为false的属性： for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 ES 6 新增Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 当只关心对象自身的属性时，尽量不要用for...in循环，而用Object.keys()代替。 8.Object.keys()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键名。ES 2017 引入配套的Object.values和Object.entries作为遍历一个对象的补充手段。 Object.values()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键值（不含 Symbol 属性）。参数为字符串时返回各个字符组成的一个数组，参数为数值或布尔值时返回空数组（与包装对象有关）。 Object.entries()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键值对数组（不含 Symbol 属性）。 9.属性的遍历：ES 6 共有5种遍历对象的方法。 for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但包括不可枚举属性）。 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性（无论是否可枚举或者属性名是 Symbol 还是字符串）。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则（之前一些遍历的方法也遵循此规则）。 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 __proto__属性及相关方法10.__proto__属性：用于读取或设置当前对象的prototype对象。内部属性，不是正式对外 API。建议使用Object.setPrototypeOf()（写操作）、Object.getPrototype()（读操作）、Object.create()（生成操作）代替。 如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。 11.Object.setPrototypeOf()：作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。 12345// 格式Object.setPrototypeOf(object, prototype)// 用法var o = Object.setPrototypeOf(&#123;&#125;, null); 如果第一个参数不是对象，会自动转为对象（由于返回的还是第一个参数，故无效果）；是undefined或null则报错（无法转为对象）。 12.Object.getPrototypeOf()：用于读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 如果参数不是对象，会被自动转为对象；是undefined或null则报错。 13.对象的扩展运算符：ES 2017 将...引入对象。主要用途有： 解构赋值： 1234let &#123;x, y, ...z&#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 注意解构赋值的拷贝是浅拷贝，且不会拷贝继承自原型对象的属性。 123456789// 扩展某个函数的参数，引入其他操作function baseFunction(&#123; a, b &#125;) &#123; // ...&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用x和y参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 扩展运算符：取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于Object.assign方法。 123456789101112let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;// 等同于let n = Object.assign(&#123;&#125;, z);// 用于合并两个对象let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。因此可用于修改现有对象部分的部分属性。 1234let newVersion = &#123; ...previousVersion, name: 'New Name' // Override the name property&#125;; 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 1let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;; 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 14.Null 传导运算符：?.，用于判断对象及其内部属性是否存在。仅为提案，详见文档。 Symbol1.概述：ES 6 引入的新的原始数据类型，表示独一无二的值。至此，JS 共有七种数据类型： Undefined Null 布尔值（Boolean） 字符串（String） 数值（Number） 对象（Object） Symbol Symbol 值通过Symbol函数生成。即对象的属性名有两种类型：原来就有的字符串，和新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就是独一无二的，不会与其他属性名产生冲突。 1234let s = Symbol();typeof s// "symbol" 生成的 Symbol 是一个原始类型的值，不是对象。因此Symbol函数前不能使用new命令（否则报错），Symbol 值也不能添加属性。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。但相同参数的Symbol函数的返回值是不相等的。 12345678var s1 = Symbol('foo');var s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // "Symbol(foo)"s2.toString() // "Symbol(bar)" 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后生成一个 Symbol 值。 1234567const obj = &#123; toString()&#123; return 'kyon'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) Symbol 值不能与其他类型的值进行运算（会报错），但可以显式转为字符串和布尔值。 2.作为属性名的Symbol： 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello'! &#125;);// 以上写法都得到同样结果a[mySymbol] // "Hello!" Symbol 值作为对象属性名时，不能用点运算符。 123456var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // "Hello!" Symbol 值作为属性名时，该属性是公开属性而非私有属性。 3.魔术字符串：在代码中多次出现、与代码形成强耦合的某一个具体的字符串或数值。应尽量消除而改用含义清晰的变量代替。 Symbol可用于消除魔术字符串。 4.属性名的遍历：Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。这个特性可被用于为对象定义一些非私有的、但又希望只用于内部的方法。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 Reflect.ownKeys(obj)方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// ["enum", "nonEnum", Symbol(my_key)] 5.Symbol.for()、Symbol.keyFor()：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234var s1 = Symbol.for('foo');var s2 = Symbol.for('foo');s1 === s2; // true Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 12345Symbol.for("bar") === Symbol.for("bar")// trueSymbol("bar") === Symbol("bar")// false Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345var s1 = Symbol.for("foo");Symbol.keyFor(s1); // "foo"var s2 = Symbol("foo")Symbol.keyFor(s2); // undefined 6.Singleton 模式：指调用一个类，任何时候返回的都是同一个实例。 Node 中，模块文件可以看作一个类。可以使用 Symbol，通过把实例放到顶层对象global来实现 Singleton 模式。 内置的 Symbol 值(暂且略过)7.Symbol.hasInstance属性：指向一个内部方法。 8.Symbol.isConcatSpreadable属性： 9.Symbol.species 10.Symbol.match 11.Symbol.replace 12.Symbol.search 13.Symbol.split 14.Symbol.iterator 15.Symbol.toPrimitive 16.Symbol.toStringTag 17.Symbol.unscopables Set 和 Map 数据结构Set1.基本用法：Set 结构不会添加重复的值。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for(let i of s)&#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。因此有一种去除数组重复成员的方法： 1[...new Set(array)] Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，类似精确相等运算符（===），主要的区别是NaN等于自身（===认为NaN不等于自身）。另外，两个对象总是不相等的。 2.Set 实例的属性和方法： 实例属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法： add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个表示删除是否成功的布尔值。 has(value)：返回一个布尔值。 clear()：清除所有成员，没有返回值。 遍历方法（Set 结构中，键名和键值是同一个值）： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Array.from方法可以将 Set 结构转为数组。 WeakSet3.含义：与 Set 类似，但成员只能是对象，且都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 ES 6 规定，WeakSet 不可遍历。 4.语法：有add、delete、has方法；没有size属性。 5.用处：是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 Map6.含义和基本用法：为了解决 Object 的只能用字符串当作键名的问题，ES 6 提供了 Map 数据结构。各种类型的值（包括对象）都可以当作键。 有set(key, value)、get(key)、has(key)、delete(key)、clear()方法。 作为构造函数，Map 可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组。 如果对同一个键多次赋值，后面的值将覆盖前面的值；如果读取一个未知的键，则返回undefined。 7.与其他数据结构的互相转换： Map 转为数组：使用扩展运算符（...）。 数组转为 Map：使用 Map 构造函数。 Map 转为对象：如果所有 Map 的键都是字符串，可以转为对象。 1234567891011function strMapToObj(strMap)&#123; let obj = Object.create(null); for(let [k, v] of strMap)&#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap);// &#123; yes: true, no: false &#125; 对象转为 Map： 1234567function objToStrMap(obj)&#123; let strMap = new Map(); for(let k of Object.keys(obj))&#123; strMap.set(k, obj[k]); &#125; return strMap;&#125; Map 转为 JSON： 12345// 情况一：Map 的键名都是字符串// 可以转换为对象 JSONfunction strMapToJson(strMap)&#123; return JSON.stringify(strMapToObj(strMap));&#125; 12345// 情况二：Map 的键名有非字符串// 可以转换为数组 JSONfunction mapToArrayJSON(map)&#123; return JSON.stringify([...map]);&#125; JSON 转为 Map：逆操作。 WeakMap8.含义：与 Map 类似，用于生成键值对。但只接受对象作为键名（null除外），且键名所指向的对象不计入垃圾回收机制。 专用场合：它的键所对应的对象可能会在将来消失。WeakMap结构有助于防止内存泄漏。 9.语法：没有遍历操作，无法清空。只有四个方法可用：get()、set()、has()、delete()。 10.用处：DOM 节点作为键名。 123456789101112// 一个例子let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function()&#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false);// 一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险 注册监听事件的listener对象，就很适合用 WeakMap 实现。 123456789const listener = new WeakMap();listener.set(element1, handler1);listener.set(element2, handler2);element1.addEventListener('click', listener.get(element1), false);element2.addEventListener('click', listener.get(element2), false);// 一旦DOM对象消失，跟它绑定的监听函数也会自动消失 WeakMap 的另一个用处是部署私有属性。 Proxy暂时跳过。 Reflect暂时跳过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通jQuery》读书笔记]]></title>
      <url>%2FjQuery-master-notes%2F</url>
      <content type="text"><![CDATA[这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。 感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。 了解 jQueryjQuery 核心库的工作通过处理浏览器加载 HTML 时动态创建的 DOM（文档对象模型），达到动态修改页面内容的目标。 HTML 入门事件流一个事件在它的生命周期中要经历 3 个阶段：捕获、处理目标元素和冒泡。 目标元素：触发事件的元素。 CSS 基础反选择器:not(&lt;selector&gt;)：选取不匹配指定选择器的元素。 样式层叠浏览器查找样式元素值的顺序： 行内样式（定义在元素 style 属性中的样式）； 内嵌样式（定义在 style 元素中的样式）； 外部样式（使用 link 元素导入的样式）； 用户样式（用户自己定义的样式）； 浏览器样式（浏览器提供的默认样式）。 前三个又合称为作者样式。 important 规则在样式声明的末尾追加!important可以把改值标识为重要样式。浏览器会给重要样式以优先权，而不再考虑这个样式的定义位置。 唯一能优先于作者样式中重要样式的样式是定义在用户样式表中的重要样式。对于普通样式来说，作者样式优先于用户样式。但对于重要样式，浏览器的做法恰恰相反。 “专一程度”浏览器根据以下 3 个特征计算样式的“专一程度”： 选择器中出现的 id 值个数； 选择器中出现的其他属性和伪类个数； 选择器中出现的元素名字和伪元素名字个数。 以 a-b-c 这种形式评估样式规则的“专一”程度，逐位比较，每一位上数字越大表示越专一。例如，1-0-0 比 0-5-5 更专一。 如果有多条样式规则的专一程度相同，那么浏览器会选择最后定义的那条规则。专一程度规则仅在同一层叠级别有效。 样式单位相对长度单位 em：相对于元素字号的高度； ex：相对于元素字体中小写字母 x 的高度； rem：相对于根元素的高度； px：CSS 像素（假定位于一个 96dpi 的显示设备上，实际上是绝对单位，不会改变大小）； %：另一属性值的百分比。 jQuery 基础使用 CDN 版的 jQueryCDN（Content Delivery Network）：内容分发网络。当用户请求其数据时，CDN 能智能地分配离用户最近的服务器提供服务。 使用 CDN 的两个优点：(1)用户体验更好（速度通常更快）；(2)节省了传输 jQuery 库所需带宽。 CDN 不适合内联网应用程序。 $ 函数jQuery.noConflict方法让 jQuery 放弃使用 $ 符号。也可将该方法的返回值赋给一个变量以自定义 jQuery 简写符号。 延迟 ready 事件的触发时间$.holdReady(true)必须在 ready 事件触发之前调用，$.holdReady(false)告诉 jQuery 触发 ready 事件。可以多次调用，但在 ready 事件被真正触发之前，使用 true 参数调用次数要等于使用 false 参数调用次数。 选择元素 使用上下文限制搜索范围多给 $ 函数提供一个参数以限制搜索的范围。如果提供的上下文选择器匹配多个元素，将会把匹配上下文选择器的元素收集在一起，然后再匹配主选择器。 12$("img:odd", $(".drow"))// img:odd选择器会应用在.drow选择器的结果上 确定选择结果 数据模版介绍了模板库 Handlebars。 定义模板数据模板库的核心是数据模板——包含着占位符的 HTML 元素。 p268 处理表单介绍了 jQuery 插件 Validation，它专门处理表单验证问题。 jQuery Validation Engine 表单验证 p297 Ajaxp331]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《ECMAScript 6 入门》读书笔记(一)]]></title>
      <url>%2Fes6-1-notes%2F</url>
      <content type="text"><![CDATA[《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：ECMAScript 6 入门。将知识点简便地总结一下，以供后续使用时参考或复习。 此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。 let和const命令1.let：let声明的变量仅在块级作用域内有效。不存在变量提升；存在暂时性死区，只能在声明的位置后面获取和使用；相同作用域内不可重复声明。 2.块级作用域：外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。 3.根据ES 6附录B的规定，在浏览器的ES 6环境中，块级作用域内声明的函数，行为类似于var声明的变量。应避免在块级作用域内声明函数，或用函数表达式代替函数声明语句。 4.do 表达式：在块级作用域之前加上do，使其变为表达式（可以返回值）。 12345// 变量x得到整个块级作用域的返回值let x = do &#123; let t = f(); t * t + 1;&#125;; 5.const：声明一个只读常量。一旦声明，就必须立即初始化。和let一样，只在声明所在的块级作用域内有效；声明的常量不提升；存在暂时性死区；不可重复声明。 const保证变量指向的内存地址不可改动。因此将对象声明为常量时，不可变的只是地址，对象本身可变，可以为其添加新属性。 如果真想将对象冻结，应用Object.freeze()方法（对象本身和 其属性都应冻结）。 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, i) =&gt; &#123; if(typeof obj[key] === 'object') &#123; constantize(obj[key]); &#125; &#125;);&#125;; 6.顶层对象的属性：let、const、class声明的全局变量不属于顶层对象的属性。 补充资料：ES6之”let”能替代”var”吗? 变量的结构赋值1.解构：按照一定模式，从数组和对象中提取值，对变量进行赋值。解构不成功，变量的值就等于undefined。 1234567891011121314151617181920212223let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []let [bar, foo] = [1];foo // undefined 2.不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 3.解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值不会生效。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 如果默认值是一个表达式，那么这个表达式是惰性求值的（用到时才会求值）。 123456// x能取到值，所以函数f根本不会执行function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 4.要将一个已经声明的变量用于解构赋值时，将大括号写在行首会导致JavaScript引擎将其解释为代码块，从而发生语法错误。 12345let x;// 错误写法&#123;x&#125; = &#123;x: 1&#125; // SyntaxError: syntax error// 正确写法(&#123;x&#125; = &#123;x: 1&#125;); 对象的结构赋值5.对象的解构：属性没有次序，变量取值由名称决定。 123let &#123; bar, foo&#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 如果变量名与属性名不一致，须写成： 1234567var &#123; foo: baz&#125; = &#123; foo: 'aaa', bar: 'bbb'&#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 6.解构也可用于嵌套结构的对象。 123456789101112let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;]&#125; = obj;x // "Hello"y // "World"// 这时p是模式，不是变量，因此不会被赋值。p // error: p is undefined 字符串的结构赋值7.此时字符串被转化成一个类似数组的对象，且具有length属性（可以针对此属性解构赋值）。 123456const [a, b, c, d, e] = 'hello';a // "h"e // "o"let &#123;length : len&#125; = 'hello';len // 5 数值、布尔值的结构赋值8.解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。undefined和null无法转为对象，所以对它们解构赋值都会报错。 1234567let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // truelet &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的结构赋值9.为函数move的参数指定默认值： 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 为变量x和y指定默认值： 12345678function move(&#123;x, y&#125; = &#123;x: 0, y:0&#125;)&#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 圆括号问题10.ES6规定，只要可能导致解构歧义，就不得使用圆括号。由于这条规则不易辨别，因此建议尽量不要在模式中放置圆括号。 11.以下三种解构赋值不得使用圆括号。 变量声明语句中，不能带有圆括号。 函数参数中，模式不能带有圆括号。 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 12.可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。 用途 交换变量的值： 123let x = 1;let y = 2;[x, y] = [y, x]; 从函数中返回多个值：将返回的数组或对象中的值取出 函数参数的定义：方便地将无序的参数与变量名对应 提取JSON数据： 12345678910let jsonData = &#123; id: 24, status: "OK", data: [424, 5920]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 24, "OK", [424, 5920] 函数参数的默认值 遍历Map结构： 123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 字符串的扩展1.字符的Unicode表示法：将码点放入大括号。 123"\u&#123;20BB7&#125;" // "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;" // "ABC" 2.新增一些方法： codePointAt()：能够正确处理4个字节储存的字符，返回一个字符的码点。是测试一个字符由两个字节还是由四个字节组成的最简单方法。 String.fromCodePoint()：用于从码点返回对应字符，可识别Unicode编号大于0xFFFF的码点（32位的UTF-16字符）。 at()（提案）：返回字符串给定位置的字符，可识别Unicode编号大于0xFFFF的码点。 repeat(n)：返回一个新字符串，表示将原字符串重复n次。 normalize()：将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 padStart()：如果某个字符串不够指定长度，会在头部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串（默认为空格）。 padEnd()：同上，用于尾部补全。 3.模版字符串：常用于定义多行字符串，或者在字符串中嵌入变量。用反引号（`）标识。 12345678910// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`// 字符串中嵌入变量var name = "Kyon", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 模板字符串中嵌入变量，要将变量名卸载${}中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，也可以调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串（例如对象调用toString方法）。 4.标签模板（功能）：函数调用的一种特殊形式。模板字符串作为参数紧跟在一个函数名后，该函数被调用以处理该模板字符串。常用于转义特殊字符和多语言转换（国际化处理）。 123console.log`Kyon`// 等同于console.log('Kyon') 模板字符有变量时，先把模板字符串处理成多个参数。处理得到的第一个参数是一个数组，包含那些没有变量替换的部分。 123456var a = 5;var b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`;// 等同于tag(['Hello', ' world', ''], 15, 50); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存转义后的原字符串。 5.String.raw()：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串；如果原字符串的斜杠已经转义，则不会做任何处理。常用于处理模板字符串。 12345String.raw`Hi\n$&#123;3+4&#125;!`;// "Hi\\n7!"String.raw`Hi\u000A!`;// 'Hi\\u000A!' 也可作为正常函数使用，第一个参数应是具有raw属性的对象，且raw属性的值应是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 6.模板字符串的限制（提案）：放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 正则的扩展1.u修饰符：Unicode 模式，用来正确处理大于\uFFFF的 Unicode 字符。对于码点大于\uFFFF的 Unicode 字符，点字符(.，除了换行符外的任意单个字符)、Unicode 字符表示法（使用大括号表示 Unicode 字符）、量词、预定义模式（\S，匹配所有不是空格的字符）必须加上u修饰符才能识别。 1234/^\uD83D/u.test('\uD83D\uDC2A')// false/^\uD83D/.test('\uD83D\uDC2A')// true 2.y修饰符：“粘连”修饰符，全局匹配，但须确保匹配必须从剩余的第一个位置开始。一个应用是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // ["aaa"]r2.exec(s) // ["aaa"]r1.exec(s) // ["aa"]r2.exec(s) // null 3.ES 6 的正则对象新增了sticky属性和flags属性，分别表示是否设置了y修饰符以及返回正则表达式的修饰符。 123var r = /hello\d/y;r.sticky // truer.flags // 'y' 4.有一些提案。因为我暂时对正则不太熟悉，所以略过。 数值的扩展1.二进制、八进制表示法：分别用前缀0b（或0B）和0o（或0O）表示。用Number()方法将其转化为十进制。 12340b111110111 === 503 // true0o767 === 503 // trueNumber('0b111') // 7 2.新增 Number 对象上的一些方法： Number.isFinite()：用于检查一个数值是否为有限的。 Number.isNaN()：用于检查一个值是否为NaN。 与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。 将全局方法parseInt()和parseFloat()移植到 Number 对象上，行为完全保持不变，目的是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()：用于判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是同样的储存方法，这个方法都会返回 true。 3.Number.EPSILON：极小的常量，表示一个可以接受的误差范围。浮点数计算误差小于Number.EPSILON时可以认为得到正确结果。 4.Number.isSafeInteger()：JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围的值无法精确表示。Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 5.Math 对象的扩展：所有新增方法都是静态方法，只能在 Math 对象上调用。 Math.trunc()：用于去除一个数的小数部分，返回整数部分。对于非数值内部使用Number方法将其先转为数值；对于空值和无法截取整数的值，返回 NaN。 Math.sign方法用来判断一个数到底是正数、负数、还是零。它会返回五种值：参数为正数，返回+1；负数返回-1；0返回0；-0返回-0；其他值返回NaN。 Math.cbrt：用于计算一个数的立方根。 此外，还有一些对数方法和三角函数方法。 6.指数运算符（**）： 1234562 ** 2 // 42 ** 3 // 8let a = 3;a **= 3;// 等同于 a = a * a * a; 数组的扩展1.Array.from()：将类数组对象（本质特征是有length属性）和可遍历对象（部署了 Iterator 接口的数据结构，包括 ES 6新增的 Set 和 Map）转化为真正的数组。 1234567891011let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;var arr1 = Array.from(arrayLike);Array.from('hello');// ['h', 'e', 'l', 'l', 'o'] 还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组；如果map函数里面用到了this关键字，还可以传入Array.from()的第三个参数，用来绑定this。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 2.Array.of()：返回参数值组成的数组（没有参数则返回空数组）。 12345Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]Array.of(3) // [3]Array.of(3, 11, 8) // [3, 11, 8] 3.数组实例的copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置（覆盖原有成员），然后返回当前数组。 接受三个参数（都为数值，否则自动转换）： target（必需）：从该位置开始替换数据； start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 1234Array.prototype.copyWithin(target, start = 0, end = this.length)[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 4.数组实例的find()和findIndex()： find()用于找出第一个符合条件的数组成员。其参数为一个回调函数（可以接收三个参数：当前的值，当前的位置和原数组），所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员，否则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 findIndex()类似，返回第一个符合条件的数组成员的位置，否则返回-1。 5.数组实例的fill()：用给定值填充一个数组。 1234567// 数组中原有的元素将被覆盖['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]// 还可以接受两个参数，用于指定填充的起始位置和结束位置['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 6.数组实例的keys()、values()和entries()：用于遍历数组。都返回一个遍历器对象，可以用for..of循环进行遍历；区别为分别对键名、键值、键值对遍历。 1234567891011121314151617for(let index of ['a', 'b'].keys())&#123; console.log(index);&#125;// 0// 1for(let elem of ['a', 'b'].values())&#123; console.log(elem);&#125;// 'a'// 'b'for(let [index, elem] of ['a', 'b'].entries())&#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 7.数组实例的includes()（属于ES 7 但 Babel 转码器已经支持）：返回一个布尔值，表示某个数组是否包含给定的值。 123[1, 2, 3].includes(2); // true[1 ,2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 8.数组的空位：和undefined不同，数组的空位没有任何值。ES 5 对空位的处理规则很不一致（大多数情况会忽略）；而 ES 6 明确将空位转为undefined。尽管如此，建议避免出现空位。 1Array(3) // [, , ,]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究伪元素及其用途]]></title>
      <url>%2Fpseudo_elements%2F</url>
      <content type="text"><![CDATA[之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。 伪类与伪元素的区别伪元素(Pseudo-elements)容易与伪类(Pseudo-classes)混淆。在 w3c 定义中，伪类用于向某些选择器添加特殊的效果，而伪元素用于将特殊的效果添加到某些选择器。可以看到从定义上来说，二者确实不好分辨。不过在种类上可以看出二者的一些不同。 伪类包括： :link：向未被访问的链接添加样式。 :visited：向已被访问的链接添加样式。 :hover：当鼠标悬浮在元素上方时，向元素添加样式。 :active：向被激活的元素添加样式。 :focus：向拥有键盘输入焦点的元素添加样式。 :first-child：向元素的第一个子元素添加样式。 :lang：向带有指定 lang 属性的元素添加样式。 其中前四个因为用不同的方式显示链接的不同状态，被称为“锚伪类”。在 CSS 定义中，a:hover必须被置于 a:link和a:visited之后，而a:active必须被置于a:hover之后才是有效的。 伪元素包括： :before：在元素之前添加内容。 :after：在元素之后添加内容。 :first-letter：向文本的第一个字母添加特殊样式。 :first-line：向文本的首行添加特殊样式。 其中前两个无疑是用的最多的。后两个也可以用于实现一些特殊效果，例如通过:first-letter实现段落首字母加粗或变色。 两者的根本区别是：伪类可以通过直接添加一个实际的类样式达到同等效果；而伪元素的效果则需要先添加一个实际的元素，再在元素上添加样式才能达到。 在 CSS 3 中修订后的伪元素使用两个冒号（::）以与伪类进行区分。但无论使用单冒号还是双冒号，浏览器都能识别。并且 IE 8 只支持单冒号的写法。因此为了更广泛的浏览器兼容性，还是推荐使用单冒号的写法。 伪元素的优点最常使用的两种伪元素——:before和:after可以在内容元素的前后插入额外的元素。通过伪元素，在实现很多炫酷的视觉效果时，我们不必修改现有的 HTML 文档结构。因为 HTML 文档本身仅仅应该包含内容，而不应该包含样式，所以伪元素更应该被提倡。 伪元素的应用鉴于伪元素应用很多时候代码相对专一，建议配合 Sass，通过设置 mixin 来使用以提高复用性（你可以通过我的上一篇博文 初见Sass－便捷的CSS预处理器 来了解Sass）。 清除浮动这大概是伪元素最为常见的应用了。比起插入额外的非语义标记来清除内联元素的浮动，这种俗称“clearfix”的方式更语义化。 CSS 123456789101112.group:before,.group:after &#123; content:&quot;&quot;; display:table;&#125;.group:after &#123; clear:both; overflow: hidden;&#125;.group &#123; zoom:1; /* For IE 6/7 (trigger hasLayout) */&#125; Sass 12345678910111213141516@mixin clearfix &#123; @if $legacy-support-for-ie &#123; *zoom: 1; &#125; &amp;:before, &amp;:after &#123; content: &quot;&quot;; display: table; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125; &#125;// 通过 @include 方法调用 实现样式效果能够借助伪元素实现的样式效果数不胜数。这里举一个简单而常用的例子。 很多时候我们会在每一节的标题下做一个类似下划线效果，用来强调。使用伪元素可以让我们不必添加额外的元素来实现这个效果。 Sass 代码如下： 123456789101112131415@mixin section-title() &#123; font-size: 2em; padding: 2em 0; text-transform: uppercase; color: #55a2dd; &amp;:after &#123; display: block; content: &quot;&quot;; background-color: #cccccc; width: 2em; height: .2em; margin: .4em auto; &#125;&#125; 设置透明度有时我们想给一张大图设置透明度，却发现其子元素都会被继承这个透明度。以往想要消除这个属性总让我头大。现在通过伪元素，我们就可以分别为文字和图片设置不同的透明度。 Sass 代码如下（来自第3周：设计你自己的页面）： 1234567891011121314151617181920212223242526272829303132333435363738394041.hero &#123; width: 100%; min-height: 50em; position: relative; background-color: $mask-color; z-index: 1; &amp;:after &#123; background: url(&apos;../images/hero-1-resized.jpg&apos;); background-size: cover; position: absolute; content: &quot;&quot;; z-index: -1; opacity: .2; width: 100%; height: 100%; top: 0; left: 0; &#125; h2 &#123; font-size: 6em; font-weight: bold; padding: 3em 0 1em 0; text-transform: uppercase; color: white; &#125; p &#123; max-width: 70%; font-size: 1.5em; font-weight: lighter; color: #cecece; line-height: 1.4; margin: 0 auto; padding: 1em 0 8em 0; span &#123; color: $heading-color; &#125; &#125;&#125; 对于 .hero 这个 section，我们将其背景设置为灰色，并将 position 设置为 relative。然后为其添加了一个伪元素，这个伪元素上包含了实际的图片，并为图片设置了透明度 .2。 参考资料CSS 伪元素 - W3School 你可以从这篇文章中了解更多伪元素的应用：大放异彩的伪元素——可以做什么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初见Sass－便捷的CSS预处理器]]></title>
      <url>%2Fsass-begin%2F</url>
      <content type="text"><![CDATA[发现自己又找到一本关于前端实践的优质开源书《3周3页面》。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。” 什么是Sass为了给 CSS 加入编程元素，人们发明了Sass。Sass 是一个 CSS3 的扩展语言，它提供了嵌套样式，变量定义，扩展，mixin等丰富的特性，使得编写样式更加容易，节省了开发者的时间。 Sass基础语法这里只记录我觉得比较关键的语法作为备忘。可以查看 sass十分钟入门 或者 SASS用法指南 以较为全面地入门。 变量：以$开头。如果变量需要镶嵌在字符串之外，需要写在#{}中。 嵌套：用&amp;引用父元素。 继承：使用@extend命令。 Mixin：使用@mixin命令定义一个代码块，使用@include命令调用。可以指定参数和缺省值。 插入文件：使用@import命令。 自定义函数：使用@function和@return。 此外支持条件语句和循环语句。 WebStorm中使用Sass注意，本节内容针对 OS X 环境。可能部分内容也兼容其他平台，但我没试过。 WebStorm 支持 Sass 的自动编译。在 WebStorm 的 Preferences 中，Tools 下选择 File Watchers。配置 Sass 和 SCSS（最新版的 Sass 后缀）需要有相应的 Program。 因为 Sass 依赖 ruby，所以要先安装 ruby。不过 OS X 好像自带 ruby（至少我没有什么时候安装过的印象…）。之后建议安装 Compass：sudo gem install compass，Sass 和 SCSS 的 Program 会被一并安装，WebStorm 也会检测到，之后点击 OK 即可。 之后，WebStorm 会自动监测 Sass 文件的改动，并时刻编译为同名 CSS 文件，保存在同一文件夹下，非常方便。 Sass实现媒体查询1234567891011121314151617// 定义两个 break-point$break-small: 320px;$break-large: 1024px;// 定义一个 mixin，接收三个可能的参数// 分别代表不同的设备——手机、平板和桌面显示器@mixin respond-to($media) &#123; @if $media == handhelds &#123; @media only screen and (max-width: $break-small) &#123; @content; &#125; &#125; @else if $media == medium-screens &#123; @media only screen and (min-width: $break-small + 1) and (max-width: $break-large) &#123; @content; &#125; &#125; @else if $media == wide-screens &#123; @media only screen and (min-width: $break-large) &#123; @content; &#125; &#125;&#125; 使用时： 12345div&#123; @include respond-to(medium-screens) &#123; //... &#125;&#125; 这种方式使用起来更方便，也便于后期统一修改变量的具体数值。 参考资料《3周3页面》的作者同样推荐了 Compass。这是一个使用了 Sass 的库，将很多常用样式打包成了一些模块以供使用。因为安装时出现了一些我还没解决的 error，我还没有使用过。可以查看 Compass用法指南 以获得更多了解。 此外，推荐 SASS基础——十个常见的Mixins。这篇文章总结了一些常用的 Mixin，更重要的是，通过这些Mixin，对 CSS 可以获得更深入的理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[神奇的CSS动画]]></title>
      <url>%2Fcss-animation%2F</url>
      <content type="text"><![CDATA[按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。 通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。 17.04.03更新：补充打字机动效。 transition 属性transition 是一个速记属性，有以下四个属性： transition-property：指定 CSS 属性的 name, transition 效果； transition-duration：transition 效果需要指定多少秒（或毫秒）才能完成； transition-timing-function：指定 transition 效果的转速曲线，包括五个模式：ease（渐慢，默认）、linear（匀速）、ease-in（加速）、ease-out（减速）、cubic-bezier 函数（自定义速度模式，可使用工具网站定制）； transition-delay：定义 transition 效果开始的时候。 123456789101112// 简写img&#123; transition: 1s 1s height ease;&#125;// 单独定义img&#123; transition-property: height; transition-duration: 1s; transition-delay: 1s; transition-timing-function: ease;&#125; 其中必须指定 transition-duration 属性，否则持续时间默认为 0 ，没有任何效果。 transition 的局限： 需要事件触发，没法在网页加载时自动发生； 一次性，除非一再触发，否则不能重复发生； 只能定义开始状态和结束状态（即只有两个状态），不能定义中间状态； 需要明确知道开始状态和结束状态的具体数值，才能计算中间状态； 一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。 keyframes（关键帧）animation 属性可以利用 keyframes 关键字定义动画的各个状态，将指定时间段内的动画划分的更为精细。 123456789@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125;div:hover &#123; animation: 1s rainbow infinite;&#125; 0% 可以用 from 表示，100% 可以用 to 表示： 12345@keyframes rainbow &#123; from &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; to &#123; background: yellowgreen; &#125;&#125; 如果省略某个状态，浏览器会自动推算中间状态。也可将多个状态写在一行。 123456789101112131415// 以下都为合法的写法@keyframes rainbow &#123; 50% &#123; background: orange &#125; to &#123; background: yellowgreen &#125;&#125;@keyframes rainbow &#123; to &#123; background: yellowgreen &#125;&#125;@keyframes pound &#123; from，to &#123; transform: none; &#125; 50% &#123; transform: scale(1.2); &#125;&#125; 从一个状态向另一个状态过渡，浏览器默认为平滑过渡。steps 函数可以实现分布过渡。 123div:hover &#123; animation: 1s rainbow infinite steps(10);&#125; animation 常用属性123456789101112131415// 简写div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125;// 单独定义div:hover&#123; animation-name: rainbow; animation-duration: 1s; ainmation-timing-function: linear; animation-delay: 1s; animation-fill-mode: forwards; animation-direction: normal; animation-iteration-count: 3;&#125; animation 有以下常用属性（其余和 transition 大致相似）： animation-iteration-count：指定动画播放次数，可指定为数值或 infinite（无限次）。 animation-direction：指定动画播放方向，默认为 normal。其他可选值有 reverse，alternate 和 alternate-reverse（后两种浏览器支持情况不佳）。 animation-fill-mode：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。有四个可选值： forwards：让动画停留在结束状态； none：回到动画没开始的状态； backwards：让动画回到第一帧的状态； both：根据 animation-direction 轮流应用 forwards 和 backwards 规则。 animation-play-state：指定动画播放突然终止时的状态，默认行为是跳回动画的开始状态。 12345678910// 让动画保持突然终止时的状态div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125; 浏览器支持IE 10、Firefox 16.0、Chrome 43.0、Safari 9.0、Opera 30.0 以上支持没有前缀的 animation。详见 CSS3 animation（动画） 属性 “浏览器支持”部分。 使用示例打字机动效依照 让页面动起来 实现的打字机动效。图片素材为自制，因此部分数据与参照有出入。素材及代码见 bighuang624/Front-end_Learning/打字机动效。 （gif图没搞好…） 参考资料CSS动画简介 - 阮一峰的网络日志 CSS3 animation（动画） 属性 CSS 变换 过渡 动画使用案例 补充： css3 animation 属性众妙]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究JS中的词法作用域]]></title>
      <url>%2Fjs-lexical-scope%2F</url>
      <content type="text"><![CDATA[这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 JavaScript 语言精粹 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 箭头函数 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。” 这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。 词法作用域《JavaScript 权威指南》第5章“8.8.1 词法作用域”中对“词法作用域”的解释如下： “JavaScript 中的函数是通过词法来划分作用域的，而不是动态地划分作用域的。这意味着它们在定义它们的作用域里运行，而不是在执行它们的作用域里运行。当定义了一个函数，当前的作用域链就保存起来，并且成为函数的内部状态的一部分。” 当然，这几句话还是玄之又玄，摸不着头脑。它还是没有具体解释“词法作用域”中的“词法”二字代表什么。不过我这学期的《编译原理》课程上经常见到这个词：编译过程被划分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成 6 个阶段（清华大学出版社《编译原理》）。在查阅资料后，我确信这个概念确实与编译有关。 JavaScript 引擎在代码执行前会对其进行编译，而所谓的词法作用域指作用域是由书写代码时函数声明的位置决定，在词法解析阶段就已经确定，之后不会改变。也就是说，JS 中的“词法作用域”等同于静态作用域，即与动态作用域（运行时确定）相对。 词法作用域关注函数在何处声明；而动态作用域关注函数从何处调用，其作用域链是基于运行时的调用栈的。换言之，在遇到既不是形参也不是函数内部定义的局部变量的变量时，词法作用域的函数会去函数定义时的环境中查询；而动态作用域的函数会到函数调用时的环境中查询。 一个例子： 1234567891011function foo()&#123; print a;&#125;function bar()&#123; var a = 1; foo();&#125;var a = 2;bar(); 采用词法作用域的语言会从函数定义位置开始向上层查找，最后输出 2。 而采用动态作用域的语言会输出 1。 顺便一提，在 JS 中eval和with可以产生动态作用域的效果。但《JavaScript 高级程序设计》不推荐使用此二者。 强调与补充函数的作用域基于函数定义的位置。 为了去实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数逻辑的代码，除此之外还包含当前作用域链的引用。函数对象可以通过这个作用域链相互关联起来。 如此，函数体内部的变量都可以保存在函数的作用域内，在程序语言范畴内这被称为闭包。而我们常说的闭包是指让外部函数访问到内部的变量，也就是说，按照一般的做法，是使内部函数返回一个函数，然后操作其中的变量。这样做的话一是可以读取函数内部的变量，二是可以让这些变量的值始终保存在内存中。 这时，调用函数的时候闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链。 参考资料：动态作用域和词法域的区别是什么？- 知乎 JavaScript深入之词法作用域和动态作用域 · Issue #3 · mqyqingfeng/Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在把玩中学习——typewriter.js]]></title>
      <url>%2Ftypewriter%2F</url>
      <content type="text"><![CDATA[大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。 好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。 这个有打字和仿光标闪烁效果的 typewriter.js 好像是我在看什么“程序员表白利器”时加到收藏夹里的。现在学习了 js，敢看看源码了，发现 js 代码只有20行不到。作者说：“原生JavaScript就是这么牛。”确实是这样的。虽然效果也很简单，但也能从里面学到一些东西。 HTML 源代码（大致结构）： 1234567891011121314&lt;body&gt; &lt;div id="mainDiv"&gt; &lt;div id="content"&gt; &lt;div id="code"&gt; &lt;span class="comments"&gt;/**&lt;/span&gt;&lt;br /&gt; &lt;span class="space"/&gt;&lt;span class="comments"&gt;* We are both XXX Unversity business administration and programmers,&lt;/span&gt;&lt;br /&gt; &lt;span class="space"/&gt;&lt;span class="comments"&gt;* so I write some code to show my love to you.&lt;/span&gt;&lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; document.getElementById("code").typewriter(); &lt;/script&gt;&lt;/body&gt; JavaScript 源代码： 12345678910111213141516171819Element.prototype.typewriter=function(a)&#123; var d = this, c = d.innerHTML, b = 0; d.innerHTML=""; var e = setInterval(function() &#123; var f = c.substr(b, 1); if (f == "&lt;") &#123; b = c.indexOf("&gt;", b) + 1 &#125; else &#123; b++ &#125; d.innerHTML=c.substring(0, b) + (b &amp; 1 ? "_" : ""); if (b &gt;= c.length) &#123; clearInterval(e) &#125; &#125;, 75) return this &#125; 在这份 js 代码中可以学习的点： 原型模式定义方法：给 Element 添加实例方法typewriter()（在 html 文件中调用），这里有一个参数 a，实际上没什么用。顺便一说，源码在 head 处引入了 js 文件，这是为了先加载 js 文件。如果按照代码规范将引入放在 body 部分的最后，则有一瞬间所有字先出现再消失，不符合效果要求。可见代码规范也要根据实际来遵守。 声明三个变量，d 保存当前对象（”code”）。这个操作是必要的，因为后面要给 “code” 的 innerHTML 赋值的时候有时在函数作用域中，this 取不到 “code”。 代码逻辑很清晰，包括对标签的处理、光标效果的实现和定时器的清除等。要对自己想要实现的效果有一个全面的认知和大致的构思再开始写代码。 末尾return this以支持链式操作。 想要用功能强大的JavaScript实现一些小效果不难，但是怎样一步步规划、修改到实现对现在的我来说还是比较有挑战性的。希望自己能在欣赏、借鉴、吸收的过程中去实现一些有趣的 demo，重拾对代码的兴趣和创造力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（五）]]></title>
      <url>%2FJS-notes-5%2F</url>
      <content type="text"><![CDATA[今天看了看LESS。前端要研究的东西确实有点多，压力有点大。而且发现自己动手写代码的水平也有待提高。从今天开始理论学习要给实践让让路了，加油加油。 这篇博文总结了《JavaScript高级程序设计》的20~21章：JSON、AJAX与Comet。此外，关于CORS的部分还参考了廖雪峰的JavaScript教程。 JSONJSON是一种数据格式。虽然有相同的语法形式，但JSON不从属于JavaScript。很多编程语言都有针对JSON的解析器和序列化器。 语法1.JSON的语法可以表示三种类型的值：简单值、对象、数组。 2.简单值：可表示字符串、数值、布尔值和 null，但不支持 undefined。JSON字符串必须使用双引号。 3.对象：表示一组无序的键值对。没有声明变量（JSON中没有变量概念），没有末尾分号，对象属性名必须加双引号。 12345678&#123; &quot;name&quot;: &quot;Kyon&quot;, &quot;age&quot;: 20, &quot;school&quot;: &#123; &quot;name&quot;: &quot;Wuhan University&quot;, &quot;major&quot;: &quot;Software Engineering&quot; &#125;&#125; 4.数组：表示一组有序的值的列表，可以通过数值索引来访问其中的值。 解析与序列化5.JSON对象有两个方法：stringify()把JavaScript对象序列化为JSON字符串，parse()把JSON字符串解析为原生JavaScript值。 6.JSON.stringify()还可以接收另外两个参数：第一个参数是个过滤器（数组：结果中只包含数组列出的属性；函数：传入的函数接收两个参数，属性名和属性值，根据属性名判断如何处理属性）；第二个参数控制结果中的缩进和空白符，数值表示缩进空格数，字符串被用作缩进字符。 7.toJSON：自定义序列化。 123456789var person = &#123; &quot;name&quot;: &quot;Kyon&quot;, age: 20, toJSON: function()&#123; return this.name; &#125;&#125;;var jsonText = JSON.stringify(person); 8.JSON.parse()还可以接受一个参数：将在每个键值对上调用的还原函数（与JSON.stringify()的过滤函数相同）。 AJAX与CometAjax 技术的核心是 XMLHttpRequest 对象（简称 XHR）。可以使用 XHR对象取得新数据，然后再通过 DOM 将新数据插入到页面中，无须刷新页面即可从服务器取得数据。 XMLHttpRequest 对象1.用法： 123456789101112131415161718192021var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; console.log(xhr.responseText); &#125; else &#123; console.log(&apos;Request was unsuccessful: &apos; + xhr.status); &#125; &#125;&#125;;// GET请求xhr.open(&apos;get&apos;, &apos;example.php&apos;);xhr.send(null);// POST请求xhr.open(&apos;open&apos;, &apos;postexample.php&apos;);xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);var form = document.getElementById(&apos;user-info&apos;);xhr.send(serialize(form));// 将ID为user-info的表单中数据序列化后发送给服务器 创建XHR对象：new XMLHttpRequest(); open()：启动一个请求以备发送。接收三个参数：请求类型（”get”、”post”等）、请求的URL、是否异步发送请求（默认是true，一定不能为false，否则必须等到服务器响应后再继续执行）。 send()：发送请求。GET请求不需要参数，POST请求要把body部分字符串或者FormData对象传进去。 2.XHR对象的属性： responseText：返回的文本； status：响应的HTTP状态； 3.HTTP状态码： 2xx：成功； 3xx：重定向，304 Not Modified 表示请求的资源没有被修改，可以直接用浏览器缓存的版本，302 Found 表示请求的资源现在临时从不同的URI响应请求； 4xx：客户端错误，403 Forbidden，404 NotFound； 5xx：服务器错误，500 Internal Server Error，503 Service Unavailable。 4.XHR的 readyState 属性：表示请求/响应过程的当前活动阶段： 0：未初始化； 1：启动，已调用open()，未发送； 2：发送，已调用send()，未收到响应； 3：接收到部分响应数据； 4：接收到全部响应数据。 5.readystatechange事件：readystate属性的值由一个值变成另一个值，都会触发readystatechange事件。 跨源资源共享6.跨域安全策略：XHR对象只能访问与包含它的页面位于同一个域的资源（域名、协议、端口号都要相同）。 7.CORS（跨源资源共享）：HTML5规范定义的如何跨域访问资源。当JavaScript 向外域发起请求后，浏览器收到响应后首先检查Access-Control-Allow-Origin是否包含本域。如果不是，请求失败，JavaScript 无法获取到响应的任何数据。 跨域是否成功，取决于对方服务器是否给本域设置一个正确的Access-Control-Allow-Origin。 以上“简单请求”包括GET、HEAD和POST（POST的Content-Type类型仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头。 对于PUT、DELETE以及其他类型如application/json的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受： 1234OPTIONS /path/to/resource HTTP/1.1Host: bar.comOrigin: http://my.comAccess-Control-Request-Method: POST 服务器必须响应并明确指出允许的Method： 1234HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONSAccess-Control-Max-Age: 86400 浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。 其他跨域技术8.图像Ping：与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。 对于 1234567var img = new Image();img.onload = img.onerror = function()&#123; console.log(&quot;Done!&quot;);&#125;;// onload和onerror事件处理程序指定为同一函数，请求完成时无关响应得到通知img.src = &quot;http://www.example.com/test?name=Nicholas&quot;;// 请求从设置src属性那一刻开始 两个主要缺点：只能发送GET请求；无法访问服务器的响应文本。因此只能用于浏览器与服务器间的单向通信。 9.JSONP（JSON with padding）：包含在函数调用中的JSON。由回调函数和数据组成。只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上利用了浏览器允许跨域引用JavaScript资源。 1234567891011121314151617181920212223// 得到的返回refreshPrice(&#123;&quot;0000001&quot;:&#123;&quot;code&quot;:&quot;0000001&quot;, ...&#125;&#125;);// 在页面中准备好回调函数function refreshPrice(data)&#123; var p = document.getElementById(&apos;test-jsonp&apos;); p.innerHTML = &apos;当前价格：&apos; + data[&apos;0000001&apos;].name + &quot;：&quot; + data[&apos;0000001&apos;].price;&#125;// 触发function getPrice()&#123; var js = document.createElement(&apos;script&apos;), head = document.getElementByTagName(&apos;head&apos;)[0]; self = document.getElementById(&apos;dynamic-jsonp&apos;); if(self)&#123; var parent = self.parentElement; parent.removeChild(self); &#125; js.id = &apos;dynamic-jsonp&apos;; js.src = &apos;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&apos;; head.appendChild(js);&#125; 缺点：从其他域中加载代码执行，安全性不可靠；不易确定请求是否失败。 10.Comet：对AJAX的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现Comet的手段主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，只有部分浏览器原生支持HTTP流。 补充：轮询是指通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器是否有新消息。缺点：(1)实时性不够；(2)频繁请求会给服务器带来极大压力。 11.SSE（服务器发送事件）：一种实现Comet交互的浏览器API，既支持长轮询，也支持HTTP流。 12.Web Sockets：目标是在一个单独的持久连接上提供全双工、双向通信。使用一种专为快速传输小数据设计的自定义协议。 安全13.为确保通过XHR访问的URL安全，通行做法是验证发送请求者是否有权限访问响应的资源。有下列方式： 要求以SSL连接来访问可以通过XHR请求的资源。 要求每一次请求都要附带经过相应算法计算得到的验证码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（四）]]></title>
      <url>%2FJS-notes-4%2F</url>
      <content type="text"><![CDATA[花旗杯的团队已经组好了。自己要加快学习进度，保证不拖组织的后腿。全力以赴，尽善尽美，希望最后能够有好的成绩。 这篇博文总结了《JavaScript高级程序设计》的13~14章：事件，表单脚本。 事件事件流1.事件流描述从页面接收事件的顺序。IE提出事件冒泡流，Netscape提出事件捕获流。 2.事件冒泡：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。 3.事件捕获：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。由于老版本浏览器不支持，不推荐使用。 4.“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件处理程序5.HTML事件处理程序：扩展作用域，在函数内部可以像访问局部变量一样访问document及该元素本身的成员。 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(value)&quot;&gt; 如果是一个表单输入元素，则作用域中还会包含访问表单元素的入口。 1234&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Echo username&quot; onclick=&quot;console.log(username.value)&quot;&gt;&lt;/form&gt; 缺点：(1)存在时差问题，函数被解析之前就触发事件会引发错误；(2)扩展处理程序的作用域链在不同浏览器中会导致不同结果；(3)HTML和JavaScript代码紧密耦合。 6.DOM0级事件处理程序：每个元素都有自己的事件处理程序属性，将其设置为一个函数，就可以指定事件处理程序。 12345678// 绑定事件处理程序var btn = document.getElementById("myBtn");btn.onclick = function()&#123; console.log(this.id); // "myBtn"&#125;;// 删除事件处理程序btn.onclick = null; 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 7.DOM2级事件处理程序：addEventListener()和removeEventListener()，接受3个参数：要处理的事件名、事件处理程序函数和一个布尔值（true表示在捕获阶段调用事件处理程序，默认为false表示冒泡阶段调用）。 移除时传入的参数与添加处理程序时使用的参数相同，意味着通过addEventListener()添加的匿名函数无法移除。 123byn.addEventListener(&quot;click&quot;, handler, false);...btn.removeEventListener(&quot;click&quot;, handler, false); // 有效 8.IE事件处理程序：attachEvent()和detachEvent()，接收两个参数：要处理的事件名、事件处理程序函数。事件处理程序被添加到冒泡阶段，在全局作用域中运行（this 等于 window）。支持IE事件处理程序的浏览器有 IE 和 Opera。 事件对象9.在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息。只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。 10.属性/方法： currentTarget：正在处理事件的那个元素。 target：事件的目标。 type：事件类型。 cancelable：可以阻止特定事件的默认行为。 preventDefault()：阻止特定事件的默认行为。 stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。 eventPhase：调用事件处理程序的阶段：捕获阶段为1，处于目标对象为2，冒泡阶段为3。 事件类型11.“DOM3级事件”规定了以下几类事件： UI（用户界面）事件，当用户与页面上的元素交互时触发：load、unload、resize、scroll。 焦点事件，当元素获得或失去焦点时触发。 鼠标与滚轮事件：click、dblclick、mousedown、mouseenter、mouseleave、mouseout、mouseover、mouseup。 键盘与文本事件：keydown、keypress、keyup、textInput。 复合事件，用于处理IME（输入法编辑器，让用户输入在物理键盘上找不到的字符）的输入序列。 变动事件，当DOM中的某一部分发生变化时给出提示。 内存和性能to be continued.. 表单脚本to be continued..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（三）]]></title>
      <url>%2FJS-notes-3%2F</url>
      <content type="text"><![CDATA[稍微大致翻了一下这本书后续的内容。为了尽快的进入ES6以及框架部分的学习，决定暂时跳过某些章节的学习。后面打算学习的章节有6、7、13、14、20、21、22、24章，剩下的章节等到用到或者时间富余的时候再看。 这篇博文总结了《JavaScript高级程序设计》的6~7章：面向对象的程序设计，以及函数表达式。 面向对象的程序设计理解对象1.ECMAScript中有两种属性：数据属性和访问器属性。 特性：描述属性的各种特征。目的是实现JavaScript，因此在JavaScript中不能直接访问。为了表示特性是内部值，放在两对方括号中，例如[[Enumerable]]。 2.数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。默认为 true。 [[Writable]]：表示能否修改属性的值。默认为 true。 [[Value]]：包含这个属性的数据值。默认为 undefined。 Object.defineProperty()方法可以修改属性默认的特性。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable、enumerable、writable 和 value 中的一或多个。 3.访问器属性： [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。默认为 true。 [[Get]]：在读取属性时调用的函数。默认为 undefined。 [[Set]]：在写入属性时调用的函数。默认为 undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 12345678910111213141516171819var book = &#123; _year: 2016, // 下划线表示只能通过对象方法访问的属性 edition: 1&#125;;Object.defineProperty(book, "year", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue) &#123; if(newValue &gt; 2016) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;); // year 是访问器属性book.year = 2017;console.log(book.edition); // 2 4.定义多个属性可用Object.defineProperties()方法。 123456789101112131415161718192021var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2016 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2016)&#123; this._year = newValue; this.edition += newValue - 2016; &#125; &#125; &#125;&#125;); Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符。 1234var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);console.log(descriptor.value); // 2016console.log(descriptor.configurable); // falseconsole.log(typeof descriptor.get); // &quot;undefined&quot; 创建对象5.工厂模式：虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题。 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () &#123; console.log(this.name); &#125; return o;&#125;var p1 = createPerson(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = createPerson(&apos;Someone&apos;, 19, &apos;Lawyer&apos;); 6.构造函数模式：以大写字母开头。 1234567891011121314function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;;&#125;var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);// 对象的constructor属性指向其构造函数console.log(p1.constructor); // function Person(name, age, job)&#123;... 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。 也可以使用call()（或者apply()）在某个特殊对象的作用域中调用构造函数，调用后这个对象就拥有了所有属性和方法。 123var o = new Object();Person.call(o, &apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);o.sayName(); // &apos;Kyon&apos; 使用构造函数的主要问题：每个方法都要在每个实例上重新创建一遍。 1console.log(p1.sayName === p2.sayName); // false 7.原型模式：每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向函数的原型对象。这个对象包含可以由该类型的所有实例共享的属性和方法。 1234Person.prototype.sayName = function()&#123; console.log(this.name);&#125;console.log(p1.sayName === p2.sayName); // true 理解原型对象： – 只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，指向函数的原型对象。 – 默认所有原型对象都会获得一个 constructor 属性，指向 prototype 属性所在函数。 – 当调用构造函数创建一个新实例后，实例将有一个 __proto__属性，指向构造函数的原型对象，指针叫[[Prototype]]，默认原型指向Object。 – 实例和构造函数没有直接关系。 – 读取属性：搜索先从对象实例本身开始，如果没找到，搜索原型对象。 – 使用isPrototype()来检测构造函数和实例之间是否有关系。 – Object.getPrototypeOf()返回[[Prototype]]的值。 – 使用hasOwnProperty()来检测属性存在于实例中还是原型中。 123456789101112131415161718192021222324function Person()&#123;&#125;Person.prototype.name = &apos;Kyon&apos;;Person.prototype.age = 29;Person.prototype.job = &apos;Software Engineer&apos;;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var p1 = new Person();var p2 = new Person();console.log(Person.prototype.isPrototypeOf(p1)); // trueconsole.log(Object.getPrototypeOf(p1) === Person.prototype); // trueconsole.log(Object.getPrototypeOf(p1).name); // &apos;Kyon&apos;console.log(p1.hasOwnProperty(&quot;name&quot;)); // falsep1.name = &quot;someone&quot;;console.log(p1.hasOwnProperty(&quot;name&quot;)); // truedelete p1.name;console.log(p1.hasOwnProperty(&quot;name&quot;)); // false 原型与 in 操作符：在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 1console.log(&apos;name&apos; in p1); // true 更简单的原型语法：用一个包含所有属性和方法的对象字面量来重写整个原型对象。 1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, // 默认的 prototype 对象被重写，需设置 name: &apos;Kyon&apos;, age: 20, job: &apos;Software Engineer&apos;, sayName: function()&#123; console.log(this.name); &#125;&#125;; 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍是最初的原型。 原生对象的原型：通过原生对象的原型可以定义新方法。不推荐，可能导致命名冲突或意外重写原生方法。 原型对象的问题：包含引用类型值的属性会被共享。 8.组合使用构造函数模式和原型模式：创建自定义类型最常见方式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。 123456789101112131415161718192021// 组合使用构造函数模式与原型模式function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Sam&quot;, &quot;Judie&quot;];&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; console.log(this.name); &#125;&#125;var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);p1.friends.push(&quot;Vue&quot;);console.log(p1.friends); // &quot;Sam, Judie, Vue&quot;console.log(p2.friends); // &quot;Sam, Judie&quot;console.log(p1.sayName === p2.sayName); // true 9.动态原型模式、寄生构造函数模式、稳妥构造函数模式 继承10.许多OO语言都支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际方法）。由于函数没有签名，ECMAScript 中无法实现接口继承，而实现继承主要依靠原型链实现。 11.原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法。 12.p182开始 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.color = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125; function SubType(name, age) &#123; SuperType.call(this, name); // 借用构造函数 this.age = age;&#125;SubType.prototype = new SuperType(); // 原型链SubType.prototype.constructor = SubType; // construcotr在上一句中被重写SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125; var instance = new SubType(&apos;Kyon&apos;, 20);instance.sayName(); // Kyoninstance.sayAge(); // 20 说实话，这部分看得我脑壳疼。要不我们直接用ES6引入的class可好？等我哪一天沐浴更衣虔诚焚香再来看… 函数表达式递归1.在严格模式下，不能通过脚本访问arguments.callee来实现递归。可以用命名函数表达式来实现。 1234567var factorial = (function f(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;); 闭包2.闭包是指有权访问另一个函数作用域中的变量的函数（匿名函数的 function 关键字后没有标识符，二者不能混用）。 3.创建闭包的常见方式：在一个函数内部创建另一个函数。 123456789function outer()&#123; var name = &quot;Kyon&quot;; return function()&#123; console.log(name); &#125;&#125;var inner = outer();inner(); // Kyoninner = null; // 解除对outer内部的匿名函数的引用，以释放内存 在外部函数内部定义的内部函数将外部函数的活动对象（作为变量对象使用）添加到它的作用域链中；外部函数执行完毕后，其活动对象不会被销毁，因为内部函数的作用域链仍在引用这个活动对象；外部函数执行完毕后，内部函数仍然可以访问到其定义的所有变量。 4.由于闭包会携带包含它的函数的作用域，过度使用可能导致内存占用过多，要慎重使用。 5.返回的函数并没有立刻执行，而是等到调用f()才执行。因此返回函数不能引用任何循环变量，或者后续会发生变化的变量。 12345678910111213141516171819function count()&#123; var arr = []; for(var i=1; i&lt;=3; i++)&#123; arr[i] = function()&#123; return i * i; &#125;; &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];// 返回的函数引用了变量i，但并非立即执行。执行时i已变成4f1(); // 16f2(); // 16f3(); // 16 一定要引用循环变量的方法：再创建一个匿名函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。 123456789101112function count()&#123; var arr = []; for(var i=1; i&lt;=3; i++)&#123; arr[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125;// i的当前值复制给参数num，匿名函数内部又创建并返回一个访问num的闭包，使得result数组中的每个函数都有自己num变量的一个副本 这里用了一个“创建一个匿名函数并立即执行”的语法： 123(function(x)&#123; return x * x;&#125;)(3); // 9 6.闭包中使用 this 对象：匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getName: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getName()); // &quot;The Window&quot;(非严格模式) 把外部作用域中的 this 对象保存在一个闭包能够访问的变量中，就可以让闭包访问该对象了（想访问作用域中的 arguments对象同理）。 12345678910111213var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getName: function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getName()); // &quot;My Object&quot; 7.补充：利用闭包可以实现私有变量的封装。 1234567891011121314151617181920// 用JavaScript创建一个计数器&apos;use strict&apos;;function create_counter(initial)&#123; var x = initial || 0; return &#123; inc: function()&#123; x += 1; return x; &#125; &#125;&#125;// 使用var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12 模仿块级作用域8.用匿名函数模仿块级作用域： JavaScript将 function 关键字当作一个函数声明的开始，而函数声明后不能加圆括号。 将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随的另一对圆括号会立即调用这个函数。 1234567(function()&#123; // 这里是块级作用域&#125;)();function()&#123; // 这里是块级作用域&#125;(); ／／ Error! 9.这种技术经常用于限制向全局作用域中添加过多的变量和函数；同时可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。 123456(function()&#123; var now = new Date(); if(now.getMonth() == 11 &amp;&amp; now.getDate() == 25)&#123; console.log(&quot;Merry Christmas!&quot;); &#125;&#125;)(); 私有变量10.任何在函数中定义的变量，都可以认为是私有变量。 11.有权访问私有变量和私有函数的公有方法被称为特权方法。两种在对象上创建特权方法的方式： 1234567891011121314151617181920212223242526// 1.构造函数中定义特权方法function MyObject()&#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc()&#123; return false; &#125; // 特权方法 this.publicMethod = function()&#123; privateVar++; return privateFunc(); &#125;;&#125;// 2.利用私有和特权成员function Person()&#123; this.getName = function()&#123; return name; &#125;; this.setName = function(value)&#123; name = value; &#125;;&#125; 12.可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（二）]]></title>
      <url>%2FJS-notes-2%2F</url>
      <content type="text"><![CDATA[继续记录在读《JavaScript高级程序设计》时的零碎知识点。这几天在知乎上看到了别人使用 Electron 构建桌面应用，感觉还蛮有意思的。有兴趣的同学可以看看使用 Electron 构建桌面应用和用 ReactJs 创建Mac版的 keep了解一下。也许在加深对JS的理解后，我也会选择用 Electron 做一个应用呢。Who knows? 这篇博文总结了《JavaScript高级程序设计》的4~5章：变量、作用域和内存问题，以及引用类型。 变量、作用域和内存问题基本类型和引用类型的值1.基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；引用类型的值是对象，保存在堆内存中。 2.当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。 3.从一个变量向另一个变量复制基本类型的值时，会创建这个值的一个副本；从一个变量向另一个变量复制引用类型的值时，复制的是指向存储在堆中的一个对象的指针，复制之后两个变量指向同一个对象。 123456789var n1 = 1;var n2 = n1;n1 = 2;console.log(n2); // 1var o1 = &#123;&#125;;var o2 = o1;o1.name = 'Kyon';console.log(o2.name); // Kyon 4.参数只能按值传递： 123456789function setName(obj)&#123; obj.name = 'Kyon'; obj = new Object(); obj.name = 'Huang';&#125;var person = new Object();setName(person);console.log(person.name); // Kyon 在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 5.typeof检测基本数据类型，instanceof检测引用类型（根据其原型链来识别）。 执行环境及作用域6.每个执行环境（简称为环境，可以理解为作用域）都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。每个函数都有自己的执行环境，全局执行环境（在Web浏览器中为window对象）是最外围的一个执行环境。 7.当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返还给之前的执行环境。 8.当代码在一个环境中执行时，会创建变量对象的一个作用域链，用于保证对执行环境有权访问的所有变量和函数的有序访问（搜索）。作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。 9.标识符解析：沿着作用域链一级一级地搜索标识符的过程。从作用域链的前端开始，逐级向后回溯，直到找到标识符为止（找不到通常导致错误）。 10.内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 11.延长作用域链：当执行流进入 try-catch 语句的 catch 块或 with 语句时，作用域链就会得到加长。这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到作用域链中；对 catch 语句，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 12.JavaScript 没有块级作用域，但有函数作用域（针对var）。 补充：在语法中的块级作用域是指if/else/for/while语句里2个大括号之间的部分。块级作用域里面定义的函数和变量在{}外部是可以被访问到的。但是函数就不行，比如你在函数体里面定义一个变量，那么函数执行完毕之后里面的变量就会直接被销毁，在函数体外部是不可能被访问到的。 再补充：ES6标准引入了新的关键字 let 和 const。它们都具有块级作用域。 垃圾收集13.JavaScript 具有自动垃圾收集机制，原理：垃圾收集器按照固定的时间间隔（或代码执行中预定的收集时间）释放不再继续使用的变量所占用的内存。 14.最常用的垃圾收集方式是标记清除：垃圾回收器在运行时会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记，而在此之后还有标记的变量被视为准备删除的变量，因为这些变量无法被访问到了。 此外，引用计数是另一种不太常用的垃圾收集策略，这种算法的思想是跟踪记录所有值被引用的次数。当代码中存在循环引用现象时，“引用计数”算法就会导致问题。JavaScript 引擎目前都不再使用这种算法，但IE访问非原生 JavaScript 对象（如DOM元素）时仍可能导致问题。 15.管理内存：优化内存占用的最佳方式为解除引用——一旦数据不再有用，通过将其值设置为null来释放其引用。解除引用的真正作用是让其值脱离执行环境，以便垃圾搜集器下次运行时将其回收，而并非自动回收该值所占的内存。 引用类型引用类型的值（对象）是引用类型的一个实例。 Object类型1.创建Object实例的两种方式：Object构造函数；对象字面量表示法。通过对象字面量定义对象时，实际不会调用Object构造函数（Firefox 2 及更早版本除外）。 12345678var person = new Object();person.name = "Kyon";person.age = 19;var person = &#123; name : "Kyon", age : 19&#125;; 2.访问对象属性常用点表示法，也可使用方括号表示法。除非必须用变量来访问属性，否则建议使用点表示法。 1234567console.log(person.name); // 点表示法console.log(person["name"]); // 方括号表示法var propertyName = "name";console.log(person[propertyName]);console.log(person["first name"]); Array类型3.ECMAScript 数组的每一项可以保存任何类型的数据，并且大小可以动态调整。 4.创建数组的两种基本方式：使用Array构造函数；使用数组字面量表示法。通过数组字面量表示法时，实际不会调用Array构造函数（Firefox 3 及更早版本除外）。 123456var colors = new Array();var colors = new Array(20);var colors = new Array('red', 'blue', 'green'); var colors = [];var colors = ['red', 'blue', 'green']; 5.length：利用length属性可以方便地在数组末尾添加新项： 12var colors = ["red", "blue"];colors[colors.length] = "green"; 6.Array.isArray()：ECMAScript新增Array.isArray()确定某个值是否数组，其解决了存在两个以上全局执行环境时instanceof检测结果出错的情况。 7.数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。 123var colors = ["red", "green", "blue"];console.log(colors.join(",")); //red,green,blueconsole.log(colors.join("||")); //red||green||blue 8.栈方法和队列方法： push()添加一项到数组末尾； pop()移除数组末尾一项； shift()移除数组第一项； unshift()添加一项到数组前端。 9.重排序方法： reverse()翻转数组项的顺序； sort()默认将数组项转换成字符串后按升序排列（可以接收一个比较函数作为参数，第一个参数应位于第二个之前则返回一个负数）。 123456789var a = [0, 1, 15, 10, 5];a.sort();console.log(a); // [0, 1, 10, 15, 5]function compare(value1, value2)&#123; return value1 - value2;&#125;a.sort(compare);console.log(a); // [0, 1, 5, 10, 15] 10.操作方法： concat()：添加项 123var a1 = ['red', 'green', 'blue'];var a2 = a1.concat('yellow', ['black', 'brown']);console.log(a2); // ["red", "green", "blue", "yellow", "black", "brown"] slice()：截取 123var a = ['red', 'green', 'blue', 'yellow', 'black', 'brown'];console.log(a.slice(1), a.slice(1,4)); // ["green", "blue", "yellow", "black", "brown"]["green", "blue", "yellow"] splice()：删除插入替换 123var a = ['red', 'green', 'blue', 'yellow', 'black', 'brown'];console.log(a.splice(2, 1), a); // ["green", "blue", "yellow", "black", "brown"]["green", "blue", "yellow"] 11.位置方法：indexOf()和lastIndexOf()都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。indexOf()从数组开头（位置0）向后查找，lastIndexOf()从数组末尾向前查找。 12345var a = ["red", "purple", "orange", "green", "red", "yellow", "black", "brown"];console.log(a.indexOf('red')); // 0console.log(a.lastIndexOf('red')); // 4console.log(a.indexOf('red', 1)); // 4console.log(a.lastIndexOf('red', 1)); // 0 12.迭代方法：每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。给定函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。 every()：如果给定函数对每一项都返回true，则返回true。 filter()：返回给定函数会返回true的项组成的数组。 foreach()：这个方法没有返回值。 map()：返回每次函数调用的结果组成的数组。 some()：如果给定函数对任一项返回true，则返回true。 1234567891011121314151617181920212223242526var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = a.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);console.log(everyResult); // falsevar filterResult = a.filter(function()&#123; return (item &gt; 2);&#125;);console.log(filterResult); // [3, 4, 5, 4, 3]var forEachResult = a.forEach(function(item, index, array)&#123; console.log(item);&#125;);console.log(forEachResult); // undefinedvar mapResult = a.map(function(item, index, array)&#123; return (item * 2);&#125;);console.log(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2]var someResult = a.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);console.log(someResult); // true 13.归并方法：都会迭代数组的所有项，然后构建一个最终返回的值。都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。给定函数接收4个参数：前一个值、当前值、项的索引和数组对象。 12345678910111213var a = [1, 2, 3, 2, 1];var sum1 = a.reduce(function(prev, cur, index, array)&#123; console.log(index); // 1 2 3 4 return prev + cur;&#125;); console.log(sum1); // 9var sum2 = a.reduceRight(function(prev, cur, index, array)&#123; console.log(index); // 3 2 1 0 return prev + cur;&#125;);console.log(sum2); // 9 Date类型12.创建日期对象：月份基于0（一月是0，二月是1，以此类推）。 123var d1 = new Date();var d2 = new Date(2017, 2, 3, 15, 33, 33); // 2017年3月3日下午3点33分33秒 13.获取调用时的日期和时间和毫秒数，可以用来分析代码。 1234var start = Date.now();doSomething();var stop = Date.now();var result = stop - start; 14.日期格式化方法：local表示以特定于地区的格式显示。 1234567var d2 = new Date(2017, 2, 3, 15, 33, 33);d2.toString(); // "Fri Mar 03 2017 15:33:33 GMT+0800 (CST)"d2.toDateString(); // "Fri Mar 03 2017"d2.toTimeString(); // "15:33:33 GMT+0800 (CST)"d2.toLocaleString(); // "2017/3/3 下午3:33:33"d2.toLocaleDateString(); // "2017/3/3"d2.toLocaleTimeString(); // "下午3:33:33" RegExp类型15.pattern：正则表达式；flags：标志，表明正则表达式的行为。g全局模式，i不区分大小写，m多行模式。 12var exp1 = /pattern/flagsvar exp2 = new RegExp('pattern','flags'); 16.RegExp实例方法： exec()专门为捕获组而设计，返回第一个匹配项信息的数组（或 null），数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。包含两个额外的属性：index 和 input。 123456789var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // "mom and dad and baby"console.log(matches[0]); // "mom and dad and baby"console.log(matches[1]); // " and dad and baby"console.log(matches[2]); // " and baby" test()接收一个字符串参数，在模式与该参数匹配的情况下返回 true，否则返回flase。 123456var text = "1234-56-7890";var pattern = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if(pattern.test(text))&#123; console.log("The pattern was matched.");&#125; 17.RegExp构造函数属性：适用于作用域中的所有正则表达式，记录一些最近一次正则表达式操作的信息。 12345678910111213var text = "This has been a short summer";var pattern = /(.)hort/g;// Opera 不支持 input、lastMatch、lastParen 和 multiline 属性// IE 不支持 multiline 属性if(pattern.test(text))&#123; console.log(RegExp.input); // This has been a short summer console.log(RegExp.leftContext); // This has been a console.log(RegExp.rightContext); // summer console.log(RegExp.lastMatch); // short console.log(RegExp.lastParen); // s console.log(); // false &#125; Function类型18.函数实际上是 Function 类型的实例，因此函数也是对象。 123456789101112// 使用函数声明语法function f1 (n1, n2) &#123; return n1 + n2;&#125; // 使用函数表达式var f2 = function (n1, n2) &#123; return n1 + n2;&#125;; // 使用构造函数，不推荐（会导致解析两次代码，影响性能）var f3 = new Function('n1', 'n2', 'return n1 + n2'); 19.函数名是一个指向函数对象的指针，因此 ECMAScript 中没有函数重载。 20.函数声明与函数表达式：解析器会率先通过名为函数声明提升的过程，读取并将函数声明添加到执行环境中，使其在执行任何代码之前可用。 而函数表达式必须等到解析器执行到它所在的代码行，才会真正被解析执行。 12345678910console.log(sum(10, 10));function sum(num1, num2)&#123; return num1 + num2;&#125;// 把函数声明改为等价的函数表达式，会在执行期间导致错误console.log(sum(10, 10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;; 21.函数内部属性：callee、this、caller。 arguments 有 callee 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。可用于递归中消除紧密耦合现象。 12345678console.log(sum(10, 10));function factorial(num)&#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; this 引用的是函数据以执行的环境对象。 caller 属性保存着调用当前函数的函数的引用（如果在全局作用域中调用当前函数，它的值为 null）。 12345678910function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller); // 为了实现更松散的耦合，也可以用 arguments.callee.caller 访问相同的信息&#125;outer(); // 打印 outer() 函数的源代码 严格模式下访问 arguments.callee 和 arguments.caller 会导致错误，且不能为函数的 caller 属性赋值。 22.函数属性：length 和 prototype。 length 属性表示函数希望接收的命名参数的个数。 23.函数方法：apply()和call()。用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值，区别仅在于接收参数的方式不同。 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中第二个参数可以是 Array 的实例，也可以是 arguments 对象。 call()方法中，传递给函数的参数必须逐个列举出来。 12345678910111213function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入 arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125; function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125; apply()和call()真正强大之处在于扩充函数赖以生存的作用域。 12345678910window.color = "red";var o =&#123; color: "blue" &#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor.call(this); // redsayColor.call(window); // redsayColor.call(o); // blue 在严格模式下，未制定环境对象而调用函数，则 this 值不会转型为 window。除非明确把函数添加到某个对象或者调用apply()或call()，否则 this 值将是 undefined。 基本包装类型24.三种基本包装类型：Boolean类型、Number类型、String类型。在读取模式下访问基本类型值时，就会创造对应的基本包装类型的一个对象，从而方便数据操作。 自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁（这意味不能在运行时为基本类型值添加属性和方法）。 单体内置对象25.在所有代码执行之前，内置对象：Global 和 Math 已经实例化，开发人员不必显式地实例化内置对象。 在大多数ECMAScript实现中都不能直接访问 Global 对象，不过Web浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【中文填词】三つ叶の结びめ -TV size.-]]></title>
      <url>%2Flyrics-seaStory%2F</url>
      <content type="text"><![CDATA[大一下学期考试周复习得好压抑，我就作死地补了《来自风平浪静的明天》。看完就感觉：啊，不愧是冈妈。虽然我不是那种容易被催泪的类型，但是还是有些胃痛的。 《来自风平浪静的明天》的音乐质量真的不错。两首OP两首ED加上几首bgm都很出彩（bgm里推荐 海の涙 和 Cry for the moon）。我当时就忍不住花了几个小时填了一个ED2的TV size（复习什么的已经无所谓了），之后基本没有修改，还算一气呵成。现在贴出来。自己感觉写的好小女生啊，哈哈。但是我就喜欢写这种暗恋的心酸。 欢迎翻唱w 希望亚人的词能填的出色. 【中文填词】三つ叶の结びめ（三片葉的花結） -TV size.- 曲：出羽良彰词：@摸鱼小能手大黄菌 等你转身 故事升温 久疏重逢的我们谈笑之间 却捕捉到 你偏离的眼神情绪慢慢下沉 听着潮声 看天空变得好陌生你笑容依旧的单纯 而我难过一直在铺陈 沉睡的心事 安静了 一整个寒冬 在春天来前解冻最后 却汇成了咸涩的洋流 经过谁的码头 把思念 只想对这片海表白泪水打湿的喜欢好像 怎么也 晒不干攒够了失望 终于才学会离开你出于礼貌的关怀 都怪我 太过分 的期待]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（一）]]></title>
      <url>%2FJS-notes-1%2F</url>
      <content type="text"><![CDATA[《JavaScript高级程序设计》，俗称红宝书。本来因为不太清楚的知识点零零碎碎，打算默默地看。但是学习热情不高，加上看到某大佬的对于这本书的读书笔记，最终决定做一个比较零散的、私人化的读书笔记，激励自己。 顺便，这里有我的Java读书笔记：Kyon Huang的java学习笔记 - Github，内容比较多，就不放在博客上了。大概包含了Java核心卷一的重点内容，之后停了有一段时间了。这学期争取继续更新。 这篇博文总结了《JavaScript高级程序设计》的前三章：JavaScript简介、在HTML中使用JavaScript、基本概念。 JavaScript简介1.ECMAScript 是一种开放的、国际上广为接受的脚本语言规范。它本身并不是一种脚本语言。而JavaScript 是 ECMAScript 规范的一种实现。 2.一个完整的 JavaScript 实现应该由三个部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。 3.ECMAScript 提供核心语言功能；DOM 提供访问和操作网页内容的方法和接口；BOM 提供与浏览器交互的方法和接口。 在HTML中使用JavaScriptJavaScript 脚本引入1.为了避免浏览器在呈现页面时出现明显延迟，现代Web应用程序一般都把全部 JavaScript 引用放在主要内容后面，&lt;/body&gt;标签前面的位置。 2.延迟脚本：&lt;script&gt;标签的 defer 属性表明脚本在执行时不会影响页面构造，会延迟到整个页面都解析完毕后再运行。延迟脚本总按指定它们的顺序执行。defer 属性只适用于外部脚本文件。 3.异步脚本：&lt;script&gt;标签的 async 属性告诉浏览器立即下载文件，不必等待其他脚本或阻塞文档呈现，目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。不保证异步脚本按照页面出现的先后顺序执行。async 属性只适用于外部脚本文件。 补充：defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 嵌入代码与外部文件4.使用外部文件的优点：可维护性、可缓存、适应未来。 文档模式5.所有浏览器默认开启混杂模式，不同浏览器在这种模式下的行为差异非常大。通过文档类型（doctype）开启标准模式： 12&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; 不支持脚本6.包含在&lt;noscript&gt;元素中的内容只有在浏览器不支持脚本，或浏览器支持脚本但脚本被禁用时才会显示出来。因此，它用于指定在不支持脚本的浏览器中显示的替代内容。 基本概念严格模式1.通过在顶部添加&quot;use strict&quot;;开启严格模式。这个编译指令告诉支持的JavaScript引擎切换到严格模式，以处理 ES 3 中一些不确定的行为，并对某些不安全的操作抛出错误。 变量2.省略var操作符可以定义全局变量（难维护，不推荐）。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。 数据类型3.五种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number和String，一种复杂数据类型 Object。ECMAScript 不支持任何创建自定义类型的机制。 Undefined类型：未初始化的变量会自动被赋予 undefined 值。 Null类型：null 值表示一个空对象指针。只要意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存 null 值，以体现 null 作为空指针对象的惯例。 Boolean类型：使用函数Boolean()将其他类型转换为Boolean类型。 Number类型：其他类型转换为Number类型，常用函数parseInt()，转换字符串时，如果第一个字符不是数字字符或者负号，会返回NaN，第二个可选参数表示进制（建议始终明确指定基数）。 String类型：不可变。其他类型转换为String类型，使用函数toString()或String()或加一个空字符串（””）。 Object类型：Object 的每个实例都具有下列属性和方法： – constructor：保留着用于创建当前对象的函数（即构造函数）； – hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在（属性名必须以字符串形式指定）； – isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型； – propertyIsEnumerable(propertyName)：用于检查给定的属性是否能使用 for-in 语句来枚举； – toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应； – toString()：返回对象的字符串表示（null 和 undefined 伪对象没有此方法，整数 number 类型需要在整数末尾多加一个.再调用）； – valueOf()：返回对象的字符串、数值或布尔值表示； 4.typeof 操作符可检测给定变量的数据类型，包括 number、boolean、string、function、undefined。 判断 Array：Array.isArray(myArr);。 判断 null：用myArr === null;。 补充：判断某个全局变量是否存在：typeof window.myVar === &#39;undefined&#39;;。 判断函数内部某个变量是否存在：typeof myVar === &#39;undefined === &#39;undefined&#39;；。 操作符5.如果两个操作数都是字符串，则比较两个字符串对应的字符串编码值。 6.如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较；如果该操作数不能被转换为合理数值，则转换成 NaN。 7.任何操作数与 NaN 比较，结果都是false。 8.相等（==）与全等（===）：全等只在两个操作数未经转换就相等的情况下返回true。 语句9.由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到： 12345var count = 10;for (var i = ; i &lt; count; i++)&#123; var j = 1;&#125;alert(i, j); //10, 1 10.for-in 语句可以用来遍历对象的属性名称： 123for(property in expression)&#123; statement&#125; 为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 补充：一个 Array 数组实际也是一个对象，它的每个元素的索引被视为一个属性。所以当手动给 Array 添加额外的属性时，for-in 语句也会将其遍历。要循环集合本身的元素，建议使用 ES 6 提供的 for-of 语句。 11.break 语句会立即退出循环，强制继续执行循环后面的语句；continue 语句退出循环后会从循环的顶部继续执行。break 和 continue 语句与 label 语句联合使用多发生在循环嵌套的情况下： 12345678910111213var num = 0;outermost:for(var i=0; i &lt; 10; i++)&#123; for(var j=0; j &lt; 10; j++)&#123; if(i == 5 &amp;&amp; j == 5)&#123; break outermost; &#125; num++; &#125;&#125;alert(num); //55 12345678910111213var num = 0;outermost:for(var i=0; i &lt; 10; i++)&#123; for(var j=0; j &lt; 10; j++)&#123; if(i == 5 &amp;&amp; j == 5)&#123; continue outermost; &#125; num++; &#125;&#125;alert(num); //95 函数12.ECMAScript中没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。所以ECMAScript函数不能重载。 13.可以向ECMAScript函数传递任意数量的参数，并通过 arguments对象来访问这些参数。没有传递值的命名参数将自动被赋予 undefined 值。arguments对象中的值与对应的命名参数的内存空间是独立的，但它们的值会同步。 15.ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(3)——圣杯布局与双飞翼布局]]></title>
      <url>%2Fcup-doubleWings%2F</url>
      <content type="text"><![CDATA[这是完成百度前端学院2015的task1后对前端布局知识点总结的第三篇博文。上两篇总结了一下overflow属性（前端布局知识点(1)——overflow属性）和负边距及文档流（前端布局知识点(2)——负边距）。 在淘宝UED探讨中诞生的双飞翼布局主要解决了两个需求： 要求三列布局，左右两边定宽，中间宽度自适应； 要求浏览器优先渲染中间栏。 其实这两个要求已经有圣杯布局实现了。双飞翼布局是沿着圣杯布局的思路加以改良探讨出来的。两者有什么区别呢？ 17.04.27更新：时至今日，Grid 布局为实现各类布局提供了非常简便的解决方案。可以通过CSS Grid布局这样玩这篇文章来对 CSS Grid 进行初步了解。 圣杯布局我们首先来看看出现时间更早的圣杯布局（这个名字让我想到Fate系列）。圣杯布局用到了浮动、负边距和相对定位来实现需求。 html代码（浏览器按照html中写的顺序渲染，因此div.main写在最前面）： 12345678910111213 &lt;div class="yellow header"&gt; task4:header&lt;/div&gt;&lt;div class="page"&gt; &lt;div id="container"&gt; &lt;div class="main red"&gt;main&lt;/div&gt; &lt;div class="left green"&gt;left&lt;/div&gt; &lt;div class="right blue"&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="yellow footer"&gt; footer&lt;/div&gt; CSS代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546body&#123; margin: 0;&#125;.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.green&#123; background-color: green;&#125;.yellow&#123; background-color: yellow;&#125;.page&#123; padding:0 150px 0 180px; overflow: hidden; zoom: 1;&#125;.header,.footer&#123; width: 100%; height: 100px; clear: both;&#125;.left&#123; width: 180px; float: left; margin-left: -100%; height: 400px; position: relative; left: -180px;&#125;.main&#123; width: 100%; float: left; height: 400px;&#125;.right&#123; width: 150px; float: left; margin-left: -150px; height: 400px; position: relative; right: -150px;&#125; 效果图如下： 首先，我们给div.page设置一个左右的padding值，这个值要和左右两边宽度相等。固定好div.page后，再分别设置div.left和div.right。以div.left为例，设置float: left使其浮动，margin-left: -100%，这里将div.left左移至左边与main平齐。再加上 position: relative，left: -180px 固定位置，让它能够挤进左右两边空白的同时不会遮住中间部分。 双飞翼布局圣杯布局有什么缺陷呢？ 圣杯布局使用了相对定位。这样的话，以后再添加额外标签时布局是有局限性的； 左右两边的宽度只能为固定像素而不能设定为百分比。因为元素宽度设定为百分比时根据父级元素宽度计算，而我们给父级元素设定了padding值，其宽度不明确。我们无法精确计算所需要的百分比。 浏览器宽度缩小时，随着两边定宽的部分向中间靠拢，中间部分有被挤下去的可能。 怎么能够优化圣杯布局？淘宝UED探讨的结果是增加一个div。这样，我们就可以不再使用相对布局，而仅仅用浮动和负边距来达到我们的需求。这就是双飞翼布局。 html代码（main内层增加一个div）： 1234567891011121314151617 &lt;div class="page"&gt; &lt;div class="header yellow"&gt; task4:header &lt;/div&gt; &lt;div id="container"&gt; &lt;div class="main red"&gt; &lt;div class="inner"&gt; //增加的div main &lt;/div&gt; &lt;/div&gt; &lt;div class="left green"&gt;left&lt;/div&gt; &lt;div class="right blue"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class="footer yellow"&gt; footer &lt;/div&gt;&lt;/div&gt; CSS代码（去掉左右栏的相对定位和包裹层的padding，增加新div的margin）： 1234567891011121314151617181920212223242526272829303132333435363738.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.green&#123; background-color: green;&#125;.yellow&#123; background-color: yellow;&#125;.header,.footer&#123; width: 100%; height: 30px; clear: both;&#125;.left&#123; width: 150px; float: left; margin-left: -100%; height: 400px;&#125;.main&#123; width: 100%; float: left; height: 400px;&#125;.right&#123; width: 180px; float: left; margin-left: -180px; height: 400px;&#125;.inner&#123; margin-left: 150px; margin-right: 180px;&#125; 效果图如下： 将浏览器宽度缩小，可以看到左右两边宽度一定，中间宽度为自适应。 div.inner的 margin-left: 150px;margin-right: 180px 负责将两边内容挤开，避免在没有padding的包裹层时两边内容遮住中间。 参考资料CSS圣杯布局 css双飞翼布局 上面两篇出自同一作者，可谓一语道破，清晰明了。 圣杯布局的实现过程 双飞翼布局介绍-始于淘宝UED CSS双飞翼布局_百度知道]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(2)——负边距]]></title>
      <url>%2Fsomething-about-margin-nega%2F</url>
      <content type="text"><![CDATA[这是完成百度前端学院2015的task1后对前端布局知识点总结的第二篇博文。上一篇总结了一下overflow这个属性：前端布局知识点(1)——overflow属性。 CSS中的负边距是布局中一个常用的技巧。因为在后面学习的双飞翼布局的实现就依赖于负边距，负边距又与文档流息息相关，所以我先对这部分的知识进行查询学习。 文档流与文本流在我了解负边距的时候出现了一个词：文档流。而在查阅文档流相关资料的时候又出现一个词叫文本流。两者有什么区别？知乎上相关问题 HTML 的文档流和文本流分别是什么？- 知乎 的高票答案提供了一个辨析的思路：文档流是相对于盒子模型讲的，而文本流是相对于文字段落讲的。 在overflow的那篇文章中我们提到，浮动(float)是一个立体的浮动。当一个元素浮动时，它后面的元素会在它身下布局。但是文字会认为浮动元素是占据了一个区域而围绕它布局。我们可以将浮动元素想象成一个在海上浮动的人，鱼可以在他的身下，但海面上的泡沫会围绕在他周围。这时，这个元素脱离了文档流，但没有脱离文本流。 但是绝对定位(absolute)会将元素从文档流和文本流中脱离，也就是说其他元素和文本都不认同绝对定位元素占据了区域，而在它身下布局。 float、absolute和fixed三种方式定位会让元素脱离文档流。 负边距的表现当 margin-top、margin-left 为负值的时候，会把元素上移、左移，同时文档流中的位置也发生相应变化，这点与 position:relative 的元素设置top、left后元素还占据原来位置不同。 而当 margin-bottom、margin-right 设为负值的时候，元素本身没有位置变化，后面的元素会上移、左移。 负边距的实例多说无益，来看实例。我们可以利用负边距和绝对定位来实现一种经典的居中方式: 12345678910111213&lt;style&gt; .middle&#123; position: absolute; width: 200px; height: 200px; left: 50%; margin-left: -100px; &#125;&lt;/style&gt;&lt;div class=&quot;middle red&quot;&gt; middle div&lt;/div&gt; 把div设置为绝对定位，然后设置top和left为50%，这时候div的上边、左边就到了父元素（这里是页面）的50%处，再对div设置其自身高度、长度一般的负边距，使div的中心移动到页面中心，实现宽度上的居中对齐。我们当然也可以用同样的方式设置高度的居中。 关于负边距更多的应用可以看参考资料： 负边距在布局中的使用 在接下来谈到的双飞翼布局中，负边距将成为主角。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(1)——从overflow属性看浮动]]></title>
      <url>%2Fsomething-about-overflow%2F</url>
      <content type="text"><![CDATA[完成了 百度前端学院2015的task1 后，感觉自己之前学习CSS以及前端布局确实不太全面，有很多知识点现在才接触到，而且也很久没有用过CSS写前端布局了。查漏补缺，总结了几个以前没有注意的知识点：overflow、负边距、圣杯布局和双飞翼布局。一开始想把所有知识点总结成一篇，写着写着发现较短的篇幅不足以把这些都总结清楚，所以还是每个知识点单写一篇。 顺便推荐 学习CSS布局，很好的布局学习资料，值得反复学习。用詹俊老师的话来说就是，好文不妨一看再看！ 探究由来task1中有一道题是这样的：实现一个浮动布局，红色容器中每一行的蓝色容器数量随着浏览器宽度的变化而变化。很快写出代码如下： html代码： 1234567891011 &lt;div class="red task5"&gt; &lt;div class="blue bfloat"&gt;1&lt;/div&gt; &lt;div class="blue bfloat"&gt;2&lt;/div&gt; &lt;div class="blue bfloat"&gt;3&lt;/div&gt; &lt;div class="blue bfloat"&gt;4&lt;/div&gt; &lt;div class="blue bfloat"&gt;5&lt;/div&gt; &lt;div class="blue bfloat"&gt;6&lt;/div&gt; &lt;div class="blue bfloat"&gt;7&lt;/div&gt; &lt;div class="blue bfloat"&gt;8&lt;/div&gt; &lt;div class="blue bfloat"&gt;9&lt;/div&gt;&lt;/div&gt; CSS代码： 12345678910111213141516.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.task5&#123; margin-top: 10px; height: 100px;&#125;.bfloat&#123; height: 50px; width: 90px; margin: 10px; float: left;&#125; 这里说一声，根据 OO CSS 的思想，结构和样式应该相互独立（不太了解 OO CSS 的话可以看一下我之前的博文 对几个前端相关概念的理解——OO CSS、语义化、CSS hack）。尽管对于这种小 Demo，OO CSS显得不实用且有些累赘，我还是坚持去实现。因此我单独写了 red 和 blue 两个 class 来控制皮肤。 以上代码的效果图： 可以看到，效果图中红色容器的高度没有随着蓝色容器的行数的变化而变化，与我们理想的效果有些差距。这是因为我们在task5这个class中写死了容器的高度，而设置了浮动的蓝色容器脱离了红色容器，行数的变化无法再影响到红色容器的高度。从这里我们可以看出，所谓“浮动”不只是平面上的浮动，而是一个立体的浮动。当然，如果不写高度的话连红色容器都看不到。那怎么解决这个问题呢？我当时没有想到好的解决方法。查看了别人的代码后，发现是要把 task5 这个 class 中高度删掉，再加一行： overflow: hidden; overflow 属性overflow 属性规定当内容溢出元素框时发生的事情。这个属性的默认值为 visible，这时内容不会被修剪，会呈现在元素框之外，就像之前的效果图一样；而值为 hidden 时，内容会被修剪，并且其余内容是不可见的。也就是说，如果这时height属性还设置了定值的话，超出这个定值的部分不可见。这个时候显示的效果如下(height: 100px)： 删掉height属性后，overflow: hidden 在这个案例的真正用途是清除浮动。这里清除的是立体的，可以理解为z轴上的浮动。因此，蓝色容器的高度现在可以受其内部，也就是红色容器的总体高度影响。现在显示的效果是符合我们要求的，实际效果图如下： overflow 属性的值还可以为 scroll 和 auto。值为 scroll 时，内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。而值为 auto 时，如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。两者区别是如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。 浮动元素特点17.04.14补充：摘自 回归CSS标准之Float 。 float 属性被设置为非 none 的元素： 元素被视作块级元素，相当于 display 设置为“block”； 元素具备包裹性，会根据它所包含的元素实现宽度、高度自适应； 浮动元素前后的块级兄弟元素忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过 z-index 属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素； 浮动元素前后的行内元素环绕浮动元素排列； 浮动元素之前的元素如果也是浮动元素，且方向相同，它会紧跟在它们后面；父元素宽度不够，换行展示； 浮动元素之间的水平间距不会重叠； 当包含元素中只有浮动元素时，包含元素将会高度塌陷； 浮动元素的父元素的非浮动兄弟元素，忽视浮动元素存在，覆盖浮动元素； 浮动元素的父元素的浮动兄弟元素，会跟随浮动元素布局，仿佛处在同一父元素中。 参考资料CSS overflow 属性 CSS - 清除浮动（clearfix hack） 17.02.07更新： 那些年我们一起清除过的浮动 一文中将 overflow: hidden 所带来的清除浮动的效果称为“闭合浮动”，以区别于 clear: left|right|both|none 。我们通过闭合浮动来解决 wrap 高度塌陷的问题。 17.04.07更新： Clear Float 介绍了解决浮动带来的高度塌陷问题的另外两种方法：“clear:both”和“clearfix”。 回归CSS标准之Float 百度EFE的文章，加深对 float 的理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[又是一个新学期开始了]]></title>
      <url>%2Fnew-term%2F</url>
      <content type="text"><![CDATA[大二的下学期就要开始了。在寒假里，我自学了JavaScript和jQuery，看完了极客学院这两部分以及AngularJS入门的视频，廖雪峰JS教程学到underscore为止。由于缺乏系统学习和动手实践，掌握肯定不甚牢固。寒假的充实度可以说差强人意吧。 新学期课感觉要比上学期略少一点，但都是专业课，也有一定难度。希望自己在课业不放松的同时尽力实现以下学习目标，并产出有质量的博文以进行总结： 前端：学习《JavaScript高级程序设计》以及ES6，研究React框架（这个放在后面）。 后端：继续Java的深入学习，Servlet、JSP、SSH三大框架。 算法：学习《算法(Java描述)》，搭配LintCode练习。 英语：以尽量高的分数过六级。 理论学习永远离不开实践，要经常给自己找项目。前端方面可以跟着百度前端学院2015的小项目动手试试。新学期也希望自己在包括足球、人际等各方面有所突破。 新学期，新气象。写下这篇博文给自己打气！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对几个前端相关概念的理解——OO CSS、语义化、CSS hack]]></title>
      <url>%2Fsome-FE-concepts%2F</url>
      <content type="text"><![CDATA[极客学院的视频《CSS 在工程中改变》中讲到了OO CSS这个概念，而在知乎上看到别人的回答中提到了语义化和CSS hack这两个概念。在查找了相关资料后，我对这几个概念有了一些自己的理解。 OO CSSOO CSS，全称为Object Oriented CSS，意为“面向对象的CSS”。 OO CSS是一种书写规则，看重代码的重用性、可维护性和可扩展性。OO CSS将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。 OO CSS更加适合大型网站的开发，因为大型网站用到更多的可重用组件。为了更好地维护，最好给每个组件写一份说明文档。 作用： 加强代码复用以便方便维护。 减小CSS体积。 提升渲染效率。 组件库思想、栅格布局可共用、减少选择器、方便扩展。 注意事项： 不要直接定义子节点，应把共性声明放在父类。 结构与样式相互独立。 容器和内容相互独立。 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。 往你想要扩展的对象本身增加class而不是他的父节点。 对象应保持独立性。 避免使用ID选择器，权重太高，无法重用。（ID选择器大多数为JS服务） 避免位置相关的样式。 保证选择器相同的权重。 类名应简短、清晰并保有语义。OOCSS的名字并不影响HTML语义化。 参考资料： OOCSS——概念篇 语义化语义化就是对数据和信息进行处理，使得机器可以理解。 如何在开放的网络、庞大的信息资源中找到需要的信息？我们当然需要借助包括搜索引擎、爬虫在内的智能程序的力量。而为了让这些程序能够理解内容、推演逻辑、建立索引并给予较高的权值，语义化变得越来越重要。SEO最有效的一种方法就是对网页的HTML结构进行重构，实质上就是语义化。 为了使机器能够尽可能理解内容，规范是必须的。程序肯定只会关注那些约定俗成的东西。某种规范被认可的程度越高，就越会成为机器算法的目标，人们就越可以根据它来实现各种功能。 HTML本身也是机器可读的语义信息，但由于HTML被设计的目的并不是为了机器可读，所以不尽完美。也因此，HTML规范一直在往语义化的方向上发展。HTML5更是在之前规范的基础上，将所有表现层的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。 当然，HTML5并非Web语义化唯一的规范。有很多组织都提出了有浏览器和搜索引擎支持的规范，为扩展、标准化Web语义做着自己的贡献。关于HTML5各个元素语义的描述，可参考 Semantic HTML。 参考资料： 如何理解 Web 语义化？- 知乎 CSS hack由于不同厂商的浏览器和浏览器的不同版本对CSS有不一样的支持和解析结果，导致我们需要针对不同的浏览器及同一浏览器的不同版本写特定的样式，以获得统一的页面效果。这个过程叫做CSS hack。 使用CSS hack虽然有助于实现页面表现的一致性，但滥用会造成编码过于复杂、文档混乱不堪，增加管理和维护的负担。因此，hack要少用、慎用。等到未来浏览器厂商的标准能够完全统一时，就是hack退出历史舞台的时候了。 参考资料： 史上最全的CSS hack方式一览]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text 使用技巧笔记]]></title>
      <url>%2Fsublime-text-learning%2F</url>
      <content type="text"><![CDATA[作为一款主流前端开发编辑器软件，Sublime Text具有代码高亮、语法提示、自动完成，轻量级，易上手，并且支持插件扩展机制，可以说功能十分强大。 我用Sublime Text已经有一段时间了，但是只是浮于表面，没有进一步探索。作为一名准备在Web方面继续深研的软工学生，我决定对Sublime Text的使用技巧进行学习，并写下这篇笔记。 快捷键(OS X) Command + 光标 多点编辑 Command + p 快速打开文件 Command + Shift + p 打开命令行面板 Command + + / - 字体放大/缩小 Command + K + B 面板显示/隐藏 Command + ] / [ 缩进/退回一个级别 Command + L 选择当前行 Command (+ Shift) + Enter (在上一行)下一行开辟新行 Option + 鼠标左键 块选择(自动进入多点编辑) Alt(Command) + 左右键 单词(行)粒度的跳跃 Alt(Command) + Shift + 左右键 单词(行)选择(可以叠加使用多次) Command + A 全选 命令编辑器右下角可以更改语法，也可以在命令行面板输入语法名进行选择。 命令行面板输入”Key Bindings - Default”可以看到所有的快捷键设置。 “Key Bindings - User”中自己可以设置快捷键，遵循JSON语法： [ { &quot;keys&quot;: [&quot;shift+tab&quot;],&quot;command&quot;: &quot;reindent&quot;,&quot;args&quot;: {&quot;single_line&quot;:false}} ] “Reindent Lines”调整缩进（已经被我设置快捷键Shift + Tab）。 如何得到命令名和参数： Ctrl + ` 打开控制台，输入”sublime.log_commands(True)”； 再在命令行面板中输入操作； 在工作台即可看到命令名和参数； 自定制用户的设置保存在/~/Library/Application Support/Sublime Text 3/Packages/User中，写到这里的数据是不会因自动升级而被覆盖的。 推荐将这个文件夹中的内容同步到Github上。这样，在更换系统或电脑时，将文件夹clone下来进行替换，可以迅速按照自己的要求配置好。 15.05.17 更新： 把 sublime 中的 Tab 换成两个空格的缩进。方法详见 sublime text3里 修改TAB键为缩进为四个空格 。 扩展包到 https://packagecontrol.io/installation 可以看到 sublime3 中的安装方式，Control + ` 打开控制台，运行代码就可以安装上了。 Command + Shift + p 打开命令行面板，敲Install Package来搜索并安装想要的包。Remove Package卸载插件。 Packages/User/ 下面的文件 Package Control.sublime-settings 里面列出已经安装的包。 我安装的包有（不定期更新）： Git：这个包可以帮助我们在编辑器里完成git相关操作。在命令行面板中输入”Git Add Current File”、”Git Commit”、”Git Push”来完成相应操作。 emmet：Web前端开发必装包，敲 tab 键代码补齐。具体触发词参见 http://docs.emmet.io/cheat-sheet/。如果我想用标签来包裹一些内容，我就先把内容选中，然后 Ctrl-w 。这个命令也可以在命令面板上呼叫 Wrap with Abbreviation 。要是忘了快捷键了，就求助命令面板。弹出的输入框中输入后回车就可以看到效果了，语法上跟前面 tab 补齐的时候没有区别。如果要删除一层标签，用 Command + , (Remove Tag)。 快速查找文件或字符串Command + P 快捷键打开的功能叫做goto anything，见menu-&gt;Goto。支持模糊匹配，同时支持下面几种操作形式，让定位更准确： filename:lineno //定位至具体行号 filename@css-selector //定位至具体CSS选择器 filename@function //定位至具体函数 还可以直接在新打开的文件中定位字符串。 filename#searchtext Command + (Alt) + F 当前文件内查找(替换)。Enter 查找下一处，Shift-Enter 查找上一处。敲 esc 就可以停在那里进行编辑。 把光标停留在要找的单词上面，然后 Command + D 连续敲多次，就可以找出所有当前文件中的这个单词，而且是直接在多点编辑模式下，可以直接进行替换。 如果要在一个文件夹内全局查找，鼠标右击文件夹，Find in Folder 就可以了。打开下一个匹配项用 F4，上一处 Shift+F4。 Ctrl + - 跳回老位置（jump_back），Ctrl + Shift + - 反向操作跳（jump_forword） 参考资料： HappySublime 如何优雅地使用Sublime Text 牛人总结的Sublime Text的心得经验 jikeytang/sublime-text · GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Java的BiliBili视频信息爬虫]]></title>
      <url>%2FbiliInfoCrawler%2F</url>
      <content type="text"><![CDATA[该项目要求设计并实现一个 BiliBili 视频信息爬虫，并且能够将每个分类收藏数前三的视频下载至本地。 该项目使用的软件有Eclipse（IDE）、Charles（抓包工具）、MySQL（数据库）、Navicat Premium（数据库可视化工具）。以下代码截图全部基于OS X系统上自己编写的代码。 了解相关知识该实验所用到的知识有且不仅限于： HTTP 请求、响应和重定向； 使用 apache-httpclient 来实现对服务器的请求并收到响应； 用 jsoup 处理 html 文件； 数据库设计与使用； Java IO下载视频文件； 同时，该程序使用了 Maven 来管理项目的依赖关系。 抓包并分析用一个抓包工具来分析浏览器打开 BiliBili 视频网时重要的请求与响应。这里我选用的是 Charles，当然也可以使用 Fiddler 或者其他好用的。 可以看到，图中选中的项即为访问 BiliBili 视频网分类页面时服务器向浏览器发送的 json 文件。路径中 tid 后的数字代表种类，pn 后的数字代表页数。可以看到访问时浏览器发出的请求参数，爬虫程序同样也要设置这些参数使服务器认为是浏览器在访问。而在每一个 json 文件中，有 20 个视频的信息，包括我们感兴趣的 av 号（Bilibili 视频 id号）、作者、种类、收藏数、硬币数等信息。我们之后将要对 json 文件进行处理来获得这些信息，并把它们存进数据库。 爬虫相关方法 使用apache-httpClient来实现请求并得到响应，最终得到json文件。 通过JSONArray和JSONObject两个类方法对请求到的json文件进行处理，将得到的视频信息初始化为一个Bilibili对象（Bilibili类在Bilibili.java中定义），并调用JDBC.java中定义的方法将数据存入数据库。 视频下载相关方法 通过SQL语句选出该种类中收藏数前三的视频，返回其av号及其他信息。通过www.ibilibili.com加上av号，对其发出请求，获得HTML文件。 使用jsoup，利用标签对HTML文件进行解析，获得以www.bilibilijj.com/Files/DownLoad/为开头的视频下载地址。 利用JAVA IO的相关方法编写readInputStream和getVideo方法，下载视频保存至本地指定地址。 调用方法并开多线程加速在main方法中调用之前写好的方法，并开多线程加速爬取和视频下载。 结语经过反复的设计、编程、测试、修改，最终的程序能够爬取 BiliBili 视频网音乐区 7 个类别约 62 万个视频的信息（由于校园网波动，最后只爬了62w，实际上音乐区应该不止这么多视频），将其存入数据库，并将每个类别收藏数前三的视频下载至本地，符合实验要求。 完整代码已经放在我的 Github 中。由于个人水平有限，可能存在错误或者性能优化方面的问题，欢迎讨论。 项目中参考的资料 普通Java工程转换成maven工程 Jsoup+json-lib解析xml带中括号的数组Json数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bye,2016 and Hello,2017]]></title>
      <url>%2Fbye2016hello2017%2F</url>
      <content type="text"><![CDATA[开始写的时候是 12 月 30 日晚上，刚刚考完的大物感觉还不错。然后马上就到了 2016 年的最后一天。希望能在2016年内写完这篇博文，给自己的这一年做一个回顾。更重要的是，认真地考虑一下，2017 年应该去做些什么。 Goodbye, 2016 从软件工程的萌新变成半萌新。感觉算是摸到了大门，往内斗胆一窥，发现这个世界广阔无垠。东瞧西瞥，还没有考虑好自己今后的发展方向，目前还是打算先以 java 的进阶为主，向 web 开发方面学习。 今年的学期感觉除了课业上按部就班外，在技术自学上没有激情。倒是暑假自学 java 有很大的收获。希望自己能够不忽视小块的时间去学习技术。当然，首先找到至少短期内的一个学习目标。 大一下学期进了院长实验室，但是总觉得项目安排上有点难受。外包任务让自己没什么长进。下学期看看怎么协调一下，当然也有可能下学期会参加花旗杯。 拿了一些院级活动的奖（而且基本都是产品&amp;设计方面的工作）。希望自己能做一些负责技术方面的、有价值的项目。 体测比去年同期略瘦，50米快了整整一秒。希望自己能保持锻炼，还能在院队有个位置。 Hello, 2017 先顺利地过了上学期所有期末考。希望自己的绩点还能保持在3.5以上。认真复习，少浪，别懒！ 寒假先定个小目标，比如啃啃 javascript，啃啃java 的高级特性，啃啃 lintcode，写几篇有用的技术博客，顺便把博客再折腾一下，最好买个域名。总之，要让 27 天的寒假过的有意义。寒假开始时再列个日程表。 早睡早起，勤奋刻苦，下学期尽量不翘课。都是专业课，认真听。还要在课余时间继续学技术。 希望能做一个真正意义上的大项目（比如花旗杯）。为了这个目标，学技术。 在自己真正的兴趣上利用时间，而不是无所事事地浪费。 每天过得健康、充实、开心！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【V家中填】飛行機雲 -full ver.-]]></title>
      <url>%2Flyrics-aircloud%2F</url>
      <content type="text"><![CDATA[在高考完的暑假，我填完了第一首可以称为“完整”的词。契机是很偶然地点进了【Shikako】飛行機雲【翻唱】。一首好听的歌加上纯真的妹子音，可惜关注度远低于作品质量所应得的。(这个up把歌传到网易云啦。如果你懒得打开网址，点击下面播放就能听) 当时B站恰巧推出了“夏日延长线”的翻唱活动，想填词＋翻唱来参加。词是以远高于一般速度地填完了（果然ddl是第一生产力w），但录制翻唱直到现在还没有尝试过。夏天终究是属于遗憾的季节。 尽管写的很快，还是花了很多心思去斟酌如何表现那种孩童时的懵懂和错过时的心酸。如果看到这的人觉得这首词填的还不错，我就很开心了。要是有唱(mei)见(zi)愿意拿这首词翻唱，那我就可以上天了ε=ε=(ノ≧∇≦)ノ当然也欢迎交流讨论。 【中文填词】飛行機雲 -full ver.- 曲：toa词：摸鱼小能手大黄菌 那时候 你决定松开手让气球飞走也松开我们之间可能有 的以后而我呢 还在原地踮着脚仰望天空看你指过的飞机云在泪水中消融 回家 在蝉鸣中难忍受 你的捉弄 挥舞拳头而你 笑着逃走我追赶 磕磕绊绊 眼泪摔落 站在分别时的十字路口我垂落的双手紧握沉默迟到的挽留总是与开口错过就像你和我 那时候 你决定松开手让气球飞走也松开我们之间可能有 的以后而我呢 还在原地踮着脚仰望天空看你指过的飞机云在泪水中消融 忽然之间 被牵住手你偏头 眼神闪躲 一字不说而我的脸已泛红转过身 闹起别扭 掩饰羞涩 那个夏天一直有风路过过往的快乐却不肯为我逗留抓不住时光匆匆流走的你我把彼此弄丢 那时候 关于未来的想象都太年幼以为长大还躲在漫长的 等待后而我呢 还在原地想念着你的笑容而你指过的飞机云再次划过天空 那时候 我们约定再见而 拉过的勾勾住的只有斑驳的 回忆和难过而我们 在物是人非后终于失去联络在世界的不同角落孤单地漂流 而我呢 还在原地想念着你的笑容想念那天归家途中见到的彩虹而你呢 在什么地方唱着熟悉的歌是否也像我偶尔望向同一片天空]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 hexo+github 搭建这个博客的一点经验]]></title>
      <url>%2Fhexo-begin%2F</url>
      <content type="text"><![CDATA[博客基本算是搭好了。当然，还有很多地方可以改进，比如加上包括评论（主要是多说不知道为什么一申请就告诉我出错）在内的第三方服务，比如样式还可以再漂亮一些，而且也没有申请自己的域名（毕竟也没什么人看吧…大概）。但是一个博客，内容的质量应该是最重要的。从现在开始，先写点东西吧，比如，先谈谈搭建这个博客时遇到的一些问题以及解决的方案。注意，我是用 mac 搭建的，以下很多内容可能只适用于 OS X 系统。 这个博客后期做的样式等修改也会在这篇博文中进行实时更新记录。 初始搭建前期准备：安装 XCode、Node.js，注册 Github。除开Node.js外都是已有的，也没遇到什么问题。 hexo 的安装推荐查看hexo的官方文档，说的很详细。看网上七七八八的教程反而可能遇到一些莫名其妙的问题。整个搭建过程中花费时间最多的就是在解决 DTrace 错误上： 1[Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; 按照百度的解决方法折腾半天（是真的半天！）也不奏效，最后的解决方案还是按照文档从安装hexo开始重新走了一遍，再使用命令： 1npm install hexo --no-optional 这才解决。果然官方文档才是坠吼的！ 然后就是主题选择了。根据知乎上有哪些好看的 Hexo 主题？－知乎问题的回答，果断选择github上star最多的NexT主题，官方文档也同样详细易懂。Muse 实在太丑，开始时我选用的 Scheme 是 Mist。后来百度看到好多大佬选用 Pisces，感觉要比 Mist 好看一些，于是换了。其实就是改改配置文件，很简单。之后加入不蒜子统计，设置 RSS（其实我并不清楚这个是干什么的…就是橙色的图标蛮好看的），加上标签、分类、关于页面、搜索功能和侧边栏社交链接。这些在官方文档写的都很清楚。 我还改了一些什么呢？第一，背景颜色。原来NexT的默认背景颜色是浅灰色，不仅沉闷，而且和其他博客的重复率太高。在网上搜到改动方法：hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _schemes -&gt; Pisces（Mist和Muse也行），找到路径下的index.styl文件，改动文件的最上方的那一行代码即可。这个方法应该也可以将背景换成图片，但是每次我用hexo server在本地看是正常的，传到github上就显示不了图片。还没找到解决方法，只好作罢。 17.04.27更新：解决了，现在背景图片为《言叶之庭》中的截图，CSS 代码为 1body &#123; background: url("../../../images/back1.jpeg"); background-repeat:no-repeat; background-attachment:fixed; background-size: 100% 100%;&#125; 第二，我对底部 powered by 的 logo 栏进行了更改。其实按理说这个地方作为对 hexo 和 NexT 的开发者的感谢不应该修改的…还是更想个性化一点，抱歉抱歉。修改方法参见 Hexo-Next底部powered by的logo栏更改以及注意事项（附官方文档,文末有福利链）。我把这里当作一个随时修改的心情栏了。（17.04.27：我改回来了） 大概就这些了。希望搭建这个博客能够督促我写下更多编程学习中的经验之谈。但我也没有打算只把这个博客当作一个写技术性文章的地方，随笔、填词什么的也会放在这里。欢迎大家多多来看，相互交流 :) 后期更新 16.12.31更新：加上了鼠标点击出爱心的特效。详见 hexo引用自定义js文件和css样式。这个blog还有粒子特效的背景，说不定哪天也给自己加上。 17.02.20更新：申请了现在的域名，域名解析详见 Hexo站点之域名配置【2】。 17.02.21更新：增加多说评论并修改样式，详见 动动手指，给你的Hexo站点添加最近访客（多说篇）。 17.02.26更新：NexT主题支持自行设定CDN以加速静态资源的加载，详见 进阶设定 - NexT 使用文档。但是经过测试，感觉修改CDN后并没有实现预期的加速（也有可能是我没找到比较好的CDN）。所以现在暂时还是保持没有修改的状态。 17.04.08更新：多说即将归西。暂无用其他评论系统替代的打算。 17.04.27更新：NexT 主题更新至 5.1.1 版本，更换背景图片（好看多了w）。 17.12.20更新：感觉字体不好看…修改了 /themes/next/source/css/_variables 文件。]]></content>
    </entry>

    
  
  
</search>
