<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Let's start Python!]]></title>
      <url>%2Flets-start-Python%2F</url>
      <content type="text"><![CDATA[年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！ 今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，Python 这方面的生态环境还是要比 Node 强大不少。当然我也希望不丢掉之前的 JS 和 Node 基础，要时常写点东西或者看看书保持状态。 顺便谈一下，朱老师让我学 Python 2.7，大概是有一些历史遗留问题。但是我在知乎上查了一下，还是决定先看廖雪峰 3.x 版本的 Python 教程。我觉得知乎里一个回答给的建议不错，摘抄一下： 学习 Python 前，先了解在 Python 3 里面已经弃用的 Python 2 语法，对这些部分简单带过不要花太多时间； 使用 Python 2，不要使用 Python 2.7 以前的版本； 使用 Python 3，不要使用 Python 3.4 以前的版本； 多了解 Python 2 的__future__库； 对同一份代码，不要为 Python 2 和 Python 3 分别维护分支，努力在一套代码中兼容 Python 2 和 Python 3。 根据以上建议，我在 Anaconda 配置了 2.7.13 和 3.6.0 的两种版本。当然这份回答里最重要的还有一句话： stop talking, just do it！ 这一篇大概就讲这么写废话。人生苦短，我用 python，常听到这句话，现在我就来体验啦！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解释器构造及 ANTLR v4 学习笔记（一）]]></title>
      <url>%2FANTLR-learning-notes-1%2F</url>
      <content type="text"><![CDATA[新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。 课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。 ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。 更新记录： 17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布 17.09.11 Chapter 3 阅读完毕，增加动手上路章节。这篇就大概到此为止。 我对编译技术的认识在正式进行 ANTLR 的学习前，先让我们聊一聊在经过上学期《编译技术及应用》的学习，以及查阅了有关资料后，我对编译技术和编译工具的一点认识。 说实话，如果单单是谈在《编译技术及应用》这门课上的认识的话，我可能只能像孔乙己一样，接连便是难懂的话，什么“上下文无关文法”，什么“LL(1)”，引得各位都哄笑起来，屏幕内外充满了快活的空气… 尽管经过了计算器和 JSONCompiler 两次实验，但我们可能对编译技术的应用还没有什么认识，觉得编译器的唯一用处就是写一个能把 xx 语言翻译成 xx 然后再运行成功… 基于写这篇博文的契机，我查了一下编译技术的各种应用，才发现其实“编译”这个概念应用还是很广泛的。 比如我的博客是用 hexo 这个博客框架搭建的，而你现在看到的这篇博文是 hexo 将我写的 markdown 文件解析成 html 生成的，这其中自然有编译模块的功劳（感兴趣可见 大前端-5分钟带你读懂Hexo源码设计模式 - 简书）。 再比如作为一个前端，有不少我使用过或日常接触的工具、框架其实都是编译相关知识的应用：Babel 作为 ES 6 的所有新特性还没有在主流浏览器全面推广的一个暂时的解决方法，将 ES 6 编译成 ES 5 等浏览器能够运行的 JavaScript 代码；在 Vue 中频繁出现的模版引擎、v-for=&quot;item in list&quot;等也有编译的身影。如果真正对编译原理理解透彻，大概可以去摸摸 v8 ，帮助提高一下 Node.js 的运行效率。 编程，本质上是程序员通过语言来控制计算机按照人的意志去进行各种运算和操作。自 20 世纪 50 年代早期，第一个只能进行单目运算的编译程序诞生起，编译技术一直作为人与计算机之间的传声筒，支撑着计算机语言的发展，使其更加系统化、合理化。 在知乎上“编译原理学了有什么用？”这个提问下，有答主贴了一幅《C 编译器解剖》序的照片，其中有一段话： 操作系统和编译器就如武侠小说中的“九阴真经”，没看过“九阴真经”的侠客也可以行走江湖，但看过并练成九阴真经的人最终才更有机会登上华山之巅。 怀着对程序员之巅的心向往之，我也对编译原理更生敬畏。 当然，如何让这门古老的屠龙术落地，而不至于成为学生心中虚无缥缈的空中楼阁。我个人认为可以再开设一些相关的新课题，让学生能够充分了解编译技术的实用性，从而能够自主学习、实践。我也希望《解释器构造实践》能成为一个不错的起点。 初识 ANTLR 对应《The Definitive ANTLR 4 Reference》中 Chapter 1 Meet ANTLR。书里的这一章主要是介绍 ANTLR 的下载安装方法，并运行了一个简单的 demo。 安装 ANTLRANTLR 是用 Java 写的，所以就算你想使用 C# 或者 C++ 来配合 ANTLR 生成解释器，安装 ANTLR 前也需要有 Java 环境。 之后需要下载 antlr-4.0-complete.jar 并把它放在你记得住的地方。这个 jar 包包含了运行 ANTLR 工具所需要的所有依赖，还包含两个支持库：一个树状排版库，以及 StringTemplate，一个用于生成代码以及其他结构化文本的模版引擎。 安装的具体步骤请直接看官网的 Quick Start。 ANTLR 全貌 对应《The Definitive ANTLR 4 Reference》中 Chapter 2 The Big Picture，书中这一章介绍了从字符流到解析树的过程、ANTLR 运行流程中的一些重要术语，以及ANTLR 自带的 Listener &amp; Visitor 这两种遍历树的机制。 想要实现一种语言，我们就需要构建读取句子（sentence）的应用，并对输入的元素做出正确的反应。 如果应用计算或执行句子，我们就叫它解释器（interpreter），包括计算器、配置文件读取器、Python 解释器都属于解释器。 而如果我们将句子转换成另一种语言，我们就叫它翻译器（translator），例如 Java 到 C# 的翻译器和编译器都属于翻译器。 不管是解释器还是翻译器，想要正确运行，应用首先都要识别出所有有效的句子、词组、字词组等，识别语言的程序就叫解析器（parser）或语法分析器（syntax analyzer）。 完全 DIY 一个解析器非常麻烦，所以我们需要 ANTLR 的帮助。ANTLR 是一种能写出程序的程序，只需编写 ANTLR 的语法（grammars）文件，描述我们要解析的语言的语法，ANTLR 就能够自动生成用来解析这种语言的解析器。而用来声明我们语言的ANTLR语言的语法，就是元语言（meta-language）。 最基本的解析过程为了简单起见，我们将解析分为两个阶段，第一阶段是词法分析（lexical analysis），对应的分析程序叫做lexer，负责将符号（token）分组成符号类（token class or token type）。而第二阶段就是真正的parser，默认 ANTLR 会构建出一棵分析树（parse tree）或叫语法树（syntax tree）。下图展示了一个简单的赋值表达式的解析过程： 语法树的叶子是输入的 token，而上级结点是包含其孩子结点的词组名（phase），线性的句子其实是语法树的序列化。最终生成语法树的好处是： 树形结构易于遍历和处理，并且容易被程序员理解，方便了应用代码做进一步处理。 多种解释或翻译的应用代码都可以重用一个解析器。但 ANTLR 也支持像传统解析器生成器那样，将应用处理代码直接嵌入到语法中。 对于因为计算依赖而需要多趟处理的翻译器来说，比起多次调用解析器去解析，遍历语法树多次更加高效。 深入 ANTLR 的解析过程ANTLR 生成的解析器叫做递归下降解析器（recursive-descent parser），属于自顶向下解析器（top-down parser）的一种。 顾名思义，递归下降指的就是解析过程是从语法树的根开始，向叶子（token）递归。还是以前面的赋值表达式解析为例，其递归下降解析器的代码大概是下面这个样子： 很酷的一点是stat()、assign()、expr()等方法调用所形成的图能与分析树相互对应。match()的调用对应树的叶子，而assign()方法直接顺序读取输入字符，而不用做任何选择。相比之下，stat()方法要复杂一些，因为在解析时，它需要向前看（lookahead）一些字符才能确认走哪个代码分支，有时甚至要读取完所有输入才能得出预测结果。 虽然 ANTLR 默默地为我们处理了这整个过程，但对这个选择过程有一个基本的了解会使得对生成的解析器进行 debug 变得更加容易。 用解析树构建语言应用在内部，ANTLR 的数据结构会尽可能地共享数据来节约内存。如下图所示，解析树的叶子节点指向 Token 流中的 Token，而 Token 中的起止字符索引指向字符流，并不拷贝子字符串。而像空格这种不与任何 Token 相关的字符会直接被 Lexer 丢弃掉。 ANTLR 为每个 rule 都会生成一个 RuleNode，叫做 Context 对象，它会记录根据规则识别词组时产生的所有信息。 解析树的 Listener 和 Visitor 机制ANTLR 在其运行库提供了 Listener 和 Visitor 两种解析树遍历机制。 Listener 的特点是全自动化，我们不必写一个解析树的遍历器，ANTLR 会生成一个 ParseTreeWalker 来主导深度优先遍历过程，我们只需处理各种事件就可以了。例如当遍历器遍历到assign规则的节点时，会触发enterAssign()并将其传递给解析树节点AssignContext；而当遍历器遍历完assign节点的所有子节点时，触发exitAssign()。 而 Visitor 则提供了可控的遍历方式，我们可以自行决定是否将子结点作为参数调用visit()方法。 动手上路 对应《The Definitive ANTLR 4 Reference》中 Chapter 3 A Starter ANTLR Project。 ANTLR 工具，运行库和生成代码ANTLR 分为两个重要的部分：ANLTR 工具自身和 ANTLR 运行（runtime） API。运行 ALTLR 工具会生成能够辨认语法所描述语言的句子的代码（词法分析程序和语法分析程序）；而运行库提供了生成代码所需的一系列类与方法，例如 Parser, Lexer 和 Token。 我们先对一份语法运行 ANTLR，然后借助运行库 jar 包中的运行类（runtime classes in the jar）对生成的代码进行编译。最后，编译得到的应用与运行库结合着运行。 《The Definitive ANTLR 4 Reference》（后文可能简写为《Reference》）给出了一份简单的示例，让我们可以快速了解 ANTLR 所需语法的格式： 12345678910111213141516/** Grammers always start with a grammer header. This grammer ** is called ArrayInit and must match the filename: ArrayInit.g4 */grammar ArrayInit;/** A rule called init that that matches comma-separated values between &#123;...&#125; */init : '&#123;' value (',' value)* '&#125;' ; // must match at least one value/** A value can be either a nested array/struct or a simple integer (INT) */value : init | INT ; // parser rules start with lowercase letters, lexer rules with uppercaseINT : [0-9]+ ; // Define token INT as one or more digitsWS : [ \t\r\n]+ -&gt; skip ; // Define whitespace rule, toss it out 之后通过命令行运行antlr4 ArrayInit.g4，ANTLR 为我们生成很多一般需要我们自己手写的文件： 这些文件的功能如下： ArrayInitParser.java：包含了专用于 ArrayInit 语法的解析器（parser）类的定义。 ArrayInitLexer.java：包含专用的词法分析程序（lexer）类的定义。 ArrayInit.tokens：对于我们定义的每个 token，ANTLR 分配了一个 token 类型码（token type number）并将这些值保存在 ArrayInit.tokens。因为这个文件的存在，当我们将较大规模的语法分割为各种小型的语法表达时，ANTLR 能够使同种 token 的类型码保持一致。 ArrayInitListener.java, ArrayInitBaseListener.java：ANTLR 生成的解释器会默认根据输入构建一棵树。通过遍历这棵树，一个遍历器可以将事件（回调函数）传递给我们提供的监听者对象（listener object）。ArrayInitListener 是描述我们可以实现的回调函数的接口，而ArrayInitBaseListener 是默认空实现的集合，使我们可以方便的重写（override）那些我们感兴趣的回调函数。通过-visitor命令行参数，ANTLR 也可以为我们生成树的 visitors。 测试生成的解析器之后，我们通过javac *.java来编译 ANTLR 生成的所有代码。UNIX 系统用户可以将以下代码写入.bash_profile或其他启动脚本，以免每次都要在命令行输入一遍： 123export CLASSPATH=".:/usr/local/lib/antlr-4.7-complete.jar:$CLASSPATH"alias antlr4='java -jar /usr/local/lib/antlr-4.7-complete.jar'alias grun='java org.antlr.v4.gui.TestRig' 之后就可以通过grun命令来测试生成的解析器了。注意输入要以 EOF（Unix 系统 Ctrl + D，Windows 系统 Ctrl + Z）作为结束。加上-tokens命令行参数，输出的每一行会展示一个单独的 token 及其所有信息： -tree会生成一个 Lisp 风格的简单语法分析树： 而-gui会生成一个展示语法分析树的 GUI 界面： 根据我们定义的语法规则，ANTLR 自动生成了这棵语法分析树。之后我们会利用 ANTLR 内置的遍历器触发enterInit()和enterValue()等各种回调函数。 将生成的解析器集成进 Java 程序我们来写一个简单的 Java main()方法来集成生成的解析器，并打印出和使用-tree参数一样的解析树。 1234567891011121314151617181920212223// import ANTLR's runtime librariesimport org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;public class Test &#123; public static void main(String[] args) throws Exception &#123; // create a CharStream that reads from standard input ANTLRInputStream input = new ANTLRInputStream(System.in); // create a lexer that feeds off of input CharStream ArrayInitLexer lexer = new ArrayInitLexer(input); // create a buffer of tokens pulled from the lexer CommonTokenStream tokens = new CommonTokenStream(lexer); // create a parser that feeds off the tokens buffer ArrayInitParser parser = new ArrayInitParser(tokens); ParseTree tree = parser.init(); // begin parsing at init rule System.out.println(tree.toStringTree(parser)); // print LISP-style tree &#125;&#125; 测试结果如下。语法错误也可以被报告： 构建语言应用我们的目标不仅仅是识别，还想做一些翻译工作。最简单的方法是利用 ANTLR 内置的语法分析树遍历器，这样我们不需要自己去进行树遍历，大大减少了工作量。 我们给 ArrayInit 加一个新需求：将 short 数组{99, 3, 451}翻译为字符串\u0063\u0003\u01c3。实现这个需求，我们只需要继承ArrayInitBaseListener，来实现其中的一些监听器方法。 我们在 ShortToUnicodeString.java 中实现我们的监听器： 123456789101112131415161718/** Convert short array inits like &#123;1, 2, 3&#125; to "\u0001\u0002\u0003" */public class ShortToUnicodeString extends ArrayInitBaseListener &#123; @Override public void enterInit(ArrayInitParser.InitContext ctx) &#123; System.out.print('"'); &#125; @Override public void exitInit(ArrayInitParser.InitContext ctx) &#123; System.out.print('"'); &#125; @Override public void enterValue(ArrayInitParser.ValueContext ctx) &#123; int value = Integer.valueOf(ctx.INT().getText()); System.out.printf("\\u%04x", value); &#125;&#125; 我们不需要覆盖每一个enter/exit方法，只需要实现我们需要的那些。代码里ctx.INT()代表上下文对象请求已经匹配的整数 INT 的值。记住我们之前提到的，Context 对象会记录根据规则识别词组时产生的所有信息。 接下来，我们要创建一个主程序： 1234567891011121314151617181920212223242526272829// import ANTLR's runtime librariesimport org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;public class Translate &#123; public static void main(String[] args) throws Exception &#123; // create a CharStream that reads from standard input ANTLRInputStream input = new ANTLRInputStream(System.in); // create a lexer that feeds off of input CharStream ArrayInitLexer lexer = new ArrayInitLexer(input); // create a buffer of tokens pulled from the lexer CommonTokenStream tokens = new CommonTokenStream(lexer); // create a parser that feeds off the tokens buffer ArrayInitParser parser = new ArrayInitParser(tokens); ParseTree tree = parser.init(); // begin parsing at init rule // Create a generic parse tree walker that can trigger callbacks ParseTreeWalker walker = new ParseTreeWalker(); // Walk the tree created during the parse, trigger callbacks walker.walk(new ShortToUnicodeString(), tree); System.out.println(); &#125;&#125; 比起上一节的主程序，我们多创建了一个树遍历器（ParseTreeWalker walker），并用它来遍历语法分析器返回的语法分析树，它会触发ShortToUnicodeString中的回调方法。 javac 进行编译后就可以使用了： 我们可以通过传入不同的监听器来产生完全不同的输出。监听器将语法和我们的语言应用很大程度上解耦了，使语法具有了更大的重用性。 结语第一篇笔记到这里就结束了。我们聊了一下我对编译技术的一点看法，并阅读了《The Definitive ANTLR 4 Reference》的前三张。之后我们会继续阅读这本书，并且可能给出使用实例，完成对计算器功能的词法语法分析器的自动实现，或是分析某一具体语言的编译开关等。 参考资料 《The Definitive ANTLR 4 Reference》 Antlr v4入门教程和实例 - 西代零零发 - CSDN博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node 学习中遇到的 repo 和 ideas（持续更新）]]></title>
      <url>%2FNode-repo-and-ideas%2F</url>
      <content type="text"><![CDATA[对 Node 有所学习后，有时感觉无所不能，真正想做一些 demo 时又自觉无能；有时突发奇想一些 ideas，有时间想敲 demo 时又有点无所事事；有时看到一些有用或者有趣的库，事后又忘的干干净净。所以专门开一篇博文，一是记录一些常用的或者没用过有机会想体验的库，二是记录一些 ideas，等着有时间、有能力、有兴趣时来实现。 repo网络请求 r2：request 模块的作者新写的 HTTP 请求模块，基于 Promise 及 async/await 实现，让 Ajax 写法更轻松（不过功能应该和 superagent 基本一致，API 不同而已，不强迫使用）： 123const r2 = require('r2')let html = await r2('https://www.google.com').text superagent + superagent-cache html 文本分析 cheerio：Node 中的 jQuery ideas 大黄说：个人短日志记录的小程序 知乎爬虫：可以参考基于node的微小爬虫——扒了一下知乎 - 掘金，需要考虑一下具体需求 markdown 按格式解析成 html：这个具体结合把我的歌词变成 html 与机器人实时聊天：可以参考 基于vue2.0的实时聊天项目，可以了解一下机器人和 Socket.io 带后台和 SSR 的博客 yuki：一个小工具，可以将算法的文件和笔记维护到大的 README.md 中，用一个 config.js 加以配置［开发中］ 一个带前端、后台、数据库的，管理什么书单、这个 ideas，或者个人每天想法什么的 micro website。这个应该作为 node 和云服务器练手不错，然后留出接口应该还可以给第一个 idea 用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node 异步 I/O]]></title>
      <url>%2Fasync-IO-in-Node%2F</url>
      <content type="text"><![CDATA[在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。 Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。 因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。 这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。 选择异步的原因选择异步的原因包括用户体验和资源分配两个方面。 从用户体验的角度分析，浏览器中 JavaScript 在单线程上执行，并且与 UI 渲染共用一个线程。因此采用异步请求将使下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为。 而从资源分配角度来看，当遇到一组互不相关的任务需要完成的场景时，主流选择有以下两种： 单线程串行依次执行：容易导致阻塞，硬件资源难以有效利用； 多线程并行：创建线程和执行期线程上下文切换的开销较大，且经常面临锁、状态同步等问题（但多线程在多核 CPU 上能够有效提升 CPU 的利用率）； 而 Node 给出的解决方案是：利用单线程，远离多线程死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞以更好地利用 CPU。 而为了弥补单线程无法有效利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效利用 CPU 和 I/O。 从操作系统看异步 I/ONode 的异步 I/O 不可否认地受到操作系统中异步 I/O 实现的启发。 要强调的是，从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。 阻塞/非阻塞 I/O在调用阻塞 I/O 时，应用程序需要等待 I/O 完成时才返回结果。特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束，因此造成 CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用。 与阻塞 I/O 完成整个获取数据的过程相比，非阻塞 I/O 则不带数据直接返回，要获取数据还需要通过文件描述符再次读取。非阻塞 I/O 返回之后，CPU 的时间片可以用来处理其他事务。 但由于完整的 I/O 并没有完成，非阻塞 I/O 立即返回的仅仅是当前调用的状态。为了获取完整数据，需要轮询这种重复调用以判断操作是否完成的技术。 现存的轮询技术包括 read（通过重复调用检查 I/O 状态，性能最低，CPU 一直等待）、select（通过对文件描述符上的事件状态进行判断）、poll（比 select 有所改进，但性能仍较低）、epoll（Linux 下效率最高的 I/O 事件通知机制，进入轮询时休眠，直到事件发生将其唤醒）和kqueue（与 epoll 类似，仅在 FreeBSD 系统存在）。 虽然轮询技术能够满足了非阻塞 I/O 确保获取完整数据的需求，但应用程序依旧花费了很多时间来等待 I/O 完全返回。等待期间，CPU 要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。因此，它仍然只能算是一种同步。 异步 I/O 的实现我们期望的完美异步 I/O 应该是：应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序即可。 Linux 原生提供 AIO 这种符合要求的异步 I/O 方式，但只有 Linux 下有，且其无法利用系统缓存。因此现实情况下，想在单线程场景完美实现异步 I/O 有些难度。 而在多线程，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加载轮询技术来完成数据获取，让一个线程进行计算处理，再通过线程间的通信将 I/O 得到的数据进行传递，可以模拟异步 I/O。 *nix 平台，Node 自行实现了线程池来完成异步 I/O；Windows 平台则采用 IOCP 实现。Node 提供了 libuv 作为抽象封装层，平台兼容性由这一层完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。 Node 在编译期间判断平台条件，选择性编译 unix 目录或 win 目录下的源文件到目标程序中。 我们常说的“Node 是单线程的”里的“单线程”仅指 JavaScript 执行在单线程。而内部完成 I/O 任务的另有线程池，只是 I/O 线程使用的 CPU 较少。 除了用户代码无法并行执行外，所有的 I/O （磁盘 I/O 和网络 I/O 等）可以并行。 Node 的异步 I/O事件循环、观察者、请求对象、I/O 线程池一同构成了 Node 异步 I/O 模型的基本要素。 事件循环每执行一次循环体的过程被称为 Tick，查看是否有事件待处理，若有则取出事件及相关回调函数。如果存在关联的回调函数，就执行它们。直到没有事件，进入下个循环。 观察者每个事件循环中有一个或者多个观察者，判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。 事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求是事件的生产者，事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。观察者相当于事件池。 在 Windows 下，这个循环基于 IOCP 创建，而在 *unix 下基于多线程创建。 请求对象请求对象是从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中的重要中间产物。所有的状态都保存在这个对象中，包括送入 I/O 线程池等待执行以及 I/O 操作完毕后的回调处理。 执行回调组装好请求对象、送入 I/O 线程池等待执行，构成了异步 I/O 的第一部分。而回调通知是第二部分。 线程池中的 I/O 操作调用完毕后，会调用方法向 IOCP 提交执行状态，并将线程归还线程池。 在每次 Tick 的执行中，I/O 观察者会调用方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。 整个异步 I/O 流程图如下： 非 I/O 的异步 APINode 中还存在一些与 I/O 无关的异步 API：setTimeout()、setInterval()、setImmediate()、process.nextTick()。 定时器setTimeout()和setInterval()与浏览器 API 一致，创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件并执行其回调函数。注意：由于事件循环自身特点，定时器并非精确的。 process.nextTick() &amp; setImmediate()两者都可用于将回调函数延迟执行，以异步执行一个任务。两者的区别如下： 优先级：process.nextTick()中回调函数执行优先级要高于setImmediate()，原因在于事件循环对观察者的检查是有先后顺序的，idle 观察者（process.nextTick()） &gt; I/O 观察者 &gt; check 观察者（setImmediate()）。 具体实现：process.nextTick()的回调函数保存在一个数组中，setImmediate()保存在链表中。 行为：process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。这样的设计是为了保证每轮循环能够较快地执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。 事件驱动与高性能服务器事件驱动的实质：通过主循环加事件触发的方式来运行程序。 几种经典的服务器模型各有其优缺点： 同步式：对于同步式的服务，一次只能处理一个请求，并且其他请求都处于等待状态。 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但因为系统资源有限而不具备扩展性。 每线程/每请求：为每个请求启动一个线程来处理。扩展性强于每进程/每请求，但由于每个线程都占用一定内存，大并发到来时内存还是会很快用光。 Apache 目前还采用每线程/每请求，而 Nginx 采用事件驱动。 Nginx 与 Node 比较： Nginx 采用纯 C 写成，性能较高，但仅适合做 Web 服务器，用于反向代理或负载均衡等服务，在处理具体业务方面欠缺； Node 是一套高性能平台，没有 Nginx 在 Web 服务器方面那么专业，但场景更大，可以处理各种具体业务。 参考资料《深入浅出Node.js》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[夏天就要过去]]></title>
      <url>%2Fsummer-time-gone%2F</url>
      <content type="text"><![CDATA[现在是 2017 年的 8 月 29 号，离 9 月还有 2 天。大三近在咫尺，而夏天就要过去。 前几天的 ASL 舞台上，平野绫、茅原实里、后藤邑子三人毫无征兆地重新聚首，演唱了《凉宫春日的忧郁》的 ED《ハレ晴レユカイ（晴天好心情）》。06 年的最强动画，我最爱的动画，11 年后再看到这些人，恍如隔世。 过去是体育场旁的石板路，现在是教学楼到二食堂的小道，低头时摇曳的叶影把光束割出形状，抬头看到的是一成不变的蓝天白云。闻着空气里隐约弥漫着躁动的气息，你会产生错觉，真的以为八月是漫无止境的，度过的每一天会被慷慨归还。 只是在那个古老的不再回来的夏日，所有的结局都已写好，所有的泪水也都已启程。 “夏天就要过去”这句话念来，总有淡淡的感伤。也许正因如此，我才喜欢上夏天。 总结与展望书籍阅读好了，矫情完毕。暑假还是老毛病，后期学习效率不高。目前成果和暑假计划写的还是有些差距。 《深入浅出 Node.js》读了几章，感觉确实有些深，很多章节涉及到操作系统的知识，而且没有大量实践经验可能很难领会其精髓。所以将前四章（主要是异步 I/O 和异步编程）总结成一个笔记，然后根据需要看一下第八章-构建 Web 应用后，就先暂停这本书的阅读。 之后看《你不知道的 JavaScript（中卷）》。这本因为前两章讲繁琐的强制转换的知识，看的我晕头转向（JS 里的各种显隐式转换至少从表面上看毫无规律，为人诟病），所以当时停下来了。现在还是要啃完，之后还有下卷。这一系列书还是将 JS 的细节讲的比较全面的。 看完以上之后可以考虑啃《JavaScript 设计模式与开发实践》。不过可能下学期时间不太够，量力而行。还要啃一下《计算机网络－自顶向下方法》的前几章，虽然是课本，也做笔记和脑图。 项目练习 做了一个简单的在线个人简历，只用到了 vue 和 axios； 上手了 electron，将上述的个人简历包装成桌面程序扔到了 Github 上：bighuang624/electron-demo 。十分粗糙，而且在 mac 上的程序大小达到 122 MB。如果有时间和兴趣可以深入研究，最好是再拿一个前后端项目来做小白鼠； 今天想用 Node.js 重写之前的基于 Java 的 BiliBili 视频爬虫。不过折腾半天，感觉 B 站有了更严的反爬机制，还没有研究出怎么爬（估计之前的那个爬虫现在也不能用了）… 跟着教程摸了摸 express 和 koa。准备写一个有后台的项目，成功了就买一个服务器折腾折腾挂上去。 可以看到项目练习这一块也不算特别满意。要求自己在夏令营之前有两到三个还（neng）不（hu）错（ren）的项目。 保研要开始准备保研了。 这学期要准备一下六级，争取考到 600 分以上，才不至于掉底子； 找一个实验室干点活，找不到靠谱的就算了； 想办法看科研和竞赛能不能有些东西； 保持绩点。这学期一定不能翘课，全部争取满分。而且要稍微多选一点课，尽量不留选修课。 慢慢读《算法》，一天 5 面吧。天杨说笔试蛮关键的，什么数据结构与算法、操作系统、机组等知识大三下学期都要重新捡起来。 虽然没有企望过，但也许我可以走的稍微远一点。那就开始努力吧，因为夏天就要过去。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再探前端自动化－持续集成]]></title>
      <url>%2Fstart-CI%2F</url>
      <content type="text"><![CDATA[本篇博文承接前端工程自动化入门系列的第一篇：《初探前端自动化测试–以 Vue 为例》。 传统开发模式中，项目经理等待所有模块都开发完成后再进行集成，出现 bug 则记录并分配责任人进行修改，之后再进行集成，直到通过测试为止持续循环。这个过程可能会出现如下问题： bug 总在最后才被发现（尤其是模块之间的依赖导致的 bug），并且越到项目后期，随着项目规模的膨胀，bug 变得愈发难以修复； 各个环节无效的等待时间较长，加上程序需要经常变更，导致软件交付时机无法保障； 用户无法随时看到项目演示原型，满意度低。 为了解决这些问题，“持续集成”（Continuous Integration）的概念被提出。 相关概念持续集成（CI）是指将所有开发者工作副本频繁地（每天多次）合并到主干，始终保持可发布状态的做法。而持续集成服务器就是能够采用自动化的手段，实现项目持续集成的工具。 持续集成的具体工作流程： 本地开发（developing） 静态代码检查（linting） 单元测试（testing）：代码仓库对 commit 操作配置钩子（hook），只要提交代码或者合并进入主干，就会跑自动化测试。这一轮可以先只跑单元测试。 合并进入主干（merging） 自动构建（building）：将源码经过安装依赖、配置各种资源（CSS、JS、images），转换为可以运行的实际代码。之后会跑全面的测试。 自动发布（publishing）：将可以直接部署的版本打包，发到生产服务器以启动应用。 持续集成之后还有持续交付和持续部署，分别强调代码在任何时候都是可交付和可部署的。 持续集成的优点 自动化部署工作解放了重复性劳动，并减少手工集成的错误； 防止分支大幅偏离主干，而导致以后的集成难度变大，甚至难以集成； 持续集成缩短了开发、集成、测试、部署等各个环节的时间，从而减少等待时间，同时可以更快地发现、定位、修复问题并交付成果，使得产品可以快速迭代； 集成服务器一般都提供 Code review、代码质量检测等功能，帮助开发人员提高产品质量。 持续集成服务平台 - Travis很多 PaaS 平台都提供了持续集成服务。Travis CI 是其中最著名的一个，对于开源项目可以免费使用。 每次跑测试时，Travis 提供的都是一个空白的环境。这个环境只有 Linux 基本的build-essential和wget、git那些依赖。连 Node.js 的运行时都是现跑现安装的。因为 Travis 默认带有的依赖都是每个用户的机器上都会有的，所以一旦应用能在 Travis 上跑通，别的用户就都能安装上。 Travis 的使用方法如下： 首先，在官网 https://travis-ci.org/ 注册后选择需要开启集成测试的仓库。 然后，需要在项目的根目录放一份配置文件.travis.yml来告诉 Travis 需要用什么版本的 Node 跑，以及跑测试的命令等信息。 12345678// 一份简单的 .travis.ymllanguage: node_jsnode_js: - '4.2.5' - '7.5.0'script: npm run test 如果有用到数据库，则.travis.yml还需要添加一些内容。详细内容参考 Setting up Databases - Travis CI。 之后将这份配置文件 push 上 github，Travis 就会被自动触发。下图是正在进行集成测试的 我的简历项目： P.S. e2e 测试需要装 chrome 浏览器这个坑又出现了…简直阴魂不散。是不是要用 PhantomJS 才行啊… 我们先只跑单元测试好了。把.travis.yml更改一下：script: npm run unit，再 push 到 github 上。过一会就看到测试通过了。可以把 BlingBling 的 build 徽章加进项目的 README.md 中，来显示项目的构建状态了（徽章添加方案可见参考资料）： 参考资料写作资料持续集成是什么？ - 阮一峰的网络日志 为什么我们迫切需要持续集成？ 《持续集成平台：travis》 扩展阅读前端开源项目持续集成三剑客 | EFE Tech：添加徽章步骤，可以说是非常具体了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 Vue 撸一份线上简历有哪些坑]]></title>
      <url>%2Fmake-a-resume%2F</url>
      <content type="text"><![CDATA[昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。 项目地址：bighuang624/resume 在线预览地址：http://kyonhuang.top/resume/ 目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。 在 Vue 中使用 sass这个步骤之前已经总结过，现在再在博客上记录一次，方便之后查找。 在 Webpack 中，所有的预处理器需要匹配相应的 loader。因此要使用 sass 或 scss，首先下载依赖： 1npm install sass-loader node-sass --save-dev 然后在单文件组件中的&lt;style&gt;标签中加上lang=&quot;sass&quot;。vue-loader会根据lang属性推断出要使用的 loaders，并将内容交给相应的 loaders 处理： 123&lt;style lang=&quot;sass&quot;&gt; /* write sass here */&lt;/style&gt; 与名称相反，sass-loader 默认解析 scss 语法，因此如果想使用 sass 语法，还需要在 build/vue-loader.conf.js 配置 vue-loader 的选项： 这样的修改不会影响 scss 的使用，记得修改&lt;style&gt;标签中为lang=&quot;scss&quot;即可。 项目资源无法加载直接npm run build得到的项目，默认引用资源文件的路径为/static/js/app.js。所以程序若不在根目录下，就会出现资源文件引用错误的情况。 最简单的解决方案就是改动 webpack 的配置文件。将/config文件夹中的 index.js 文件中的assetsPublicPath: &#39;/&#39;改为assetsPublicPath: &#39;./&#39;即可，截图如下： 如果你还使用了 vue-router，你需要在 router 的配置中加上一行base: &#39;/[项目所在文件夹的名字]/&#39;，如下所示： 注意：如果启用了 vue-router 的 history 模式，你需要跟着 vue-router 官方文档的后端配置例子 对服务器进行一定的配置。 这是因为在 history 模式下，router 只是通过 JS 操作 window.history 来改变浏览器地址栏里的路径，并没有发起 http 请求。但是直接在地址栏中输入形如http://www.example.com/example/item/1这样的地址时，就一定先要对服务器发起 http 请求。此目标在服务器上不存在，于是会返回 404。修改服务器的配置，以将所有的请求全部转发到index.html上。 当然，这意味着单纯使用 Github Pages 的在线预览功能没办法进行这样的配置。你也可以关注知乎上的这个问题 怎样为Github pages Hack使用了vue-router history模式的vue应用？ - 知乎 来看别人的解决方法。 iconfont 无法加载字体图标无法正确加载。参考 https://github.com/vuejs-templates/webpack/issues/166 ，得到的解决方法是修改 build/utils.js 文件，增加一行publicPath: &#39;../../&#39;，如截图所示： 保存后，npm run build打包得到的项目中 iconfont 就可以正常显示了。 实现 Github Pages 在线预览参考 Configuring a publishing source for GitHub Pages - User Documentation，实现 Github Pages 在线预览功能有好几种方法，可以设置从master分支、gh-pages分支或者master分支下的/docs文件夹中读取。我就选择了最简单的一种方法，把npm run build打包下来的/dist文件夹改名为/docs。 之后，在 Github 项目主页的 Settings 下的 Github pages 下进行设置 Source 为master branch /docs folder即可。 如果你之前使用过 Github Pages 并绑定了一个域名，那么这个项目的预览地址会像http://kyonhuang.top/resume/这样在这个域名下，看起来很爽。 参考资料预处理器 · vue-loader Vue项目打包上传到github预览 vuejs怎么在服务器部署？ - 知乎 结语撸这份简历，是一个总结，也是一个激励。 真正撸完简历，才发现自己在技术层面上的项目经历少的可怜，而技术也不敢说有什么掌握。以后看到这份简历，会让我非常想写一些拿得出手的开源项目，然后对项目经历进行修改。 读完《你不知道的JavaScript（中卷）》，就给 JS 的技能条涨 5 个百分点；用 Node 开发一个支持登录注册的后台，就给 Node 的技能条涨 5 个百分点；或者再点亮一个新的技能。 随着我的不断学习，希望这份简历越来越吸引人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探前端自动化测试--以 Vue 为例]]></title>
      <url>%2Fstart-front-end-test%2F</url>
      <content type="text"><![CDATA[随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高；但对于稳定、多次复用以及需要长期维护的项目，自动化测试就尤为重要。 现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。 前端的测试类型分为单元测试（unit testing）、集成测试（integration testing）和端到端测试（e2e testing）。 单元测试将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作； 集成测试是针对产品的某个功能的测试，又称功能测试； e2e 测试则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。 开发模式先绕点路，了解一下 TDD、BDD等以测试为导向的开发模式，有助于我们更深入地理解自动化测试。 TDDTDD（Test Driven Development），即测试驱动开发。其先针对每个功能点抽象出接口代码，然后编写单元测试用例代码。之后实现接口，运行单元测试代码进行测试，循环往复直至所有单元测试通过。 TDD 要求测试先于编写功能代码。测试用例不仅是对于代码的验证，更成为对代码的规范与约束，确保在开发以及未来进行修改时能够极大程度地保证该模块行为仍然是正确的。 BDDBDD（Behavior Driven Development），即行为驱动开发。BDD 和 TDD 一样，都要求先写测试，再写代码。可以认为 BDD 是 TDD 的一个子集或分支，是测试驱动开发的扩展。 TDD 基于开发者角度，重点测试函数的输入输出；而 BDD 更侧重于使用者角度，重点测试对用户行为的反应。 BDD 测试中，客户与开发者共同考虑系统该如何运行，然后用通用的语言抽象描述系统的行为，使得双方从技术层面和业务需求都能理解，避免沟通障碍。 测试工具测试管理工具用来组织和运行整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行被测试代码进行测试。 可选择的有 Karma、Selenium、Mocha（Mocha既是测试工具，也是测试框架）。 测试框架测试框架是单元测试的核心，提供了单元测试所需的各种API，并对测试用例分组。测试框架会抓取到代码抛出的 AssertionError 并提供附加信息。 选择较多，有名的有 Mocha、Jasmine等。不过 Mocha 既支持 TDD 也支持 BDD 的测试语法，Jasmine 只支持 BDD。 断言库断言库提供了很多语义化的方法来对值做各种判断。当然也可以不用断言库，Node.js 中也可以直接使用原生 assert 库。 可供选择的断言库也很多，包括 should.js、expect.js、chai.js等。 测试浏览器前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持调用和运行本地浏览器来进行测试，但如果测试仅仅是针对函数和模块的单元测试，则完全可以使用一款无界面的 webkit 内核浏览器：PhantomJS。 测试覆盖率统计工具测试覆盖率工具为代码在语法级分支上打点，之后运行代码，并在运行结束后根据收集到的信息统计出当前测试用例对源码的覆盖情况。 一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。 vue-cli 的配置vue-cli 的 webpack 模版内置了开箱即用的 Karma + Jasmine 单元测试配置，以及 Nightwatch + Selenium E2E 测试配置，npm run test即可测试自带的一个初始测试用例。 有坑请注意： 建议使用 cnpm 对 vue-cli 项目进行依赖安装，否则可能有些东西装不上。 自带的 e2e 测试要求装有 chrome 浏览器，否则报错Error retrieving a new session from the selenium server。我被这个坑折腾了半天… 开始编写测试代码我的简历项目 是我花了一天时间写的一个 vue-cli 初始化、只用了 Vue 的一个小项目，我们拿这个简单的小项目来入门测试代码的编写。我们直接利用 vue-cli 的初始配置，即用 Karma + Jasmine 进行单元测试，Nightwatch + Selenium 进行 E2E 测试。 你可以将我的项目 clone 下来进行测试代码的编写练习，不过项目里的测试代码可能已经因为更新而何下面的示例不一样了。 单元测试/test/unit/index.js中可以看到，单元测试的测试代码是/specs文件夹下以.spec.js结尾的文件。将自带的Hello.spec.js改写为LeftNav.spec.js： 1234567891011121314151617import Vue from 'vue';import LeftNav from '@/components/LeftNav';describe('LeftNav.vue', () =&gt; &#123; const Constructor = Vue.extend(LeftNav); const vm = new Constructor().$mount(); it('should render correct name', () =&gt; &#123; expect(vm.$el.querySelector('.leftNav h1').textContent) .to.equal('Kyon Huang'); &#125;); it('should render correct title', () =&gt; &#123; expect(vm.$el.querySelector('.leftNav h3').textContent) .to.equal('Web 开发工程师'); &#125;);&#125;); E2E 测试同理，将/test/e2e/specs/test.js改写为 12345678910111213141516171819// For authoring Nightwatch tests, see// http://nightwatchjs.org/guide#usagemodule.exports = &#123; 'default e2e tests': function test(browser) &#123; // automatically uses dev Server port from /config.index.js // default: http://localhost:8080 // see nightwatch.conf.js const devServer = browser.globals.devServerURL; browser .url(devServer) .waitForElementVisible('#app', 5000) .assert.elementPresent('.leftNav') .assert.containsText('h1', 'Kyon Huang') .assert.elementCount('img', 1) .end(); &#125;,&#125;; 测试结果： 可以看到，我们的单元测试和 e2e 测试都通过了。不过单元测试的覆盖率有点低，只有 25%。如何写好测试代码，需要进一步的学习。 结语前端工程自动化入门系列下一篇：《再探前端自动化－持续集成》 参考资料写作资料开发人员看测试之TDD和BDD - JackieZheng - 博客园 前端自动化单元测试初探 - 简书 扩展阅读虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发 PhantomJS 基础及示例 - 腾云阁 - 腾讯云]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 的异步操作 - Generator & async]]></title>
      <url>%2FGenerator-and-async%2F</url>
      <content type="text"><![CDATA[继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：回调函数、事件监听器模式（发布/订阅模式）、流程控制库和 Promise/Deferred 模式。为了使异步操作更加清晰、简洁、方便，ES6 引入了 Generator 函数，而 ES2017 标准引入了 async 函数作为 Generator 函数的语法糖。 由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。 本博文在 Promise 对象 | 大黄菌的个人博客 之后食用最佳。 注：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。 Generator 函数 Generator 与协程一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程（coroutine）。 Generator 函数是 ES6 对协程的不完全实现，因为只有 Generator 函数的调用者才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 Generator 函数的异步应用Generator 是一个异步操作的容器。想让 Generator 自动执行，即需要当异步操作有结果时能够自动交回执行权。两种方法： 回调函数。将异步操作包装成 Thunk 函数，在回调函数里交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 其中，JavaScript 中的 Thunk 函数指将多参数函数替换成的一个只接受回调函数作为参数的单参数函数。任何参数有回调函数的函数，都能写成 Thunk 函数的形式。 12345678// ES6 版本的简单 Thunk 函数转换器const Thunk = function(fn)&#123; return function(...args)&#123; return function(callback)&#123; return fn.call(this, ...args, callback); &#125; &#125;&#125; 前者的实现可用 Thunkify 模块，后者可用 co 模块。了解更多请看 Generator 函数的异步应用 - ECMAScript 6入门。暂时用不到的工具就不进一步消耗脑细胞了。 实例通过 Generator 函数部署 Ajax 操作1234567891011121314function main () &#123; var result = yield request('http://some.url'); var resp = JSON.parse(result); console.log(resp.value);&#125;function request (url) &#123; makeAjaxCall(url, (response) =&gt; &#123; it.next(response); &#125;);&#125;var it = main();it.next(); 使用 yield* 语句遍历完全二叉树1234567891011121314151617181920212223242526272829303132function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 中序（inorder）遍历函数function* inorder(t) &#123; if(t) &#123; yield* inoreder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 生成二叉树function make(array) &#123; // 判断是否为叶节点 if(array.length === 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for(let node of inoreder(tree))&#123; result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 利用 Generator 函数部署 Iterator 接口12345678910111213141516171819function* iterEntries (obj) &#123; let keys = Object.keys(obj); for(let i = 0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7&#125;;for(let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 async 函数 感觉前面的知识短时间内都消化不了，就没有看处于提案的异步遍历器。 实例异步获取股票报价123456789async function getStockPriceByName (name) &#123; var symbol = await getStockStmbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then((result) =&gt; &#123; console.log(result);&#125;); 并发发出远程请求123456789101112async function logInorder(urls) &#123; // 并发读取远程 URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for(const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 结语经过学习，我感觉 async 函数真的为一组资源依次异步加载等实际开发场景提供了一种非常简便的处理方案。不过想要运用好 async 函数，深究其实现原理，就必须也要对 Generator 函数有清晰的认知。 异步编程不管是在浏览器还是在服务器端的开发都很重要，知识量也很大，一时半会大概消化不过来。在总结完这些知识后，还需要时常复习，并在实际开发过程中探索更好的实践。 补充阅读JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志：帮助加深对同步、异步执行机制的认识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJS 入门笔记]]></title>
      <url>%2Fstart-to-learn-NodeJS%2F</url>
      <content type="text"><![CDATA[上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 七天学会NodeJS 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。 在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。 虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。 更新记录： 17.08.30 根据《深入浅出 Node.js》的笔记，对”NodeJS 应用领域及特点”部分进行文字补充。 17.09.02 根据《深入浅出 Node.js》的笔记，对”模块”部分进行文字补充。 NodeJS 应用领域及特点 设计高性能 Web 服务器的要点：事件驱动、非阻塞 I/O。 Node 从 Ryan Dahl 一开始设想的 Web 服务器，发展成一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施的网络应用平台。 Node 与浏览器的异同Chrome 浏览器除了 V8 作为 JavaScript 引擎外，还有一个 WebKit 布局引擎。 Node 的结构和 Chrome 十分相似，都是基于事件驱动的异步架构。浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。 Node 的特点异步 I/O事件与回调函数事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，各事件之间各自独立，如何协作是一个问题。 单线程保持了 JS 在浏览器中单线程的特点。在 Node 中，JS 与其余线程无法共享状态。 好处： 不用在意状态同步问题； 没有死锁； 没有线程上下文交换带来的性能开销； 弱点： 无法利用多核 CPU； 错误会引起整个应用退出，应用的健壮性值得考验； 大量计算占用 COU 导致无法继续调用异步 I/O。 浏览器端，Web Workers 能够创建工作线程进行计算。为了不阻塞主线程，工作线程采用消息传递的方式来传递运行结果，使得工作线程不能访问主线程的 UI。 Node 采用同样的思路解决单线程中大计算量的问题：child_process。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息传递结果。 子进程的出现，意味着 Node 可以从容应对单线程在健壮性和无法利用多核 CPU 方面的问题。 跨平台操作系统与 Node 上层模块之间构建了一层平台层架构，即libuv。 Node 的应用场景I/O 密集型Node 面向网络且擅长并行 I/O，能够有效组织更多的硬件资源。 I/O 密集的优势在于Node 利用事件循环的处理能力（而非为每一个服务启动一个线程），资源占用极少。 不擅长 CPU 密集型业务？由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将导致 CPU 时间片不能释放，使得后续 I/O 无法发起。适当调整和分解大型运算任务能使运算适时释放，不阻塞 I/O 调用的发起。 与遗留系统和平共处可以将稳定的旧有系统作为后端接口与中间件，而让 Node 将该数据源作为数据接口，发挥异步并行的优势。 分布式应用模块 使用模块的好处 大大提高代码的可维护性； 可以随时引用； 避免函数名和变量名冲突； CommonJS 规范CommonJS 主要是在 Node 服务器端的规范。意义在于将类聚的方法与变量限定在私有的作用域中，使得用户完全不必考虑变量污染。 CommonJS 对模块的定义主要分为模块引用、模块定义、模块标识三个部分： 模块引用一个模块要引用其他模块暴露的变量，用var foo = require(&#39;module_name&#39;)就拿到了引用模块的变量。 模块定义上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一的出口。 在模块中，还存在一个 module 对象，代表模块自身，而 exports 是 module 的属性。 一个模块要对外暴露变量（函数也是变量），可以用module.exports = variable;。 模块标识即传递给require()方法的参数。 模块实现在 Node 中引入模块，需要经历如下三个步骤： 路径分析 文件定位 编译执行 在 Node 中，模块分为 Node 提供的核心模块和用户编写的文件模块。 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就直接加载进内存中。因此可以省略文件定位和编译执行两个步骤，且在路径分析中优先判断，加载速度最快。 文件模块在运动时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。 优先从缓存加载模块加载会有缓存，且其根据绝对路径识别。因此同样的模块名放在不同的路径之中多次 require 不会重新加载。 Node 对引入过的模块都会以编译和执行后的对象的形式进行缓存。核心模块和文件模块都采用缓存优先进行二次加载，核心模块的缓存检查先于文件模块。 路径分析和文件定位模块路径是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。 其生成规则为从当前文件目录下的 node_modules 目录开始，沿路径向上逐级递归，直到根目录下的 node_modules 目录。 Node 在当前目录下查找 package.json，通过JSON.parse()解析出包描述对象，从中取出main属性制定的文件名进行定位。 模块编译 .js 文件。通过 fs 模块同步读取文件后编译执行。 .node 文件。这是用 C/C++ 编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。 .json 文件。通过 fs 模块同步读取文件后，用JSON.parse()解析返回结果。 其余扩展名。它们都被当作 .js 文件载入。 每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能。 如果要达成 require 引入一个类的效果，请赋值给 module.exports 对象。 前后端共用模块浏览器端的 JavaScript 需要经历从同一个服务器端分发到多个客户端执行，瓶颈在于带宽；而服务器端 JavaScript 则是相同的代码需要多次执行，瓶颈在于 CPU 和内存等资源。 CommonJS 是同步加载的，在服务器端模块文件一般存放在本地，再加上有缓存，加载速度很快。而在浏览器端就可能导致“假死”，因此浏览器端采用另一种异步加载方式 - AMD（Asynchronous Module Definition，异步模块定义）规范。 1234567define(function()&#123; var exports = &#123;&#125; exports.sayHello = function() &#123; alert('Hello from module: ' + module.id) &#125; return exports&#125;) 可以看到 AMD 的模块定义与 Node 模块相似，不同之处在于 AMD 模块需要用define来明确定义一个模块，而在 Node 实现中是隐式包装的；以及内容需要通过返回的方式实现导出。 想要进一步了解，可参考 Javascript模块化编程（二）：AMD规范 - 阮一峰的网络日志。 深入了解模块原理Node.js 的“模块”功能利用了 JavaScript 函数式编程的特性，通过闭包实现。 代码的组织和部署 包描述文件中的部分属性 maintainers。包维护者列表，npm 通过该属性进行权限认证。 bin。将包作为命令行工具使用，需配置好 bin 字段，通过npm install package_name -g命令将脚本添加到执行路径中。之后可以在命令行中直接执行。例如：&quot;bin&quot;: { &quot;express&quot;: &quot;./bin/express&quot; } 全局模式安装-g将一个包安装为全局可用的可执行命令。通过全局模式安装的所有模块包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来： 1path.resolve(process.execPath, '..', '..', 'lib', 'node_modules'); 基本模块 Node.js 内置的常用模块是为了实现基本的服务器功能，底层代码是用 C/C++ 在 Node.js 运行环境中实现。 globalNode.js 环境中唯一的全局变量。 process代表当前 Node.js 进程。 判断 JavaScript 执行环境12345if(typeof(window) === 'undefined')&#123; console.log('node.js');&#125; else &#123; console.log('browser');&#125; 文件操作 不同系统下路径的标准化标准化之后的路径里的斜杠在 Windows 系统下是\，而在 Linux 系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &#39;/&#39;)再替换一下标准路径。 遍历目录12345678910111213141516171819202122232425262728293031323334353637// 同步遍历获取某一文件夹下的所有文件，用 callback 处理function travel(dir, callback)&#123; fs.readdirSync(dir).forEach((file) =&gt; &#123; var pathname = path.join(dir, file); if(fs.statSync(pathname).isDirectory())&#123; travel(pathname, callback)； &#125; else &#123; callback(pathname); &#125; &#125;)&#125;// 异步遍历function travel(dir, callback, finish)&#123; fs.readdir(dir, (err, files) =&gt; &#123; (function next(i)&#123; if(i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, (err, stats) =&gt; &#123; if(stats.isDirectory())&#123; travel(pathname, callback, () =&gt; &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, () =&gt; &#123; next(i + 1); &#125;) &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;)(0); &#125;)&#125; 网络操作 监听端口的权限问题在 Linux 系统下，监听 1024 以下端口需要 root 权限。因此，如果想监听 80 或 443 端口的话，需要使用 sudo 命令启动程序。 URL 的完整组成123456789 href ----------------------------------------------------------------- host path --------------- ---------------------------- http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash ----- --------- -------- ---- -------- ------------- -----protocol auth hostname port pathname search hash ------------ query 网络操作常见问题 问： 为什么通过headers对象访问到的 HTTP 请求头或响应头字段不是驼峰的？ 答： 从规范上讲，HTTP 请求头和响应头字段都应该是驼峰的。但现实中不是每个 HTTP 服务端或客户端程序都严格遵循规范，所以 NodeJS 在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如headers[&#39;content-length&#39;]。 问： 为什么http模块创建的 HTTP 服务器返回的响应是chunked传输方式的？ 答： 因为默认情况下，使用.writeHead方法写入响应头后，允许使用.write方法写入任意长度的响应体数据，并使用.end方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了Transfer-Encoding: chunked字段，并采用chunked传输方式。但是当响应体数据长度确定时，可使用.writeHead方法在响应头里加上Content-Length字段，这样做之后 NodeJS 就不会自动添加Transfer-Encoding字段和使用chunked传输方式。 问： 为什么使用http模块发起 HTTP 客户端请求时，有时候会发生socket hang up错误？ 答： 发起客户端 HTTP 请求前需要先创建一个客户端。http模块提供了一个全局客户端http.globalAgent，可以让我们使用.request或.get方法时不用手动创建客户端。但是全局客户端默认只允许5个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生socket hang up错误。解决方法也很简单，通过http.globalAgent.maxSockets属性把这个数字改大些即可。另外，https模块遇到这个问题时也一样通过https.globalAgent.maxSockets属性来处理。 进程操作 降权123456789// 降权http.createServer(callback).listen(80, () =&gt; &#123; var env = process.env, uid = parseInt(env['SUDO_UID'] || process.getuid(), 10); gid = parseInt(env['SUDO_GID'] || process.getgid(), 10); process.setgid(gid); process.setuid(uid);&#125;) 注意点： 如果是通过sudo获取 root 权限的，运行程序的用户的 UID 和 GID 保存在环境变量SUDO_UID和SUDO_GID里边。如果是通过chmod +s方式获取 root 权限的，运行程序的用户的 UID 和 GID 可直接通过process.getuid和process.getgid方法获取。 process.setuid和process.setgid方法只接受number类型的参数。 降权时必须先降 GID 再降 UID，否则顺序反过来的话就没权限更改程序的 GID 了。 进程间通讯如果父子进程都是 NodeJS 进程，就可以通过 IPC（进程间通讯）双向传递数据。 123456789101112131415161718/* parent.js */// 在 options.stdio 字段中通过 ipc 开启一条 IPC 通道var child = child_process.spawn('node', ['child.js'], &#123; stdio: [0, 1, 2, 'ipc']&#125;);child.on('message', (msg) =&gt; &#123; console.log(msg);&#125;)// 给子进程发送消息child.send(&#123; hello: 'hello' &#125;);/* child.js */process.on('message', (msg) =&gt; &#123; msg.hello = msg.hello.toUpperCase(); process.send(msg);&#125;) 数据在传递过程中，会先在发送端使用JSON.stringify方法序列化，再在接收端使用JSON.parse方法反序列化。 守护进程12345678910111213// 守护子进程/* daemon.js */function spawn(mainModule)&#123; var worker = child_process.spawn('node', [mainModule]); worker.on('exit', (code) =&gt; &#123; if(code !== 0)&#123; spawn(mainModule); &#125; &#125;);&#125;spawn('worker.js'); 异步编程 domain 捕获异常1234567891011121314151617181920212223242526272829function async(request, callback)&#123; // Do something asyncA(request, (data) =&gt; &#123; // Do something asyncB(request, (data) =&gt; &#123; // Do something asyncC(request, (data) =&gt; &#123; // Do something callback(data); &#125;) &#125;) &#125;)&#125;http.createServer((request, response) =&gt; &#123; var d = domain.create(); d.on('error', () =&gt; &#123; response.writeHead(500); response.end(); &#125;); d.run(() =&gt; &#123; async(request, (data) =&gt; &#123; response.writeHead(200); response.end(data); &#125;) &#125;)&#125;) 陷阱使用uncaughtException或domain捕获异常，代码执行路径里涉及到了 C/C++ 部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用try语句捕获异常时一般捕获到的都是 JS 本身的异常，不用担心上述问题。 结语NodeJS 的学习其实主要分为三块： JavaScript 语言本身。要学会借助 ECMAScript 规范 加深自己的理解。 NodeJS 的 API。要熟悉官方 API 文档，主要是熟悉 NodeJS 提供的功能以及知道该查询文档的哪块地方。不推荐死记硬背，因为新版本会更改和弃用部分 API。 生态圈中的各种三方库。要学习检索、过滤、去其糟粕取其精华，利用但不迷信。 而在 NodeJS 开发时，首先要有一个全局的设计，再再实现的过程中对之间忽略掉的细节进行设计上的改进，为二次迭代做准备。 参考资料除开文章开头提到的资料，结语部分参考了 当我们学习 Node.js 时，我们在学习什么？。 下一步学习《Node.js 包教不包会》 by alsotang 《深入浅出Node.js》 自己撸个爬虫]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《你不知道的 JavaScript（上卷）》脑图]]></title>
      <url>%2FYou-Dont-Know-JS-notes-1%2F</url>
      <content type="text"><![CDATA[这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。 作用域和闭包 大图：作用域和闭包.png this 和对象原型 大图：this和对象原型.png 原型链补一张来自 JavaScript深入之从原型到原型链 的图，来直观地表现原型链。 图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探人工智能]]></title>
      <url>%2Fstart-to-know-AI%2F</url>
      <content type="text"><![CDATA[一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。 为什么为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？ 发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。 随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。 确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。 何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。 这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。 不要拒绝未来的任何可能性。 相关概念脑图一直感觉纯文字的笔记比较难以记忆，导致自己的学习吸收率不高。看到别人的读书笔记是总结了一张脑图，条理比较清晰。这里也试着用 Xmind 总结一张相关概念的脑图（P.S.使用感觉百度脑图比 Xmind 条理清晰+好用）。 数据学习算法的输入数据，叫“训练数据”。训练数据的每一行称为一个“训练样本”（Training Sample），通常简称“样本”（Sample）。 样本的各种属性称为“特征”（Feature）。而希望学得的模型可以用来预判的信息称为样本的“标注”（Label）。 模型机器学到的模型是一个映射。 映射的输入每个样本 xi 的特征组成一个“特征向量” (Feature Vector)。所有特征向量的集合就是总的输入集合，称为“样本空间” (Sample Space)。 映射的输出第 i 个样本的标注记作 yi。同理有“标注空间”(Label Space)。 映射的表示机器学习模型就是输入空间 X 到输出空间 Y 的一个映射，将映射用符号 g 表示，则模型记作 g: X -&gt; Y。 机器学习学习算法 (Learning Algorithm) 根据训练数据，从假设集合 (Hypothesis Set) 中选出最优的那个映射 g 作为最终学得的模型，使得 g 越接近上帝真相 f 越好。 分类不是所有的机器学习问题都需要标注。根据训练数据是否有标注，机器学习问题大致划分为监督学习（Supervised Learning）和无监督学习（Unsupervised Learning）两大类（还有半监督学习、增强学习等）。 监督学习：每个输入样本都有标注。大致分成两类： 分类（Classification）问题：标注是离散值，比如用户”点击“和”不点击“。如果标注只有两个值，则称为二分类，如果标注有多个值，则称为多分类。 回归（Regression）问题：标注是连续值，比如如果问题是预测北京市房屋的价格，价格作为标注就是一个连续值，属于回归问题。 无监督学习：训练样本没有标注，无监督学习解决的典型问题是聚类（clustering）问题。比如对一个网站的用户进行聚类，看看这个网站用户的大致构成，分析下每类用户群的特点是什么。 以上总结为脑图（感觉百度脑图看起来条理稍微清晰一些）： 神经网络把听上去最高端的“神经网络”放到最后介绍。 神经网络一组大致模仿人类大脑构造设计的算法，用于识别模式。神经网络通过机器感知系统解释传感器数据，能够对原始输入进行标记或聚类等操作。 神经网络所能识别的模式是数值形式，因此图像、声音、文本、时间序列等一切现实世界的数据必须转换为数值。 感知器、权重与阈值大家都在高中的生物课上学过，人类大脑思考的基础是神经元（神经细胞）。如果能够人工制造神经元，就能组成人工神经网络来模拟思考。 上世纪六十年代，科学家们提出了最早的“人造神经元”，并将其称为“感知器”（perceptron）。感知器接受一些因素，这些因素根据不同的重要性（决定性因素与次要因素）获得不同的权重（weight）。因素的条件成立为 1，不成立为 0，乘以权重的总和大于指定的阈值（threshold），感知器便输出 11，否则输出 0。 决策模型单个的感知器构成一个简单的决策模型。而实际的决策模型是由多个感知器组成的多层网络。 每一个节点层在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂，因为每一层会整合并重组前一层的特征。 而在“递归神经网络”中，上下层的感知器的输入与输出还可能发生循环传递。 神经网络运作过程一个神经网络的搭建，需要满足三个条件： 输入和输出 权重（w）和阈值（b） 多层感知器的结构 最困难的部分就是确定权重和阈值。我们通过试错法，即保证其他参数不变，对 w 或 b 进行微小变动，然后观察输出的变化。通过不断重复这个过程来得到最精确的那组 w 和 b。这个过程即被称为模型的训练。 因此，神经网络的运作过程如下： 确定输入和输出 找到一种或多种算法，可以从输入得到输出 找到一组已知答案的数据集，用来训练模型，估算 w 和 b 一旦新的数据产生，输入模型，就可以得到结果，同时对 w 和 b 进行校正 整个过程需要海量计算，所以需要使用专门为机器学习定制的 GPU。 输出的连续性为了保证模型的敏感，要将 0、1 输出改造为连续性函数。 12z = wx + bσ(z) = 1 / (1 + e^(-z)) 这样，当 z 趋向正无穷（表示感知器强烈匹配）时，σ(z) → 1；如果 z 趋向负无穷（表示感知器强烈不匹配），σ(z) → 0。 同时，Δσ 满足下面的公式： 即 Δσ 和 Δw 和 Δb 之间是线性关系，变化率是偏导数。这就有利于精确推算出 w 和 b 的值了。 基于 JavaScript 的机器学习尽管确实是第一选择，机器学习不一定要用 Python。为什么不试试神奇的 JavaScript 呢？ JavaScript 开发者们已经开源了不少基于 Node.js 的机器学习库： brain.js (神经网络) Synaptic (神经网络) Natural (自然语言处理) ConvNetJS (卷积神经网络) mljs (一系列具有多个函数方法的 AI 库) Neataptic (神经网络) Webdnn (深度学习) 你可以从 github 的这个项目：abhisheksoni27/machine-learning-with-js 中获得一些实例的源码，目前作者实现了线性规划和 KNN 算法。你也可以在参考资料的对应章节找到翻译版本进行阅读。 结语emmm，如果你看了之后的参考资料中的每一篇，你会发现这篇博文只是一个拙劣的归纳总结。这是因为我确实对相关领域没有什么了解。但我对此兴致勃勃，也已经关注了不少数据挖掘和机器学习的知乎专栏及收藏夹。希望自己将来会有相关方面有价值的产出。 参考资料相关概念部分简单理解：人工智能、数据挖掘、模式识别、机器学习、深度学习 - feichizhongwu888的博客 - CSDN博客 一篇文章讲清楚人工智能、机器学习和深度学习的区别 数据、模型部分写给大家看的机器学习书（第二篇） - 知乎专栏 神经网络部分神经网络入门 - 阮一峰的网络日志 写给大家看的机器学习书（第三篇） 基于 JavaScript 的机器学习JavaScript机器学习之线性回归 JavaScript机器学习之KNN算法 扩展学习神经网络浅讲：从神经元到深度学习 机器学习算法的基本知识（使用Python和R代码）：带有 Python 和 R 语言代码实例 Deep Learning 中文翻译 [机器学习]机器学习笔记整理全解 DT新纪元 - 知乎专栏]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[暑假计划进行中]]></title>
      <url>%2Fsummer-plan%2F</url>
      <content type="text"><![CDATA[出征前內心忐忑鋒利的匕首反握準備殺死對手前先讓我來殺死懶惰 — 艾福杰尼 / Killa4nia《酒精》 简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感兴趣的知识，并且认真做学习笔记和总结。 07.20 更新：暑假已经过去了半个月。对暑期计划进行一些变更使其更加合理。最重要的是提高效率。 08.06 更新：暑假快过了 2/3 了，对计划进行一些修正。 读书计划（脑图整理知识点）[Finished] 7月23日为 deadline，看完《你不知道的 JavaScript（上卷）》。 8月8日为deadline， 看完《你不知道的 JavaScript（中卷）》。 8月读《Node.js 深入浅出》。 争取暑假读完《JavaScript 设计模式与开发实践》。 整个暑假： 每天 12 点前睡觉，8 点前起床。 前端各类练习题。每天 2 - 3 道原生 js 实例题。学累了刷刷 牛客网。 每天 2 面六级单词。 想做的练习： 谈谈一些有趣的CSS题目 原生JavaScript学习-实例索引 百度前端技术学院［可缓］ 七月： 写花旗杯项目前端。 Vue 全家桶及相关技术实践。 八月： Node.js学习。首先是廖雪峰的入门教程，争取一天看完 [08.06：koa 有点难理解…先从 express 学习好了]。接下来选一本书看看（据说朴灵的《Node.js 深入浅出》不错…） 完成一个类似 带你用 Vue 全家桶和 Node.js 完成一个聚合应用 的 demo。 如果还有时间，试试 Electron 或者 Lavas 天下武功，唯勤不破！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise 对象]]></title>
      <url>%2Fpromise%2F</url>
      <content type="text"><![CDATA[Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。 特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Fulfilled（已完成，又称 Resolved）和Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变只有两种可能：从Pending变为Fulfilled和从Pending变为Rejected。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 缺点： 无法取消Promise，一旦新建就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误不会反映到外部。 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。 基本用法一个栗子🌰，用Promise对象实现 Ajax 操作： 1234567891011121314151617181920212223242526272829var getJSON = function(url)&#123; var promise = new Promise((resolve, reject) =&gt; &#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystagechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if(this.readyState !== 4)&#123; return; &#125; if(this.status === 200)&#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;); return promise;&#125;;getJSON("/post.json").then( json =&gt; console.log('Contents: ' + json), error =&gt; console.error('出错了', error)); resolve和reject函数由 JavaScript 引擎提供，不用自己部署。两者在改变 Promise对象的状态的同时，将异步操作的结果或报出的错误作为参数传递出去。 then方法可以接受两个回调函数作为参数（可以说是处理 result 和 err 的回调）。第一个在Promise对象状态变为Fulfilled时调用，第二个（可省）在Promise对象状态变为Rejected时调用，都接受Promise对象传出的值作为参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例（决定前一个Promise对象的状态），表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。 注意点1then方法会返回一个 Promise 实例： 1234var outputPromise = promise.then( (fulfilled) =&gt; &#123;...&#125;, (rejected) =&gt; &#123;...&#125;,) 这时，outputPromise变成了受function(fulfilled)或者 function(rejected)控制状态的 Promise 实例了： 若function(fulfilled)或者 function(rejected)返回一个值（字符串、数组、对象等），那么outputPromise的状态变为Resolved； 若function(fulfilled)或者 function(rejected)抛出异常（throw new Error(...)），那么outputPromise的状态变为Rejected； 若function(fulfilled)或者 function(rejected)返回一个 Promise 实例，那么outputPromise就成为这个新的 Promise 实例。 可以看 promise的传递 的例子（使用了 q）加深理解： 123456789101112131415161718192021222324252627282930313233var Q = require('q');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfilled时，调用function(fulfilled) * 当inputPromise状态由未完成变成rejected时，调用function(rejected) * 将then返回的promise赋给outputPromise * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由 * 未完成改变为fulfilled * @private */var outputPromise = getInputPromise().then(function(fulfilled)&#123; return 'fulfilled';&#125;,function(rejected)&#123; return 'rejected';&#125;);outputPromise.then(function(fulfilled)&#123; console.log('fulfilled: ' + fulfilled);&#125;,function(rejected)&#123; console.log('rejected: ' + rejected);&#125;);defer.reject(); // 输出 fulfilled: rejected// defer.resolve(); // 输出 fulfilled: fulfilled 2在创建新的 Promise 时，作为 Promise 参数传入的函数是会被立即执行的（而不是调用 then 时才执行），只是其中执行的代码可以是异步代码。 虽然 Promise 作为参数接收的函数是同步执行的，但是then方法的回调函数执行是异步的。 🌰： 12345678910var p = new Promise(function(resolve, reject)&#123; console.log("create a promise"); resolve("success");&#125;);console.log("after new Promise");p.then(function(value)&#123; console.log(value);&#125;); 控制台输出： 123"create a promise""after new Promise""success" 方法Promise.prototype.then()then方法返回一个新的Promise实例。链式写法调用then方法时，前一个回调函数将返回结果作为参数，传入第二个回调函数（前一个回调函数没有用return返回结果时，默认返回 undefined）。 Promise.prototype.catch()reject方法的作用，等同于抛出错误。如果Promise状态已经变成Fulfilled，在resolve语句后再抛出错误是无效的，因为状态不会再改变了。 一般来说，不要在then方法中定义Reject状态的回调函数，总是使用catch方法。因为catch可以捕获之前所有then方法执行中的错误，也更接近同步的try/catch写法。 catch方法返回的也是一个Promise对象。 Promise.all()Promise.all方法用于将多个Promise实例（否则调用Promise.resolve方法再处理），包装成一个新的Promise实例。接受一个具有Iterator接口，且返回的每个成员都是Promise实例的参数（一般为数组）。 1var p = Promise.all([p1, p2, p3]); 只有每个成员的状态都为Fulfilled，p 的状态才为Fulfilled，所有返回值组成一个参数传递给 p 的回调函数；否则只要有一个成员被rejected，p 的状态为Rejected，第一个被reject的实例的返回值被传递给 p 的回调函数。 如果作为参数的Promise实例自身定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 Promise.race()1var p = Promise.race([p1, p2, p3]); p 的状态随第一个改变状态的成员而做相同改变，该成员返回值传递给 p 的回调函数。其他与Promise.all方法一致。 Promise.resolve()将现有对象转为Promise对象。根据参数分为四种情况： Promise实例：不作任何修改，直接返回该实例； thenable对象（具有then方法的对象）：转为Promise对象，然后在立即调用其then方法的同时状态变为Resolved； 不符合以上情况的任何参数：返回状态为Fulfilled的Promise对象，参数传给回调函数； 不带有任何参数：返回状态为Fulfilled的Promise对象。 注意：当Promise.resolve()的参数是Promise实例时，resolve会“拆箱”获取这个 Promise 实例的状态和值，但这个过程是异步的。 Promise.reject()返回一个新的Promise实例，状态为Rejected。方法的参数会作为reject的理由，变成后续方法的参数。 reject不具备“拆箱”能力。 应用 加载图片：加载完成时Promise的状态发生变化。 Generator 函数与 Promise 的结合：使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 参考资料写作： Promise 对象 - ECMAScript 6入门 八段代码彻底掌握 Promise 进阶（之后阅读）： JavaScript Promise迷你书（中文版）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何给终端安上炫酷的皮神黄皮肤？]]></title>
      <url>%2Fpikachu-iterm%2F</url>
      <content type="text"><![CDATA[昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西： 给终端安上超几把炫酷的皮神黄皮肤！作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？ 一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！ 如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。 从零开始的项目安装打开 Pokemon-Terminal 项目的 github 主页，我发现安装前有两个要求： 3.5及以上版本的 python； 已安装 iTerm2。 巧了，这两个要求我都不符合！ iTerm2 我从来没有接触过，根本不知道是什么。而比较久远的时候，我在试图将 OS X 系统自带的 python 2.+ 升级为 3.+ 时，跟着网上不知道靠不靠谱的教程误操作，以致 2.+ 删掉了 3.+ 却没安好，依赖于 python 的以 Xcode 为首的一系列软件全部罢工（而且过了一周左右才查出来是这个原因），最后灰溜溜地又下了一遍 2.+，从此留下了对 python 的心理阴影（但是我们这篇教程还是很靠谱的）。 没关系，作为（准）程序员，要勇于折腾！我们一步一步的搞起。 iTerm2我是先下载的 iTerm2，官网在此，下载即可。 iTerm2 是 OS X 系统下很好用的一款命令行工具，至于具体怎么好用，敬请百度了解。因为我现在只是为了皮神黄皮肤。当然之后我也会进一步学习使用。 python 3.5+昨晚吃瘪后的我心有不甘，发了一条说说。然后幸得初中同学救驾： 这个允许用户方便地安装不同版本的 python 并可以快速切换的 anaconda 帮助我解决了问题。官网提供了图形化安装和命令行安装两种方式，根据自己的专业程度选择下载即可。 这个 anaconda 据说也是 python 开发的利器之一，不过我也不会 python。也许之后机缘巧合会深入学习（想了解可以参照这篇文章Anaconda使用总结）。说实话为了给终端换个皮肤，让我本不宽裕的存储空间又少了 1G 左右，有些心疼。但是折腾还是给了我很多乐趣，也许之后有用呢。 那么要求都满足了。按照项目 README 要求，在 iTerm 2 中输入以下三条语句： 1234# Pokemon Installationgit clone https://github.com/LazoCoder/Pokemon-Terminal $HOME/.Pokemon-Terminalecho PATH=&quot;$HOME/.Pokemon-Terminal:$&#123;PATH&#125;&quot; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 安装完毕，皮神我来了！ 1$ pokemon pikachu 然后…出现以下报错提示： 1.Pokemon-Terminal/./Scripts/background.scpt:39:46: script error: Expected end of line but found identifier. (-2741) 翻越最后一座 bug 高山想去给作者提一个 issue，就发现作者对于这个 bug 已经给出了解决方法。 按照解决方法，我们需要对 .Pokemon-Terminal/scripter.py 文件进行一些修改（当然，不一定每个人都碰上了这个 bug）。其实我也不太会用 vim，所以以下操作参照了这篇文章修改文件内容 vi命令。 用以下命令在终端打开： 1vi .Pokemon-Terminal/scripter.py 然后按一下 i，从命令行模式进入插入模式。找到函数__terminal_script（在比较靠上的位置），将： 1content = &quot;tell application \&quot;iTerm\&quot;\n&quot; 修改为：1content = &quot;tell application \&quot;iTerm2\&quot;\n&quot; 按 Esc 键进入命令行模式，再按:wq保存退出。大功告成！ 再在 iTerm2 中输入pokemon pikachu，就会发现黑漆漆（或者白晃晃）的背景变成了皮神黄！ 深度使用123456789101112131415161718192021222324Usage: pokemon [parameter]Parameters: [name] - Change the terminal background to the specified Pokemon. [index] - Change the terminal background to a Pokemon by its index. [region] - List all the Pokemon of the specified region. [one letter] - List all Pokemon who&apos;s names begin with a particular letter. [two letters] - List all Pokemon who&apos;s names begin with those two letters.Other Parameters: pokemon all - List all the Pokemon supported. pokemon regions - List all the available regions. pokemon extra - List all the Pokemon from the &apos;Extra&apos; folder. pokemon random - Change the terminal background to a random Pokemon. pokemon random-kanto - Change the terminal background to a random Pokemon from the specified region. pokemon ? - Identify the current Pokemon in the terminal. pokemon _pikachu - Change the wallpaper to the specified Pokemon. pokemon _random - Change the wallpaper to a random Pokemon. pokemon _random-kanto - Change the wallpaper to a random Pokemon from the specified region. pokemon _? - Identify the current Pokemon in the wallpaper. pokemon slideshow - Iterate through each Pokemon. pokemon slideshow-kanto - Iterate through each Pokemon in the specified region. pokemon help - Display this menu. 以上是作者提供的用法。可以通过口袋妖怪的英文名或者编号切换皮肤，或者用pokemon random来切换成随机的皮肤。 我们现在还得每次打开 iTerm 后输入命令来切换皮肤。作者同样提供了点开就换的方法，只用在 iTerm 的 Preferences 里做一点配置： 想一想，通过配置为pokemon random，每次打开都是不同皮肤说不定更爽到。 最后作者建议你改变一下透明度之类的，使皮神看起来更酷炫有范： 我的配置是这样的： 结语其实一个皮肤也没有那么重要（还是有那么一点爽的啦），重要的是通过这一番折腾，接触到了很多常规学习中可能不会接触的东西，包括 iTerm 和 anaconda。这也是我第一次有目的性地去看项目的 issue。希望自己以后能多一点这样地非常规学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端学习之路上的暂歇思考]]></title>
      <url>%2Frelax-and-think%2F</url>
      <content type="text"><![CDATA[又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。 到现在为止，我的前端学习之路大概插了这些旗帜： 对前端生态有了一个大致的了解，对例如 Webpack、Babel 等常用的工具有使用经验或者大概知道是干什么的。 在知乎和微博上关注了前端大佬，养成每天在掘金上看技术文章以及不时逛一些较为优秀的技术博客的习惯。 看了一些前端书籍，大多是 JavaScript 相关。 大致啃完了 Vue.js 的文档，正在学习 Vue-router。同时也对 i-View 等相关项目有一些了解。 在之前的前端学习中也有一些问题： 最大的问题是不太重视基础。看张鑫旭对前端的要求中，光是“掌握 JS 中的字符串、函数、对象、数组、字面量等基本概念，熟记所有内置的方法（包括参数和返回值）”这一条就足够我汗颜了。看的书籍虽然有笔记，但也感觉是没有过心。之后会将博客中的读书笔记再按照知识点，辅以自己的进一步学习成果拆分细化。虽然这是一个比较大的工程，但我觉得这是一个很有必要的工作。 经典书籍读的不够多。像《你不知道的 JavaScript》、《JavaScript 设计模式与开发实践》等书都没有看。 某些时候还是有些懒惰，没有抽出空余时间来学习。或者是在学习过程中在知乎、贴吧、空间、微博耗费了注意力，导致学习效率不高。 包括博文和项目在内的学习产出还是不多，博文也没有特别有价值的内容。毕业前要在 github 上有一个 100+ star 的项目，还要部署到 npm 上。博客考虑备案和 SEO，以激励自己写出更有价值的文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单页面程序及组件化相关笔记]]></title>
      <url>%2FSPA-learning-notes%2F</url>
      <content type="text"><![CDATA[随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 xufei 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。 提高开发效率的两个主要途径： 加快开发速度：少造轮子。 减少变更代价：清理模块之间的关系，合理分层。 单页面程序SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。 优越性高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。 实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。 代码合并与加载策略典型特征：部分加载。 一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的异步加载机制去运行时加载。 因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。 需要考虑的点路由与状态的管理界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。 缓存与本地存储动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。 在本地存储一些临时数据可以用 localStorage。 服务器通信WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。 例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。 困难与缺陷SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。 缺陷：不利于 SEO；要注意内存管理。 样式规划基准样式的分离包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。 组件样式的划分组件样式应当尽量减少相互依赖，各组件的样式允许冗余。 堆叠次序的管理在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。 组件化整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。 职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。 HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。 JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。 CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。 开发框架jQuery 轻量、灵活，但对代码缺乏约束。 需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。 因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。 AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。 React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。 依赖注入： 核心理念：通过配置来实例化所依赖的组件。 缺点：性能以及跟踪调试的便利性上的损失。 优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。 应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。 MV*框架的基本原理充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在配置文件（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动： 初始化自身（bootstrap） 异步加载可能尚未引入的 JavaScript 代码（require） 解析定义在 HTML 上的规则（template parser） 实例化模型（scopr） 创建模型和 DOM 的关联关系（binding, injection） 这些是主线流程，还有一些支线，比如： 解析 url 的 search 字符串，恢复状态（route） 加载 HTML 部件模板（template url） 部件模板和模型的关联（binding） 业务模型指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。 Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。 参考资料博文参考资料： Web应用的组件化（一）——基本思路 构建单页Web应用 关于新框架的学习 延伸阅读资料： Web应用的组件化（二）——管控平台]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最近在干以及打算干些什么]]></title>
      <url>%2Frecent-and-will%2F</url>
      <content type="text"><![CDATA[这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。 在干什么： 写花旗杯项目前端第一版。 开始看 Vue.js 的文档。 看一些关于前端工程化的博文。 打算干什么： 继续看完 Vue.js 的文档并且找一个 Demo 做一做。 尽早看完 ES 6 新特性。 看一看 Grid。 最近看的优秀文章： CSS Modules 入门及 React 中实践 玩转 npm：介绍了常用的 npm 命令。 构建单页Web应用：理解单页 Web 应用。我想这篇文章我还会再看至少两遍。 HTML5 高级系列：web Storage：了解如何通过 localStorage 和 sessionStorage 存储一些数据。 [译] 人人须知的 jQuery 技巧：介绍了一些 jQuery 代码片段，包括预加载图片、禁用输入字段、简单的手风琴效果等。建议自己整理一份类似的代码片段库。 FIGlet初识：了解一下 FIGlet，不实用，但还有点意思。 如何处理CSS3属性前缀：介绍了 Autoprefixer，用于处理 CSS 3 属性前缀的问题。 JavaScript Modularization Journey：JS 模块化发展史。还得再看几遍…等我到了该接触 Webpack 的时候。 看到的好玩意： Awesomes - Web前端开发资源库：全是前端的开源项目，遍地的轮子啊。关键是文档很多都翻译成中文了。 pkg：帮助你将你的 Node.js 程序打包成即使在没有 node 环境的设备上也能运行。 Axios：基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用。这个貌似很常用，看看能不能用在现在的项目中。 一个有趣的 CSS 按钮效果 Hover.css：Hover.css 是一个 CSS3 的鼠标悬停效果集合，可用于超链接，按钮，logo，SVG，推荐图片等等。能够很简单地运用到我们的元素中。 之后想做的练习（时间好少QAQ）： 谈谈一些有趣的CSS题目 原生JavaScript学习-实例索引 百度前端技术学院]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《ECMAScript 6 入门》读书笔记(二)]]></title>
      <url>%2Fes6-2-notes%2F</url>
      <content type="text"><![CDATA[说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《ECMAScript 6 入门》。希望能早日啃完，想去看 Vue.js 了… 此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。 函数的扩展函数参数的默认值1.ES 6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 12345678910111213141516171819202122232425262728293031323334353637function log(x, y = 'World')&#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'Kyon') // Hello Kyonlog('Hello', '') // Hello// 与解构赋值默认值结合使用function foo(&#123;x, y = 5&#125;)&#123; console.log(x, y);&#125;foo(&#123;x: 1&#125;) // 1, 5foo() // TypeeError: Cannot read property 'x' of undefined// 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x有值，y无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x和y都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined] 参数变量是默认声明的，所以不能用let或const再次声明；使用参数默认值时，函数不能有同名参数。 定义了默认值的参数通常应该为函数的尾参数。 2.函数的length属性：将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，后面的参数也不会被计入。 3.作用域：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，作用域消失。 12345678910// 函数foo内部声明的内部变量与参数不是同一个作用域var x = 1;function foo(x, y = function()&#123; x = 2; &#125;)&#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 123456789var x = 1;function foo(x, y = function()&#123; x = 2; &#125;)&#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 4.函数参数默认值的应用：可以指定某一个参数不得省略，如果省略就抛出一个错误。 123456789101112function throwIfMissing()&#123; throw new Error('Missing parameter');&#125;function foo(mustBeprovided = throwIfMissing())&#123; return mustBeProvided;&#125;// throwIfMissing函数名之后有一对圆括号// 表明参数的默认值不是在定义时执行，而是在运行时执行// 即如果参数已经赋值，默认值中的函数就不会运行foo() // Error: Missing parameter 可以将参数默认值设为undefined，表明这个参数是可以省略的。 5.rest 参数：形式为”…变量名”，用于获取函数的多余参数。rest 参数中的变量代表一个数组。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1const sortNumbers = (...numbers) =&gt; numbers.sort(); 函数的length属性，不包括 rest 参数。 1(function(a,...b)&#123;&#125;).length // 1 函数参数的默认值6.扩展运算符：...，将一个数组转为用逗号分隔的参数序列。 123456789console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5var numbers = [4, 35];add(...numbers) // 39// 不再需要 apply 方法将数组转为函数参数function f(x, y, z)&#123;&#125;f(...args); 7.扩展运算符的应用： 合并数组：提供了新写法。 123456var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];arr1.concat(arr2, arr3); // ES 5[...arr1, ...arr2, ...arr3] // ES 6 与解构赋值结合：用于生成数组（只能放在参数最后一位）。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = ["foo"];first // "foo"rest // [] 函数的返回值：为函数提供一种返回多个值的方法。 1234// 从数据库取出一行数据，通过扩展运算符，直接传入构造函数Datevar dateFields = readDateFields(database);var d = newDate(...dateFields); 字符串：扩展运算符还可以将字符串转为真正的数组。 1234567let str = 'x\uD83D\uDE80y';str.split('').reverse().join('')// 'y\uDE80\uD83Dx'[...str].reverse().join('')// 'y\uD83D\uDE80x' 实现了 Iterator 接口的对象：可以通过扩展运算符转为真正的数组。 12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符。Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567891011121314151617// Map结构let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3]// Generator 函数var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 8.函数内部严格模式：ES 5 时函数内部可以设定为严格模式；ES 6 规定只要函数参数使用了默认值、解构赋值或者扩展运算符，则函数内部不能显式设定为严格模式，否则报错。 原因：只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。 两种规避方法：全局性严格模式，将函数包在一个无参数的立即执行函数里。 9.name 属性：返回该函数的函数名。 如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。 1234const bar = function baz()&#123;&#125;;// ES 5、ES 6bar.name // "baz" Function构造函数返回的函数实例，name 属性的值为 anonymous。 1(new Function).name // "anonymous" bind返回的函数，name属性值会加上bound前缀。 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // "bound foo"(function()&#123;&#125;).bind(&#123;&#125;).name // "bound " 箭头函数10.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 12345678910111213141516// 箭头函数与变量解构结合使用const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person)&#123; return person.first + ' ' + person.last;&#125;// 简化回调函数[1, 2, 3].map(x =&gt; x * x);// 等同于[1, 2, 3].map(function(x)&#123; return x * x;&#125;); 11.箭头函数使用注意点： 函数体内的this对象就是定义时所在对象，而不是使用时所在对象。 不可当作构造函数（即不可使用new命令），否则抛出错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。也正因如此，箭头函数不能用作构造函数，也不能用call()、apply()、bind()这些方法去改变this的指向。 除了this，arguments、super、new.target在箭头函数中也是不存在的，指向外层函数的对应变量。 12.嵌套的箭头函数： 12345678910111213141516171819// ES 5function insert(value) &#123; return &#123;into: function(array) &#123; return &#123;after: function(afterValue) &#123; array.splice(array.indexOf(afterValue)+1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); // [1, 2, 3]// ES 6let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue)+1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); // [1, 2, 3] 13.函数绑定运算符：::，左边为对象，右边为函数。该运算符自动将左边的对象作为上下文环境（即 this 对象），绑定到右边的函数上。用来取代call、apply、bind调用。 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;var log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 12345let &#123; find, html &#125; = jake;document.querySelectorAll("div.myClass")::find("p")::html("hahaha"); 该语法为已被 Babel 转码器支持的一个 ES 7 提案。 14.尾调用：某个函数的最后一步是调用另一个函数。 To be continued… 对象的扩展1.属性的简洁表示法：ES 6 允许直接写入变量和函数，作为对象的属性和方法。这时，属性名为变量名，属性值为变量值。 1234567891011121314151617181920var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于var baz = &#123;foo: foo&#125;;var o = &#123; method()&#123; return "Hello!"; &#125;&#125;;// 等同于var o = &#123; method: function()&#123; return "Hello!"; &#125;&#125;; 如果某个方法的值是一个 Generator 函数，前面需要加上星号。 12345var obj = &#123; * m()&#123; yield 'hello world'; &#125;&#125;; 2.属性名表达式：ES 6 允许字面量定义对象时，把表达式放在方括号内。表达式也可用于定义方法名。 123456789101112131415let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;;// 表达式用于定义方法名let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 但属性名表达式与简洁表达式不能同时使用。 12345678// 报错var foo = 'bar';var bar = 'abc';var baz = &#123; [foo] &#125;;// 正确var foo = 'bar';var baz = &#123; [foo]: 'abc'&#125;; 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]（即不要这么用）。 3.方法的 name 属性：返回函数名。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 4.Object.is()：比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致（不同之处为+0不等于-0，以及NaN等于自身）。 5.Object.assign()：用于对象的合并，将源对象的所有可枚举属性复制到目标对象。第一个参数是目标对象，其他参数是源对象。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果多个对象有同名属性，后面的属性会覆盖前面的。 如果只有一个参数将直接返回（参数不是对象会先转成对象）。无法转成对象的源对象将被跳过。undefined和null无法转成对象，所以不能作为目标对象（否则报错）。其他相关注意事项见文档。 实行浅拷贝，即源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。对于嵌套对象，一旦遇到同名属性会被替换。 1234var target = &#123; a: &#123; b: 'c', d: 'e'&#125; &#125;;var source = &#123; a: &#123; b: 'hello' &#125; &#125;;Object.assign(target, source); // &#123;a: &#123; b: 'hello' &#125;&#125; Object.assign()有很多用处，其中包括为对象添加属性和方法。 1234567891011121314151617// 添加属性class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125;// 添加方法Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2)&#123; ... &#125;, anotherMethod()&#123; ... &#125;&#125;);// 等同于SomeClass.prototype.someMethod = function(arg1, arg2) &#123; ... &#125;;SomeClass.prototype.anotherMethod = function()&#123; ... &#125;; 属性的可枚举性与遍历6.Object.getOwnPropertyDescriptor：对象的每个属性都有一个描述对象，用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获得该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo');// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; ES 7 引入Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。 1234567891011121314151617181920const obj = &#123; foo: 123, get bar() &#123; return 'abc'; &#125;&#125;;Object.getOwnPropertyDescriptors(obj);// &#123;// foo: &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125;,// bar: &#123;// get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true// &#125;// &#125; 7.属性的可枚举性：描述对象的enumerable属性，成为“可枚举性”。ES 5 有三个操作会忽略enumerable为false的属性： for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 ES 6 新增Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 当只关心对象自身的属性时，尽量不要用for...in循环，而用Object.keys()代替。 8.Object.keys()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键名。ES 2017 引入配套的Object.values和Object.entries作为遍历一个对象的补充手段。 Object.values()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键值（不含 Symbol 属性）。参数为字符串时返回各个字符组成的一个数组，参数为数值或布尔值时返回空数组（与包装对象有关）。 Object.entries()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键值对数组（不含 Symbol 属性）。 9.属性的遍历：ES 6 共有5种遍历对象的方法。 for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但包括不可枚举属性）。 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性（无论是否可枚举或者属性名是 Symbol 还是字符串）。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则（之前一些遍历的方法也遵循此规则）。 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 __proto__属性及相关方法10.__proto__属性：用于读取或设置当前对象的prototype对象。内部属性，不是正式对外 API。建议使用Object.setPrototypeOf()（写操作）、Object.getPrototype()（读操作）、Object.create()（生成操作）代替。 如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。 11.Object.setPrototypeOf()：作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。 12345// 格式Object.setPrototypeOf(object, prototype)// 用法var o = Object.setPrototypeOf(&#123;&#125;, null); 如果第一个参数不是对象，会自动转为对象（由于返回的还是第一个参数，故无效果）；是undefined或null则报错（无法转为对象）。 12.Object.getPrototypeOf()：用于读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 如果参数不是对象，会被自动转为对象；是undefined或null则报错。 13.对象的扩展运算符：ES 2017 将...引入对象。主要用途有： 解构赋值： 1234let &#123;x, y, ...z&#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 注意解构赋值的拷贝是浅拷贝，且不会拷贝继承自原型对象的属性。 123456789// 扩展某个函数的参数，引入其他操作function baseFunction(&#123; a, b &#125;) &#123; // ...&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用x和y参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 扩展运算符：取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于Object.assign方法。 123456789101112let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;// 等同于let n = Object.assign(&#123;&#125;, z);// 用于合并两个对象let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。因此可用于修改现有对象部分的部分属性。 1234let newVersion = &#123; ...previousVersion, name: 'New Name' // Override the name property&#125;; 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 1let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;; 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 14.Null 传导运算符：?.，用于判断对象及其内部属性是否存在。仅为提案，详见文档。 Symbol1.概述：ES 6 引入的新的原始数据类型，表示独一无二的值。至此，JS 共有七种数据类型： Undefined Null 布尔值（Boolean） 字符串（String） 数值（Number） 对象（Object） Symbol Symbol 值通过Symbol函数生成。即对象的属性名有两种类型：原来就有的字符串，和新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就是独一无二的，不会与其他属性名产生冲突。 1234let s = Symbol();typeof s// "symbol" 生成的 Symbol 是一个原始类型的值，不是对象。因此Symbol函数前不能使用new命令（否则报错），Symbol 值也不能添加属性。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。但相同参数的Symbol函数的返回值是不相等的。 12345678var s1 = Symbol('foo');var s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // "Symbol(foo)"s2.toString() // "Symbol(bar)" 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后生成一个 Symbol 值。 1234567const obj = &#123; toString()&#123; return 'kyon'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) Symbol 值不能与其他类型的值进行运算（会报错），但可以显式转为字符串和布尔值。 2.作为属性名的Symbol： 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello'! &#125;);// 以上写法都得到同样结果a[mySymbol] // "Hello!" Symbol 值作为对象属性名时，不能用点运算符。 123456var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // "Hello!" Symbol 值作为属性名时，该属性是公开属性而非私有属性。 3.魔术字符串：在代码中多次出现、与代码形成强耦合的某一个具体的字符串或数值。应尽量消除而改用含义清晰的变量代替。 Symbol可用于消除魔术字符串。 4.属性名的遍历：Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。这个特性可被用于为对象定义一些非私有的、但又希望只用于内部的方法。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 Reflect.ownKeys(obj)方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// ["enum", "nonEnum", Symbol(my_key)] 5.Symbol.for()、Symbol.keyFor()：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234var s1 = Symbol.for('foo');var s2 = Symbol.for('foo');s1 === s2; // true Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 12345Symbol.for("bar") === Symbol.for("bar")// trueSymbol("bar") === Symbol("bar")// false Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345var s1 = Symbol.for("foo");Symbol.keyFor(s1); // "foo"var s2 = Symbol("foo")Symbol.keyFor(s2); // undefined 6.Singleton 模式：指调用一个类，任何时候返回的都是同一个实例。 Node 中，模块文件可以看作一个类。可以使用 Symbol，通过把实例放到顶层对象global来实现 Singleton 模式。 内置的 Symbol 值(暂且略过)7.Symbol.hasInstance属性：指向一个内部方法。 8.Symbol.isConcatSpreadable属性： 9.Symbol.species 10.Symbol.match 11.Symbol.replace 12.Symbol.search 13.Symbol.split 14.Symbol.iterator 15.Symbol.toPrimitive 16.Symbol.toStringTag 17.Symbol.unscopables Set 和 Map 数据结构Set1.基本用法：Set 结构不会添加重复的值。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for(let i of s)&#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。因此有一种去除数组重复成员的方法： 1[...new Set(array)] Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，类似精确相等运算符（===），主要的区别是NaN等于自身（===认为NaN不等于自身）。另外，两个对象总是不相等的。 2.Set 实例的属性和方法： 实例属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法： add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个表示删除是否成功的布尔值。 has(value)：返回一个布尔值。 clear()：清除所有成员，没有返回值。 遍历方法（Set 结构中，键名和键值是同一个值）： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Array.from方法可以将 Set 结构转为数组。 WeakSet3.含义：与 Set 类似，但成员只能是对象，且都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 ES 6 规定，WeakSet 不可遍历。 4.语法：有add、delete、has方法；没有size属性。 5.用处：是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 Map6.含义和基本用法：为了解决 Object 的只能用字符串当作键名的问题，ES 6 提供了 Map 数据结构。各种类型的值（包括对象）都可以当作键。 有set(key, value)、get(key)、has(key)、delete(key)、clear()方法。 作为构造函数，Map 可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组。 如果对同一个键多次赋值，后面的值将覆盖前面的值；如果读取一个未知的键，则返回undefined。 7.与其他数据结构的互相转换： Map 转为数组：使用扩展运算符（...）。 数组转为 Map：使用 Map 构造函数。 Map 转为对象：如果所有 Map 的键都是字符串，可以转为对象。 1234567891011function strMapToObj(strMap)&#123; let obj = Object.create(null); for(let [k, v] of strMap)&#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap);// &#123; yes: true, no: false &#125; 对象转为 Map： 1234567function objToStrMap(obj)&#123; let strMap = new Map(); for(let k of Object.keys(obj))&#123; strMap.set(k, obj[k]); &#125; return strMap;&#125; Map 转为 JSON： 12345// 情况一：Map 的键名都是字符串// 可以转换为对象 JSONfunction strMapToJson(strMap)&#123; return JSON.stringify(strMapToObj(strMap));&#125; 12345// 情况二：Map 的键名有非字符串// 可以转换为数组 JSONfunction mapToArrayJSON(map)&#123; return JSON.stringify([...map]);&#125; JSON 转为 Map：逆操作。 WeakMap8.含义：与 Map 类似，用于生成键值对。但只接受对象作为键名（null除外），且键名所指向的对象不计入垃圾回收机制。 专用场合：它的键所对应的对象可能会在将来消失。WeakMap结构有助于防止内存泄漏。 9.语法：没有遍历操作，无法清空。只有四个方法可用：get()、set()、has()、delete()。 10.用处：DOM 节点作为键名。 123456789101112// 一个例子let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function()&#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false);// 一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险 注册监听事件的listener对象，就很适合用 WeakMap 实现。 123456789const listener = new WeakMap();listener.set(element1, handler1);listener.set(element2, handler2);element1.addEventListener('click', listener.get(element1), false);element2.addEventListener('click', listener.get(element2), false);// 一旦DOM对象消失，跟它绑定的监听函数也会自动消失 WeakMap 的另一个用处是部署私有属性。 Proxy暂时跳过。 Reflect暂时跳过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通jQuery》读书笔记]]></title>
      <url>%2FjQuery-master-notes%2F</url>
      <content type="text"><![CDATA[这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。 感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。 了解 jQueryjQuery 核心库的工作通过处理浏览器加载 HTML 时动态创建的 DOM（文档对象模型），达到动态修改页面内容的目标。 HTML 入门事件流一个事件在它的生命周期中要经历 3 个阶段：捕获、处理目标元素和冒泡。 目标元素：触发事件的元素。 CSS 基础反选择器:not(&lt;selector&gt;)：选取不匹配指定选择器的元素。 样式层叠浏览器查找样式元素值的顺序： 行内样式（定义在元素 style 属性中的样式）； 内嵌样式（定义在 style 元素中的样式）； 外部样式（使用 link 元素导入的样式）； 用户样式（用户自己定义的样式）； 浏览器样式（浏览器提供的默认样式）。 前三个又合称为作者样式。 important 规则在样式声明的末尾追加!important可以把改值标识为重要样式。浏览器会给重要样式以优先权，而不再考虑这个样式的定义位置。 唯一能优先于作者样式中重要样式的样式是定义在用户样式表中的重要样式。对于普通样式来说，作者样式优先于用户样式。但对于重要样式，浏览器的做法恰恰相反。 “专一程度”浏览器根据以下 3 个特征计算样式的“专一程度”： 选择器中出现的 id 值个数； 选择器中出现的其他属性和伪类个数； 选择器中出现的元素名字和伪元素名字个数。 以 a-b-c 这种形式评估样式规则的“专一”程度，逐位比较，每一位上数字越大表示越专一。例如，1-0-0 比 0-5-5 更专一。 如果有多条样式规则的专一程度相同，那么浏览器会选择最后定义的那条规则。专一程度规则仅在同一层叠级别有效。 样式单位相对长度单位 em：相对于元素字号的高度； ex：相对于元素字体中小写字母 x 的高度； rem：相对于根元素的高度； px：CSS 像素（假定位于一个 96dpi 的显示设备上，实际上是绝对单位，不会改变大小）； %：另一属性值的百分比。 jQuery 基础使用 CDN 版的 jQueryCDN（Content Delivery Network）：内容分发网络。当用户请求其数据时，CDN 能智能地分配离用户最近的服务器提供服务。 使用 CDN 的两个优点：(1)用户体验更好（速度通常更快）；(2)节省了传输 jQuery 库所需带宽。 CDN 不适合内联网应用程序。 $ 函数jQuery.noConflict方法让 jQuery 放弃使用 $ 符号。也可将该方法的返回值赋给一个变量以自定义 jQuery 简写符号。 延迟 ready 事件的触发时间$.holdReady(true)必须在 ready 事件触发之前调用，$.holdReady(false)告诉 jQuery 触发 ready 事件。可以多次调用，但在 ready 事件被真正触发之前，使用 true 参数调用次数要等于使用 false 参数调用次数。 选择元素 使用上下文限制搜索范围多给 $ 函数提供一个参数以限制搜索的范围。如果提供的上下文选择器匹配多个元素，将会把匹配上下文选择器的元素收集在一起，然后再匹配主选择器。 12$("img:odd", $(".drow"))// img:odd选择器会应用在.drow选择器的结果上 确定选择结果 数据模版介绍了模板库 Handlebars。 定义模板数据模板库的核心是数据模板——包含着占位符的 HTML 元素。 p268 处理表单介绍了 jQuery 插件 Validation，它专门处理表单验证问题。 jQuery Validation Engine 表单验证 p297 Ajaxp331]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《ECMAScript 6 入门》读书笔记(一)]]></title>
      <url>%2Fes6-1-notes%2F</url>
      <content type="text"><![CDATA[《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：ECMAScript 6 入门。将知识点简便地总结一下，以供后续使用时参考或复习。 此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。 let和const命令1.let：let声明的变量仅在块级作用域内有效。不存在变量提升；存在暂时性死区，只能在声明的位置后面获取和使用；相同作用域内不可重复声明。 2.块级作用域：外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。 3.根据ES 6附录B的规定，在浏览器的ES 6环境中，块级作用域内声明的函数，行为类似于var声明的变量。应避免在块级作用域内声明函数，或用函数表达式代替函数声明语句。 4.do 表达式：在块级作用域之前加上do，使其变为表达式（可以返回值）。 12345// 变量x得到整个块级作用域的返回值let x = do &#123; let t = f(); t * t + 1;&#125;; 5.const：声明一个只读常量。一旦声明，就必须立即初始化。和let一样，只在声明所在的块级作用域内有效；声明的常量不提升；存在暂时性死区；不可重复声明。 const保证变量指向的内存地址不可改动。因此将对象声明为常量时，不可变的只是地址，对象本身可变，可以为其添加新属性。 如果真想将对象冻结，应用Object.freeze()方法（对象本身和 其属性都应冻结）。 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, i) =&gt; &#123; if(typeof obj[key] === 'object') &#123; constantize(obj[key]); &#125; &#125;);&#125;; 6.顶层对象的属性：let、const、class声明的全局变量不属于顶层对象的属性。 补充资料：ES6之”let”能替代”var”吗? 变量的结构赋值1.解构：按照一定模式，从数组和对象中提取值，对变量进行赋值。解构不成功，变量的值就等于undefined。 1234567891011121314151617181920212223let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []let [bar, foo] = [1];foo // undefined 2.不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 3.解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值不会生效。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 如果默认值是一个表达式，那么这个表达式是惰性求值的（用到时才会求值）。 123456// x能取到值，所以函数f根本不会执行function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 4.要将一个已经声明的变量用于解构赋值时，将大括号写在行首会导致JavaScript引擎将其解释为代码块，从而发生语法错误。 12345let x;// 错误写法&#123;x&#125; = &#123;x: 1&#125; // SyntaxError: syntax error// 正确写法(&#123;x&#125; = &#123;x: 1&#125;); 对象的结构赋值5.对象的解构：属性没有次序，变量取值由名称决定。 123let &#123; bar, foo&#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 如果变量名与属性名不一致，须写成： 1234567var &#123; foo: baz&#125; = &#123; foo: 'aaa', bar: 'bbb'&#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 6.解构也可用于嵌套结构的对象。 123456789101112let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;]&#125; = obj;x // "Hello"y // "World"// 这时p是模式，不是变量，因此不会被赋值。p // error: p is undefined 字符串的结构赋值7.此时字符串被转化成一个类似数组的对象，且具有length属性（可以针对此属性解构赋值）。 123456const [a, b, c, d, e] = 'hello';a // "h"e // "o"let &#123;length : len&#125; = 'hello';len // 5 数值、布尔值的结构赋值8.解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。undefined和null无法转为对象，所以对它们解构赋值都会报错。 1234567let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // truelet &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的结构赋值9.为函数move的参数指定默认值： 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 为变量x和y指定默认值： 12345678function move(&#123;x, y&#125; = &#123;x: 0, y:0&#125;)&#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 圆括号问题10.ES6规定，只要可能导致解构歧义，就不得使用圆括号。由于这条规则不易辨别，因此建议尽量不要在模式中放置圆括号。 11.以下三种解构赋值不得使用圆括号。 变量声明语句中，不能带有圆括号。 函数参数中，模式不能带有圆括号。 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 12.可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。 用途 交换变量的值： 123let x = 1;let y = 2;[x, y] = [y, x]; 从函数中返回多个值：将返回的数组或对象中的值取出 函数参数的定义：方便地将无序的参数与变量名对应 提取JSON数据： 12345678910let jsonData = &#123; id: 24, status: "OK", data: [424, 5920]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 24, "OK", [424, 5920] 函数参数的默认值 遍历Map结构： 123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 字符串的扩展1.字符的Unicode表示法：将码点放入大括号。 123"\u&#123;20BB7&#125;" // "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;" // "ABC" 2.新增一些方法： codePointAt()：能够正确处理4个字节储存的字符，返回一个字符的码点。是测试一个字符由两个字节还是由四个字节组成的最简单方法。 String.fromCodePoint()：用于从码点返回对应字符，可识别Unicode编号大于0xFFFF的码点（32位的UTF-16字符）。 at()（提案）：返回字符串给定位置的字符，可识别Unicode编号大于0xFFFF的码点。 repeat(n)：返回一个新字符串，表示将原字符串重复n次。 normalize()：将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 padStart()：如果某个字符串不够指定长度，会在头部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串（默认为空格）。 padEnd()：同上，用于尾部补全。 3.模版字符串：常用于定义多行字符串，或者在字符串中嵌入变量。用反引号（`）标识。 12345678910// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`// 字符串中嵌入变量var name = "Kyon", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 模板字符串中嵌入变量，要将变量名卸载${}中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，也可以调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串（例如对象调用toString方法）。 4.标签模板（功能）：函数调用的一种特殊形式。模板字符串作为参数紧跟在一个函数名后，该函数被调用以处理该模板字符串。常用于转义特殊字符和多语言转换（国际化处理）。 123console.log`Kyon`// 等同于console.log('Kyon') 模板字符有变量时，先把模板字符串处理成多个参数。处理得到的第一个参数是一个数组，包含那些没有变量替换的部分。 123456var a = 5;var b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`;// 等同于tag(['Hello', ' world', ''], 15, 50); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存转义后的原字符串。 5.String.raw()：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串；如果原字符串的斜杠已经转义，则不会做任何处理。常用于处理模板字符串。 12345String.raw`Hi\n$&#123;3+4&#125;!`;// "Hi\\n7!"String.raw`Hi\u000A!`;// 'Hi\\u000A!' 也可作为正常函数使用，第一个参数应是具有raw属性的对象，且raw属性的值应是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 6.模板字符串的限制（提案）：放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 正则的扩展1.u修饰符：Unicode 模式，用来正确处理大于\uFFFF的 Unicode 字符。对于码点大于\uFFFF的 Unicode 字符，点字符(.，除了换行符外的任意单个字符)、Unicode 字符表示法（使用大括号表示 Unicode 字符）、量词、预定义模式（\S，匹配所有不是空格的字符）必须加上u修饰符才能识别。 1234/^\uD83D/u.test('\uD83D\uDC2A')// false/^\uD83D/.test('\uD83D\uDC2A')// true 2.y修饰符：“粘连”修饰符，全局匹配，但须确保匹配必须从剩余的第一个位置开始。一个应用是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // ["aaa"]r2.exec(s) // ["aaa"]r1.exec(s) // ["aa"]r2.exec(s) // null 3.ES 6 的正则对象新增了sticky属性和flags属性，分别表示是否设置了y修饰符以及返回正则表达式的修饰符。 123var r = /hello\d/y;r.sticky // truer.flags // 'y' 4.有一些提案。因为我暂时对正则不太熟悉，所以略过。 数值的扩展1.二进制、八进制表示法：分别用前缀0b（或0B）和0o（或0O）表示。用Number()方法将其转化为十进制。 12340b111110111 === 503 // true0o767 === 503 // trueNumber('0b111') // 7 2.新增 Number 对象上的一些方法： Number.isFinite()：用于检查一个数值是否为有限的。 Number.isNaN()：用于检查一个值是否为NaN。 与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。 将全局方法parseInt()和parseFloat()移植到 Number 对象上，行为完全保持不变，目的是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()：用于判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是同样的储存方法，这个方法都会返回 true。 3.Number.EPSILON：极小的常量，表示一个可以接受的误差范围。浮点数计算误差小于Number.EPSILON时可以认为得到正确结果。 4.Number.isSafeInteger()：JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围的值无法精确表示。Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 5.Math 对象的扩展：所有新增方法都是静态方法，只能在 Math 对象上调用。 Math.trunc()：用于去除一个数的小数部分，返回整数部分。对于非数值内部使用Number方法将其先转为数值；对于空值和无法截取整数的值，返回 NaN。 Math.sign方法用来判断一个数到底是正数、负数、还是零。它会返回五种值：参数为正数，返回+1；负数返回-1；0返回0；-0返回-0；其他值返回NaN。 Math.cbrt：用于计算一个数的立方根。 此外，还有一些对数方法和三角函数方法。 6.指数运算符（**）： 1234562 ** 2 // 42 ** 3 // 8let a = 3;a **= 3;// 等同于 a = a * a * a; 数组的扩展1.Array.from()：将类数组对象（本质特征是有length属性）和可遍历对象（部署了 Iterator 接口的数据结构，包括 ES 6新增的 Set 和 Map）转化为真正的数组。1234567891011let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;var arr1 = Array.from(arrayLike);Array.from('hello');// ['h', 'e', 'l', 'l', 'o'] 还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组；如果map函数里面用到了this关键字，还可以传入Array.from()的第三个参数，用来绑定this。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 2.Array.of()：返回参数值组成的数组（没有参数则返回空数组）。 12345Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]Array.of(3) // [3]Array.of(3, 11, 8) // [3, 11, 8] 3.数组实例的copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置（覆盖原有成员），然后返回当前数组。 接受三个参数（都为数值，否则自动转换）： target（必需）：从该位置开始替换数据； start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 1234Array.prototype.copyWithin(target, start = 0, end = this.length)[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 4.数组实例的find()和findIndex()： find()用于找出第一个符合条件的数组成员。其参数为一个回调函数（可以接收三个参数：当前的值，当前的位置和原数组），所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员，否则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 findIndex()类似，返回第一个符合条件的数组成员的位置，否则返回-1。 5.数组实例的fill()：用给定值填充一个数组。 1234567// 数组中原有的元素将被覆盖['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]// 还可以接受两个参数，用于指定填充的起始位置和结束位置['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 6.数组实例的keys()、values()和entries()：用于遍历数组。都返回一个遍历器对象，可以用for..of循环进行遍历；区别为分别对键名、键值、键值对遍历。 1234567891011121314151617for(let index of ['a', 'b'].keys())&#123; console.log(index);&#125;// 0// 1for(let elem of ['a', 'b'].values())&#123; console.log(elem);&#125;// 'a'// 'b'for(let [index, elem] of ['a', 'b'].entries())&#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 7.数组实例的includes()（属于ES 7 但 Babel 转码器已经支持）：返回一个布尔值，表示某个数组是否包含给定的值。 123[1, 2, 3].includes(2); // true[1 ,2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 8.数组的空位：和undefined不同，数组的空位没有任何值。ES 5 对空位的处理规则很不一致（大多数情况会忽略）；而 ES 6 明确将空位转为undefined。尽管如此，建议避免出现空位。 1Array(3) // [, , ,]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究伪元素及其用途]]></title>
      <url>%2Fpseudo_elements%2F</url>
      <content type="text"><![CDATA[之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。 伪类与伪元素的区别伪元素(Pseudo-elements)容易与伪类(Pseudo-classes)混淆。在 w3c 定义中，伪类用于向某些选择器添加特殊的效果，而伪元素用于将特殊的效果添加到某些选择器。可以看到从定义上来说，二者确实不好分辨。不过在种类上可以看出二者的一些不同。 伪类包括： :link：向未被访问的链接添加样式。 :visited：向已被访问的链接添加样式。 :hover：当鼠标悬浮在元素上方时，向元素添加样式。 :active：向被激活的元素添加样式。 :focus：向拥有键盘输入焦点的元素添加样式。 :first-child：向元素的第一个子元素添加样式。 :lang：向带有指定 lang 属性的元素添加样式。 其中前四个因为用不同的方式显示链接的不同状态，被称为“锚伪类”。在 CSS 定义中，a:hover必须被置于 a:link和a:visited之后，而a:active必须被置于a:hover之后才是有效的。 伪元素包括： :before：在元素之前添加内容。 :after：在元素之后添加内容。 :first-letter：向文本的第一个字母添加特殊样式。 :first-line：向文本的首行添加特殊样式。 其中前两个无疑是用的最多的。后两个也可以用于实现一些特殊效果，例如通过:first-letter实现段落首字母加粗或变色。 两者的根本区别是：伪类可以通过直接添加一个实际的类样式达到同等效果；而伪元素的效果则需要先添加一个实际的元素，再在元素上添加样式才能达到。 在 CSS 3 中修订后的伪元素使用两个冒号（::）以与伪类进行区分。但无论使用单冒号还是双冒号，浏览器都能识别。并且 IE 8 只支持单冒号的写法。因此为了更广泛的浏览器兼容性，还是推荐使用单冒号的写法。 伪元素的优点最常使用的两种伪元素——:before和:after可以在内容元素的前后插入额外的元素。通过伪元素，在实现很多炫酷的视觉效果时，我们不必修改现有的 HTML 文档结构。因为 HTML 文档本身仅仅应该包含内容，而不应该包含样式，所以伪元素更应该被提倡。 伪元素的应用鉴于伪元素应用很多时候代码相对专一，建议配合 Sass，通过设置 mixin 来使用以提高复用性（你可以通过我的上一篇博文 初见Sass－便捷的CSS预处理器 来了解Sass）。 清除浮动这大概是伪元素最为常见的应用了。比起插入额外的非语义标记来清除内联元素的浮动，这种俗称“clearfix”的方式更语义化。 CSS 123456789101112.group:before,.group:after &#123; content:&quot;&quot;; display:table;&#125;.group:after &#123; clear:both; overflow: hidden;&#125;.group &#123; zoom:1; /* For IE 6/7 (trigger hasLayout) */&#125; Sass 12345678910111213141516@mixin clearfix &#123; @if $legacy-support-for-ie &#123; *zoom: 1; &#125; &amp;:before, &amp;:after &#123; content: &quot;&quot;; display: table; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125; &#125;// 通过 @include 方法调用 实现样式效果能够借助伪元素实现的样式效果数不胜数。这里举一个简单而常用的例子。 很多时候我们会在每一节的标题下做一个类似下划线效果，用来强调。使用伪元素可以让我们不必添加额外的元素来实现这个效果。 Sass 代码如下： 123456789101112131415@mixin section-title() &#123; font-size: 2em; padding: 2em 0; text-transform: uppercase; color: #55a2dd; &amp;:after &#123; display: block; content: &quot;&quot;; background-color: #cccccc; width: 2em; height: .2em; margin: .4em auto; &#125;&#125; 设置透明度有时我们想给一张大图设置透明度，却发现其子元素都会被继承这个透明度。以往想要消除这个属性总让我头大。现在通过伪元素，我们就可以分别为文字和图片设置不同的透明度。 Sass 代码如下（来自第3周：设计你自己的页面）： 1234567891011121314151617181920212223242526272829303132333435363738394041.hero &#123; width: 100%; min-height: 50em; position: relative; background-color: $mask-color; z-index: 1; &amp;:after &#123; background: url(&apos;../images/hero-1-resized.jpg&apos;); background-size: cover; position: absolute; content: &quot;&quot;; z-index: -1; opacity: .2; width: 100%; height: 100%; top: 0; left: 0; &#125; h2 &#123; font-size: 6em; font-weight: bold; padding: 3em 0 1em 0; text-transform: uppercase; color: white; &#125; p &#123; max-width: 70%; font-size: 1.5em; font-weight: lighter; color: #cecece; line-height: 1.4; margin: 0 auto; padding: 1em 0 8em 0; span &#123; color: $heading-color; &#125; &#125;&#125; 对于 .hero 这个 section，我们将其背景设置为灰色，并将 position 设置为 relative。然后为其添加了一个伪元素，这个伪元素上包含了实际的图片，并为图片设置了透明度 .2。 参考资料CSS 伪元素 - W3School 你可以从这篇文章中了解更多伪元素的应用：大放异彩的伪元素——可以做什么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初见Sass－便捷的CSS预处理器]]></title>
      <url>%2Fsass-begin%2F</url>
      <content type="text"><![CDATA[发现自己又找到一本关于前端实践的优质开源书《3周3页面》。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。” 什么是Sass为了给 CSS 加入编程元素，人们发明了Sass。Sass 是一个 CSS3 的扩展语言，它提供了嵌套样式，变量定义，扩展，mixin等丰富的特性，使得编写样式更加容易，节省了开发者的时间。 Sass基础语法这里只记录我觉得比较关键的语法作为备忘。可以查看 sass十分钟入门 或者 SASS用法指南 以较为全面地入门。 变量：以$开头。如果变量需要镶嵌在字符串之外，需要写在#{}中。 嵌套：用&amp;引用父元素。 继承：使用@extend命令。 Mixin：使用@mixin命令定义一个代码块，使用@include命令调用。可以指定参数和缺省值。 插入文件：使用@import命令。 自定义函数：使用@function和@return。 此外支持条件语句和循环语句。 WebStorm中使用Sass注意，本节内容针对 OS X 环境。可能部分内容也兼容其他平台，但我没试过。 WebStorm 支持 Sass 的自动编译。在 WebStorm 的 Preferences 中，Tools 下选择 File Watchers。配置 Sass 和 SCSS（最新版的 Sass 后缀）需要有相应的 Program。 因为 Sass 依赖 ruby，所以要先安装 ruby。不过 OS X 好像自带 ruby（至少我没有什么时候安装过的印象…）。之后建议安装 Compass：sudo gem install compass，Sass 和 SCSS 的 Program 会被一并安装，WebStorm 也会检测到，之后点击 OK 即可。 之后，WebStorm 会自动监测 Sass 文件的改动，并时刻编译为同名 CSS 文件，保存在同一文件夹下，非常方便。 Sass实现媒体查询1234567891011121314151617// 定义两个 break-point$break-small: 320px;$break-large: 1024px;// 定义一个 mixin，接收三个可能的参数// 分别代表不同的设备——手机、平板和桌面显示器@mixin respond-to($media) &#123; @if $media == handhelds &#123; @media only screen and (max-width: $break-small) &#123; @content; &#125; &#125; @else if $media == medium-screens &#123; @media only screen and (min-width: $break-small + 1) and (max-width: $break-large) &#123; @content; &#125; &#125; @else if $media == wide-screens &#123; @media only screen and (min-width: $break-large) &#123; @content; &#125; &#125;&#125; 使用时： 12345div&#123; @include respond-to(medium-screens) &#123; //... &#125;&#125; 这种方式使用起来更方便，也便于后期统一修改变量的具体数值。 参考资料《3周3页面》的作者同样推荐了 Compass。这是一个使用了 Sass 的库，将很多常用样式打包成了一些模块以供使用。因为安装时出现了一些我还没解决的 error，我还没有使用过。可以查看 Compass用法指南 以获得更多了解。 此外，推荐 SASS基础——十个常见的Mixins。这篇文章总结了一些常用的 Mixin，更重要的是，通过这些Mixin，对 CSS 可以获得更深入的理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[神奇的CSS动画]]></title>
      <url>%2Fcss-animation%2F</url>
      <content type="text"><![CDATA[按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。 通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。 17.04.03更新：补充打字机动效。 transition 属性transition 是一个速记属性，有以下四个属性： transition-property：指定 CSS 属性的 name, transition 效果； transition-duration：transition 效果需要指定多少秒（或毫秒）才能完成； transition-timing-function：指定 transition 效果的转速曲线，包括五个模式：ease（渐慢，默认）、linear（匀速）、ease-in（加速）、ease-out（减速）、cubic-bezier 函数（自定义速度模式，可使用工具网站定制）； transition-delay：定义 transition 效果开始的时候。 123456789101112// 简写img&#123; transition: 1s 1s height ease;&#125;// 单独定义img&#123; transition-property: height; transition-duration: 1s; transition-delay: 1s; transition-timing-function: ease;&#125; 其中必须指定 transition-duration 属性，否则持续时间默认为 0 ，没有任何效果。 transition 的局限： 需要事件触发，没法在网页加载时自动发生； 一次性，除非一再触发，否则不能重复发生； 只能定义开始状态和结束状态（即只有两个状态），不能定义中间状态； 需要明确知道开始状态和结束状态的具体数值，才能计算中间状态； 一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。 keyframes（关键帧）animation 属性可以利用 keyframes 关键字定义动画的各个状态，将指定时间段内的动画划分的更为精细。 123456789@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125;div:hover &#123; animation: 1s rainbow infinite;&#125; 0% 可以用 from 表示，100% 可以用 to 表示： 12345@keyframes rainbow &#123; from &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; to &#123; background: yellowgreen; &#125;&#125; 如果省略某个状态，浏览器会自动推算中间状态。也可将多个状态写在一行。 123456789101112131415// 以下都为合法的写法@keyframes rainbow &#123; 50% &#123; background: orange &#125; to &#123; background: yellowgreen &#125;&#125;@keyframes rainbow &#123; to &#123; background: yellowgreen &#125;&#125;@keyframes pound &#123; from，to &#123; transform: none; &#125; 50% &#123; transform: scale(1.2); &#125;&#125; 从一个状态向另一个状态过渡，浏览器默认为平滑过渡。steps 函数可以实现分布过渡。 123div:hover &#123; animation: 1s rainbow infinite steps(10);&#125; animation 常用属性123456789101112131415// 简写div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125;// 单独定义div:hover&#123; animation-name: rainbow; animation-duration: 1s; ainmation-timing-function: linear; animation-delay: 1s; animation-fill-mode: forwards; animation-direction: normal; animation-iteration-count: 3;&#125; animation 有以下常用属性（其余和 transition 大致相似）： animation-iteration-count：指定动画播放次数，可指定为数值或 infinite（无限次）。 animation-direction：指定动画播放方向，默认为 normal。其他可选值有 reverse，alternate 和 alternate-reverse（后两种浏览器支持情况不佳）。 animation-fill-mode：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。有四个可选值： forwards：让动画停留在结束状态； none：回到动画没开始的状态； backwards：让动画回到第一帧的状态； both：根据 animation-direction 轮流应用 forwards 和 backwards 规则。 animation-play-state：指定动画播放突然终止时的状态，默认行为是跳回动画的开始状态。 12345678910// 让动画保持突然终止时的状态div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125; 浏览器支持IE 10、Firefox 16.0、Chrome 43.0、Safari 9.0、Opera 30.0 以上支持没有前缀的 animation。详见 CSS3 animation（动画） 属性 “浏览器支持”部分。 使用示例打字机动效依照 让页面动起来 实现的打字机动效。图片素材为自制，因此部分数据与参照有出入。素材及代码见 bighuang624/Front-end_Learning/打字机动效。 （gif图没搞好…） 参考资料CSS动画简介 - 阮一峰的网络日志 CSS3 animation（动画） 属性 CSS 变换 过渡 动画使用案例 补充： css3 animation 属性众妙]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究JS中的词法作用域]]></title>
      <url>%2Fjs-lexical-scope%2F</url>
      <content type="text"><![CDATA[这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 JavaScript 语言精粹 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 箭头函数 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。” 这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。 词法作用域《JavaScript 权威指南》第5章“8.8.1 词法作用域”中对“词法作用域”的解释如下： “JavaScript 中的函数是通过词法来划分作用域的，而不是动态地划分作用域的。这意味着它们在定义它们的作用域里运行，而不是在执行它们的作用域里运行。当定义了一个函数，当前的作用域链就保存起来，并且成为函数的内部状态的一部分。” 当然，这几句话还是玄之又玄，摸不着头脑。它还是没有具体解释“词法作用域”中的“词法”二字代表什么。不过我这学期的《编译原理》课程上经常见到这个词：编译过程被划分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成 6 个阶段（清华大学出版社《编译原理》）。在查阅资料后，我确信这个概念确实与编译有关。 JavaScript 引擎在代码执行前会对其进行编译，而所谓的词法作用域指作用域是由书写代码时函数声明的位置决定，在词法解析阶段就已经确定，之后不会改变。也就是说，JS 中的“词法作用域”等同于静态作用域，即与动态作用域（运行时确定）相对。 词法作用域关注函数在何处声明；而动态作用域关注函数从何处调用，其作用域链是基于运行时的调用栈的。换言之，在遇到既不是形参也不是函数内部定义的局部变量的变量时，词法作用域的函数会去函数定义时的环境中查询；而动态作用域的函数会到函数调用时的环境中查询。 一个例子： 1234567891011function foo()&#123; print a;&#125;function bar()&#123; var a = 1; foo();&#125;var a = 2;bar(); 采用词法作用域的语言会从函数定义位置开始向上层查找，最后输出 2。 而采用动态作用域的语言会输出 1。 顺便一提，在 JS 中eval和with可以产生动态作用域的效果。但《JavaScript 高级程序设计》不推荐使用此二者。 强调与补充函数的作用域基于函数定义的位置。 为了去实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数逻辑的代码，除此之外还包含当前作用域链的引用。函数对象可以通过这个作用域链相互关联起来。 如此，函数体内部的变量都可以保存在函数的作用域内，在程序语言范畴内这被称为闭包。而我们常说的闭包是指让外部函数访问到内部的变量，也就是说，按照一般的做法，是使内部函数返回一个函数，然后操作其中的变量。这样做的话一是可以读取函数内部的变量，二是可以让这些变量的值始终保存在内存中。 这时，调用函数的时候闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链。 参考资料：动态作用域和词法域的区别是什么？- 知乎 JavaScript深入之词法作用域和动态作用域 · Issue #3 · mqyqingfeng/Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在把玩中学习——typewriter.js]]></title>
      <url>%2Ftypewriter%2F</url>
      <content type="text"><![CDATA[大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。 好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。 这个有打字和仿光标闪烁效果的 typewriter.js 好像是我在看什么“程序员表白利器”时加到收藏夹里的。现在学习了 js，敢看看源码了，发现 js 代码只有20行不到。作者说：“原生JavaScript就是这么牛。”确实是这样的。虽然效果也很简单，但也能从里面学到一些东西。 HTML 源代码（大致结构）： 1234567891011121314&lt;body&gt; &lt;div id="mainDiv"&gt; &lt;div id="content"&gt; &lt;div id="code"&gt; &lt;span class="comments"&gt;/**&lt;/span&gt;&lt;br /&gt; &lt;span class="space"/&gt;&lt;span class="comments"&gt;* We are both XXX Unversity business administration and programmers,&lt;/span&gt;&lt;br /&gt; &lt;span class="space"/&gt;&lt;span class="comments"&gt;* so I write some code to show my love to you.&lt;/span&gt;&lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; document.getElementById("code").typewriter(); &lt;/script&gt;&lt;/body&gt; JavaScript 源代码： 12345678910111213141516171819Element.prototype.typewriter=function(a)&#123; var d = this, c = d.innerHTML, b = 0; d.innerHTML=""; var e = setInterval(function() &#123; var f = c.substr(b, 1); if (f == "&lt;") &#123; b = c.indexOf("&gt;", b) + 1 &#125; else &#123; b++ &#125; d.innerHTML=c.substring(0, b) + (b &amp; 1 ? "_" : ""); if (b &gt;= c.length) &#123; clearInterval(e) &#125; &#125;, 75) return this &#125; 在这份 js 代码中可以学习的点： 原型模式定义方法：给 Element 添加实例方法typewriter()（在 html 文件中调用），这里有一个参数 a，实际上没什么用。顺便一说，源码在 head 处引入了 js 文件，这是为了先加载 js 文件。如果按照代码规范将引入放在 body 部分的最后，则有一瞬间所有字先出现再消失，不符合效果要求。可见代码规范也要根据实际来遵守。 声明三个变量，d 保存当前对象（”code”）。这个操作是必要的，因为后面要给 “code” 的 innerHTML 赋值的时候有时在函数作用域中，this 取不到 “code”。 代码逻辑很清晰，包括对标签的处理、光标效果的实现和定时器的清除等。要对自己想要实现的效果有一个全面的认知和大致的构思再开始写代码。 末尾return this以支持链式操作。 想要用功能强大的JavaScript实现一些小效果不难，但是怎样一步步规划、修改到实现对现在的我来说还是比较有挑战性的。希望自己能在欣赏、借鉴、吸收的过程中去实现一些有趣的 demo，重拾对代码的兴趣和创造力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（五）]]></title>
      <url>%2FJS-notes-5%2F</url>
      <content type="text"><![CDATA[今天看了看LESS。前端要研究的东西确实有点多，压力有点大。而且发现自己动手写代码的水平也有待提高。从今天开始理论学习要给实践让让路了，加油加油。 这篇博文总结了《JavaScript高级程序设计》的20~21章：JSON、AJAX与Comet。此外，关于CORS的部分还参考了廖雪峰的JavaScript教程。 JSONJSON是一种数据格式。虽然有相同的语法形式，但JSON不从属于JavaScript。很多编程语言都有针对JSON的解析器和序列化器。 语法1.JSON的语法可以表示三种类型的值：简单值、对象、数组。 2.简单值：可表示字符串、数值、布尔值和 null，但不支持 undefined。JSON字符串必须使用双引号。 3.对象：表示一组无序的键值对。没有声明变量（JSON中没有变量概念），没有末尾分号，对象属性名必须加双引号。 12345678&#123; &quot;name&quot;: &quot;Kyon&quot;, &quot;age&quot;: 20, &quot;school&quot;: &#123; &quot;name&quot;: &quot;Wuhan University&quot;, &quot;major&quot;: &quot;Software Engineering&quot; &#125;&#125; 4.数组：表示一组有序的值的列表，可以通过数值索引来访问其中的值。 解析与序列化5.JSON对象有两个方法：stringify()把JavaScript对象序列化为JSON字符串，parse()把JSON字符串解析为原生JavaScript值。 6.JSON.stringify()还可以接收另外两个参数：第一个参数是个过滤器（数组：结果中只包含数组列出的属性；函数：传入的函数接收两个参数，属性名和属性值，根据属性名判断如何处理属性）；第二个参数控制结果中的缩进和空白符，数值表示缩进空格数，字符串被用作缩进字符。 7.toJSON：自定义序列化。 123456789var person = &#123; &quot;name&quot;: &quot;Kyon&quot;, age: 20, toJSON: function()&#123; return this.name; &#125;&#125;;var jsonText = JSON.stringify(person); 8.JSON.parse()还可以接受一个参数：将在每个键值对上调用的还原函数（与JSON.stringify()的过滤函数相同）。 AJAX与CometAjax 技术的核心是 XMLHttpRequest 对象（简称 XHR）。可以使用 XHR对象取得新数据，然后再通过 DOM 将新数据插入到页面中，无须刷新页面即可从服务器取得数据。 XMLHttpRequest 对象1.用法： 123456789101112131415161718192021var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; console.log(xhr.responseText); &#125; else &#123; console.log(&apos;Request was unsuccessful: &apos; + xhr.status); &#125; &#125;&#125;;// GET请求xhr.open(&apos;get&apos;, &apos;example.php&apos;);xhr.send(null);// POST请求xhr.open(&apos;open&apos;, &apos;postexample.php&apos;);xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);var form = document.getElementById(&apos;user-info&apos;);xhr.send(serialize(form));// 将ID为user-info的表单中数据序列化后发送给服务器 创建XHR对象：new XMLHttpRequest(); open()：启动一个请求以备发送。接收三个参数：请求类型（”get”、”post”等）、请求的URL、是否异步发送请求（默认是true，一定不能为false，否则必须等到服务器响应后再继续执行）。 send()：发送请求。GET请求不需要参数，POST请求要把body部分字符串或者FormData对象传进去。 2.XHR对象的属性： responseText：返回的文本； status：响应的HTTP状态； 3.HTTP状态码： 2xx：成功； 3xx：重定向，304 Not Modified 表示请求的资源没有被修改，可以直接用浏览器缓存的版本，302 Found 表示请求的资源现在临时从不同的URI响应请求； 4xx：客户端错误，403 Forbidden，404 NotFound； 5xx：服务器错误，500 Internal Server Error，503 Service Unavailable。 4.XHR的 readyState 属性：表示请求/响应过程的当前活动阶段： 0：未初始化； 1：启动，已调用open()，未发送； 2：发送，已调用send()，未收到响应； 3：接收到部分响应数据； 4：接收到全部响应数据。 5.readystatechange事件：readystate属性的值由一个值变成另一个值，都会触发readystatechange事件。 跨源资源共享6.跨域安全策略：XHR对象只能访问与包含它的页面位于同一个域的资源（域名、协议、端口号都要相同）。 7.CORS（跨源资源共享）：HTML5规范定义的如何跨域访问资源。当JavaScript 向外域发起请求后，浏览器收到响应后首先检查Access-Control-Allow-Origin是否包含本域。如果不是，请求失败，JavaScript 无法获取到响应的任何数据。 跨域是否成功，取决于对方服务器是否给本域设置一个正确的Access-Control-Allow-Origin。 以上“简单请求”包括GET、HEAD和POST（POST的Content-Type类型仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头。 对于PUT、DELETE以及其他类型如application/json的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受： 1234OPTIONS /path/to/resource HTTP/1.1Host: bar.comOrigin: http://my.comAccess-Control-Request-Method: POST 服务器必须响应并明确指出允许的Method： 1234HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONSAccess-Control-Max-Age: 86400 浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。 其他跨域技术8.图像Ping：与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。 对于 1234567var img = new Image();img.onload = img.onerror = function()&#123; console.log(&quot;Done!&quot;);&#125;;// onload和onerror事件处理程序指定为同一函数，请求完成时无关响应得到通知img.src = &quot;http://www.example.com/test?name=Nicholas&quot;;// 请求从设置src属性那一刻开始 两个主要缺点：只能发送GET请求；无法访问服务器的响应文本。因此只能用于浏览器与服务器间的单向通信。 9.JSONP（JSON with padding）：包含在函数调用中的JSON。由回调函数和数据组成。只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上利用了浏览器允许跨域引用JavaScript资源。 1234567891011121314151617181920212223// 得到的返回refreshPrice(&#123;&quot;0000001&quot;:&#123;&quot;code&quot;:&quot;0000001&quot;, ...&#125;&#125;);// 在页面中准备好回调函数function refreshPrice(data)&#123; var p = document.getElementById(&apos;test-jsonp&apos;); p.innerHTML = &apos;当前价格：&apos; + data[&apos;0000001&apos;].name + &quot;：&quot; + data[&apos;0000001&apos;].price;&#125;// 触发function getPrice()&#123; var js = document.createElement(&apos;script&apos;), head = document.getElementByTagName(&apos;head&apos;)[0]; self = document.getElementById(&apos;dynamic-jsonp&apos;); if(self)&#123; var parent = self.parentElement; parent.removeChild(self); &#125; js.id = &apos;dynamic-jsonp&apos;; js.src = &apos;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&apos;; head.appendChild(js);&#125; 缺点：从其他域中加载代码执行，安全性不可靠；不易确定请求是否失败。 10.Comet：对AJAX的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现Comet的手段主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，只有部分浏览器原生支持HTTP流。 补充：轮询是指通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器是否有新消息。缺点：(1)实时性不够；(2)频繁请求会给服务器带来极大压力。 11.SSE（服务器发送事件）：一种实现Comet交互的浏览器API，既支持长轮询，也支持HTTP流。 12.Web Sockets：目标是在一个单独的持久连接上提供全双工、双向通信。使用一种专为快速传输小数据设计的自定义协议。 安全13.为确保通过XHR访问的URL安全，通行做法是验证发送请求者是否有权限访问响应的资源。有下列方式： 要求以SSL连接来访问可以通过XHR请求的资源。 要求每一次请求都要附带经过相应算法计算得到的验证码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（四）]]></title>
      <url>%2FJS-notes-4%2F</url>
      <content type="text"><![CDATA[花旗杯的团队已经组好了。自己要加快学习进度，保证不拖组织的后腿。全力以赴，尽善尽美，希望最后能够有好的成绩。 这篇博文总结了《JavaScript高级程序设计》的13~14章：事件，表单脚本。 事件事件流1.事件流描述从页面接收事件的顺序。IE提出事件冒泡流，Netscape提出事件捕获流。 2.事件冒泡：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。 3.事件捕获：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。由于老版本浏览器不支持，不推荐使用。 4.“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件处理程序5.HTML事件处理程序：扩展作用域，在函数内部可以像访问局部变量一样访问document及该元素本身的成员。 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(value)&quot;&gt; 如果是一个表单输入元素，则作用域中还会包含访问表单元素的入口。 1234&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Echo username&quot; onclick=&quot;console.log(username.value)&quot;&gt;&lt;/form&gt; 缺点：(1)存在时差问题，函数被解析之前就触发事件会引发错误；(2)扩展处理程序的作用域链在不同浏览器中会导致不同结果；(3)HTML和JavaScript代码紧密耦合。 6.DOM0级事件处理程序：每个元素都有自己的事件处理程序属性，将其设置为一个函数，就可以指定事件处理程序。 12345678// 绑定事件处理程序var btn = document.getElementById("myBtn");btn.onclick = function()&#123; console.log(this.id); // "myBtn"&#125;;// 删除事件处理程序btn.onclick = null; 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 7.DOM2级事件处理程序：addEventListener()和removeEventListener()，接受3个参数：要处理的事件名、事件处理程序函数和一个布尔值（true表示在捕获阶段调用事件处理程序，默认为false表示冒泡阶段调用）。 移除时传入的参数与添加处理程序时使用的参数相同，意味着通过addEventListener()添加的匿名函数无法移除。 123byn.addEventListener(&quot;click&quot;, handler, false);...btn.removeEventListener(&quot;click&quot;, handler, false); // 有效 8.IE事件处理程序：attachEvent()和detachEvent()，接收两个参数：要处理的事件名、事件处理程序函数。事件处理程序被添加到冒泡阶段，在全局作用域中运行（this 等于 window）。支持IE事件处理程序的浏览器有 IE 和 Opera。 事件对象9.在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息。只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。 10.属性/方法： currentTarget：正在处理事件的那个元素。 target：事件的目标。 type：事件类型。 cancelable：可以阻止特定事件的默认行为。 preventDefault()：阻止特定事件的默认行为。 stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。 eventPhase：调用事件处理程序的阶段：捕获阶段为1，处于目标对象为2，冒泡阶段为3。 事件类型11.“DOM3级事件”规定了以下几类事件： UI（用户界面）事件，当用户与页面上的元素交互时触发：load、unload、resize、scroll。 焦点事件，当元素获得或失去焦点时触发。 鼠标与滚轮事件：click、dblclick、mousedown、mouseenter、mouseleave、mouseout、mouseover、mouseup。 键盘与文本事件：keydown、keypress、keyup、textInput。 复合事件，用于处理IME（输入法编辑器，让用户输入在物理键盘上找不到的字符）的输入序列。 变动事件，当DOM中的某一部分发生变化时给出提示。 内存和性能to be continued.. 表单脚本to be continued..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（三）]]></title>
      <url>%2FJS-notes-3%2F</url>
      <content type="text"><![CDATA[稍微大致翻了一下这本书后续的内容。为了尽快的进入ES6以及框架部分的学习，决定暂时跳过某些章节的学习。后面打算学习的章节有6、7、13、14、20、21、22、24章，剩下的章节等到用到或者时间富余的时候再看。 这篇博文总结了《JavaScript高级程序设计》的6~7章：面向对象的程序设计，以及函数表达式。 面向对象的程序设计理解对象1.ECMAScript中有两种属性：数据属性和访问器属性。 特性：描述属性的各种特征。目的是实现JavaScript，因此在JavaScript中不能直接访问。为了表示特性是内部值，放在两对方括号中，例如[[Enumerable]]。 2.数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。默认为 true。 [[Writable]]：表示能否修改属性的值。默认为 true。 [[Value]]：包含这个属性的数据值。默认为 undefined。 Object.defineProperty()方法可以修改属性默认的特性。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable、enumerable、writable 和 value 中的一或多个。 3.访问器属性： [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。默认为 true。 [[Get]]：在读取属性时调用的函数。默认为 undefined。 [[Set]]：在写入属性时调用的函数。默认为 undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 12345678910111213141516171819var book = &#123; _year: 2016, // 下划线表示只能通过对象方法访问的属性 edition: 1&#125;;Object.defineProperty(book, "year", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue) &#123; if(newValue &gt; 2016) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;); // year 是访问器属性book.year = 2017;console.log(book.edition); // 2 4.定义多个属性可用Object.defineProperties()方法。 123456789101112131415161718192021var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2016 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2016)&#123; this._year = newValue; this.edition += newValue - 2016; &#125; &#125; &#125;&#125;); Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符。 1234var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);console.log(descriptor.value); // 2016console.log(descriptor.configurable); // falseconsole.log(typeof descriptor.get); // &quot;undefined&quot; 创建对象5.工厂模式：虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题。 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () &#123; console.log(this.name); &#125; return o;&#125;var p1 = createPerson(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = createPerson(&apos;Someone&apos;, 19, &apos;Lawyer&apos;); 6.构造函数模式：以大写字母开头。 1234567891011121314function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;;&#125;var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);// 对象的constructor属性指向其构造函数console.log(p1.constructor); // function Person(name, age, job)&#123;... 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。 也可以使用call()（或者apply()）在某个特殊对象的作用域中调用构造函数，调用后这个对象就拥有了所有属性和方法。 123var o = new Object();Person.call(o, &apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);o.sayName(); // &apos;Kyon&apos; 使用构造函数的主要问题：每个方法都要在每个实例上重新创建一遍。 1console.log(p1.sayName === p2.sayName); // false 7.原型模式：每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向函数的原型对象。这个对象包含可以由该类型的所有实例共享的属性和方法。 1234Person.prototype.sayName = function()&#123; console.log(this.name);&#125;console.log(p1.sayName === p2.sayName); // true 理解原型对象： – 只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，指向函数的原型对象。 – 默认所有原型对象都会获得一个 constructor 属性，指向 prototype 属性所在函数。 – 当调用构造函数创建一个新实例后，实例将有一个 __proto__属性，指向构造函数的原型对象，指针叫[[Prototype]]，默认原型指向Object。 – 实例和构造函数没有直接关系。 – 读取属性：搜索先从对象实例本身开始，如果没找到，搜索原型对象。 – 使用isPrototype()来检测构造函数和实例之间是否有关系。 – Object.getPrototypeOf()返回[[Prototype]]的值。 – 使用hasOwnProperty()来检测属性存在于实例中还是原型中。 123456789101112131415161718192021222324function Person()&#123;&#125;Person.prototype.name = &apos;Kyon&apos;;Person.prototype.age = 29;Person.prototype.job = &apos;Software Engineer&apos;;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var p1 = new Person();var p2 = new Person();console.log(Person.prototype.isPrototypeOf(p1)); // trueconsole.log(Object.getPrototypeOf(p1) === Person.prototype); // trueconsole.log(Object.getPrototypeOf(p1).name); // &apos;Kyon&apos;console.log(p1.hasOwnProperty(&quot;name&quot;)); // falsep1.name = &quot;someone&quot;;console.log(p1.hasOwnProperty(&quot;name&quot;)); // truedelete p1.name;console.log(p1.hasOwnProperty(&quot;name&quot;)); // false 原型与 in 操作符：在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 1console.log(&apos;name&apos; in p1); // true 更简单的原型语法：用一个包含所有属性和方法的对象字面量来重写整个原型对象。 1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, // 默认的 prototype 对象被重写，需设置 name: &apos;Kyon&apos;, age: 20, job: &apos;Software Engineer&apos;, sayName: function()&#123; console.log(this.name); &#125;&#125;; 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍是最初的原型。 原生对象的原型：通过原生对象的原型可以定义新方法。不推荐，可能导致命名冲突或意外重写原生方法。 原型对象的问题：包含引用类型值的属性会被共享。 8.组合使用构造函数模式和原型模式：创建自定义类型最常见方式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。 123456789101112131415161718192021// 组合使用构造函数模式与原型模式function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Sam&quot;, &quot;Judie&quot;];&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; console.log(this.name); &#125;&#125;var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);p1.friends.push(&quot;Vue&quot;);console.log(p1.friends); // &quot;Sam, Judie, Vue&quot;console.log(p2.friends); // &quot;Sam, Judie&quot;console.log(p1.sayName === p2.sayName); // true 9.动态原型模式、寄生构造函数模式、稳妥构造函数模式 继承10.许多OO语言都支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际方法）。由于函数没有签名，ECMAScript 中无法实现接口继承，而实现继承主要依靠原型链实现。 11.原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法。 12.p182开始 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.color = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125; function SubType(name, age) &#123; SuperType.call(this, name); // 借用构造函数 this.age = age;&#125;SubType.prototype = new SuperType(); // 原型链SubType.prototype.constructor = SubType; // construcotr在上一句中被重写SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125; var instance = new SubType(&apos;Kyon&apos;, 20);instance.sayName(); // Kyoninstance.sayAge(); // 20 说实话，这部分看得我脑壳疼。要不我们直接用ES6引入的class可好？等我哪一天沐浴更衣虔诚焚香再来看… 函数表达式递归1.在严格模式下，不能通过脚本访问arguments.callee来实现递归。可以用命名函数表达式来实现。 1234567var factorial = (function f(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;); 闭包2.闭包是指有权访问另一个函数作用域中的变量的函数（匿名函数的 function 关键字后没有标识符，二者不能混用）。 3.创建闭包的常见方式：在一个函数内部创建另一个函数。 123456789function outer()&#123; var name = &quot;Kyon&quot;; return function()&#123; console.log(name); &#125;&#125;var inner = outer();inner(); // Kyoninner = null; // 解除对outer内部的匿名函数的引用，以释放内存 在外部函数内部定义的内部函数将外部函数的活动对象（作为变量对象使用）添加到它的作用域链中；外部函数执行完毕后，其活动对象不会被销毁，因为内部函数的作用域链仍在引用这个活动对象；外部函数执行完毕后，内部函数仍然可以访问到其定义的所有变量。 4.由于闭包会携带包含它的函数的作用域，过度使用可能导致内存占用过多，要慎重使用。 5.返回的函数并没有立刻执行，而是等到调用f()才执行。因此返回函数不能引用任何循环变量，或者后续会发生变化的变量。 12345678910111213141516171819function count()&#123; var arr = []; for(var i=1; i&lt;=3; i++)&#123; arr[i] = function()&#123; return i * i; &#125;; &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];// 返回的函数引用了变量i，但并非立即执行。执行时i已变成4f1(); // 16f2(); // 16f3(); // 16 一定要引用循环变量的方法：再创建一个匿名函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。 123456789101112function count()&#123; var arr = []; for(var i=1; i&lt;=3; i++)&#123; arr[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125;// i的当前值复制给参数num，匿名函数内部又创建并返回一个访问num的闭包，使得result数组中的每个函数都有自己num变量的一个副本 这里用了一个“创建一个匿名函数并立即执行”的语法： 123(function(x)&#123; return x * x;&#125;)(3); // 9 6.闭包中使用 this 对象：匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getName: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getName()); // &quot;The Window&quot;(非严格模式) 把外部作用域中的 this 对象保存在一个闭包能够访问的变量中，就可以让闭包访问该对象了（想访问作用域中的 arguments对象同理）。 12345678910111213var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getName: function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getName()); // &quot;My Object&quot; 7.补充：利用闭包可以实现私有变量的封装。 1234567891011121314151617181920// 用JavaScript创建一个计数器&apos;use strict&apos;;function create_counter(initial)&#123; var x = initial || 0; return &#123; inc: function()&#123; x += 1; return x; &#125; &#125;&#125;// 使用var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12 模仿块级作用域8.用匿名函数模仿块级作用域： JavaScript将 function 关键字当作一个函数声明的开始，而函数声明后不能加圆括号。 将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随的另一对圆括号会立即调用这个函数。 1234567(function()&#123; // 这里是块级作用域&#125;)();function()&#123; // 这里是块级作用域&#125;(); ／／ Error! 9.这种技术经常用于限制向全局作用域中添加过多的变量和函数；同时可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。 123456(function()&#123; var now = new Date(); if(now.getMonth() == 11 &amp;&amp; now.getDate() == 25)&#123; console.log(&quot;Merry Christmas!&quot;); &#125;&#125;)(); 私有变量10.任何在函数中定义的变量，都可以认为是私有变量。 11.有权访问私有变量和私有函数的公有方法被称为特权方法。两种在对象上创建特权方法的方式： 1234567891011121314151617181920212223242526// 1.构造函数中定义特权方法function MyObject()&#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc()&#123; return false; &#125; // 特权方法 this.publicMethod = function()&#123; privateVar++; return privateFunc(); &#125;;&#125;// 2.利用私有和特权成员function Person()&#123; this.getName = function()&#123; return name; &#125;; this.setName = function(value)&#123; name = value; &#125;;&#125; 12.可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（二）]]></title>
      <url>%2FJS-notes-2%2F</url>
      <content type="text"><![CDATA[继续记录在读《JavaScript高级程序设计》时的零碎知识点。这几天在知乎上看到了别人使用 Electron 构建桌面应用，感觉还蛮有意思的。有兴趣的同学可以看看使用 Electron 构建桌面应用和用 ReactJs 创建Mac版的 keep了解一下。也许在加深对JS的理解后，我也会选择用 Electron 做一个应用呢。Who knows? 这篇博文总结了《JavaScript高级程序设计》的4~5章：变量、作用域和内存问题，以及引用类型。 变量、作用域和内存问题基本类型和引用类型的值1.基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；引用类型的值是对象，保存在堆内存中。 2.当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。 3.从一个变量向另一个变量复制基本类型的值时，会创建这个值的一个副本；从一个变量向另一个变量复制引用类型的值时，复制的是指向存储在堆中的一个对象的指针，复制之后两个变量指向同一个对象。 123456789var n1 = 1;var n2 = n1;n1 = 2;console.log(n2); // 1var o1 = &#123;&#125;;var o2 = o1;o1.name = &apos;Kyon&apos;;console.log(o2.name); // Kyon 4.参数只能按值传递： 123456789function setName(obj)&#123; obj.name = &apos;Kyon&apos;; obj = new Object(); obj.name = &apos;Huang&apos;;&#125;var person = new Object();setName(person);console.log(person.name); // Kyon 在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 5.typeof检测基本数据类型，instanceof检测引用类型（根据其原型链来识别）。 执行环境及作用域6.每个执行环境（简称为环境，可以理解为作用域）都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。每个函数都有自己的执行环境，全局执行环境（在Web浏览器中为window对象）是最外围的一个执行环境。 7.当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返还给之前的执行环境。 8.当代码在一个环境中执行时，会创建变量对象的一个作用域链，用于保证对执行环境有权访问的所有变量和函数的有序访问（搜索）。作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。 9.标识符解析：沿着作用域链一级一级地搜索标识符的过程。从作用域链的前端开始，逐级向后回溯，直到找到标识符为止（找不到通常导致错误）。 10.内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 11.延长作用域链：当执行流进入 try-catch 语句的 catch 块或 with 语句时，作用域链就会得到加长。这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到作用域链中；对 catch 语句，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 12.JavaScript 没有块级作用域，但有函数作用域（针对var）。 补充：在语法中的块级作用域是指if/else/for/while语句里2个大括号之间的部分。块级作用域里面定义的函数和变量在{}外部是可以被访问到的。但是函数就不行，比如你在函数体里面定义一个变量，那么函数执行完毕之后里面的变量就会直接被销毁，在函数体外部是不可能被访问到的。 再补充：ES6标准引入了新的关键字 let 和 const。它们都具有块级作用域。 垃圾收集13.JavaScript 具有自动垃圾收集机制，原理：垃圾收集器按照固定的时间间隔（或代码执行中预定的收集时间）释放不再继续使用的变量所占用的内存。 14.最常用的垃圾收集方式是标记清除：垃圾回收器在运行时会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记，而在此之后还有标记的变量被视为准备删除的变量，因为这些变量无法被访问到了。 此外，引用计数是另一种不太常用的垃圾收集策略，这种算法的思想是跟踪记录所有值被引用的次数。当代码中存在循环引用现象时，“引用计数”算法就会导致问题。JavaScript 引擎目前都不再使用这种算法，但IE访问非原生 JavaScript 对象（如DOM元素）时仍可能导致问题。 15.管理内存：优化内存占用的最佳方式为解除引用——一旦数据不再有用，通过将其值设置为null来释放其引用。解除引用的真正作用是让其值脱离执行环境，以便垃圾搜集器下次运行时将其回收，而并非自动回收该值所占的内存。 引用类型引用类型的值（对象）是引用类型的一个实例。 Object类型1.创建Object实例的两种方式：Object构造函数；对象字面量表示法。通过对象字面量定义对象时，实际不会调用Object构造函数（Firefox 2 及更早版本除外）。 12345678var person = new Object();person.name = &quot;Kyon&quot;;person.age = 19;var person = &#123; name : &quot;Kyon&quot;, age : 19&#125;; 2.访问对象属性常用点表示法，也可使用方括号表示法。除非必须用变量来访问属性，否则建议使用点表示法。 1234567console.log(person.name); // 点表示法console.log(person[&quot;name&quot;]); // 方括号表示法var propertyName = &quot;name&quot;;console.log(person[propertyName]);console.log(person[&quot;first name&quot;]); Array类型3.ECMAScript 数组的每一项可以保存任何类型的数据，并且大小可以动态调整。 4.创建数组的两种基本方式：使用Array构造函数；使用数组字面量表示法。通过数组字面量表示法时，实际不会调用Array构造函数（Firefox 3 及更早版本除外）。 123456var colors = new Array();var colors = new Array(20);var colors = new Array(&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;); var colors = [];var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]; 5.length：利用length属性可以方便地在数组末尾添加新项： 12var colors = [&quot;red&quot;, &quot;blue&quot;];colors[colors.length] = &quot;green&quot;; 6.Array.isArray()：ECMAScript新增Array.isArray()确定某个值是否数组，其解决了存在两个以上全局执行环境时instanceof检测结果出错的情况。 7.数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。 123var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];console.log(colors.join(&quot;,&quot;)); //red,green,blueconsole.log(colors.join(&quot;||&quot;)); //red||green||blue 8.栈方法和队列方法： push()添加一项到数组末尾； pop()移除数组末尾一项； shift()移除数组第一项； unshift()添加一项到数组前端。 9.重排序方法： reverse()翻转数组项的顺序； sort()默认将数组项转换成字符串后按升序排列（可以接收一个比较函数作为参数，第一个参数应位于第二个之前则返回一个负数）。 123456789var a = [0, 1, 15, 10, 5];a.sort();console.log(a); // [0, 1, 10, 15, 5]function compare(value1, value2)&#123; return value1 - value2;&#125;a.sort(compare);console.log(a); // [0, 1, 5, 10, 15] 10.操作方法： concat()：添加项 123var a1 = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];var a2 = a1.concat(&apos;yellow&apos;, [&apos;black&apos;, &apos;brown&apos;]);console.log(a2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;] slice()：截取 123var a = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;black&apos;, &apos;brown&apos;];console.log(a.slice(1), a.slice(1,4)); // [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;][&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;] splice()：删除插入替换 123var a = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;black&apos;, &apos;brown&apos;];console.log(a.splice(2, 1), a); // [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;][&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;] 11.位置方法：indexOf()和lastIndexOf()都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。indexOf()从数组开头（位置0）向后查找，lastIndexOf()从数组末尾向前查找。 12345var a = [&quot;red&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];console.log(a.indexOf(&apos;red&apos;)); // 0console.log(a.lastIndexOf(&apos;red&apos;)); // 4console.log(a.indexOf(&apos;red&apos;, 1)); // 4console.log(a.lastIndexOf(&apos;red&apos;, 1)); // 0 12.迭代方法：每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。给定函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。 every()：如果给定函数对每一项都返回true，则返回true。 filter()：返回给定函数会返回true的项组成的数组。 foreach()：这个方法没有返回值。 map()：返回每次函数调用的结果组成的数组。 some()：如果给定函数对任一项返回true，则返回true。 1234567891011121314151617181920212223242526var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = a.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);console.log(everyResult); // falsevar filterResult = a.filter(function()&#123; return (item &gt; 2);&#125;);console.log(filterResult); // [3, 4, 5, 4, 3]var forEachResult = a.forEach(function(item, index, array)&#123; console.log(item);&#125;);console.log(forEachResult); // undefinedvar mapResult = a.map(function(item, index, array)&#123; return (item * 2);&#125;);console.log(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2]var someResult = a.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);console.log(someResult); // true 13.归并方法：都会迭代数组的所有项，然后构建一个最终返回的值。都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。给定函数接收4个参数：前一个值、当前值、项的索引和数组对象。 12345678910111213var a = [1, 2, 3, 2, 1];var sum1 = a.reduce(function(prev, cur, index, array)&#123; console.log(index); // 1 2 3 4 return prev + cur;&#125;); console.log(sum1); // 9var sum2 = a.reduceRight(function(prev, cur, index, array)&#123; console.log(index); // 3 2 1 0 return prev + cur;&#125;);console.log(sum2); // 9 Date类型12.创建日期对象：月份基于0（一月是0，二月是1，以此类推）。123var d1 = new Date();var d2 = new Date(2017, 2, 3, 15, 33, 33); // 2017年3月3日下午3点33分33秒 13.获取调用时的日期和时间和毫秒数，可以用来分析代码。1234var start = Date.now();doSomething();var stop = Date.now();var result = stop - start; 14.日期格式化方法：local表示以特定于地区的格式显示。1234567var d2 = new Date(2017, 2, 3, 15, 33, 33);d2.toString(); // &quot;Fri Mar 03 2017 15:33:33 GMT+0800 (CST)&quot;d2.toDateString(); // &quot;Fri Mar 03 2017&quot;d2.toTimeString(); // &quot;15:33:33 GMT+0800 (CST)&quot;d2.toLocaleString(); // &quot;2017/3/3 下午3:33:33&quot;d2.toLocaleDateString(); // &quot;2017/3/3&quot;d2.toLocaleTimeString(); // &quot;下午3:33:33&quot; RegExp类型15.pattern：正则表达式；flags：标志，表明正则表达式的行为。g全局模式，i不区分大小写，m多行模式。12var exp1 = /pattern/flagsvar exp2 = new RegExp(&apos;pattern&apos;,&apos;flags&apos;); 16.RegExp实例方法： exec()专门为捕获组而设计，返回第一个匹配项信息的数组（或 null），数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。包含两个额外的属性：index 和 input。 123456789var text = &quot;mom and dad and baby&quot;;var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // &quot;mom and dad and baby&quot;console.log(matches[0]); // &quot;mom and dad and baby&quot;console.log(matches[1]); // &quot; and dad and baby&quot;console.log(matches[2]); // &quot; and baby&quot; test()接收一个字符串参数，在模式与该参数匹配的情况下返回 true，否则返回flase。 123456var text = &quot;1234-56-7890&quot;;var pattern = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if(pattern.test(text))&#123; console.log(&quot;The pattern was matched.&quot;);&#125; 17.RegExp构造函数属性：适用于作用域中的所有正则表达式，记录一些最近一次正则表达式操作的信息。 12345678910111213var text = &quot;This has been a short summer&quot;;var pattern = /(.)hort/g;// Opera 不支持 input、lastMatch、lastParen 和 multiline 属性// IE 不支持 multiline 属性if(pattern.test(text))&#123; console.log(RegExp.input); // This has been a short summer console.log(RegExp.leftContext); // This has been a console.log(RegExp.rightContext); // summer console.log(RegExp.lastMatch); // short console.log(RegExp.lastParen); // s console.log(); // false &#125; Function类型18.函数实际上是 Function 类型的实例，因此函数也是对象。 12345678910111213 // 使用函数声明语法function f1 (n1, n2) &#123; return n1 + n2;&#125; // 使用函数表达式var f2 = function (n1, n2) &#123; return n1 + n2;&#125;; // 使用构造函数，不推荐（会导致解析两次代码，影响性能）var f3 = new Function(&apos;n1&apos;, &apos;n2&apos;, &apos;return n1 + n2&apos;); 19.函数名是一个指向函数对象的指针，因此 ECMAScript 中没有函数重载。 20.函数声明与函数表达式：解析器会率先通过名为函数声明提升的过程，读取并将函数声明添加到执行环境中，使其在执行任何代码之前可用。 而函数表达式必须等到解析器执行到它所在的代码行，才会真正被解析执行。 1234567891011 console.log(sum(10, 10));function sum(num1, num2)&#123; return num1 + num2;&#125;// 把函数声明改为等价的函数表达式，会在执行期间导致错误console.log(sum(10, 10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;; 21.函数内部属性：callee、this、caller。 arguments 有 callee 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。可用于递归中消除紧密耦合现象。 123456789 console.log(sum(10, 10));function factorial(num)&#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; this 引用的是函数据以执行的环境对象。 caller 属性保存着调用当前函数的函数的引用（如果在全局作用域中调用当前函数，它的值为 null）。 1234567891011 function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller); // 为了实现更松散的耦合，也可以用 arguments.callee.caller 访问相同的信息&#125;outer(); // 打印 outer() 函数的源代码 严格模式下访问 arguments.callee 和 arguments.caller 会导致错误，且不能为函数的 caller 属性赋值。 22.函数属性：length 和 prototype。 length 属性表示函数希望接收的命名参数的个数。 23.函数方法：apply()和call()。用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值，区别仅在于接收参数的方式不同。 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中第二个参数可以是 Array 的实例，也可以是 arguments 对象。 call()方法中，传递给函数的参数必须逐个列举出来。 1234567891011121314 function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入 arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125; function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125; apply()和call()真正强大之处在于扩充函数赖以生存的作用域。 1234567891011 window.color = &quot;red&quot;;var o =&#123; color: &quot;blue&quot; &#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor.call(this); // redsayColor.call(window); // redsayColor.call(o); // blue 在严格模式下，未制定环境对象而调用函数，则 this 值不会转型为 window。除非明确把函数添加到某个对象或者调用apply()或call()，否则 this 值将是 undefined。 基本包装类型24.三种基本包装类型：Boolean类型、Number类型、String类型。在读取模式下访问基本类型值时，就会创造对应的基本包装类型的一个对象，从而方便数据操作。 自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁（这意味不能在运行时为基本类型值添加属性和方法）。 单体内置对象25.在所有代码执行之前，内置对象：Global 和 Math 已经实例化，开发人员不必显式地实例化内置对象。 在大多数ECMAScript实现中都不能直接访问 Global 对象，不过Web浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【中文填词】三つ叶の结びめ -TV size.-]]></title>
      <url>%2Flyrics-seaStory%2F</url>
      <content type="text"><![CDATA[大一下学期考试周复习得好压抑，我就作死地补了《来自风平浪静的明天》。看完就感觉：啊，不愧是冈妈。虽然我不是那种容易被催泪的类型，但是还是有些胃痛的。 《来自风平浪静的明天》的音乐质量真的不错。两首OP两首ED加上几首bgm都很出彩（bgm里推荐 海の涙 和 Cry for the moon）。我当时就忍不住花了几个小时填了一个ED2的TV size（复习什么的已经无所谓了），之后基本没有修改，还算一气呵成。现在贴出来。自己感觉写的好小女生啊，哈哈。但是我就喜欢写这种暗恋的心酸。 欢迎翻唱w 希望亚人的词能填的出色. 【中文填词】三つ叶の结びめ（三片葉的花結） -TV size.- 曲：出羽良彰词：@摸鱼小能手大黄菌 等你转身 故事升温 久疏重逢的我们谈笑之间 却捕捉到 你偏离的眼神情绪慢慢下沉 听着潮声 看天空变得好陌生你笑容依旧的单纯 而我难过一直在铺陈 沉睡的心事 安静了 一整个寒冬 在春天来前解冻最后 却汇成了咸涩的洋流 经过谁的码头 把思念 只想对这片海表白泪水打湿的喜欢好像 怎么也 晒不干攒够了失望 终于才学会离开你出于礼貌的关怀 都怪我 太过分 的期待]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（一）]]></title>
      <url>%2FJS-notes-1%2F</url>
      <content type="text"><![CDATA[《JavaScript高级程序设计》，俗称红宝书。本来因为不太清楚的知识点零零碎碎，打算默默地看。但是学习热情不高，加上看到某大佬的对于这本书的读书笔记，最终决定做一个比较零散的、私人化的读书笔记，激励自己。 顺便，这里有我的Java读书笔记：Kyon Huang的java学习笔记 - Github，内容比较多，就不放在博客上了。大概包含了Java核心卷一的重点内容，之后停了有一段时间了。这学期争取继续更新。 这篇博文总结了《JavaScript高级程序设计》的前三章：JavaScript简介、在HTML中使用JavaScript、基本概念。 JavaScript简介1.ECMAScript 是一种开放的、国际上广为接受的脚本语言规范。它本身并不是一种脚本语言。而JavaScript 是 ECMAScript 规范的一种实现。 2.一个完整的 JavaScript 实现应该由三个部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。 3.ECMAScript 提供核心语言功能；DOM 提供访问和操作网页内容的方法和接口；BOM 提供与浏览器交互的方法和接口。 在HTML中使用JavaScriptJavaScript 脚本引入1.为了避免浏览器在呈现页面时出现明显延迟，现代Web应用程序一般都把全部 JavaScript 引用放在主要内容后面，&lt;/body&gt;标签前面的位置。 2.延迟脚本：&lt;script&gt;标签的 defer 属性表明脚本在执行时不会影响页面构造，会延迟到整个页面都解析完毕后再运行。延迟脚本总按指定它们的顺序执行。defer 属性只适用于外部脚本文件。 3.异步脚本：&lt;script&gt;标签的 async 属性告诉浏览器立即下载文件，不必等待其他脚本或阻塞文档呈现，目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。不保证异步脚本按照页面出现的先后顺序执行。async 属性只适用于外部脚本文件。 补充：defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 嵌入代码与外部文件4.使用外部文件的优点：可维护性、可缓存、适应未来。 文档模式5.所有浏览器默认开启混杂模式，不同浏览器在这种模式下的行为差异非常大。通过文档类型（doctype）开启标准模式： 12&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; 不支持脚本6.包含在&lt;noscript&gt;元素中的内容只有在浏览器不支持脚本，或浏览器支持脚本但脚本被禁用时才会显示出来。因此，它用于指定在不支持脚本的浏览器中显示的替代内容。 基本概念严格模式1.通过在顶部添加&quot;use strict&quot;;开启严格模式。这个编译指令告诉支持的JavaScript引擎切换到严格模式，以处理 ES 3 中一些不确定的行为，并对某些不安全的操作抛出错误。 变量2.省略var操作符可以定义全局变量（难维护，不推荐）。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。 数据类型3.五种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number和String，一种复杂数据类型 Object。ECMAScript 不支持任何创建自定义类型的机制。 Undefined类型：未初始化的变量会自动被赋予 undefined 值。 Null类型：null 值表示一个空对象指针。只要意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存 null 值，以体现 null 作为空指针对象的惯例。 Boolean类型：使用函数Boolean()将其他类型转换为Boolean类型。 Number类型：其他类型转换为Number类型，常用函数parseInt()，转换字符串时，如果第一个字符不是数字字符或者负号，会返回NaN，第二个可选参数表示进制（建议始终明确指定基数）。 String类型：不可变。其他类型转换为String类型，使用函数toString()或String()或加一个空字符串（””）。 Object类型：Object 的每个实例都具有下列属性和方法： – constructor：保留着用于创建当前对象的函数（即构造函数）； – hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在（属性名必须以字符串形式指定）； – isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型； – propertyIsEnumerable(propertyName)：用于检查给定的属性是否能使用 for-in 语句来枚举； – toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应； – toString()：返回对象的字符串表示（null 和 undefined 伪对象没有此方法，整数 number 类型需要在整数末尾多加一个.再调用）； – valueOf()：返回对象的字符串、数值或布尔值表示； 4.typeof 操作符可检测给定变量的数据类型，包括 number、boolean、string、function、undefined。 判断 Array：Array.isArray(myArr);。 判断 null：用myArr === null;。 补充：判断某个全局变量是否存在：typeof window.myVar === &#39;undefined&#39;;。 判断函数内部某个变量是否存在：typeof myVar === &#39;undefined === &#39;undefined&#39;；。 操作符5.如果两个操作数都是字符串，则比较两个字符串对应的字符串编码值。 6.如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较；如果该操作数不能被转换为合理数值，则转换成 NaN。 7.任何操作数与 NaN 比较，结果都是false。 8.相等（==）与全等（===）：全等只在两个操作数未经转换就相等的情况下返回true。 语句9.由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到： 12345var count = 10;for (var i = ; i &lt; count; i++)&#123; var j = 1;&#125;alert(i, j); //10, 1 10.for-in 语句可以用来遍历对象的属性名称： 123for(property in expression)&#123; statement&#125; 为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 补充：一个 Array 数组实际也是一个对象，它的每个元素的索引被视为一个属性。所以当手动给 Array 添加额外的属性时，for-in 语句也会将其遍历。要循环集合本身的元素，建议使用 ES 6 提供的 for-of 语句。 11.break 语句会立即退出循环，强制继续执行循环后面的语句；continue 语句退出循环后会从循环的顶部继续执行。break 和 continue 语句与 label 语句联合使用多发生在循环嵌套的情况下： 12345678910111213var num = 0;outermost:for(var i=0; i &lt; 10; i++)&#123; for(var j=0; j &lt; 10; j++)&#123; if(i == 5 &amp;&amp; j == 5)&#123; break outermost; &#125; num++; &#125;&#125;alert(num); //55 12345678910111213var num = 0;outermost:for(var i=0; i &lt; 10; i++)&#123; for(var j=0; j &lt; 10; j++)&#123; if(i == 5 &amp;&amp; j == 5)&#123; continue outermost; &#125; num++; &#125;&#125;alert(num); //95 函数12.ECMAScript中没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。所以ECMAScript函数不能重载。 13.可以向ECMAScript函数传递任意数量的参数，并通过 arguments对象来访问这些参数。没有传递值的命名参数将自动被赋予 undefined 值。arguments对象中的值与对应的命名参数的内存空间是独立的，但它们的值会同步。 15.ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(3)——圣杯布局与双飞翼布局]]></title>
      <url>%2Fcup-doubleWings%2F</url>
      <content type="text"><![CDATA[这是完成百度前端学院2015的task1后对前端布局知识点总结的第三篇博文。上两篇总结了一下overflow属性（前端布局知识点(1)——overflow属性）和负边距及文档流（前端布局知识点(2)——负边距）。 在淘宝UED探讨中诞生的双飞翼布局主要解决了两个需求： 要求三列布局，左右两边定宽，中间宽度自适应； 要求浏览器优先渲染中间栏。 其实这两个要求已经有圣杯布局实现了。双飞翼布局是沿着圣杯布局的思路加以改良探讨出来的。两者有什么区别呢？ 17.04.27更新：时至今日，Grid 布局为实现各类布局提供了非常简便的解决方案。可以通过CSS Grid布局这样玩这篇文章来对 CSS Grid 进行初步了解。 圣杯布局我们首先来看看出现时间更早的圣杯布局（这个名字让我想到Fate系列）。圣杯布局用到了浮动、负边距和相对定位来实现需求。 html代码（浏览器按照html中写的顺序渲染，因此div.main写在最前面）： 12345678910111213 &lt;div class=&quot;yellow header&quot;&gt; task4:header&lt;/div&gt;&lt;div class=&quot;page&quot;&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;main red&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;left green&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right blue&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;yellow footer&quot;&gt; footer&lt;/div&gt; CSS代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546body&#123; margin: 0;&#125;.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.green&#123; background-color: green;&#125;.yellow&#123; background-color: yellow;&#125;.page&#123; padding:0 150px 0 180px; overflow: hidden; zoom: 1;&#125;.header,.footer&#123; width: 100%; height: 100px; clear: both;&#125;.left&#123; width: 180px; float: left; margin-left: -100%; height: 400px; position: relative; left: -180px;&#125;.main&#123; width: 100%; float: left; height: 400px;&#125;.right&#123; width: 150px; float: left; margin-left: -150px; height: 400px; position: relative; right: -150px;&#125; 效果图如下： 首先，我们给div.page设置一个左右的padding值，这个值要和左右两边宽度相等。固定好div.page后，再分别设置div.left和div.right。以div.left为例，设置float: left使其浮动，margin-left: -100%，这里将div.left左移至左边与main平齐。再加上 position: relative，left: -180px 固定位置，让它能够挤进左右两边空白的同时不会遮住中间部分。 双飞翼布局圣杯布局有什么缺陷呢？ 圣杯布局使用了相对定位。这样的话，以后再添加额外标签时布局是有局限性的； 左右两边的宽度只能为固定像素而不能设定为百分比。因为元素宽度设定为百分比时根据父级元素宽度计算，而我们给父级元素设定了padding值，其宽度不明确。我们无法精确计算所需要的百分比。 浏览器宽度缩小时，随着两边定宽的部分向中间靠拢，中间部分有被挤下去的可能。 怎么能够优化圣杯布局？淘宝UED探讨的结果是增加一个div。这样，我们就可以不再使用相对布局，而仅仅用浮动和负边距来达到我们的需求。这就是双飞翼布局。 html代码（main内层增加一个div）： 1234567891011121314151617 &lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;header yellow&quot;&gt; task4:header &lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;main red&quot;&gt; &lt;div class=&quot;inner&quot;&gt; //增加的div main &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left green&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right blue&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer yellow&quot;&gt; footer &lt;/div&gt;&lt;/div&gt; CSS代码（去掉左右栏的相对定位和包裹层的padding，增加新div的margin）： 1234567891011121314151617181920212223242526272829303132333435363738.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.green&#123; background-color: green;&#125;.yellow&#123; background-color: yellow;&#125;.header,.footer&#123; width: 100%; height: 30px; clear: both;&#125;.left&#123; width: 150px; float: left; margin-left: -100%; height: 400px;&#125;.main&#123; width: 100%; float: left; height: 400px;&#125;.right&#123; width: 180px; float: left; margin-left: -180px; height: 400px;&#125;.inner&#123; margin-left: 150px; margin-right: 180px;&#125; 效果图如下： 将浏览器宽度缩小，可以看到左右两边宽度一定，中间宽度为自适应。 div.inner的 margin-left: 150px;margin-right: 180px 负责将两边内容挤开，避免在没有padding的包裹层时两边内容遮住中间。 参考资料： CSS圣杯布局 css双飞翼布局 上面两篇出自同一作者，可谓一语道破，清晰明了。 圣杯布局的实现过程 双飞翼布局介绍-始于淘宝UED CSS双飞翼布局_百度知道]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(2)——负边距]]></title>
      <url>%2Fsomething-about-margin-nega%2F</url>
      <content type="text"><![CDATA[这是完成百度前端学院2015的task1后对前端布局知识点总结的第二篇博文。上一篇总结了一下overflow这个属性：前端布局知识点(1)——overflow属性。 CSS中的负边距是布局中一个常用的技巧。因为在后面学习的双飞翼布局的实现就依赖于负边距，负边距又与文档流息息相关，所以我先对这部分的知识进行查询学习。 文档流与文本流在我了解负边距的时候出现了一个词：文档流。而在查阅文档流相关资料的时候又出现一个词叫文本流。两者有什么区别？知乎上相关问题 HTML 的文档流和文本流分别是什么？- 知乎 的高票答案提供了一个辨析的思路：文档流是相对于盒子模型讲的，而文本流是相对于文字段落讲的。 在overflow的那篇文章中我们提到，浮动(float)是一个立体的浮动。当一个元素浮动时，它后面的元素会在它身下布局。但是文字会认为浮动元素是占据了一个区域而围绕它布局。我们可以将浮动元素想象成一个在海上浮动的人，鱼可以在他的身下，但海面上的泡沫会围绕在他周围。这时，这个元素脱离了文档流，但没有脱离文本流。 但是绝对定位(absolute)会将元素从文档流和文本流中脱离，也就是说其他元素和文本都不认同绝对定位元素占据了区域，而在它身下布局。 float、absolute和fixed三种方式定位会让元素脱离文档流。 负边距的表现当 margin-top、margin-left 为负值的时候，会把元素上移、左移，同时文档流中的位置也发生相应变化，这点与 position:relative 的元素设置top、left后元素还占据原来位置不同。 而当 margin-bottom、margin-right 设为负值的时候，元素本身没有位置变化，后面的元素会上移、左移。 负边距的实例多说无益，来看实例。我们可以利用负边距和绝对定位来实现一种经典的居中方式: 12345678910111213&lt;style&gt; .middle&#123; position: absolute; width: 200px; height: 200px; left: 50%; margin-left: -100px; &#125;&lt;/style&gt;&lt;div class=&quot;middle red&quot;&gt; middle div&lt;/div&gt; 把div设置为绝对定位，然后设置top和left为50%，这时候div的上边、左边就到了父元素（这里是页面）的50%处，再对div设置其自身高度、长度一般的负边距，使div的中心移动到页面中心，实现宽度上的居中对齐。我们当然也可以用同样的方式设置高度的居中。 关于负边距更多的应用可以看参考资料： 负边距在布局中的使用 在接下来谈到的双飞翼布局中，负边距将成为主角。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(1)——从overflow属性看浮动]]></title>
      <url>%2Fsomething-about-overflow%2F</url>
      <content type="text"><![CDATA[完成了 百度前端学院2015的task1 后，感觉自己之前学习CSS以及前端布局确实不太全面，有很多知识点现在才接触到，而且也很久没有用过CSS写前端布局了。查漏补缺，总结了几个以前没有注意的知识点：overflow、负边距、圣杯布局和双飞翼布局。一开始想把所有知识点总结成一篇，写着写着发现较短的篇幅不足以把这些都总结清楚，所以还是每个知识点单写一篇。 顺便推荐 学习CSS布局，很好的布局学习资料，值得反复学习。用詹俊老师的话来说就是，好文不妨一看再看！ 探究由来task1中有一道题是这样的：实现一个浮动布局，红色容器中每一行的蓝色容器数量随着浏览器宽度的变化而变化。很快写出代码如下： html代码： 1234567891011 &lt;div class="red task5"&gt; &lt;div class="blue bfloat"&gt;1&lt;/div&gt; &lt;div class="blue bfloat"&gt;2&lt;/div&gt; &lt;div class="blue bfloat"&gt;3&lt;/div&gt; &lt;div class="blue bfloat"&gt;4&lt;/div&gt; &lt;div class="blue bfloat"&gt;5&lt;/div&gt; &lt;div class="blue bfloat"&gt;6&lt;/div&gt; &lt;div class="blue bfloat"&gt;7&lt;/div&gt; &lt;div class="blue bfloat"&gt;8&lt;/div&gt; &lt;div class="blue bfloat"&gt;9&lt;/div&gt;&lt;/div&gt; CSS代码： 12345678910111213141516.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.task5&#123; margin-top: 10px; height: 100px;&#125;.bfloat&#123; height: 50px; width: 90px; margin: 10px; float: left;&#125; 这里说一声，根据 OO CSS 的思想，结构和样式应该相互独立（不太了解 OO CSS 的话可以看一下我之前的博文 对几个前端相关概念的理解——OO CSS、语义化、CSS hack）。尽管对于这种小 Demo，OO CSS显得不实用且有些累赘，我还是坚持去实现。因此我单独写了 red 和 blue 两个 class 来控制皮肤。 以上代码的效果图： 可以看到，效果图中红色容器的高度没有随着蓝色容器的行数的变化而变化，与我们理想的效果有些差距。这是因为我们在task5这个class中写死了容器的高度，而设置了浮动的蓝色容器脱离了红色容器，行数的变化无法再影响到红色容器的高度。从这里我们可以看出，所谓“浮动”不只是平面上的浮动，而是一个立体的浮动。当然，如果不写高度的话连红色容器都看不到。那怎么解决这个问题呢？我当时没有想到好的解决方法。查看了别人的代码后，发现是要把 task5 这个 class 中高度删掉，再加一行： overflow: hidden; overflow 属性overflow 属性规定当内容溢出元素框时发生的事情。这个属性的默认值为 visible，这时内容不会被修剪，会呈现在元素框之外，就像之前的效果图一样；而值为 hidden 时，内容会被修剪，并且其余内容是不可见的。也就是说，如果这时height属性还设置了定值的话，超出这个定值的部分不可见。这个时候显示的效果如下(height: 100px)： 删掉height属性后，overflow: hidden 在这个案例的真正用途是清除浮动。这里清除的是立体的，可以理解为z轴上的浮动。因此，蓝色容器的高度现在可以受其内部，也就是红色容器的总体高度影响。现在显示的效果是符合我们要求的，实际效果图如下： overflow 属性的值还可以为 scroll 和 auto。值为 scroll 时，内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。而值为 auto 时，如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。两者区别是如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。 浮动元素特点17.04.14补充：摘自 回归CSS标准之Float 。 float 属性被设置为非 none 的元素： 元素被视作块级元素，相当于 display 设置为“block”； 元素具备包裹性，会根据它所包含的元素实现宽度、高度自适应； 浮动元素前后的块级兄弟元素忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过 z-index 属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素； 浮动元素前后的行内元素环绕浮动元素排列； 浮动元素之前的元素如果也是浮动元素，且方向相同，它会紧跟在它们后面；父元素宽度不够，换行展示； 浮动元素之间的水平间距不会重叠； 当包含元素中只有浮动元素时，包含元素将会高度塌陷； 浮动元素的父元素的非浮动兄弟元素，忽视浮动元素存在，覆盖浮动元素； 浮动元素的父元素的浮动兄弟元素，会跟随浮动元素布局，仿佛处在同一父元素中。 参考资料CSS overflow 属性 CSS - 清除浮动（clearfix hack） 17.02.07更新： 那些年我们一起清除过的浮动 一文中将 overflow: hidden 所带来的清除浮动的效果称为“闭合浮动”，以区别于 clear: left|right|both|none 。我们通过闭合浮动来解决 wrap 高度塌陷的问题。 17.04.07更新： Clear Float 介绍了解决浮动带来的高度塌陷问题的另外两种方法：“clear:both”和“clearfix”。 回归CSS标准之Float 百度EFE的文章，加深对 float 的理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[又是一个新学期开始了]]></title>
      <url>%2Fnew-term%2F</url>
      <content type="text"><![CDATA[大二的下学期就要开始了。在寒假里，我自学了JavaScript和jQuery，看完了极客学院这两部分以及AngularJS入门的视频，廖雪峰JS教程学到underscore为止。由于缺乏系统学习和动手实践，掌握肯定不甚牢固。寒假的充实度可以说差强人意吧。 新学期课感觉要比上学期略少一点，但都是专业课，也有一定难度。希望自己在课业不放松的同时尽力实现以下学习目标，并产出有质量的博文以进行总结： 前端：学习《JavaScript高级程序设计》以及ES6，研究React框架（这个放在后面）。 后端：继续Java的深入学习，Servlet、JSP、SSH三大框架。 算法：学习《算法(Java描述)》，搭配LintCode练习。 英语：以尽量高的分数过六级。 理论学习永远离不开实践，要经常给自己找项目。前端方面可以跟着百度前端学院2015的小项目动手试试。新学期也希望自己在包括足球、人际等各方面有所突破。 新学期，新气象。写下这篇博文给自己打气！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对几个前端相关概念的理解——OO CSS、语义化、CSS hack]]></title>
      <url>%2Fsome-FE-concepts%2F</url>
      <content type="text"><![CDATA[极客学院的视频《CSS 在工程中改变》中讲到了OO CSS这个概念，而在知乎上看到别人的回答中提到了语义化和CSS hack这两个概念。在查找了相关资料后，我对这几个概念有了一些自己的理解。 OO CSSOO CSS，全称为Object Oriented CSS，意为“面向对象的CSS”。 OO CSS是一种书写规则，看重代码的重用性、可维护性和可扩展性。OO CSS将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。 OO CSS更加适合大型网站的开发，因为大型网站用到更多的可重用组件。为了更好地维护，最好给每个组件写一份说明文档。 作用： 加强代码复用以便方便维护。 减小CSS体积。 提升渲染效率。 组件库思想、栅格布局可共用、减少选择器、方便扩展。 注意事项： 不要直接定义子节点，应把共性声明放在父类。 结构与样式相互独立。 容器和内容相互独立。 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。 往你想要扩展的对象本身增加class而不是他的父节点。 对象应保持独立性。 避免使用ID选择器，权重太高，无法重用。（ID选择器大多数为JS服务） 避免位置相关的样式。 保证选择器相同的权重。 类名应简短、清晰并保有语义。OOCSS的名字并不影响HTML语义化。 参考资料： OOCSS——概念篇 语义化语义化就是对数据和信息进行处理，使得机器可以理解。 如何在开放的网络、庞大的信息资源中找到需要的信息？我们当然需要借助包括搜索引擎、爬虫在内的智能程序的力量。而为了让这些程序能够理解内容、推演逻辑、建立索引并给予较高的权值，语义化变得越来越重要。SEO最有效的一种方法就是对网页的HTML结构进行重构，实质上就是语义化。 为了使机器能够尽可能理解内容，规范是必须的。程序肯定只会关注那些约定俗成的东西。某种规范被认可的程度越高，就越会成为机器算法的目标，人们就越可以根据它来实现各种功能。 HTML本身也是机器可读的语义信息，但由于HTML被设计的目的并不是为了机器可读，所以不尽完美。也因此，HTML规范一直在往语义化的方向上发展。HTML5更是在之前规范的基础上，将所有表现层的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。 当然，HTML5并非Web语义化唯一的规范。有很多组织都提出了有浏览器和搜索引擎支持的规范，为扩展、标准化Web语义做着自己的贡献。关于HTML5各个元素语义的描述，可参考 Semantic HTML。 参考资料： 如何理解 Web 语义化？- 知乎 CSS hack由于不同厂商的浏览器和浏览器的不同版本对CSS有不一样的支持和解析结果，导致我们需要针对不同的浏览器及同一浏览器的不同版本写特定的样式，以获得统一的页面效果。这个过程叫做CSS hack。 使用CSS hack虽然有助于实现页面表现的一致性，但滥用会造成编码过于复杂、文档混乱不堪，增加管理和维护的负担。因此，hack要少用、慎用。等到未来浏览器厂商的标准能够完全统一时，就是hack退出历史舞台的时候了。 参考资料： 史上最全的CSS hack方式一览]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text使用技巧笔记]]></title>
      <url>%2Fsublime-text-learning%2F</url>
      <content type="text"><![CDATA[作为一款主流前端开发编辑器软件，Sublime Text具有代码高亮、语法提示、自动完成，轻量级，易上手，并且支持插件扩展机制，可以说功能十分强大。 我用Sublime Text已经有一段时间了，但是只是浮于表面，没有进一步探索。作为一名准备在Web方面继续深研的软工学生，我决定对Sublime Text的使用技巧进行学习，并写下这篇笔记。 快捷键(OS X) Command + 光标 多点编辑 Command + p 快速打开文件 Command + Shift + p 打开命令行面板 Command + + / - 字体放大/缩小 Command + K + B 面板显示/隐藏 Command + ] / [ 缩进/退回一个级别 Command + L 选择当前行 Command (+ Shift) + Enter (在上一行)下一行开辟新行 Option + 鼠标左键 块选择(自动进入多点编辑) Alt(Command) + 左右键 单词(行)粒度的跳跃 Alt(Command) + Shift + 左右键 单词(行)选择(可以叠加使用多次) Command + A 全选 命令编辑器右下角可以更改语法，也可以在命令行面板输入语法名进行选择。 命令行面板输入”Key Bindings - Default”可以看到所有的快捷键设置。 “Key Bindings - User”中自己可以设置快捷键，遵循JSON语法： [ { &quot;keys&quot;: [&quot;shift+tab&quot;],&quot;command&quot;: &quot;reindent&quot;,&quot;args&quot;: {&quot;single_line&quot;:false}} ] “Reindent Lines”调整缩进（已经被我设置快捷键Shift + Tab）。 如何得到命令名和参数： Ctrl + ` 打开控制台，输入”sublime.log_commands(True)”； 再在命令行面板中输入操作； 在工作台即可看到命令名和参数； 自定制用户的设置保存在/~/Library/Application Support/Sublime Text 3/Packages/User中，写到这里的数据是不会因自动升级而被覆盖的。 推荐将这个文件夹中的内容同步到Github上。这样，在更换系统或电脑时，将文件夹clone下来进行替换，可以迅速按照自己的要求配置好。 15.05.17 更新： 把 sublime 中的 Tab 换成两个空格的缩进。方法详见 sublime text3里 修改TAB键为缩进为四个空格 。 扩展包到 https://packagecontrol.io/installation 可以看到 sublime3 中的安装方式，Control + ` 打开控制台，运行代码就可以安装上了。 Command + Shift + p 打开命令行面板，敲Install Package来搜索并安装想要的包。Remove Package卸载插件。 Packages/User/ 下面的文件 Package Control.sublime-settings 里面列出已经安装的包。 我安装的包有（不定期更新）： Git：这个包可以帮助我们在编辑器里完成git相关操作。在命令行面板中输入”Git Add Current File”、”Git Commit”、”Git Push”来完成相应操作。 emmet：Web前端开发必装包，敲 tab 键代码补齐。具体触发词参见 http://docs.emmet.io/cheat-sheet/。如果我想用标签来包裹一些内容，我就先把内容选中，然后 Ctrl-w 。这个命令也可以在命令面板上呼叫 Wrap with Abbreviation 。要是忘了快捷键了，就求助命令面板。弹出的输入框中输入后回车就可以看到效果了，语法上跟前面 tab 补齐的时候没有区别。如果要删除一层标签，用 Command + , (Remove Tag)。 快速查找文件或字符串Command + P 快捷键打开的功能叫做goto anything，见menu-&gt;Goto。支持模糊匹配，同时支持下面几种操作形式，让定位更准确： filename:lineno //定位至具体行号 filename@css-selector //定位至具体CSS选择器 filename@function //定位至具体函数 还可以直接在新打开的文件中定位字符串。 filename#searchtext Command + (Alt) + F 当前文件内查找(替换)。Enter 查找下一处，Shift-Enter 查找上一处。敲 esc 就可以停在那里进行编辑。 把光标停留在要找的单词上面，然后 Command + D 连续敲多次，就可以找出所有当前文件中的这个单词，而且是直接在多点编辑模式下，可以直接进行替换。 如果要在一个文件夹内全局查找，鼠标右击文件夹，Find in Folder 就可以了。打开下一个匹配项用 F4，上一处 Shift+F4。 Ctrl + - 跳回老位置（jump_back），Ctrl + Shift + - 反向操作跳（jump_forword） 参考资料： HappySublime 如何优雅地使用Sublime Text 牛人总结的Sublime Text的心得经验 jikeytang/sublime-text · GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Java的BiliBili视频信息爬虫]]></title>
      <url>%2FbiliInfoCrawler%2F</url>
      <content type="text"><![CDATA[该项目要求设计并实现一个 BiliBili 视频信息爬虫，并且能够将每个分类收藏数前三的视频下载至本地。 该项目使用的软件有Eclipse（IDE）、Charles（抓包工具）、MySQL（数据库）、Navicat Premium（数据库可视化工具）。以下代码截图全部基于OS X系统上自己编写的代码。 了解相关知识该实验所用到的知识有且不仅限于： HTTP 请求、响应和重定向； 使用 apache-httpclient 来实现对服务器的请求并收到响应； 用 jsoup 处理 html 文件； 数据库设计与使用； Java IO下载视频文件； 同时，该程序使用了 Maven 来管理项目的依赖关系。 抓包并分析用一个抓包工具来分析浏览器打开 BiliBili 视频网时重要的请求与响应。这里我选用的是 Charles，当然也可以使用 Fiddler 或者其他好用的。 可以看到，图中选中的项即为访问 BiliBili 视频网分类页面时服务器向浏览器发送的 json 文件。路径中 tid 后的数字代表种类，pn 后的数字代表页数。可以看到访问时浏览器发出的请求参数，爬虫程序同样也要设置这些参数使服务器认为是浏览器在访问。而在每一个 json 文件中，有 20 个视频的信息，包括我们感兴趣的 av 号（Bilibili 视频 id号）、作者、种类、收藏数、硬币数等信息。我们之后将要对 json 文件进行处理来获得这些信息，并把它们存进数据库。 爬虫相关方法 使用apache-httpClient来实现请求并得到响应，最终得到json文件。 通过JSONArray和JSONObject两个类方法对请求到的json文件进行处理，将得到的视频信息初始化为一个Bilibili对象（Bilibili类在Bilibili.java中定义），并调用JDBC.java中定义的方法将数据存入数据库。 视频下载相关方法 通过SQL语句选出该种类中收藏数前三的视频，返回其av号及其他信息。通过www.ibilibili.com加上av号，对其发出请求，获得HTML文件。 使用jsoup，利用标签对HTML文件进行解析，获得以www.bilibilijj.com/Files/DownLoad/为开头的视频下载地址。 利用JAVA IO的相关方法编写readInputStream和getVideo方法，下载视频保存至本地指定地址。 调用方法并开多线程加速在main方法中调用之前写好的方法，并开多线程加速爬取和视频下载。 结语经过反复的设计、编程、测试、修改，最终的程序能够爬取 BiliBili 视频网音乐区 7 个类别约 62 万个视频的信息（由于校园网波动，最后只爬了62w，实际上音乐区应该不止这么多视频），将其存入数据库，并将每个类别收藏数前三的视频下载至本地，符合实验要求。 完整代码已经放在我的 Github 中。由于个人水平有限，可能存在错误或者性能优化方面的问题，欢迎讨论。 项目中参考的资料 普通Java工程转换成maven工程 Jsoup+json-lib解析xml带中括号的数组Json数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bye,2016 AND Hello,2017]]></title>
      <url>%2Fbye2016hello2017%2F</url>
      <content type="text"><![CDATA[开始写的时候是12月30日晚上，刚刚考完的大物感觉还不错。然后马上就到了2016年的最后一天。希望能在2016年内写完这篇博文，给自己的这一年做一个回顾。更重要的是，认真地考虑一下，2017年应该去做些什么。 Goodbye,2016 从软件工程的萌新变成半萌新。感觉算是摸到了大门，往内斗胆一窥，发现这个世界广阔无垠。东瞧西瞥，还没有考虑好自己今后的发展方向，目前还是打算先以java的进阶为主，向web开发方面学习。 今年的学期感觉除了课业上按部就班外，在技术自学上没有激情。倒是暑假自学java有很大的收获。希望自己能够不忽视小块的时间去学习技术。当然，首先找到至少短期内的一个学习目标。 大一下学期进了院长实验室，但是总觉得项目安排上有点难受。外包任务让自己没什么长进。下学期看看怎么协调一下，当然也有可能下学期会参加花旗杯。 拿了一些院级活动的奖（而且基本都是产品&amp;设计方面的工作）。希望自己能做一些负责技术方面的、有价值的项目。 体测比去年同期略瘦，50米快了整整一秒。希望自己能保持锻炼，还能在院队有个位置。 Hello,2017 先顺利地过了上学期所有期末考。希望自己的绩点还能保持在3.5以上。认真复习，少浪，别懒！ 寒假先定个小目标，比如啃啃 javascript，啃啃java 的高级特性，啃啃 lintcode，写几篇有用的技术博客，顺便把博客再折腾一下，最好买个域名。总之，要让27天的寒假过的有意义。寒假开始时再列个日程表。 早睡早起，勤奋刻苦，下学期尽量不翘课。都是专业课，认真听。还要在课余时间继续学技术。 希望能做一个真正意义上的大项目（比如花旗杯）。为了这个目标，学技术。 在自己真正的兴趣上利用时间，而不是无所事事地浪费。 每天过得健康、充实、开心！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【V家中填】飛行機雲 -full ver.-]]></title>
      <url>%2Flyrics-aircloud%2F</url>
      <content type="text"><![CDATA[在高考完的暑假，我填完了第一首可以称为“完整”的词。契机是很偶然地点进了【Shikako】飛行機雲【翻唱】。一首好听的歌加上纯真的妹子音，可惜关注度远低于作品质量所应得的。(这个up把歌传到网易云啦。如果你懒得打开网址，点击下面播放就能听) 当时B站恰巧推出了“夏日延长线”的翻唱活动，想填词＋翻唱来参加。词是以远高于一般速度地填完了（果然ddl是第一生产力w），但录制翻唱直到现在还没有尝试过。夏天终究是属于遗憾的季节。 尽管写的很快，还是花了很多心思去斟酌如何表现那种孩童时的懵懂和错过时的心酸。如果看到这的人觉得这首词填的还不错，我就很开心了。要是有唱(mei)见(zi)愿意拿这首词翻唱，那我就可以上天了ε=ε=(ノ≧∇≦)ノ当然也欢迎交流讨论。 【中文填词】飛行機雲 -full ver.- 曲：toa词：摸鱼小能手大黄菌 那时候 你决定松开手让气球飞走也松开我们之间可能有 的以后而我呢 还在原地踮着脚仰望天空看你指过的飞机云在泪水中消融 回家 在蝉鸣中难忍受 你的捉弄 挥舞拳头而你 笑着逃走我追赶 磕磕绊绊 眼泪摔落 站在分别时的十字路口我垂落的双手紧握沉默迟到的挽留总是与开口错过就像你和我 那时候 你决定松开手让气球飞走也松开我们之间可能有 的以后而我呢 还在原地踮着脚仰望天空看你指过的飞机云在泪水中消融 忽然之间 被牵住手你偏头 眼神闪躲 一字不说而我的脸已泛红转过身 闹起别扭 掩饰羞涩 那个夏天一直有风路过过往的快乐却不肯为我逗留抓不住时光匆匆流走的你我把彼此弄丢 那时候 关于未来的想象都太年幼以为长大还躲在漫长的 等待后而我呢 还在原地想念着你的笑容而你指过的飞机云再次划过天空 那时候 我们约定再见而 拉过的勾勾住的只有斑驳的 回忆和难过而我们 在物是人非后终于失去联络在世界的不同角落孤单地漂流 而我呢 还在原地想念着你的笑容想念那天归家途中见到的彩虹而你呢 在什么地方唱着熟悉的歌是否也像我偶尔望向同一片天空]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用hexo+github搭建这个博客的一点经验]]></title>
      <url>%2Fhexo-begin%2F</url>
      <content type="text"><![CDATA[博客基本算是搭好了。当然，还有很多地方可以改进，比如加上包括评论（主要是多说不知道为什么一申请就告诉我出错）在内的第三方服务，比如样式还可以再漂亮一些，而且也没有申请自己的域名（毕竟也没什么人看吧…大概）。但是一个个人博客，内容的质量应该是最重要的。从现在开始，先写点东西吧，比如，先谈谈搭建这个博客时遇到的一些问题以及解决的方案。注意，我是用 mac 搭建的，以下很多内容可能只适用于 OS X 系统。 这个博客后期做的样式等修改也会记录在这篇博文中。 初始搭建 前期准备：安装 XCode、Node.js，注册 Github。除开Node.js外都是已有的，也没遇到什么问题。 hexo 的安装推荐查看hexo的官方文档，说的很详细。看网上七七八八的教程反而可能遇到一些莫名其妙的问题。整个搭建过程中花费时间最多的就是在解决 DTrace 错误上： [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; 按照百度的解决方法折腾半天（是真的半天！）也不奏效，最后的解决方案还是按照文档从安装hexo开始重新走了一遍，再使用命令： npm install hexo --no-optional 这才解决。果然官方文档才是坠吼的！ 然后就是主题选择了。根据知乎上有哪些好看的 Hexo 主题？－知乎问题的回答，果断选择github上star最多的NexT主题，官方文档也同样详细易懂。Muse 实在太丑，开始时我选用的 Scheme 是 Mist。后来百度看到好多大佬选用 Pisces，感觉要比 Mist 好看一些，于是换了。其实就是改改配置文件，很简单。之后加入不蒜子统计，设置 RSS（其实我并不清楚这个是干什么的…就是橙色的图标蛮好看的），加上标签、分类、关于页面、搜索功能和侧边栏社交链接。这些在官方文档写的都很清楚。 我还改了一些什么呢？第一，背景颜色。原来NexT的默认背景颜色是浅灰色，不仅沉闷，而且和其他博客的重复率太高。在网上搜到改动方法：hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _schemes -&gt; Pisces（Mist和Muse也行），找到路径下的index.styl文件，改动文件的最上方的那一行代码即可（现在这个博客改成了body { background: #bdeaf7; }）。这个方法应该也可以将背景换成图片，但是每次我用hexo server在本地看是正常的，传到github上就显示不了图片。还没找到解决方法，只好作罢。（17.04.27：解决了，现在背景图片为《言叶之庭》中的截图，CSS 代码为body { background: url(&quot;../../../images/back1.jpeg&quot;); background-repeat:no-repeat; background-attachment:fixed; background-size: 100% 100%;}） 第二，我对底部 powered by 的 logo 栏进行了更改。其实按理说这个地方作为对 hexo 和 NexT 的开发者的感谢不应该修改的…还是更想个性化一点，抱歉抱歉。修改方法参见 Hexo-Next底部powered by的logo栏更改以及注意事项（附官方文档,文末有福利链）。我把这里当作一个随时修改的心情栏了。（17.04.27：我改回来了） 后期更新 16.12.31更新：加上了鼠标点击出爱心的特效。详见 hexo引用自定义js文件和css样式。这个blog还有粒子特效的背景，说不定哪天也给自己加上。 17.02.20更新：申请了现在的域名，域名解析详见 Hexo站点之域名配置【2】。 17.02.21更新：增加多说评论并修改样式，详见 动动手指，给你的Hexo站点添加最近访客（多说篇）。 17.02.26更新：NexT主题支持自行设定CDN以加速静态资源的加载，详见 进阶设定 - NexT 使用文档。但是经过测试，感觉修改CDN后并没有实现预期的加速（也有可能是我没找到比较好的CDN）。所以现在暂时还是保持没有修改的状态。 17.03.14更新：增加复制文本自带版权信息，详见版权狗退散 — 仿知乎复制文本自带版权声明。 17.04.08更新：多说即将归西。暂无用其他评论系统替代的打算。 17.04.27更新：NexT 主题更新至 5.1.1 版本，更换背景图片（好看多了w）。 大概就这些了。希望搭建这个博客能够督促我写下更多编程学习中的经验之谈。但我也没有打算只把这个博客当作一个写技术性文章的地方，随笔、填词什么的也会放在这里。欢迎大家多多来看，相互交流 :)]]></content>
    </entry>

    
  
  
</search>
