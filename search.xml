<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[简单的暑假计划]]></title>
      <url>%2Fsummer-plan%2F</url>
      <content type="text"><![CDATA[出征前內心忐忑鋒利的匕首反握準備殺死對手前先讓我來殺死懶惰 — 艾福杰尼 / Killa4nia《酒精》 简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感兴趣的知识，并且认真做学习笔记和总结。 整个暑假： 每天 12 点前睡觉，8 点前起床。 第一阶段，每天 15 - 20 面左右的《JavaScript 设计模式与开发实践》 第二阶段，每天 5 - 8 面左右的《算法》，1－2 道的 LeetCode 练习。 前端各类练习题。每天 2 - 3 道原生 js 实例题。 每天 2 面六级单词。 想做的练习： 谈谈一些有趣的CSS题目 原生JavaScript学习-实例索引 百度前端技术学院 七月： 写花旗杯项目前端。 Vue 全家桶及相关技术实践。 八月： Node.js。 如果还有时间，试试 Electron 或者 Lavas 天下武功，唯勤不破！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从零开始的 Vue 实践（更新中）]]></title>
      <url>%2Fvue-project-practice%2F</url>
      <content type="text"><![CDATA[到目前为止，我阅读了 Vue、Vue-router、Vuex 的官方文档并进行了一定的实践来体会，使用了 Element 和 Axios。那么在这段时间的学习基础上，我决定做一个规模较大的、基于 Vue 全家桶的项目，一方面巩固自己所学知识，另一方面继续学习一些大规模项目中要用到的工具、库、插件等等。 项目地址：bighuang624/vip 技术栈（到目前为止项目中引入的）：Vue + Vue-router + vuex + axios + Element 这个项目的工程量还是比较大的。这篇博文会记录我在这个项目中技术选型考量、使用细节和坑、项目中某些设计的缘由，等等… 技术选型坑参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise 对象]]></title>
      <url>%2Fpromise%2F</url>
      <content type="text"><![CDATA[Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。 特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变只有两种可能：从Pending变为Resovled和从Pending变为Rejected。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 缺点： 无法取消Promise，一旦新建就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误不会反映到外部。 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。 基本用法一个栗子，用Promise对象实现 Ajax 操作： 1234567891011121314151617181920212223242526272829var getJSON = function(url)&#123; var promise = new Promise((resolve, reject) =&gt; &#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystagechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if(this.readyState !== 4)&#123; return; &#125; if(this.status === 200)&#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;); return promise;&#125;;getJSON("/post.json").then( json =&gt; console.log('Contents: ' + json), error =&gt; console.error('出错了', error)); resolve和reject函数由 JavaScript 引擎提供，不用自己部署。两者在改变 Promise对象的状态的同时，将异步操作的结果或报出的错误作为参数传递出去。 then方法可以接受两个回调函数作为参数，第一个在Promise对象状态变为Resolved时调用，第二个（可省）在Promise对象状态变为Rejected时调用，都接受Promise对象传出的值作为参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例（决定前一个Promise对象的状态），表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。 方法Promise.prototype.then()then方法返回一个新的Promise实例。链式写法调用then方法时，前一个回调函数将返回结果作为参数，传入第二个回调函数。 Promise.prototype.catch()reject方法的作用，等同于抛出错误。如果Promise状态已经变成Resolved，在resolve语句后再抛出错误是无效的，因为状态不会再改变了。 一般来说，不要在then方法中定义Reject状态的回调函数，总是使用catch方法。因为catch可以捕获之前所有then方法执行中的错误，也更接近同步的try/catch写法。 catch方法返回的也是一个Promise对象。 Promise.all()Promise.all方法用于将多个Promise实例（否则调用Promise.resolve方法再处理），包装成一个新的Promise实例。接受一个具有Iterator接口，且返回的每个成员都是Promise实例的参数（一般为数组）。 1var p = Promise.all([p1, p2, p3]); 只有每个成员的状态都为Resolved，p 的状态才为Resolved，所有返回值组成一个参数传递给 p 的回调函数；否则只要有一个成员被rejected，p 的状态为Rejected，第一个被reject的实例的返回值被传递给 p 的回调函数。 如果作为参数的Promise实例自身定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 Promise.race()1var p = Promise.race([p1, p2, p3]); p 的状态随第一个改变状态的成员而做相同改变，该成员返回值传递给 p 的回调函数。其他与Promise.all方法一致。 Promise.resolve()将现有对象转为Promise对象。根据参数分为四种情况： Promise实例：不作任何修改，直接返回该实例； thenable对象（具有then方法的对象）：转为Promise对象，然后在立即调用其then方法的同时状态变为Resolved； 不符合以上情况的任何参数：返回状态为Resolved的Promise对象，参数传给回调函数； 不带有任何参数：返回状态为Resolved的Promise对象。 Promise.reject()返回一个新的Promise实例，状态为Rejected。方法的参数会作为reject的理由，变成后续方法的参数。 应用 加载图片：加载完成时Promise的状态发生变化。 Generator 函数与 Promise 的结合：使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 参考资料写作： Promise 对象 - ECMAScript 6入门 进阶（之后阅读）： JavaScript Promise迷你书（中文版）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何给终端安上炫酷的皮神黄皮肤？]]></title>
      <url>%2Fpikachu-iterm%2F</url>
      <content type="text"><![CDATA[昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西： 给终端安上超几把炫酷的皮神黄皮肤！作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？ 一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！ 如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。 从零开始的项目安装打开 Pokemon-Terminal 项目的 github 主页，我发现安装前有两个要求： 3.5及以上版本的 python； 已安装 iTerm2。 巧了，这两个要求我都不符合！ iTerm2 我从来没有接触过，根本不知道是什么。而比较久远的时候，我在试图将 OS X 系统自带的 python 2.+ 升级为 3.+ 时，跟着网上不知道靠不靠谱的教程误操作，以致 2.+ 删掉了 3.+ 却没安好，依赖于 python 的以 Xcode 为首的一系列软件全部罢工（而且过了一周左右才查出来是这个原因），最后灰溜溜地又下了一遍 2.+，从此留下了对 python 的心理阴影（但是我们这篇教程还是很靠谱的）。 没关系，作为（准）程序员，要勇于折腾！我们一步一步的搞起。 iTerm2我是先下载的 iTerm2，官网在此，下载即可。 iTerm2 是 OS X 系统下很好用的一款命令行工具，至于具体怎么好用，敬请百度了解。因为我现在只是为了皮神黄皮肤。当然之后我也会进一步学习使用。 python 3.5+昨晚吃瘪后的我心有不甘，发了一条说说。然后幸得初中同学救驾： 这个允许用户方便地安装不同版本的 python 并可以快速切换的 anaconda 帮助我解决了问题。官网提供了图形化安装和命令行安装两种方式，根据自己的专业程度选择下载即可。 这个 anaconda 据说也是 python 开发的利器之一，不过我也不会 python。也许之后机缘巧合会深入学习（想了解可以参照这篇文章Anaconda使用总结）。说实话为了给终端换个皮肤，让我本不宽裕的存储空间又少了 1G 左右，有些心疼。但是折腾还是给了我很多乐趣，也许之后有用呢。 那么要求都满足了。按照项目 README 要求，在 iTerm 2 中输入以下三条语句： 1234# Pokemon Installationgit clone https://github.com/LazoCoder/Pokemon-Terminal $HOME/.Pokemon-Terminalecho PATH=&quot;$HOME/.Pokemon-Terminal:$&#123;PATH&#125;&quot; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 安装完毕，皮神我来了！ 1$ pokemon pikachu 然后…出现以下报错提示： 1.Pokemon-Terminal/./Scripts/background.scpt:39:46: script error: Expected end of line but found identifier. (-2741) 翻越最后一座 bug 高山想去给作者提一个 issue，就发现作者对于这个 bug 已经给出了解决方法。 按照解决方法，我们需要对 .Pokemon-Terminal/scripter.py 文件进行一些修改（当然，不一定每个人都碰上了这个 bug）。其实我也不太会用 vim，所以以下操作参照了这篇文章修改文件内容 vi命令。 用以下命令在终端打开： 1vi .Pokemon-Terminal/scripter.py 然后按一下 i，从命令行模式进入插入模式。找到函数__terminal_script（在比较靠上的位置），将： 1content = &quot;tell application \&quot;iTerm\&quot;\n&quot; 修改为：1content = &quot;tell application \&quot;iTerm2\&quot;\n&quot; 按 Esc 键进入命令行模式，再按:wq保存退出。大功告成！ 再在 iTerm2 中输入pokemon pikachu，就会发现黑漆漆（或者白晃晃）的背景变成了皮神黄！ 深度使用123456789101112131415161718192021222324Usage: pokemon [parameter]Parameters: [name] - Change the terminal background to the specified Pokemon. [index] - Change the terminal background to a Pokemon by its index. [region] - List all the Pokemon of the specified region. [one letter] - List all Pokemon who&apos;s names begin with a particular letter. [two letters] - List all Pokemon who&apos;s names begin with those two letters.Other Parameters: pokemon all - List all the Pokemon supported. pokemon regions - List all the available regions. pokemon extra - List all the Pokemon from the &apos;Extra&apos; folder. pokemon random - Change the terminal background to a random Pokemon. pokemon random-kanto - Change the terminal background to a random Pokemon from the specified region. pokemon ? - Identify the current Pokemon in the terminal. pokemon _pikachu - Change the wallpaper to the specified Pokemon. pokemon _random - Change the wallpaper to a random Pokemon. pokemon _random-kanto - Change the wallpaper to a random Pokemon from the specified region. pokemon _? - Identify the current Pokemon in the wallpaper. pokemon slideshow - Iterate through each Pokemon. pokemon slideshow-kanto - Iterate through each Pokemon in the specified region. pokemon help - Display this menu. 以上是作者提供的用法。可以通过口袋妖怪的英文名或者编号切换皮肤，或者用pokemon random来切换成随机的皮肤。 我们现在还得每次打开 iTerm 后输入命令来切换皮肤。作者同样提供了点开就换的方法，只用在 iTerm 的 Preferences 里做一点配置： 想一想，通过配置为pokemon random，每次打开都是不同皮肤说不定更爽到。 最后作者建议你改变一下透明度之类的，使皮神看起来更酷炫有范： 我的配置是这样的： 结语其实一个皮肤也没有那么重要（还是有那么一点爽的啦），重要的是通过这一番折腾，接触到了很多常规学习中可能不会接触的东西，包括 iTerm 和 anaconda。这也是我第一次有目的性地去看项目的 issue。希望自己以后能多一点这样地非常规学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端学习之路上的暂歇思考]]></title>
      <url>%2Frelax-and-think%2F</url>
      <content type="text"><![CDATA[又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。 到现在为止，我的前端学习之路大概插了这些旗帜： 对前端生态有了一个大致的了解，对例如 Webpack、Babel 等常用的工具有使用经验或者大概知道是干什么的。 在知乎和微博上关注了前端大佬，养成每天在掘金上看技术文章以及不时逛一些较为优秀的技术博客的习惯。 看了一些前端书籍，大多是 JavaScript 相关。 大致啃完了 Vue.js 的文档，正在学习 Vue-router。同时也对 i-View 等相关项目有一些了解。 在之前的前端学习中也有一些问题： 最大的问题是不太重视基础。看张鑫旭对前端的要求中，光是“掌握JS中的字符串、函数、对象、数组、字面量等基本概念，熟记所有内置的方法（包括参数和返回值）”这一条就足够我汗颜了。看的书籍虽然有笔记，但也感觉是没有过心。之后会将博客中的读书笔记再按照知识点，辅以自己的进一步学习成果拆分细化。虽然这是一个比较大的工程，但我觉得这是一个很有必要的工作。 经典书籍读的不够多。像《你不知道的 JavaScript》、《JavaScript 设计模式与开发实践》等书都没有看。 某些时候还是有些懒惰，没有抽出空余时间来学习。或者是在学习过程中在知乎、贴吧、空间、微博耗费了注意力，导致学习效率不高。 包括博文和项目在内的学习产出还是不多，博文也没有特别有价值的内容。毕业前要在 github 上有一个 100+ star 的项目，还要部署到 npm 上。博客考虑备案和 SEO，以激励自己写出更有价值的文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单页面程序及组件化相关笔记]]></title>
      <url>%2FSPA-learning-notes%2F</url>
      <content type="text"><![CDATA[随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 xufei 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。 提高开发效率的两个主要途径： 加快开发速度：少造轮子。 减少变更代价：清理模块之间的关系，合理分层。 单页面程序SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。 优越性高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。 实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。 代码合并与加载策略典型特征：部分加载。 一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的异步加载机制去运行时加载。 因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。 需要考虑的点路由与状态的管理界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。 缓存与本地存储动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。 在本地存储一些临时数据可以用 localStorage。 服务器通信WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。 例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。 困难与缺陷SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。 缺陷：不利于 SEO；要注意内存管理。 样式规划基准样式的分离包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。 组件样式的划分组件样式应当尽量减少相互依赖，各组件的样式允许冗余。 堆叠次序的管理在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。 组件化整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。 职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。 HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。 JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。 CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。 开发框架jQuery 轻量、灵活，但对代码缺乏约束。 需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。 因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。 AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。 React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。 依赖注入： 核心理念：通过配置来实例化所依赖的组件。 缺点：性能以及跟踪调试的便利性上的损失。 优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。 应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。 MV*框架的基本原理充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在配置文件（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动： 初始化自身（bootstrap） 异步加载可能尚未引入的 JavaScript 代码（require） 解析定义在 HTML 上的规则（template parser） 实例化模型（scopr） 创建模型和 DOM 的关联关系（binding, injection） 这些是主线流程，还有一些支线，比如： 解析 url 的 search 字符串，恢复状态（route） 加载 HTML 部件模板（template url） 部件模板和模型的关联（binding） 业务模型指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。 Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。 参考资料博文参考资料： Web应用的组件化（一）——基本思路 构建单页Web应用 关于新框架的学习 延伸阅读资料： Web应用的组件化（二）——管控平台]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最近在干以及打算干些什么]]></title>
      <url>%2Frecent-and-will%2F</url>
      <content type="text"><![CDATA[这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。 在干什么： 写花旗杯项目前端第一版。 开始看 Vue.js 的文档。 看一些关于前端工程化的博文。 打算干什么： 继续看完 Vue.js 的文档并且找一个 Demo 做一做。 尽早看完 ES 6 新特性。 看一看 Grid。 最近看的优秀文章： CSS Modules 入门及 React 中实践 玩转 npm：介绍了常用的 npm 命令。 构建单页Web应用：理解单页 Web 应用。我想这篇文章我还会再看至少两遍。 HTML5 高级系列：web Storage：了解如何通过 localStorage 和 sessionStorage 存储一些数据。 [译] 人人须知的 jQuery 技巧：介绍了一些 jQuery 代码片段，包括预加载图片、禁用输入字段、简单的手风琴效果等。建议自己整理一份类似的代码片段库。 FIGlet初识：了解一下 FIGlet，不实用，但还有点意思。 如何处理CSS3属性前缀：介绍了 Autoprefixer，用于处理 CSS 3 属性前缀的问题。 JavaScript Modularization Journey：JS 模块化发展史。还得再看几遍…等我到了该接触 Webpack 的时候。 看到的好玩意： Awesomes - Web前端开发资源库：全是前端的开源项目，遍地的轮子啊。关键是文档很多都翻译成中文了。 pkg：帮助你将你的 Node.js 程序打包成即使在没有 node 环境的设备上也能运行。 Axios：基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用。这个貌似很常用，看看能不能用在现在的项目中。 一个有趣的 CSS 按钮效果 Hover.css：Hover.css 是一个 CSS3 的鼠标悬停效果集合，可用于超链接，按钮，logo，SVG，推荐图片等等。能够很简单地运用到我们的元素中。 之后想做的练习（时间好少QAQ）： 谈谈一些有趣的CSS题目 原生JavaScript学习-实例索引 百度前端技术学院]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《ECMAScript 6 入门》读书笔记(二)]]></title>
      <url>%2Fes6-2-notes%2F</url>
      <content type="text"><![CDATA[说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《ECMAScript 6 入门》。希望能早日啃完，想去看 Vue.js 了… 此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。 函数的扩展函数参数的默认值1.ES 6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 12345678910111213141516171819202122232425262728293031323334353637function log(x, y = 'World')&#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'Kyon') // Hello Kyonlog('Hello', '') // Hello// 与解构赋值默认值结合使用function foo(&#123;x, y = 5&#125;)&#123; console.log(x, y);&#125;foo(&#123;x: 1&#125;) // 1, 5foo() // TypeeError: Cannot read property 'x' of undefined// 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x有值，y无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x和y都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined] 参数变量是默认声明的，所以不能用let或const再次声明；使用参数默认值时，函数不能有同名参数。 定义了默认值的参数通常应该为函数的尾参数。 2.函数的length属性：将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，后面的参数也不会被计入。 3.作用域：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，作用域消失。 12345678910// 函数foo内部声明的内部变量与参数不是同一个作用域var x = 1;function foo(x, y = function()&#123; x = 2; &#125;)&#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 123456789var x = 1;function foo(x, y = function()&#123; x = 2; &#125;)&#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 4.函数参数默认值的应用：可以指定某一个参数不得省略，如果省略就抛出一个错误。 123456789101112function throwIfMissing()&#123; throw new Error('Missing parameter');&#125;function foo(mustBeprovided = throwIfMissing())&#123; return mustBeProvided;&#125;// throwIfMissing函数名之后有一对圆括号// 表明参数的默认值不是在定义时执行，而是在运行时执行// 即如果参数已经赋值，默认值中的函数就不会运行foo() // Error: Missing parameter 可以将参数默认值设为undefined，表明这个参数是可以省略的。 5.rest 参数：形式为”…变量名”，用于获取函数的多余参数。rest 参数中的变量代表一个数组。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1const sortNumbers = (...numbers) =&gt; numbers.sort(); 函数的length属性，不包括 rest 参数。 1(function(a,...b)&#123;&#125;).length // 1 函数参数的默认值6.扩展运算符：...，将一个数组转为用逗号分隔的参数序列。 123456789console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5var numbers = [4, 35];add(...numbers) // 39// 不再需要 apply 方法将数组转为函数参数function f(x, y, z)&#123;&#125;f(...args); 7.扩展运算符的应用： 合并数组：提供了新写法。 123456var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];arr1.concat(arr2, arr3); // ES 5[...arr1, ...arr2, ...arr3] // ES 6 与解构赋值结合：用于生成数组（只能放在参数最后一位）。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = ["foo"];first // "foo"rest // [] 函数的返回值：为函数提供一种返回多个值的方法。 1234// 从数据库取出一行数据，通过扩展运算符，直接传入构造函数Datevar dateFields = readDateFields(database);var d = newDate(...dateFields); 字符串：扩展运算符还可以将字符串转为真正的数组。 1234567let str = 'x\uD83D\uDE80y';str.split('').reverse().join('')// 'y\uDE80\uD83Dx'[...str].reverse().join('')// 'y\uD83D\uDE80x' 实现了 Iterator 接口的对象：可以通过扩展运算符转为真正的数组。 12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符。Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567891011121314151617// Map结构let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3]// Generator 函数var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 8.函数内部严格模式：ES 5 时函数内部可以设定为严格模式；ES 6 规定只要函数参数使用了默认值、解构赋值或者扩展运算符，则函数内部不能显式设定为严格模式，否则报错。 原因：只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。 两种规避方法：全局性严格模式，将函数包在一个无参数的立即执行函数里。 9.name 属性：返回该函数的函数名。 如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。 1234const bar = function baz()&#123;&#125;;// ES 5、ES 6bar.name // "baz" Function构造函数返回的函数实例，name 属性的值为 anonymous。 1(new Function).name // "anonymous" bind返回的函数，name属性值会加上bound前缀。 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // "bound foo"(function()&#123;&#125;).bind(&#123;&#125;).name // "bound " 箭头函数10.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 12345678910111213141516// 箭头函数与变量解构结合使用const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person)&#123; return person.first + ' ' + person.last;&#125;// 简化回调函数[1, 2, 3].map(x =&gt; x * x);// 等同于[1, 2, 3].map(function(x)&#123; return x * x;&#125;); 11.箭头函数使用注意点： 函数体内的this对象就是定义时所在对象，而不是使用时所在对象。 不可当作构造函数（即不可使用new命令），否则抛出错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。也正因如此，箭头函数不能用作构造函数，也不能用call()、apply()、bind()这些方法去改变this的指向。 除了this，arguments、super、new.target在箭头函数中也是不存在的，指向外层函数的对应变量。 12.嵌套的箭头函数： 12345678910111213141516171819// ES 5function insert(value) &#123; return &#123;into: function(array) &#123; return &#123;after: function(afterValue) &#123; array.splice(array.indexOf(afterValue)+1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); // [1, 2, 3]// ES 6let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue)+1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); // [1, 2, 3] 13.函数绑定运算符：::，左边为对象，右边为函数。该运算符自动将左边的对象作为上下文环境（即 this 对象），绑定到右边的函数上。用来取代call、apply、bind调用。 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;var log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 12345let &#123; find, html &#125; = jake;document.querySelectorAll("div.myClass")::find("p")::html("hahaha"); 该语法为已被 Babel 转码器支持的一个 ES 7 提案。 14.尾调用：某个函数的最后一步是调用另一个函数。 To be continued… 对象的扩展1.属性的简洁表示法：ES 6 允许直接写入变量和函数，作为对象的属性和方法。这时，属性名为变量名，属性值为变量值。 1234567891011121314151617181920var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于var baz = &#123;foo: foo&#125;;var o = &#123; method()&#123; return "Hello!"; &#125;&#125;;// 等同于var o = &#123; method: function()&#123; return "Hello!"; &#125;&#125;; 如果某个方法的值是一个 Generator 函数，前面需要加上星号。 12345var obj = &#123; * m()&#123; yield 'hello world'; &#125;&#125;; 2.属性名表达式：ES 6 允许字面量定义对象时，把表达式放在方括号内。表达式也可用于定义方法名。 123456789101112131415let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;;// 表达式用于定义方法名let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 但属性名表达式与简洁表达式不能同时使用。 12345678// 报错var foo = 'bar';var bar = 'abc';var baz = &#123; [foo] &#125;;// 正确var foo = 'bar';var baz = &#123; [foo]: 'abc'&#125;; 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]（即不要这么用）。 3.方法的 name 属性：返回函数名。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 4.Object.is()：比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致（不同之处为+0不等于-0，以及NaN等于自身）。 5.Object.assign()：用于对象的合并，将源对象的所有可枚举属性复制到目标对象。第一个参数是目标对象，其他参数是源对象。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果多个对象有同名属性，后面的属性会覆盖前面的。 如果只有一个参数将直接返回（参数不是对象会先转成对象）。无法转成对象的源对象将被跳过。undefined和null无法转成对象，所以不能作为目标对象（否则报错）。其他相关注意事项见文档。 实行浅拷贝，即源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。对于嵌套对象，一旦遇到同名属性会被替换。 1234var target = &#123; a: &#123; b: 'c', d: 'e'&#125; &#125;;var source = &#123; a: &#123; b: 'hello' &#125; &#125;;Object.assign(target, source); // &#123;a: &#123; b: 'hello' &#125;&#125; Object.assign()有很多用处，其中包括为对象添加属性和方法。 1234567891011121314151617// 添加属性class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125;// 添加方法Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2)&#123; ... &#125;, anotherMethod()&#123; ... &#125;&#125;);// 等同于SomeClass.prototype.someMethod = function(arg1, arg2) &#123; ... &#125;;SomeClass.prototype.anotherMethod = function()&#123; ... &#125;; 属性的可枚举性与遍历6.Object.getOwnPropertyDescriptor：对象的每个属性都有一个描述对象，用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获得该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo');// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; ES 7 引入Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。 1234567891011121314151617181920const obj = &#123; foo: 123, get bar() &#123; return 'abc'; &#125;&#125;;Object.getOwnPropertyDescriptors(obj);// &#123;// foo: &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125;,// bar: &#123;// get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true// &#125;// &#125; 7.属性的可枚举性：描述对象的enumerable属性，成为“可枚举性”。ES 5 有三个操作会忽略enumerable为false的属性： for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 ES 6 新增Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 当只关心对象自身的属性时，尽量不要用for...in循环，而用Object.keys()代替。 8.Object.keys()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键名。ES 2017 引入配套的Object.values和Object.entries作为遍历一个对象的补充手段。 Object.values()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键值（不含 Symbol 属性）。参数为字符串时返回各个字符组成的一个数组，参数为数值或布尔值时返回空数组（与包装对象有关）。 Object.entries()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键值对数组（不含 Symbol 属性）。 9.属性的遍历：ES 6 共有5种遍历对象的方法。 for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但包括不可枚举属性）。 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性（无论是否可枚举或者属性名是 Symbol 还是字符串）。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则（之前一些遍历的方法也遵循此规则）。 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 __proto__属性及相关方法10.__proto__属性：用于读取或设置当前对象的prototype对象。内部属性，不是正式对外 API。建议使用Object.setPrototypeOf()（写操作）、Object.getPrototype()（读操作）、Object.create()（生成操作）代替。 如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。 11.Object.setPrototypeOf()：作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。 12345// 格式Object.setPrototypeOf(object, prototype)// 用法var o = Object.setPrototypeOf(&#123;&#125;, null); 如果第一个参数不是对象，会自动转为对象（由于返回的还是第一个参数，故无效果）；是undefined或null则报错（无法转为对象）。 12.Object.getPrototypeOf()：用于读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 如果参数不是对象，会被自动转为对象；是undefined或null则报错。 13.对象的扩展运算符：ES 2017 将...引入对象。主要用途有： 解构赋值： 1234let &#123;x, y, ...z&#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 注意解构赋值的拷贝是浅拷贝，且不会拷贝继承自原型对象的属性。 123456789// 扩展某个函数的参数，引入其他操作function baseFunction(&#123; a, b &#125;) &#123; // ...&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用x和y参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 扩展运算符：取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于Object.assign方法。 123456789101112let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;// 等同于let n = Object.assign(&#123;&#125;, z);// 用于合并两个对象let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。因此可用于修改现有对象部分的部分属性。 1234let newVersion = &#123; ...previousVersion, name: 'New Name' // Override the name property&#125;; 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 1let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;; 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 14.Null 传导运算符：?.，用于判断对象及其内部属性是否存在。仅为提案，详见文档。 Symbol1.概述：ES 6 引入的新的原始数据类型，表示独一无二的值。至此，JS 共有七种数据类型： Undefined Null 布尔值（Boolean） 字符串（String） 数值（Number） 对象（Object） Symbol Symbol 值通过Symbol函数生成。即对象的属性名有两种类型：原来就有的字符串，和新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就是独一无二的，不会与其他属性名产生冲突。 1234let s = Symbol();typeof s// "symbol" 生成的 Symbol 是一个原始类型的值，不是对象。因此Symbol函数前不能使用new命令（否则报错），Symbol 值也不能添加属性。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。但相同参数的Symbol函数的返回值是不相等的。 12345678var s1 = Symbol('foo');var s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // "Symbol(foo)"s2.toString() // "Symbol(bar)" 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后生成一个 Symbol 值。 1234567const obj = &#123; toString()&#123; return 'kyon'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) Symbol 值不能与其他类型的值进行运算（会报错），但可以显式转为字符串和布尔值。 2.作为属性名的Symbol： 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello'! &#125;);// 以上写法都得到同样结果a[mySymbol] // "Hello!" Symbol 值作为对象属性名时，不能用点运算符。 123456var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // "Hello!" Symbol 值作为属性名时，该属性是公开属性而非私有属性。 3.魔术字符串：在代码中多次出现、与代码形成强耦合的某一个具体的字符串或数值。应尽量消除而改用含义清晰的变量代替。 Symbol可用于消除魔术字符串。 4.属性名的遍历：Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。这个特性可被用于为对象定义一些非私有的、但又希望只用于内部的方法。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 Reflect.ownKeys(obj)方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// ["enum", "nonEnum", Symbol(my_key)] 5.Symbol.for()、Symbol.keyFor()：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234var s1 = Symbol.for('foo');var s2 = Symbol.for('foo');s1 === s2; // true Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 12345Symbol.for("bar") === Symbol.for("bar")// trueSymbol("bar") === Symbol("bar")// false Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345var s1 = Symbol.for("foo");Symbol.keyFor(s1); // "foo"var s2 = Symbol("foo")Symbol.keyFor(s2); // undefined 6.Singleton 模式：指调用一个类，任何时候返回的都是同一个实例。 Node 中，模块文件可以看作一个类。可以使用 Symbol，通过把实例放到顶层对象global来实现 Singleton 模式。 内置的 Symbol 值(暂且略过)7.Symbol.hasInstance属性：指向一个内部方法。 8.Symbol.isConcatSpreadable属性： 9.Symbol.species 10.Symbol.match 11.Symbol.replace 12.Symbol.search 13.Symbol.split 14.Symbol.iterator 15.Symbol.toPrimitive 16.Symbol.toStringTag 17.Symbol.unscopables Set 和 Map 数据结构Set1.基本用法：Set 结构不会添加重复的值。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for(let i of s)&#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。因此有一种去除数组重复成员的方法： 1[...new Set(array)] Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，类似精确相等运算符（===），主要的区别是NaN等于自身（===认为NaN不等于自身）。另外，两个对象总是不相等的。 2.Set 实例的属性和方法： 实例属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法： add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个表示删除是否成功的布尔值。 has(value)：返回一个布尔值。 clear()：清除所有成员，没有返回值。 遍历方法（Set 结构中，键名和键值是同一个值）： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Array.from方法可以将 Set 结构转为数组。 WeakSet3.含义：与 Set 类似，但成员只能是对象，且都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 ES 6 规定，WeakSet 不可遍历。 4.语法：有add、delete、has方法；没有size属性。 5.用处：是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 Map6.含义和基本用法：为了解决 Object 的只能用字符串当作键名的问题，ES 6 提供了 Map 数据结构。各种类型的值（包括对象）都可以当作键。 有set(key, value)、get(key)、has(key)、delete(key)、clear()方法。 作为构造函数，Map 可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组。 如果对同一个键多次赋值，后面的值将覆盖前面的值；如果读取一个未知的键，则返回undefined。 7.与其他数据结构的互相转换： Map 转为数组：使用扩展运算符（...）。 数组转为 Map：使用 Map 构造函数。 Map 转为对象：如果所有 Map 的键都是字符串，可以转为对象。 1234567891011function strMapToObj(strMap)&#123; let obj = Object.create(null); for(let [k, v] of strMap)&#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap);// &#123; yes: true, no: false &#125; 对象转为 Map： 1234567function objToStrMap(obj)&#123; let strMap = new Map(); for(let k of Object.keys(obj))&#123; strMap.set(k, obj[k]); &#125; return strMap;&#125; Map 转为 JSON： 12345// 情况一：Map 的键名都是字符串// 可以转换为对象 JSONfunction strMapToJson(strMap)&#123; return JSON.stringify(strMapToObj(strMap));&#125; 12345// 情况二：Map 的键名有非字符串// 可以转换为数组 JSONfunction mapToArrayJSON(map)&#123; return JSON.stringify([...map]);&#125; JSON 转为 Map：逆操作。 WeakMap8.含义：与 Map 类似，用于生成键值对。但只接受对象作为键名（null除外），且键名所指向的对象不计入垃圾回收机制。 专用场合：它的键所对应的对象可能会在将来消失。WeakMap结构有助于防止内存泄漏。 9.语法：没有遍历操作，无法清空。只有四个方法可用：get()、set()、has()、delete()。 10.用处：DOM 节点作为键名。 123456789101112// 一个例子let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function()&#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false);// 一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险 注册监听事件的listener对象，就很适合用 WeakMap 实现。 123456789const listener = new WeakMap();listener.set(element1, handler1);listener.set(element2, handler2);element1.addEventListener('click', listener.get(element1), false);element2.addEventListener('click', listener.get(element2), false);// 一旦DOM对象消失，跟它绑定的监听函数也会自动消失 WeakMap 的另一个用处是部署私有属性。 Proxy暂时跳过。 Reflect暂时跳过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通jQuery》读书笔记]]></title>
      <url>%2FjQuery-master-notes%2F</url>
      <content type="text"><![CDATA[这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。 感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。 了解 jQueryjQuery 核心库的工作通过处理浏览器加载 HTML 时动态创建的 DOM（文档对象模型），达到动态修改页面内容的目标。 HTML 入门事件流一个事件在它的生命周期中要经历 3 个阶段：捕获、处理目标元素和冒泡。 目标元素：触发事件的元素。 CSS 基础反选择器:not(&lt;selector&gt;)：选取不匹配指定选择器的元素。 样式层叠浏览器查找样式元素值的顺序： 行内样式（定义在元素 style 属性中的样式）； 内嵌样式（定义在 style 元素中的样式）； 外部样式（使用 link 元素导入的样式）； 用户样式（用户自己定义的样式）； 浏览器样式（浏览器提供的默认样式）。 前三个又合称为作者样式。 important 规则在样式声明的末尾追加!important可以把改值标识为重要样式。浏览器会给重要样式以优先权，而不再考虑这个样式的定义位置。 唯一能优先于作者样式中重要样式的样式是定义在用户样式表中的重要样式。对于普通样式来说，作者样式优先于用户样式。但对于重要样式，浏览器的做法恰恰相反。 “专一程度”浏览器根据以下 3 个特征计算样式的“专一程度”： 选择器中出现的 id 值个数； 选择器中出现的其他属性和伪类个数； 选择器中出现的元素名字和伪元素名字个数。 以 a-b-c 这种形式评估样式规则的“专一”程度，逐位比较，每一位上数字越大表示越专一。例如，1-0-0 比 0-5-5 更专一。 如果有多条样式规则的专一程度相同，那么浏览器会选择最后定义的那条规则。专一程度规则仅在同一层叠级别有效。 样式单位相对长度单位 em：相对于元素字号的高度； ex：相对于元素字体中小写字母 x 的高度； rem：相对于根元素的高度； px：CSS 像素（假定位于一个 96dpi 的显示设备上，实际上是绝对单位，不会改变大小）； %：另一属性值的百分比。 jQuery 基础使用 CDN 版的 jQueryCDN（Content Delivery Network）：内容分发网络。当用户请求其数据时，CDN 能智能地分配离用户最近的服务器提供服务。 使用 CDN 的两个优点：(1)用户体验更好（速度通常更快）；(2)节省了传输 jQuery 库所需带宽。 CDN 不适合内联网应用程序。 $ 函数jQuery.noConflict方法让 jQuery 放弃使用 $ 符号。也可将该方法的返回值赋给一个变量以自定义 jQuery 简写符号。 延迟 ready 事件的触发时间$.holdReady(true)必须在 ready 事件触发之前调用，$.holdReady(false)告诉 jQuery 触发 ready 事件。可以多次调用，但在 ready 事件被真正触发之前，使用 true 参数调用次数要等于使用 false 参数调用次数。 选择元素 使用上下文限制搜索范围多给 $ 函数提供一个参数以限制搜索的范围。如果提供的上下文选择器匹配多个元素，将会把匹配上下文选择器的元素收集在一起，然后再匹配主选择器。 12$("img:odd", $(".drow"))// img:odd选择器会应用在.drow选择器的结果上 确定选择结果 数据模版介绍了模板库 Handlebars。 定义模板数据模板库的核心是数据模板——包含着占位符的 HTML 元素。 p268 处理表单介绍了 jQuery 插件 Validation，它专门处理表单验证问题。 jQuery Validation Engine 表单验证 p297 Ajaxp331]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《ECMAScript 6 入门》读书笔记(一)]]></title>
      <url>%2Fes6-1-notes%2F</url>
      <content type="text"><![CDATA[《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：ECMAScript 6 入门。将知识点简便地总结一下，以供后续使用时参考或复习。 此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。 let和const命令1.let：let声明的变量仅在块级作用域内有效。不存在变量提升；存在暂时性死区，只能在声明的位置后面获取和使用；相同作用域内不可重复声明。 2.块级作用域：外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。 3.根据ES 6附录B的规定，在浏览器的ES 6环境中，块级作用域内声明的函数，行为类似于var声明的变量。应避免在块级作用域内声明函数，或用函数表达式代替函数声明语句。 4.do 表达式：在块级作用域之前加上do，使其变为表达式（可以返回值）。 12345// 变量x得到整个块级作用域的返回值let x = do &#123; let t = f(); t * t + 1;&#125;; 5.const：声明一个只读常量。一旦声明，就必须立即初始化。和let一样，只在声明所在的块级作用域内有效；声明的常量不提升；存在暂时性死区；不可重复声明。 const保证变量指向的内存地址不可改动。因此将对象声明为常量时，不可变的只是地址，对象本身可变，可以为其添加新属性。 如果真想将对象冻结，应用Object.freeze()方法（对象本身和 其属性都应冻结）。 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, i) =&gt; &#123; if(typeof obj[key] === 'object') &#123; constantize(obj[key]); &#125; &#125;);&#125;; 6.顶层对象的属性：let、const、class声明的全局变量不属于顶层对象的属性。 补充资料：ES6之”let”能替代”var”吗? 变量的结构赋值1.解构：按照一定模式，从数组和对象中提取值，对变量进行赋值。解构不成功，变量的值就等于undefined。 1234567891011121314151617181920212223let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []let [bar, foo] = [1];foo // undefined 2.不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 3.解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值不会生效。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 如果默认值是一个表达式，那么这个表达式是惰性求值的（用到时才会求值）。 123456// x能取到值，所以函数f根本不会执行function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 4.要将一个已经声明的变量用于解构赋值时，将大括号写在行首会导致JavaScript引擎将其解释为代码块，从而发生语法错误。 12345let x;// 错误写法&#123;x&#125; = &#123;x: 1&#125; // SyntaxError: syntax error// 正确写法(&#123;x&#125; = &#123;x: 1&#125;); 对象的结构赋值5.对象的解构：属性没有次序，变量取值由名称决定。 123let &#123; bar, foo&#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 如果变量名与属性名不一致，须写成： 1234567var &#123; foo: baz&#125; = &#123; foo: 'aaa', bar: 'bbb'&#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 6.解构也可用于嵌套结构的对象。 123456789101112let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;]&#125; = obj;x // "Hello"y // "World"// 这时p是模式，不是变量，因此不会被赋值。p // error: p is undefined 字符串的结构赋值7.此时字符串被转化成一个类似数组的对象，且具有length属性（可以针对此属性解构赋值）。 123456const [a, b, c, d, e] = 'hello';a // "h"e // "o"let &#123;length : len&#125; = 'hello';len // 5 数值、布尔值的结构赋值8.解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。undefined和null无法转为对象，所以对它们解构赋值都会报错。 1234567let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // truelet &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的结构赋值9.为函数move的参数指定默认值： 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 为变量x和y指定默认值： 12345678function move(&#123;x, y&#125; = &#123;x: 0, y:0&#125;)&#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 圆括号问题10.ES6规定，只要可能导致解构歧义，就不得使用圆括号。由于这条规则不易辨别，因此建议尽量不要在模式中放置圆括号。 11.以下三种解构赋值不得使用圆括号。 变量声明语句中，不能带有圆括号。 函数参数中，模式不能带有圆括号。 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 12.可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。 用途 交换变量的值： 123let x = 1;let y = 2;[x, y] = [y, x]; 从函数中返回多个值：将返回的数组或对象中的值取出 函数参数的定义：方便地将无序的参数与变量名对应 提取JSON数据： 12345678910let jsonData = &#123; id: 24, status: "OK", data: [424, 5920]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 24, "OK", [424, 5920] 函数参数的默认值 遍历Map结构： 123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 字符串的扩展1.字符的Unicode表示法：将码点放入大括号。 123"\u&#123;20BB7&#125;" // "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;" // "ABC" 2.新增一些方法： codePointAt()：能够正确处理4个字节储存的字符，返回一个字符的码点。是测试一个字符由两个字节还是由四个字节组成的最简单方法。 String.fromCodePoint()：用于从码点返回对应字符，可识别Unicode编号大于0xFFFF的码点（32位的UTF-16字符）。 at()（提案）：返回字符串给定位置的字符，可识别Unicode编号大于0xFFFF的码点。 repeat(n)：返回一个新字符串，表示将原字符串重复n次。 normalize()：将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 padStart()：如果某个字符串不够指定长度，会在头部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串（默认为空格）。 padEnd()：同上，用于尾部补全。 3.模版字符串：常用于定义多行字符串，或者在字符串中嵌入变量。用反引号（`）标识。 12345678910// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`// 字符串中嵌入变量var name = "Kyon", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 模板字符串中嵌入变量，要将变量名卸载${}中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，也可以调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串（例如对象调用toString方法）。 4.标签模板（功能）：函数调用的一种特殊形式。模板字符串作为参数紧跟在一个函数名后，该函数被调用以处理该模板字符串。常用于转义特殊字符和多语言转换（国际化处理）。 123console.log`Kyon`// 等同于console.log('Kyon') 模板字符有变量时，先把模板字符串处理成多个参数。处理得到的第一个参数是一个数组，包含那些没有变量替换的部分。 123456var a = 5;var b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`;// 等同于tag(['Hello', ' world', ''], 15, 50); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存转义后的原字符串。 5.String.raw()：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串；如果原字符串的斜杠已经转义，则不会做任何处理。常用于处理模板字符串。 12345String.raw`Hi\n$&#123;3+4&#125;!`;// "Hi\\n7!"String.raw`Hi\u000A!`;// 'Hi\\u000A!' 也可作为正常函数使用，第一个参数应是具有raw属性的对象，且raw属性的值应是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 6.模板字符串的限制（提案）：放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 正则的扩展1.u修饰符：Unicode 模式，用来正确处理大于\uFFFF的 Unicode 字符。对于码点大于\uFFFF的 Unicode 字符，点字符(.，除了换行符外的任意单个字符)、Unicode 字符表示法（使用大括号表示 Unicode 字符）、量词、预定义模式（\S，匹配所有不是空格的字符）必须加上u修饰符才能识别。 1234/^\uD83D/u.test('\uD83D\uDC2A')// false/^\uD83D/.test('\uD83D\uDC2A')// true 2.y修饰符：“粘连”修饰符，全局匹配，但须确保匹配必须从剩余的第一个位置开始。一个应用是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // ["aaa"]r2.exec(s) // ["aaa"]r1.exec(s) // ["aa"]r2.exec(s) // null 3.ES 6 的正则对象新增了sticky属性和flags属性，分别表示是否设置了y修饰符以及返回正则表达式的修饰符。 123var r = /hello\d/y;r.sticky // truer.flags // 'y' 4.有一些提案。因为我暂时对正则不太熟悉，所以略过。 数值的扩展1.二进制、八进制表示法：分别用前缀0b（或0B）和0o（或0O）表示。用Number()方法将其转化为十进制。 12340b111110111 === 503 // true0o767 === 503 // trueNumber('0b111') // 7 2.新增 Number 对象上的一些方法： Number.isFinite()：用于检查一个数值是否为有限的。 Number.isNaN()：用于检查一个值是否为NaN。 与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。 将全局方法parseInt()和parseFloat()移植到 Number 对象上，行为完全保持不变，目的是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()：用于判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是同样的储存方法，这个方法都会返回 true。 3.Number.EPSILON：极小的常量，表示一个可以接受的误差范围。浮点数计算误差小于Number.EPSILON时可以认为得到正确结果。 4.Number.isSafeInteger()：JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围的值无法精确表示。Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 5.Math 对象的扩展：所有新增方法都是静态方法，只能在 Math 对象上调用。 Math.trunc()：用于去除一个数的小数部分，返回整数部分。对于非数值内部使用Number方法将其先转为数值；对于空值和无法截取整数的值，返回 NaN。 Math.sign方法用来判断一个数到底是正数、负数、还是零。它会返回五种值：参数为正数，返回+1；负数返回-1；0返回0；-0返回-0；其他值返回NaN。 Math.cbrt：用于计算一个数的立方根。 此外，还有一些对数方法和三角函数方法。 6.指数运算符（**）： 1234562 ** 2 // 42 ** 3 // 8let a = 3;a **= 3;// 等同于 a = a * a * a; 数组的扩展1.Array.from()：将类数组对象（本质特征是有length属性）和可遍历对象（部署了 Iterator 接口的数据结构，包括 ES 6新增的 Set 和 Map）转化为真正的数组。1234567891011let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;var arr1 = Array.from(arrayLike);Array.from('hello');// ['h', 'e', 'l', 'l', 'o'] 还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组；如果map函数里面用到了this关键字，还可以传入Array.from()的第三个参数，用来绑定this。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 2.Array.of()：返回参数值组成的数组（没有参数则返回空数组）。 12345Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]Array.of(3) // [3]Array.of(3, 11, 8) // [3, 11, 8] 3.数组实例的copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置（覆盖原有成员），然后返回当前数组。 接受三个参数（都为数值，否则自动转换）： target（必需）：从该位置开始替换数据； start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 1234Array.prototype.copyWithin(target, start = 0, end = this.length)[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 4.数组实例的find()和findIndex()： find()用于找出第一个符合条件的数组成员。其参数为一个回调函数（可以接收三个参数：当前的值，当前的位置和原数组），所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员，否则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 findIndex()类似，返回第一个符合条件的数组成员的位置，否则返回-1。 5.数组实例的fill()：用给定值填充一个数组。 1234567// 数组中原有的元素将被覆盖['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]// 还可以接受两个参数，用于指定填充的起始位置和结束位置['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 6.数组实例的keys()、values()和entries()：用于遍历数组。都返回一个遍历器对象，可以用for..of循环进行遍历；区别为分别对键名、键值、键值对遍历。 1234567891011121314151617for(let index of ['a', 'b'].keys())&#123; console.log(index);&#125;// 0// 1for(let elem of ['a', 'b'].values())&#123; console.log(elem);&#125;// 'a'// 'b'for(let [index, elem] of ['a', 'b'].entries())&#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 7.数组实例的includes()（属于ES 7 但 Babel 转码器已经支持）：返回一个布尔值，表示某个数组是否包含给定的值。 123[1, 2, 3].includes(2); // true[1 ,2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 8.数组的空位：和undefined不同，数组的空位没有任何值。ES 5 对空位的处理规则很不一致（大多数情况会忽略）；而 ES 6 明确将空位转为undefined。尽管如此，建议避免出现空位。 1Array(3) // [, , ,]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究伪元素及其用途]]></title>
      <url>%2Fpseudo_elements%2F</url>
      <content type="text"><![CDATA[之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。 伪类与伪元素的区别伪元素(Pseudo-elements)容易与伪类(Pseudo-classes)混淆。在 w3c 定义中，伪类用于向某些选择器添加特殊的效果，而伪元素用于将特殊的效果添加到某些选择器。可以看到从定义上来说，二者确实不好分辨。不过在种类上可以看出二者的一些不同。 伪类包括： :link：向未被访问的链接添加样式。 :visited：向已被访问的链接添加样式。 :hover：当鼠标悬浮在元素上方时，向元素添加样式。 :active：向被激活的元素添加样式。 :focus：向拥有键盘输入焦点的元素添加样式。 :first-child：向元素的第一个子元素添加样式。 :lang：向带有指定 lang 属性的元素添加样式。 其中前四个因为用不同的方式显示链接的不同状态，被称为“锚伪类”。在 CSS 定义中，a:hover必须被置于 a:link和a:visited之后，而a:active必须被置于a:hover之后才是有效的。 伪元素包括： :before：在元素之前添加内容。 :after：在元素之后添加内容。 :first-letter：向文本的第一个字母添加特殊样式。 :first-line：向文本的首行添加特殊样式。 其中前两个无疑是用的最多的。后两个也可以用于实现一些特殊效果，例如通过:first-letter实现段落首字母加粗或变色。 两者的根本区别是：伪类可以通过直接添加一个实际的类样式达到同等效果；而伪元素的效果则需要先添加一个实际的元素，再在元素上添加样式才能达到。 在 CSS 3 中修订后的伪元素使用两个冒号（::）以与伪类进行区分。但无论使用单冒号还是双冒号，浏览器都能识别。并且 IE 8 只支持单冒号的写法。因此为了更广泛的浏览器兼容性，还是推荐使用单冒号的写法。 伪元素的优点最常使用的两种伪元素——:before和:after可以在内容元素的前后插入额外的元素。通过伪元素，在实现很多炫酷的视觉效果时，我们不必修改现有的 HTML 文档结构。因为 HTML 文档本身仅仅应该包含内容，而不应该包含样式，所以伪元素更应该被提倡。 伪元素的应用鉴于伪元素应用很多时候代码相对专一，建议配合 Sass，通过设置 mixin 来使用以提高复用性（你可以通过我的上一篇博文 初见Sass－便捷的CSS预处理器 来了解Sass）。 清除浮动这大概是伪元素最为常见的应用了。比起插入额外的非语义标记来清除内联元素的浮动，这种俗称“clearfix”的方式更语义化。 CSS 123456789101112.group:before,.group:after &#123; content:&quot;&quot;; display:table;&#125;.group:after &#123; clear:both; overflow: hidden;&#125;.group &#123; zoom:1; /* For IE 6/7 (trigger hasLayout) */&#125; Sass 12345678910111213141516@mixin clearfix &#123; @if $legacy-support-for-ie &#123; *zoom: 1; &#125; &amp;:before, &amp;:after &#123; content: &quot;&quot;; display: table; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125; &#125;// 通过 @include 方法调用 实现样式效果能够借助伪元素实现的样式效果数不胜数。这里举一个简单而常用的例子。 很多时候我们会在每一节的标题下做一个类似下划线效果，用来强调。使用伪元素可以让我们不必添加额外的元素来实现这个效果。 Sass 代码如下： 123456789101112131415@mixin section-title() &#123; font-size: 2em; padding: 2em 0; text-transform: uppercase; color: #55a2dd; &amp;:after &#123; display: block; content: &quot;&quot;; background-color: #cccccc; width: 2em; height: .2em; margin: .4em auto; &#125;&#125; 设置透明度有时我们想给一张大图设置透明度，却发现其子元素都会被继承这个透明度。以往想要消除这个属性总让我头大。现在通过伪元素，我们就可以分别为文字和图片设置不同的透明度。 Sass 代码如下（来自第3周：设计你自己的页面）： 1234567891011121314151617181920212223242526272829303132333435363738394041.hero &#123; width: 100%; min-height: 50em; position: relative; background-color: $mask-color; z-index: 1; &amp;:after &#123; background: url(&apos;../images/hero-1-resized.jpg&apos;); background-size: cover; position: absolute; content: &quot;&quot;; z-index: -1; opacity: .2; width: 100%; height: 100%; top: 0; left: 0; &#125; h2 &#123; font-size: 6em; font-weight: bold; padding: 3em 0 1em 0; text-transform: uppercase; color: white; &#125; p &#123; max-width: 70%; font-size: 1.5em; font-weight: lighter; color: #cecece; line-height: 1.4; margin: 0 auto; padding: 1em 0 8em 0; span &#123; color: $heading-color; &#125; &#125;&#125; 对于 .hero 这个 section，我们将其背景设置为灰色，并将 position 设置为 relative。然后为其添加了一个伪元素，这个伪元素上包含了实际的图片，并为图片设置了透明度 .2。 参考资料CSS 伪元素 - W3School 你可以从这篇文章中了解更多伪元素的应用：大放异彩的伪元素——可以做什么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初见Sass－便捷的CSS预处理器]]></title>
      <url>%2Fsass-begin%2F</url>
      <content type="text"><![CDATA[发现自己又找到一本关于前端实践的优质开源书《3周3页面》。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。” 什么是Sass为了给 CSS 加入编程元素，人们发明了Sass。Sass 是一个 CSS3 的扩展语言，它提供了嵌套样式，变量定义，扩展，mixin等丰富的特性，使得编写样式更加容易，节省了开发者的时间。 Sass基础语法这里只记录我觉得比较关键的语法作为备忘。可以查看 sass十分钟入门 或者 SASS用法指南 以较为全面地入门。 变量：以$开头。如果变量需要镶嵌在字符串之外，需要写在#{}中。 嵌套：用&amp;引用父元素。 继承：使用@extend命令。 Mixin：使用@mixin命令定义一个代码块，使用@include命令调用。可以指定参数和缺省值。 插入文件：使用@import命令。 自定义函数：使用@function和@return。 此外支持条件语句和循环语句。 WebStorm中使用Sass注意，本节内容针对 OS X 环境。可能部分内容也兼容其他平台，但我没试过。 WebStorm 支持 Sass 的自动编译。在 WebStorm 的 Preferences 中，Tools 下选择 File Watchers。配置 Sass 和 SCSS（最新版的 Sass 后缀）需要有相应的 Program。 因为 Sass 依赖 ruby，所以要先安装 ruby。不过 OS X 好像自带 ruby（至少我没有什么时候安装过的印象…）。之后建议安装 Compass：sudo gem install compass，Sass 和 SCSS 的 Program 会被一并安装，WebStorm 也会检测到，之后点击 OK 即可。 之后，WebStorm 会自动监测 Sass 文件的改动，并时刻编译为同名 CSS 文件，保存在同一文件夹下，非常方便。 Sass实现媒体查询1234567891011121314151617// 定义两个 break-point$break-small: 320px;$break-large: 1024px;// 定义一个 mixin，接收三个可能的参数// 分别代表不同的设备——手机、平板和桌面显示器@mixin respond-to($media) &#123; @if $media == handhelds &#123; @media only screen and (max-width: $break-small) &#123; @content; &#125; &#125; @else if $media == medium-screens &#123; @media only screen and (min-width: $break-small + 1) and (max-width: $break-large) &#123; @content; &#125; &#125; @else if $media == wide-screens &#123; @media only screen and (min-width: $break-large) &#123; @content; &#125; &#125;&#125; 使用时： 12345div&#123; @include respond-to(medium-screens) &#123; //... &#125;&#125; 这种方式使用起来更方便，也便于后期统一修改变量的具体数值。 参考资料《3周3页面》的作者同样推荐了 Compass。这是一个使用了 Sass 的库，将很多常用样式打包成了一些模块以供使用。因为安装时出现了一些我还没解决的 error，我还没有使用过。可以查看 Compass用法指南 以获得更多了解。 此外，推荐 SASS基础——十个常见的Mixins。这篇文章总结了一些常用的 Mixin，更重要的是，通过这些Mixin，对 CSS 可以获得更深入的理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[神奇的CSS动画]]></title>
      <url>%2Fcss-animation%2F</url>
      <content type="text"><![CDATA[按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。 通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。 17.04.03更新：补充打字机动效。 transition 属性transition 是一个速记属性，有以下四个属性： transition-property：指定 CSS 属性的 name, transition 效果； transition-duration：transition 效果需要指定多少秒（或毫秒）才能完成； transition-timing-function：指定 transition 效果的转速曲线，包括五个模式：ease（渐慢，默认）、linear（匀速）、ease-in（加速）、ease-out（减速）、cubic-bezier 函数（自定义速度模式，可使用工具网站定制）； transition-delay：定义 transition 效果开始的时候。 123456789101112// 简写img&#123; transition: 1s 1s height ease;&#125;// 单独定义img&#123; transition-property: height; transition-duration: 1s; transition-delay: 1s; transition-timing-function: ease;&#125; 其中必须指定 transition-duration 属性，否则持续时间默认为 0 ，没有任何效果。 transition 的局限： 需要事件触发，没法在网页加载时自动发生； 一次性，除非一再触发，否则不能重复发生； 只能定义开始状态和结束状态（即只有两个状态），不能定义中间状态； 需要明确知道开始状态和结束状态的具体数值，才能计算中间状态； 一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。 keyframes（关键帧）animation 属性可以利用 keyframes 关键字定义动画的各个状态，将指定时间段内的动画划分的更为精细。 123456789@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125;div:hover &#123; animation: 1s rainbow infinite;&#125; 0% 可以用 from 表示，100% 可以用 to 表示： 12345@keyframes rainbow &#123; from &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; to &#123; background: yellowgreen; &#125;&#125; 如果省略某个状态，浏览器会自动推算中间状态。也可将多个状态写在一行。 123456789101112131415// 以下都为合法的写法@keyframes rainbow &#123; 50% &#123; background: orange &#125; to &#123; background: yellowgreen &#125;&#125;@keyframes rainbow &#123; to &#123; background: yellowgreen &#125;&#125;@keyframes pound &#123; from，to &#123; transform: none; &#125; 50% &#123; transform: scale(1.2); &#125;&#125; 从一个状态向另一个状态过渡，浏览器默认为平滑过渡。steps 函数可以实现分布过渡。 123div:hover &#123; animation: 1s rainbow infinite steps(10);&#125; animation 常用属性123456789101112131415// 简写div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125;// 单独定义div:hover&#123; animation-name: rainbow; animation-duration: 1s; ainmation-timing-function: linear; animation-delay: 1s; animation-fill-mode: forwards; animation-direction: normal; animation-iteration-count: 3;&#125; animation 有以下常用属性（其余和 transition 大致相似）： animation-iteration-count：指定动画播放次数，可指定为数值或 infinite（无限次）。 animation-direction：指定动画播放方向，默认为 normal。其他可选值有 reverse，alternate 和 alternate-reverse（后两种浏览器支持情况不佳）。 animation-fill-mode：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。有四个可选值： forwards：让动画停留在结束状态； none：回到动画没开始的状态； backwards：让动画回到第一帧的状态； both：根据 animation-direction 轮流应用 forwards 和 backwards 规则。 animation-play-state：指定动画播放突然终止时的状态，默认行为是跳回动画的开始状态。 12345678910// 让动画保持突然终止时的状态div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125; 浏览器支持IE 10、Firefox 16.0、Chrome 43.0、Safari 9.0、Opera 30.0 以上支持没有前缀的 animation。详见 CSS3 animation（动画） 属性 “浏览器支持”部分。 使用示例打字机动效依照 让页面动起来 实现的打字机动效。图片素材为自制，因此部分数据与参照有出入。素材及代码见 bighuang624/Front-end_Learning/打字机动效。 （gif图没搞好…） 参考资料CSS动画简介 - 阮一峰的网络日志 CSS3 animation（动画） 属性 CSS 变换 过渡 动画使用案例 补充： css3 animation 属性众妙]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究JS中的词法作用域]]></title>
      <url>%2F20953%2F</url>
      <content type="text"><![CDATA[这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 JavaScript 语言精粹 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 箭头函数 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。” 这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。 词法作用域《JavaScript 权威指南》第5章“8.8.1 词法作用域”中对“词法作用域”的解释如下： “JavaScript 中的函数是通过词法来划分作用域的，而不是动态地划分作用域的。这意味着它们在定义它们的作用域里运行，而不是在执行它们的作用域里运行。当定义了一个函数，当前的作用域链就保存起来，并且成为函数的内部状态的一部分。” 当然，这几句话还是玄之又玄，摸不着头脑。它还是没有具体解释“词法作用域”中的“词法”二字代表什么。不过我这学期的《编译原理》课程上经常见到这个词：编译过程被划分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成 6 个阶段（清华大学出版社《编译原理》）。在查阅资料后，我确信这个概念确实与编译有关。 JavaScript 引擎在代码执行前会对其进行编译，而所谓的词法作用域指作用域是由书写代码时函数声明的位置决定，在词法解析阶段就已经确定，之后不会改变。也就是说，JS 中的“词法作用域”等同于静态作用域，即与动态作用域（运行时确定）相对。 词法作用域关注函数在何处声明；而动态作用域关注函数从何处调用，其作用域链是基于运行时的调用栈的。换言之，在遇到既不是形参也不是函数内部定义的局部变量的变量时，词法作用域的函数会去函数定义时的环境中查询；而动态作用域的函数会到函数调用时的环境中查询。 一个例子： 1234567891011function foo()&#123; print a;&#125;function bar()&#123; var a = 3; foo();&#125;var a = 2;bar(); 采用词法作用域的语言会输出 2，而采用动态作用域的语言会输出 3。 顺便一提，在 JS 中eval和with可以产生动态作用域的效果。但《JavaScript 高级程序设计》不推荐使用此二者。 参考资料： 动态作用域和词法域的区别是什么？- 知乎]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在把玩中学习——typewriter.js]]></title>
      <url>%2Ftypewriter%2F</url>
      <content type="text"><![CDATA[大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。 好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。 这个有打字和仿光标闪烁效果的 typewriter.js 好像是我在看什么“程序员表白利器”时加到收藏夹里的。现在学习了 js，敢看看源码了，发现 js 代码只有20行不到。作者说：“原生JavaScript就是这么牛。”确实是这样的。虽然效果也很简单，但也能从里面学到一些东西。 HTML 源代码（大致结构）： 1234567891011121314&lt;body&gt; &lt;div id=&quot;mainDiv&quot;&gt; &lt;div id=&quot;content&quot;&gt; &lt;div id=&quot;code&quot;&gt; &lt;span class=&quot;comments&quot;&gt;/**&lt;/span&gt;&lt;br /&gt; &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* We are both XXX Unversity business administration and programmers,&lt;/span&gt;&lt;br /&gt; &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* so I write some code to show my love to you.&lt;/span&gt;&lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;code&quot;).typewriter(); &lt;/script&gt;&lt;/body&gt; JavaScript 源代码： 12345678910111213141516171819Element.prototype.typewriter=function(a)&#123; var d = this, c = d.innerHTML, b = 0; d.innerHTML=&quot;&quot;; var e = setInterval(function() &#123; var f = c.substr(b, 1); if (f == &quot;&lt;&quot;) &#123; b = c.indexOf(&quot;&gt;&quot;, b) + 1 &#125; else &#123; b++ &#125; d.innerHTML=c.substring(0, b) + (b &amp; 1 ? &quot;_&quot; : &quot;&quot;); if (b &gt;= c.length) &#123; clearInterval(e) &#125; &#125;, 75) return this &#125; 在这份 js 代码中可以学习的点： 原型模式定义方法：给 Element 添加实例方法typewriter()（在 html 文件中调用），这里有一个参数 a，实际上没什么用。顺便一说，源码在 head 处引入了 js 文件，这是为了先加载 js 文件。如果按照代码规范将引入放在 body 部分的最后，则有一瞬间所有字先出现再消失，不符合效果要求。可见代码规范也要根据实际来遵守。 声明三个变量，d 保存当前对象（”code”）。这个操作是必要的，因为后面要给 “code” 的 innerHTML 赋值的时候有时在函数作用域中，this 取不到 “code”。 代码逻辑很清晰，包括对标签的处理、光标效果的实现和定时器的清除等。要对自己想要实现的效果有一个全面的认知和大致的构思再开始写代码。 末尾return this以支持链式操作。 想要用功能强大的JavaScript实现一些小效果不难，但是怎样一步步规划、修改到实现对现在的我来说还是比较有挑战性的。希望自己能在欣赏、借鉴、吸收的过程中去实现一些有趣的 demo，重拾对代码的兴趣和创造力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（五）]]></title>
      <url>%2FJS-notes-5%2F</url>
      <content type="text"><![CDATA[今天看了看LESS。前端要研究的东西确实有点多，压力有点大。而且发现自己动手写代码的水平也有待提高。从今天开始理论学习要给实践让让路了，加油加油。 这篇博文总结了《JavaScript高级程序设计》的20~21章：JSON、AJAX与Comet。此外，关于CORS的部分还参考了廖雪峰的JavaScript教程。 JSONJSON是一种数据格式。虽然有相同的语法形式，但JSON不从属于JavaScript。很多编程语言都有针对JSON的解析器和序列化器。 语法1.JSON的语法可以表示三种类型的值：简单值、对象、数组。 2.简单值：可表示字符串、数值、布尔值和 null，但不支持 undefined。JSON字符串必须使用双引号。 3.对象：表示一组无序的键值对。没有声明变量（JSON中没有变量概念），没有末尾分号，对象属性名必须加双引号。 12345678&#123; &quot;name&quot;: &quot;Kyon&quot;, &quot;age&quot;: 20, &quot;school&quot;: &#123; &quot;name&quot;: &quot;Wuhan University&quot;, &quot;major&quot;: &quot;Software Engineering&quot; &#125;&#125; 4.数组：表示一组有序的值的列表，可以通过数值索引来访问其中的值。 解析与序列化5.JSON对象有两个方法：stringify()把JavaScript对象序列化为JSON字符串，parse()把JSON字符串解析为原生JavaScript值。 6.JSON.stringify()还可以接收另外两个参数：第一个参数是个过滤器（数组：结果中只包含数组列出的属性；函数：传入的函数接收两个参数，属性名和属性值，根据属性名判断如何处理属性）；第二个参数控制结果中的缩进和空白符，数值表示缩进空格数，字符串被用作缩进字符。 7.toJSON：自定义序列化。 123456789var person = &#123; &quot;name&quot;: &quot;Kyon&quot;, age: 20, toJSON: function()&#123; return this.name; &#125;&#125;;var jsonText = JSON.stringify(person); 8.JSON.parse()还可以接受一个参数：将在每个键值对上调用的还原函数（与JSON.stringify()的过滤函数相同）。 AJAX与CometAjax 技术的核心是 XMLHttpRequest 对象（简称 XHR）。可以使用 XHR对象取得新数据，然后再通过 DOM 将新数据插入到页面中，无须刷新页面即可从服务器取得数据。 XMLHttpRequest 对象1.用法： 123456789101112131415161718192021var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; console.log(xhr.responseText); &#125; else &#123; console.log(&apos;Request was unsuccessful: &apos; + xhr.status); &#125; &#125;&#125;;// GET请求xhr.open(&apos;get&apos;, &apos;example.php&apos;);xhr.send(null);// POST请求xhr.open(&apos;open&apos;, &apos;postexample.php&apos;);xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);var form = document.getElementById(&apos;user-info&apos;);xhr.send(serialize(form));// 将ID为user-info的表单中数据序列化后发送给服务器 创建XHR对象：new XMLHttpRequest(); open()：启动一个请求以备发送。接收三个参数：请求类型（”get”、”post”等）、请求的URL、是否异步发送请求（默认是true，一定不能为false，否则必须等到服务器响应后再继续执行）。 send()：发送请求。GET请求不需要参数，POST请求要把body部分字符串或者FormData对象传进去。 2.XHR对象的属性： responseText：返回的文本； status：响应的HTTP状态； 3.HTTP状态码： 2xx：成功； 3xx：重定向，304 Not Modified 表示请求的资源没有被修改，可以直接用浏览器缓存的版本，302 Found 表示请求的资源现在临时从不同的URI响应请求； 4xx：客户端错误，403 Forbidden，404 NotFound； 5xx：服务器错误，500 Internal Server Error，503 Service Unavailable。 4.XHR的 readyState 属性：表示请求/响应过程的当前活动阶段： 0：未初始化； 1：启动，已调用open()，未发送； 2：发送，已调用send()，未收到响应； 3：接收到部分响应数据； 4：接收到全部响应数据。 5.readystatechange事件：readystate属性的值由一个值变成另一个值，都会触发readystatechange事件。 跨源资源共享6.跨域安全策略：XHR对象只能访问与包含它的页面位于同一个域的资源（域名、协议、端口号都要相同）。 7.CORS（跨源资源共享）：HTML5规范定义的如何跨域访问资源。当JavaScript 向外域发起请求后，浏览器收到响应后首先检查Access-Control-Allow-Origin是否包含本域。如果不是，请求失败，JavaScript 无法获取到响应的任何数据。 跨域是否成功，取决于对方服务器是否给本域设置一个正确的Access-Control-Allow-Origin。 以上“简单请求”包括GET、HEAD和POST（POST的Content-Type类型仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头。 对于PUT、DELETE以及其他类型如application/json的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受： 1234OPTIONS /path/to/resource HTTP/1.1Host: bar.comOrigin: http://my.comAccess-Control-Request-Method: POST 服务器必须响应并明确指出允许的Method： 1234HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONSAccess-Control-Max-Age: 86400 浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。 其他跨域技术8.图像Ping：与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。 对于 1234567var img = new Image();img.onload = img.onerror = function()&#123; console.log(&quot;Done!&quot;);&#125;;// onload和onerror事件处理程序指定为同一函数，请求完成时无关响应得到通知img.src = &quot;http://www.example.com/test?name=Nicholas&quot;;// 请求从设置src属性那一刻开始 两个主要缺点：只能发送GET请求；无法访问服务器的响应文本。因此只能用于浏览器与服务器间的单向通信。 9.JSONP（JSON with padding）：包含在函数调用中的JSON。由回调函数和数据组成。只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上利用了浏览器允许跨域引用JavaScript资源。 1234567891011121314151617181920212223// 得到的返回refreshPrice(&#123;&quot;0000001&quot;:&#123;&quot;code&quot;:&quot;0000001&quot;, ...&#125;&#125;);// 在页面中准备好回调函数function refreshPrice(data)&#123; var p = document.getElementById(&apos;test-jsonp&apos;); p.innerHTML = &apos;当前价格：&apos; + data[&apos;0000001&apos;].name + &quot;：&quot; + data[&apos;0000001&apos;].price;&#125;// 触发function getPrice()&#123; var js = document.createElement(&apos;script&apos;), head = document.getElementByTagName(&apos;head&apos;)[0]; self = document.getElementById(&apos;dynamic-jsonp&apos;); if(self)&#123; var parent = self.parentElement; parent.removeChild(self); &#125; js.id = &apos;dynamic-jsonp&apos;; js.src = &apos;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&apos;; head.appendChild(js);&#125; 缺点：从其他域中加载代码执行，安全性不可靠；不易确定请求是否失败。 10.Comet：对AJAX的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现Comet的手段主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，只有部分浏览器原生支持HTTP流。 补充：轮询是指通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器是否有新消息。缺点：(1)实时性不够；(2)频繁请求会给服务器带来极大压力。 11.SSE（服务器发送事件）：一种实现Comet交互的浏览器API，既支持长轮询，也支持HTTP流。 12.Web Sockets：目标是在一个单独的持久连接上提供全双工、双向通信。使用一种专为快速传输小数据设计的自定义协议。 安全13.为确保通过XHR访问的URL安全，通行做法是验证发送请求者是否有权限访问响应的资源。有下列方式： 要求以SSL连接来访问可以通过XHR请求的资源。 要求每一次请求都要附带经过相应算法计算得到的验证码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（四）]]></title>
      <url>%2FJS-notes-4%2F</url>
      <content type="text"><![CDATA[花旗杯的团队已经组好了。自己要加快学习进度，保证不拖组织的后腿。全力以赴，尽善尽美，希望最后能够有好的成绩。 这篇博文总结了《JavaScript高级程序设计》的13~14章：事件，表单脚本。 事件事件流1.事件流描述从页面接收事件的顺序。IE提出事件冒泡流，Netscape提出事件捕获流。 2.事件冒泡：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。 3.事件捕获：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。由于老版本浏览器不支持，不推荐使用。 4.“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件处理程序5.HTML事件处理程序：扩展作用域，在函数内部可以像访问局部变量一样访问document及该元素本身的成员。 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(value)&quot;&gt; 如果是一个表单输入元素，则作用域中还会包含访问表单元素的入口。 1234&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Echo username&quot; onclick=&quot;console.log(username.value)&quot;&gt;&lt;/form&gt; 缺点：(1)存在时差问题，函数被解析之前就触发事件会引发错误；(2)扩展处理程序的作用域链在不同浏览器中会导致不同结果；(3)HTML和JavaScript代码紧密耦合。 6.DOM0级事件处理程序：每个元素都有自己的事件处理程序属性，将其设置为一个函数，就可以指定事件处理程序。 12345678// 绑定事件处理程序var btn = document.getElementById("myBtn");btn.onclick = function()&#123; console.log(this.id); // "myBtn"&#125;;// 删除事件处理程序btn.onclick = null; 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 7.DOM2级事件处理程序：addEventListener()和removeEventListener()，接受3个参数：要处理的事件名、事件处理程序函数和一个布尔值（true表示在捕获阶段调用事件处理程序，默认为false表示冒泡阶段调用）。 移除时传入的参数与添加处理程序时使用的参数相同，意味着通过addEventListener()添加的匿名函数无法移除。 123byn.addEventListener(&quot;click&quot;, handler, false);...btn.removeEventListener(&quot;click&quot;, handler, false); // 有效 8.IE事件处理程序：attachEvent()和detachEvent()，接收两个参数：要处理的事件名、事件处理程序函数。事件处理程序被添加到冒泡阶段，在全局作用域中运行（this 等于 window）。支持IE事件处理程序的浏览器有 IE 和 Opera。 事件对象9.在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息。只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。 10.属性/方法： currentTarget：正在处理事件的那个元素。 target：事件的目标。 type：事件类型。 cancelable：可以阻止特定事件的默认行为。 preventDefault()：阻止特定事件的默认行为。 stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。 eventPhase：调用事件处理程序的阶段：捕获阶段为1，处于目标对象为2，冒泡阶段为3。 事件类型11.“DOM3级事件”规定了以下几类事件： UI（用户界面）事件，当用户与页面上的元素交互时触发：load、unload、resize、scroll。 焦点事件，当元素获得或失去焦点时触发。 鼠标与滚轮事件：click、dblclick、mousedown、mouseenter、mouseleave、mouseout、mouseover、mouseup。 键盘与文本事件：keydown、keypress、keyup、textInput。 复合事件，用于处理IME（输入法编辑器，让用户输入在物理键盘上找不到的字符）的输入序列。 变动事件，当DOM中的某一部分发生变化时给出提示。 内存和性能to be continued.. 表单脚本to be continued..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（三）]]></title>
      <url>%2FJS-notes-3%2F</url>
      <content type="text"><![CDATA[稍微大致翻了一下这本书后续的内容。为了尽快的进入ES6以及框架部分的学习，决定暂时跳过某些章节的学习。后面打算学习的章节有6、7、13、14、20、21、22、24章，剩下的章节等到用到或者时间富余的时候再看。 这篇博文总结了《JavaScript高级程序设计》的6~7章：面向对象的程序设计，以及函数表达式。 面向对象的程序设计理解对象1.ECMAScript中有两种属性：数据属性和访问器属性。 特性：描述属性的各种特征。目的是实现JavaScript，因此在JavaScript中不能直接访问。为了表示特性是内部值，放在两对方括号中，例如[[Enumerable]]。 2.数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。默认为 true。 [[Writable]]：表示能否修改属性的值。默认为 true。 [[Value]]：包含这个属性的数据值。默认为 undefined。 Object.defineProperty()方法可以修改属性默认的特性。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable、enumerable、writable 和 value 中的一或多个。 3.访问器属性： [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。默认为 true。 [[Get]]：在读取属性时调用的函数。默认为 undefined。 [[Set]]：在写入属性时调用的函数。默认为 undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 12345678910111213141516171819var book = &#123; _year: 2016, // 下划线表示只能通过对象方法访问的属性 edition: 1&#125;;Object.defineProperty(book, "year", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue) &#123; if(newValue &gt; 2016) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;); // year 是访问器属性book.year = 2017;console.log(book.edition); // 2 4.定义多个属性可用Object.defineProperties()方法。 123456789101112131415161718192021var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2016 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2016)&#123; this._year = newValue; this.edition += newValue - 2016; &#125; &#125; &#125;&#125;); Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符。 1234var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);console.log(descriptor.value); // 2016console.log(descriptor.configurable); // falseconsole.log(typeof descriptor.get); // &quot;undefined&quot; 创建对象5.工厂模式：虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题。 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () &#123; console.log(this.name); &#125; return o;&#125;var p1 = createPerson(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = createPerson(&apos;Someone&apos;, 19, &apos;Lawyer&apos;); 6.构造函数模式：以大写字母开头。 1234567891011121314function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;;&#125;var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);// 对象的constructor属性指向其构造函数console.log(p1.constructor); // function Person(name, age, job)&#123;... 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。 也可以使用call()（或者apply()）在某个特殊对象的作用域中调用构造函数，调用后这个对象就拥有了所有属性和方法。 123var o = new Object();Person.call(o, &apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);o.sayName(); // &apos;Kyon&apos; 使用构造函数的主要问题：每个方法都要在每个实例上重新创建一遍。 1console.log(p1.sayName === p2.sayName); // false 7.原型模式：每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向函数的原型对象。这个对象包含可以由该类型的所有实例共享的属性和方法。 1234Person.prototype.sayName = function()&#123; console.log(this.name);&#125;console.log(p1.sayName === p2.sayName); // true 理解原型对象： – 只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，指向函数的原型对象。 – 默认所有原型对象都会获得一个 constructor 属性，指向 prototype 属性所在函数。 – 当调用构造函数创建一个新实例后，实例将有一个 __proto__属性，指向构造函数的原型对象，指针叫[[Prototype]]，默认原型指向Object。 – 实例和构造函数没有直接关系。 – 读取属性：搜索先从对象实例本身开始，如果没找到，搜索原型对象。 – 使用isPrototype()来检测构造函数和实例之间是否有关系。 – Object.getPrototypeOf()返回[[Prototype]]的值。 – 使用hasOwnProperty()来检测属性存在于实例中还是原型中。 123456789101112131415161718192021222324function Person()&#123;&#125;Person.prototype.name = &apos;Kyon&apos;;Person.prototype.age = 29;Person.prototype.job = &apos;Software Engineer&apos;;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var p1 = new Person();var p2 = new Person();console.log(Person.prototype.isPrototypeOf(p1)); // trueconsole.log(Object.getPrototypeOf(p1) === Person.prototype); // trueconsole.log(Object.getPrototypeOf(p1).name); // &apos;Kyon&apos;console.log(p1.hasOwnProperty(&quot;name&quot;)); // falsep1.name = &quot;someone&quot;;console.log(p1.hasOwnProperty(&quot;name&quot;)); // truedelete p1.name;console.log(p1.hasOwnProperty(&quot;name&quot;)); // false 原型与 in 操作符：在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 1console.log(&apos;name&apos; in p1); // true 更简单的原型语法：用一个包含所有属性和方法的对象字面量来重写整个原型对象。 1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, // 默认的 prototype 对象被重写，需设置 name: &apos;Kyon&apos;, age: 20, job: &apos;Software Engineer&apos;, sayName: function()&#123; console.log(this.name); &#125;&#125;; 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍是最初的原型。 原生对象的原型：通过原生对象的原型可以定义新方法。不推荐，可能导致命名冲突或意外重写原生方法。 原型对象的问题：包含引用类型值的属性会被共享。 8.组合使用构造函数模式和原型模式：创建自定义类型最常见方式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。 123456789101112131415161718192021// 组合使用构造函数模式与原型模式function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Sam&quot;, &quot;Judie&quot;];&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; console.log(this.name); &#125;&#125;var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);p1.friends.push(&quot;Vue&quot;);console.log(p1.friends); // &quot;Sam, Judie, Vue&quot;console.log(p2.friends); // &quot;Sam, Judie&quot;console.log(p1.sayName === p2.sayName); // true 9.动态原型模式、寄生构造函数模式、稳妥构造函数模式 继承10.许多OO语言都支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际方法）。由于函数没有签名，ECMAScript 中无法实现接口继承，而实现继承主要依靠原型链实现。 11.原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法。 12.p182开始 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.color = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125; function SubType(name, age) &#123; SuperType.call(this, name); // 借用构造函数 this.age = age;&#125;SubType.prototype = new SuperType(); // 原型链SubType.prototype.constructor = SubType; // construcotr在上一句中被重写SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125; var instance = new SubType(&apos;Kyon&apos;, 20);instance.sayName(); // Kyoninstance.sayAge(); // 20 说实话，这部分看得我脑壳疼。要不我们直接用ES6引入的class可好？等我哪一天沐浴更衣虔诚焚香再来看… 函数表达式递归1.在严格模式下，不能通过脚本访问arguments.callee来实现递归。可以用命名函数表达式来实现。 1234567var factorial = (function f(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;); 闭包2.闭包是指有权访问另一个函数作用域中的变量的函数（匿名函数的 function 关键字后没有标识符，二者不能混用）。 3.创建闭包的常见方式：在一个函数内部创建另一个函数。 123456789function outer()&#123; var name = &quot;Kyon&quot;; return function()&#123; console.log(name); &#125;&#125;var inner = outer();inner(); // Kyoninner = null; // 解除对outer内部的匿名函数的引用，以释放内存 在外部函数内部定义的内部函数将外部函数的活动对象（作为变量对象使用）添加到它的作用域链中；外部函数执行完毕后，其活动对象不会被销毁，因为内部函数的作用域链仍在引用这个活动对象；外部函数执行完毕后，内部函数仍然可以访问到其定义的所有变量。 4.由于闭包会携带包含它的函数的作用域，过度使用可能导致内存占用过多，要慎重使用。 5.返回的函数并没有立刻执行，而是等到调用f()才执行。因此返回函数不能引用任何循环变量，或者后续会发生变化的变量。 12345678910111213141516171819function count()&#123; var arr = []; for(var i=1; i&lt;=3; i++)&#123; arr[i] = function()&#123; return i * i; &#125;; &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];// 返回的函数引用了变量i，但并非立即执行。执行时i已变成4f1(); // 16f2(); // 16f3(); // 16 一定要引用循环变量的方法：再创建一个匿名函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。 123456789101112function count()&#123; var arr = []; for(var i=1; i&lt;=3; i++)&#123; arr[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125;// i的当前值复制给参数num，匿名函数内部又创建并返回一个访问num的闭包，使得result数组中的每个函数都有自己num变量的一个副本 这里用了一个“创建一个匿名函数并立即执行”的语法： 123(function(x)&#123; return x * x;&#125;)(3); // 9 6.闭包中使用 this 对象：匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getName: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getName()); // &quot;The Window&quot;(非严格模式) 把外部作用域中的 this 对象保存在一个闭包能够访问的变量中，就可以让闭包访问该对象了（想访问作用域中的 arguments对象同理）。 12345678910111213var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getName: function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getName()); // &quot;My Object&quot; 7.补充：利用闭包可以实现私有变量的封装。 1234567891011121314151617181920// 用JavaScript创建一个计数器&apos;use strict&apos;;function create_counter(initial)&#123; var x = initial || 0; return &#123; inc: function()&#123; x += 1; return x; &#125; &#125;&#125;// 使用var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12 模仿块级作用域8.用匿名函数模仿块级作用域： JavaScript将 function 关键字当作一个函数声明的开始，而函数声明后不能加圆括号。 将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随的另一对圆括号会立即调用这个函数。 1234567(function()&#123; // 这里是块级作用域&#125;)();function()&#123; // 这里是块级作用域&#125;(); ／／ Error! 9.这种技术经常用于限制向全局作用域中添加过多的变量和函数；同时可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。 123456(function()&#123; var now = new Date(); if(now.getMonth() == 11 &amp;&amp; now.getDate() == 25)&#123; console.log(&quot;Merry Christmas!&quot;); &#125;&#125;)(); 私有变量10.任何在函数中定义的变量，都可以认为是私有变量。 11.有权访问私有变量和私有函数的公有方法被称为特权方法。两种在对象上创建特权方法的方式： 1234567891011121314151617181920212223242526// 1.构造函数中定义特权方法function MyObject()&#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc()&#123; return false; &#125; // 特权方法 this.publicMethod = function()&#123; privateVar++; return privateFunc(); &#125;;&#125;// 2.利用私有和特权成员function Person()&#123; this.getName = function()&#123; return name; &#125;; this.setName = function(value)&#123; name = value; &#125;;&#125; 12.可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（二）]]></title>
      <url>%2FJS-notes-2%2F</url>
      <content type="text"><![CDATA[继续记录在读《JavaScript高级程序设计》时的零碎知识点。这几天在知乎上看到了别人使用 Electron 构建桌面应用，感觉还蛮有意思的。有兴趣的同学可以看看使用 Electron 构建桌面应用和用 ReactJs 创建Mac版的 keep了解一下。也许在加深对JS的理解后，我也会选择用 Electron 做一个应用呢。Who knows? 这篇博文总结了《JavaScript高级程序设计》的4~5章：变量、作用域和内存问题，以及引用类型。 变量、作用域和内存问题基本类型和引用类型的值1.基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；引用类型的值是对象，保存在堆内存中。 2.当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。 3.从一个变量向另一个变量复制基本类型的值时，会创建这个值的一个副本；从一个变量向另一个变量复制引用类型的值时，复制的是指向存储在堆中的一个对象的指针，复制之后两个变量指向同一个对象。 123456789var n1 = 1;var n2 = n1;n1 = 2;console.log(n2); // 1var o1 = &#123;&#125;;var o2 = o1;o1.name = &apos;Kyon&apos;;console.log(o2.name); // Kyon 4.参数只能按值传递： 123456789function setName(obj)&#123; obj.name = &apos;Kyon&apos;; obj = new Object(); obj.name = &apos;Huang&apos;;&#125;var person = new Object();setName(person);console.log(person.name); // Kyon 在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 5.typeof检测基本数据类型，instanceof检测引用类型（根据其原型链来识别）。 执行环境及作用域6.每个执行环境（简称为环境，可以理解为作用域）都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。每个函数都有自己的执行环境，全局执行环境（在Web浏览器中为window对象）是最外围的一个执行环境。 7.当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返还给之前的执行环境。 8.当代码在一个环境中执行时，会创建变量对象的一个作用域链，用于保证对执行环境有权访问的所有变量和函数的有序访问（搜索）。作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。 9.标识符解析：沿着作用域链一级一级地搜索标识符的过程。从作用域链的前端开始，逐级向后回溯，直到找到标识符为止（找不到通常导致错误）。 10.内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 11.延长作用域链：当执行流进入 try-catch 语句的 catch 块或 with 语句时，作用域链就会得到加长。这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到作用域链中；对 catch 语句，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 12.JavaScript 没有块级作用域，但有函数作用域（针对var）。 补充：在语法中的块级作用域是指if/else/for/while语句里2个大括号之间的部分。块级作用域里面定义的函数和变量在{}外部是可以被访问到的。但是函数就不行，比如你在函数体里面定义一个变量，那么函数执行完毕之后里面的变量就会直接被销毁，在函数体外部是不可能被访问到的。 再补充：ES6标准引入了新的关键字 let 和 const。它们都具有块级作用域。 垃圾收集13.JavaScript 具有自动垃圾收集机制，原理：垃圾收集器按照固定的时间间隔（或代码执行中预定的收集时间）释放不再继续使用的变量所占用的内存。 14.最常用的垃圾收集方式是标记清除：垃圾回收器在运行时会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记，而在此之后还有标记的变量被视为准备删除的变量，因为这些变量无法被访问到了。 此外，引用计数是另一种不太常用的垃圾收集策略，这种算法的思想是跟踪记录所有值被引用的次数。当代码中存在循环引用现象时，“引用计数”算法就会导致问题。JavaScript 引擎目前都不再使用这种算法，但IE访问非原生 JavaScript 对象（如DOM元素）时仍可能导致问题。 15.管理内存：优化内存占用的最佳方式为解除引用——一旦数据不再有用，通过将其值设置为null来释放其引用。解除引用的真正作用是让其值脱离执行环境，以便垃圾搜集器下次运行时将其回收，而并非自动回收该值所占的内存。 引用类型引用类型的值（对象）是引用类型的一个实例。 Object类型1.创建Object实例的两种方式：Object构造函数；对象字面量表示法。通过对象字面量定义对象时，实际不会调用Object构造函数（Firefox 2 及更早版本除外）。 12345678var person = new Object();person.name = &quot;Kyon&quot;;person.age = 19;var person = &#123; name : &quot;Kyon&quot;, age : 19&#125;; 2.访问对象属性常用点表示法，也可使用方括号表示法。除非必须用变量来访问属性，否则建议使用点表示法。 1234567console.log(person.name); // 点表示法console.log(person[&quot;name&quot;]); // 方括号表示法var propertyName = &quot;name&quot;;console.log(person[propertyName]);console.log(person[&quot;first name&quot;]); Array类型3.ECMAScript 数组的每一项可以保存任何类型的数据，并且大小可以动态调整。 4.创建数组的两种基本方式：使用Array构造函数；使用数组字面量表示法。通过数组字面量表示法时，实际不会调用Array构造函数（Firefox 3 及更早版本除外）。 123456var colors = new Array();var colors = new Array(20);var colors = new Array(&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;); var colors = [];var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]; 5.length：利用length属性可以方便地在数组末尾添加新项： 12var colors = [&quot;red&quot;, &quot;blue&quot;];colors[colors.length] = &quot;green&quot;; 6.Array.isArray()：ECMAScript新增Array.isArray()确定某个值是否数组，其解决了存在两个以上全局执行环境时instanceof检测结果出错的情况。 7.数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。 123var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];console.log(colors.join(&quot;,&quot;)); //red,green,blueconsole.log(colors.join(&quot;||&quot;)); //red||green||blue 8.栈方法和队列方法： push()添加一项到数组末尾； pop()移除数组末尾一项； shift()移除数组第一项； unshift()添加一项到数组前端。 9.重排序方法： reverse()翻转数组项的顺序； sort()默认将数组项转换成字符串后按升序排列（可以接收一个比较函数作为参数，第一个参数应位于第二个之前则返回一个负数）。 123456789var a = [0, 1, 15, 10, 5];a.sort();console.log(a); // [0, 1, 10, 15, 5]function compare(value1, value2)&#123; return value1 - value2;&#125;a.sort(compare);console.log(a); // [0, 1, 5, 10, 15] 10.操作方法： concat()：添加项 123var a1 = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];var a2 = a1.concat(&apos;yellow&apos;, [&apos;black&apos;, &apos;brown&apos;]);console.log(a2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;] slice()：截取 123var a = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;black&apos;, &apos;brown&apos;];console.log(a.slice(1), a.slice(1,4)); // [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;][&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;] splice()：删除插入替换 123var a = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;black&apos;, &apos;brown&apos;];console.log(a.splice(2, 1), a); // [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;][&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;] 11.位置方法：indexOf()和lastIndexOf()都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。indexOf()从数组开头（位置0）向后查找，lastIndexOf()从数组末尾向前查找。 12345var a = [&quot;red&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];console.log(a.indexOf(&apos;red&apos;)); // 0console.log(a.lastIndexOf(&apos;red&apos;)); // 4console.log(a.indexOf(&apos;red&apos;, 1)); // 4console.log(a.lastIndexOf(&apos;red&apos;, 1)); // 0 12.迭代方法：每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。给定函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。 every()：如果给定函数对每一项都返回true，则返回true。 filter()：返回给定函数会返回true的项组成的数组。 foreach()：这个方法没有返回值。 map()：返回每次函数调用的结果组成的数组。 some()：如果给定函数对任一项返回true，则返回true。 1234567891011121314151617181920212223242526var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = a.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);console.log(everyResult); // falsevar filterResult = a.filter(function()&#123; return (item &gt; 2);&#125;);console.log(filterResult); // [3, 4, 5, 4, 3]var forEachResult = a.forEach(function(item, index, array)&#123; console.log(item);&#125;);console.log(forEachResult); // undefinedvar mapResult = a.map(function(item, index, array)&#123; return (item * 2);&#125;);console.log(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2]var someResult = a.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);console.log(someResult); // true 13.归并方法：都会迭代数组的所有项，然后构建一个最终返回的值。都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。给定函数接收4个参数：前一个值、当前值、项的索引和数组对象。 12345678910111213var a = [1, 2, 3, 2, 1];var sum1 = a.reduce(function(prev, cur, index, array)&#123; console.log(index); // 1 2 3 4 return prev + cur;&#125;); console.log(sum1); // 9var sum2 = a.reduceRight(function(prev, cur, index, array)&#123; console.log(index); // 3 2 1 0 return prev + cur;&#125;);console.log(sum2); // 9 Date类型12.创建日期对象：月份基于0（一月是0，二月是1，以此类推）。123var d1 = new Date();var d2 = new Date(2017, 2, 3, 15, 33, 33); // 2017年3月3日下午3点33分33秒 13.获取调用时的日期和时间和毫秒数，可以用来分析代码。1234var start = Date.now();doSomething();var stop = Date.now();var result = stop - start; 14.日期格式化方法：local表示以特定于地区的格式显示。1234567var d2 = new Date(2017, 2, 3, 15, 33, 33);d2.toString(); // &quot;Fri Mar 03 2017 15:33:33 GMT+0800 (CST)&quot;d2.toDateString(); // &quot;Fri Mar 03 2017&quot;d2.toTimeString(); // &quot;15:33:33 GMT+0800 (CST)&quot;d2.toLocaleString(); // &quot;2017/3/3 下午3:33:33&quot;d2.toLocaleDateString(); // &quot;2017/3/3&quot;d2.toLocaleTimeString(); // &quot;下午3:33:33&quot; RegExp类型15.pattern：正则表达式；flags：标志，表明正则表达式的行为。g全局模式，i不区分大小写，m多行模式。12var exp1 = /pattern/flagsvar exp2 = new RegExp(&apos;pattern&apos;,&apos;flags&apos;); 16.RegExp实例方法： exec()专门为捕获组而设计，返回第一个匹配项信息的数组（或 null），数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。包含两个额外的属性：index 和 input。 123456789var text = &quot;mom and dad and baby&quot;;var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // &quot;mom and dad and baby&quot;console.log(matches[0]); // &quot;mom and dad and baby&quot;console.log(matches[1]); // &quot; and dad and baby&quot;console.log(matches[2]); // &quot; and baby&quot; test()接收一个字符串参数，在模式与该参数匹配的情况下返回 true，否则返回flase。 123456var text = &quot;1234-56-7890&quot;;var pattern = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if(pattern.test(text))&#123; console.log(&quot;The pattern was matched.&quot;);&#125; 17.RegExp构造函数属性：适用于作用域中的所有正则表达式，记录一些最近一次正则表达式操作的信息。 12345678910111213var text = &quot;This has been a short summer&quot;;var pattern = /(.)hort/g;// Opera 不支持 input、lastMatch、lastParen 和 multiline 属性// IE 不支持 multiline 属性if(pattern.test(text))&#123; console.log(RegExp.input); // This has been a short summer console.log(RegExp.leftContext); // This has been a console.log(RegExp.rightContext); // summer console.log(RegExp.lastMatch); // short console.log(RegExp.lastParen); // s console.log(); // false &#125; Function类型18.函数实际上是 Function 类型的实例，因此函数也是对象。 12345678910111213 // 使用函数声明语法function f1 (n1, n2) &#123; return n1 + n2;&#125; // 使用函数表达式var f2 = function (n1, n2) &#123; return n1 + n2;&#125;; // 使用构造函数，不推荐（会导致解析两次代码，影响性能）var f3 = new Function(&apos;n1&apos;, &apos;n2&apos;, &apos;return n1 + n2&apos;); 19.函数名是一个指向函数对象的指针，因此 ECMAScript 中没有函数重载。 20.函数声明与函数表达式：解析器会率先通过名为函数声明提升的过程，读取并将函数声明添加到执行环境中，使其在执行任何代码之前可用。 而函数表达式必须等到解析器执行到它所在的代码行，才会真正被解析执行。 1234567891011 console.log(sum(10, 10));function sum(num1, num2)&#123; return num1 + num2;&#125;// 把函数声明改为等价的函数表达式，会在执行期间导致错误console.log(sum(10, 10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;; 21.函数内部属性：callee、this、caller。 arguments 有 callee 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。可用于递归中消除紧密耦合现象。 123456789 console.log(sum(10, 10));function factorial(num)&#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; this 引用的是函数据以执行的环境对象。 caller 属性保存着调用当前函数的函数的引用（如果在全局作用域中调用当前函数，它的值为 null）。 1234567891011 function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller); // 为了实现更松散的耦合，也可以用 arguments.callee.caller 访问相同的信息&#125;outer(); // 打印 outer() 函数的源代码 严格模式下访问 arguments.callee 和 arguments.caller 会导致错误，且不能为函数的 caller 属性赋值。 22.函数属性：length 和 prototype。 length 属性表示函数希望接收的命名参数的个数。 23.函数方法：apply()和call()。用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值，区别仅在于接收参数的方式不同。 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中第二个参数可以是 Array 的实例，也可以是 arguments 对象。 call()方法中，传递给函数的参数必须逐个列举出来。 1234567891011121314 function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入 arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125; function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125; apply()和call()真正强大之处在于扩充函数赖以生存的作用域。 1234567891011 window.color = &quot;red&quot;;var o =&#123; color: &quot;blue&quot; &#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor.call(this); // redsayColor.call(window); // redsayColor.call(o); // blue 在严格模式下，未制定环境对象而调用函数，则 this 值不会转型为 window。除非明确把函数添加到某个对象或者调用apply()或call()，否则 this 值将是 undefined。 基本包装类型24.三种基本包装类型：Boolean类型、Number类型、String类型。在读取模式下访问基本类型值时，就会创造对应的基本包装类型的一个对象，从而方便数据操作。 自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁（这意味不能在运行时为基本类型值添加属性和方法）。 单体内置对象25.在所有代码执行之前，内置对象：Global 和 Math 已经实例化，开发人员不必显式地实例化内置对象。 在大多数ECMAScript实现中都不能直接访问 Global 对象，不过Web浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【中文填词】三つ叶の结びめ -TV size.-]]></title>
      <url>%2Flyrics-seaStory%2F</url>
      <content type="text"><![CDATA[大一下学期考试周复习得好压抑，我就作死地补了《来自风平浪静的明天》。看完就感觉：啊，不愧是冈妈。虽然我不是那种容易被催泪的类型，但是还是有些胃痛的。 《来自风平浪静的明天》的音乐质量真的不错。两首OP两首ED加上几首bgm都很出彩（bgm里推荐 海の涙 和 Cry for the moon）。我当时就忍不住花了几个小时填了一个ED2的TV size（复习什么的已经无所谓了），之后基本没有修改，还算一气呵成。现在贴出来。自己感觉写的好小女生啊，哈哈。但是我就喜欢写这种暗恋的心酸。 欢迎翻唱w希望亚人的词能填的出色 【中文填词】三つ叶の结びめ（三片葉的花結） -TV size.- 曲：出羽良彰词：@摸鱼小能手大黄菌 等你转身 故事升温 久疏重逢的我们谈笑之间 却捕捉到 你偏离的眼神情绪慢慢下沉 听着潮声 看天空变得好陌生你笑容依旧的单纯 而我难过一直在铺陈 沉睡的心事 安静了 一整个寒冬 在春天来前解冻最后 却汇成了咸涩的洋流 经过谁的码头 把思念 只想对这片海表白泪水打湿的喜欢好像 怎么也 晒不干攒够了失望 终于才学会离开你出于礼貌的关怀 都怪我 太过分 的期待]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记（一）]]></title>
      <url>%2FJS-notes-1%2F</url>
      <content type="text"><![CDATA[《JavaScript高级程序设计》，俗称红宝书。本来因为不太清楚的知识点零零碎碎，打算默默地看。但是学习热情不高，加上看到某大佬的对于这本书的读书笔记，最终决定做一个比较零散的、私人化的读书笔记，激励自己。 顺便，这里有我的Java读书笔记：Kyon Huang的java学习笔记 - Github，内容比较多，就不放在博客上了。大概包含了Java核心卷一的内容，之后停了有一段时间了。这学期会继续更新的。 这篇博文总结了《JavaScript高级程序设计》的前三章：JavaScript简介、在HTML中使用JavaScript、基本概念。 JavaScript简介1.ECMAScript 是一种开放的、国际上广为接受的脚本语言规范。它本身并不是一种脚本语言。而JavaScript 是 ECMAScript 规范的一种实现。 2.一个完整的 JavaScript 实现应该由三个部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。 3.ECMAScript 提供核心语言功能；DOM 提供访问和操作网页内容的方法和接口；BOM 提供与浏览器交互的方法和接口。 在HTML中使用JavaScript&lt;script&gt;元素1.为了避免浏览器在呈现页面时出现明显延迟，现代Web应用程序一般都把全部 JavaScript 引用放在主要内容后面，&lt;/body&gt;标签前面的位置。 2.延迟脚本：&lt;script&gt;标签的 defer 属性表明脚本在执行时不会影响页面构造，会延迟到整个页面都解析完毕后再运行。延迟脚本总按指定它们的顺序执行。defer 属性只适用于外部脚本文件。 3.异步脚本：&lt;script&gt;标签的 async 属性告诉浏览器立即下载文件，不必等待其他脚本或阻塞文档呈现，目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。不保证异步脚本按照页面出现的先后顺序执行。async 属性只适用于外部脚本文件。 补充：defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 嵌入代码与外部文件4.使用外部文件的优点：可维护性、可缓存、适应未来。 文档模式5.所有浏览器默认开启混杂模式，不同浏览器在这种模式下的行为差异非常大。通过文档类型（doctype）开启标准模式： 12&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; &lt;noscript&gt;元素6.包含在&lt;noscript&gt;元素中的内容只有在浏览器不支持脚本，或浏览器支持脚本但脚本被禁用时才会显示出来。因此，它用于指定在不支持脚本的浏览器中显示的替代内容。 基本概念严格模式1.通过在顶部添加&quot;use strict&quot;;开启严格模式。这个编译指令告诉支持的JavaScript引擎切换到严格模式，以处理 ES 3 中一些不确定的行为，并对某些不安全的操作抛出错误。 变量2.省略var操作符可以定义全局变量（难维护，不推荐）。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。 数据类型3.五种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number和String，一种复杂数据类型 Object。ECMAScript 不支持任何创建自定义类型的机制。 Undefined类型：未初始化的变量会自动被赋予 undefined 值。 Null类型：null 值表示一个空对象指针。只要意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存 null 值，以体现 null 作为空指针对象的惯例。 Boolean类型：使用函数Boolean()将其他类型转换为Boolean类型。 Number类型：其他类型转换为Number类型，常用函数parseInt()，转换字符串时，如果第一个字符不是数字字符或者负号，会返回NaN，第二个可选参数表示进制（建议始终明确指定基数）。 String类型：不可变。其他类型转换为String类型，使用函数toString()或String()或加一个空字符串（””）。 Object类型：Object 的每个实例都具有下列属性和方法： – constructor：保留着用于创建当前对象的函数（即构造函数）； – hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在（属性名必须以字符串形式指定）； – isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型； – propertyIsEnumerable(propertyName)：用于检查给定的属性是否能使用 for-in 语句来枚举； – toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应； – toString()：返回对象的字符串表示（null 和 undefined 伪对象没有此方法，整数 number 类型需要在整数末尾多加一个.再调用）； – valueOf()：返回对象的字符串、数值或布尔值表示； 4.typeof 操作符可检测给定变量的数据类型，包括 number、boolean、string、function、undefined。 判断 Array：Array.isArray(myArr);。 判断 null：用myArr === null;。 补充：判断某个全局变量是否存在：typeof window.myVar === &#39;undefined&#39;;。 判断函数内部某个变量是否存在：typeof myVar === &#39;undefined === &#39;undefined&#39;；。 操作符5.如果两个操作数都是字符串，则比较两个字符串对应的字符串编码值。 6.如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较；如果该操作数不能被转换为合理数值，则转换成 NaN。 7.任何操作数与 NaN 比较，结果都是false。 8.相等（==）与全等（===）：全等只在两个操作数未经转换就相等的情况下返回true。 语句9.由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到： 12345var count = 10;for (var i = ; i &lt; count; i++)&#123; var j = 1;&#125;alert(i, j); //10, 1 10.for-in 语句可以用来遍历对象的属性名称：123for(property in expression)&#123; statement&#125; 为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 补充：一个 Array 数组实际也是一个对象，它的每个元素的索引被视为一个属性。所以当手动给 Array 添加额外的属性时，for-in 语句也会将其遍历。要循环集合本身的元素，建议使用 ES 6 提供的 for-of 语句。 11.break 语句会立即退出循环，强制继续执行循环后面的语句；continue 语句退出循环后会从循环的顶部继续执行。break 和 continue 语句与 label 语句联合使用多发生在循环嵌套的情况下： 12345678910111213var num = 0;outermost:for(var i=0; i &lt; 10; i++)&#123; for(var j=0; j &lt; 10; j++)&#123; if(i == 5 &amp;&amp; j == 5)&#123; break outermost; &#125; num++; &#125;&#125;alert(num); //55 12345678910111213var num = 0;outermost:for(var i=0; i &lt; 10; i++)&#123; for(var j=0; j &lt; 10; j++)&#123; if(i == 5 &amp;&amp; j == 5)&#123; continue outermost; &#125; num++; &#125;&#125;alert(num); //95 函数12.ECMAScript中没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。所以ECMAScript函数不能重载。 13.可以向ECMAScript函数传递任意数量的参数，并通过 arguments对象来访问这些参数。没有传递值的命名参数将自动被赋予 undefined 值。arguments对象中的值与对应的命名参数的内存空间是独立的，但它们的值会同步。 15.ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(3)——圣杯布局与双飞翼布局]]></title>
      <url>%2Fcup-doubleWings%2F</url>
      <content type="text"><![CDATA[这是完成百度前端学院2015的task1后对前端布局知识点总结的第三篇博文。上两篇总结了一下overflow属性（前端布局知识点(1)——overflow属性）和负边距及文档流（前端布局知识点(2)——负边距）。 在淘宝UED探讨中诞生的双飞翼布局主要解决了两个需求： 要求三列布局，左右两边定宽，中间宽度自适应； 要求浏览器优先渲染中间栏。 其实这两个要求已经有圣杯布局实现了。双飞翼布局是沿着圣杯布局的思路加以改良探讨出来的。两者有什么区别呢？ 17.04.27更新：时至今日，Grid 布局为实现各类布局提供了非常简便的解决方案。可以通过CSS Grid布局这样玩这篇文章来对 CSS Grid 进行初步了解。 圣杯布局我们首先来看看出现时间更早的圣杯布局（这个名字让我想到Fate系列）。圣杯布局用到了浮动、负边距和相对定位来实现需求。 html代码（浏览器按照html中写的顺序渲染，因此div.main写在最前面）： 12345678910111213 &lt;div class=&quot;yellow header&quot;&gt; task4:header&lt;/div&gt;&lt;div class=&quot;page&quot;&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;main red&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;left green&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right blue&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;yellow footer&quot;&gt; footer&lt;/div&gt; CSS代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546body&#123; margin: 0;&#125;.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.green&#123; background-color: green;&#125;.yellow&#123; background-color: yellow;&#125;.page&#123; padding:0 150px 0 180px; overflow: hidden; zoom: 1;&#125;.header,.footer&#123; width: 100%; height: 100px; clear: both;&#125;.left&#123; width: 180px; float: left; margin-left: -100%; height: 400px; position: relative; left: -180px;&#125;.main&#123; width: 100%; float: left; height: 400px;&#125;.right&#123; width: 150px; float: left; margin-left: -150px; height: 400px; position: relative; right: -150px;&#125; 效果图如下： 首先，我们给div.page设置一个左右的padding值，这个值要和左右两边宽度相等。固定好div.page后，再分别设置div.left和div.right。以div.left为例，设置float: left使其浮动，margin-left: -100%，这里将div.left左移至左边与main平齐。再加上 position: relative，left: -180px 固定位置，让它能够挤进左右两边空白的同时不会遮住中间部分。 双飞翼布局圣杯布局有什么缺陷呢？ 圣杯布局使用了相对定位。这样的话，以后再添加额外标签时布局是有局限性的； 左右两边的宽度只能为固定像素而不能设定为百分比。因为元素宽度设定为百分比时根据父级元素宽度计算，而我们给父级元素设定了padding值，其宽度不明确。我们无法精确计算所需要的百分比。 浏览器宽度缩小时，随着两边定宽的部分向中间靠拢，中间部分有被挤下去的可能。 怎么能够优化圣杯布局？淘宝UED探讨的结果是增加一个div。这样，我们就可以不再使用相对布局，而仅仅用浮动和负边距来达到我们的需求。这就是双飞翼布局。 html代码（main内层增加一个div）： 1234567891011121314151617 &lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;header yellow&quot;&gt; task4:header &lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;main red&quot;&gt; &lt;div class=&quot;inner&quot;&gt; //增加的div main &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left green&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right blue&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer yellow&quot;&gt; footer &lt;/div&gt;&lt;/div&gt; CSS代码（去掉左右栏的相对定位和包裹层的padding，增加新div的margin）： 1234567891011121314151617181920212223242526272829303132333435363738.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.green&#123; background-color: green;&#125;.yellow&#123; background-color: yellow;&#125;.header,.footer&#123; width: 100%; height: 30px; clear: both;&#125;.left&#123; width: 150px; float: left; margin-left: -100%; height: 400px;&#125;.main&#123; width: 100%; float: left; height: 400px;&#125;.right&#123; width: 180px; float: left; margin-left: -180px; height: 400px;&#125;.inner&#123; margin-left: 150px; margin-right: 180px;&#125; 效果图如下： 将浏览器宽度缩小，可以看到左右两边宽度一定，中间宽度为自适应。 div.inner的 margin-left: 150px;margin-right: 180px 负责将两边内容挤开，避免在没有padding的包裹层时两边内容遮住中间。 参考资料： CSS圣杯布局 css双飞翼布局 上面两篇出自同一作者，可谓一语道破，清晰明了。 圣杯布局的实现过程 双飞翼布局介绍-始于淘宝UED CSS双飞翼布局_百度知道]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(2)——负边距]]></title>
      <url>%2Fsomething-about-margin-nega%2F</url>
      <content type="text"><![CDATA[这是完成百度前端学院2015的task1后对前端布局知识点总结的第二篇博文。上一篇总结了一下overflow这个属性：前端布局知识点(1)——overflow属性。 CSS中的负边距是布局中一个常用的技巧。因为在后面学习的双飞翼布局的实现就依赖于负边距，负边距又与文档流息息相关，所以我先对这部分的知识进行查询学习。 文档流与文本流在我了解负边距的时候出现了一个词：文档流。而在查阅文档流相关资料的时候又出现一个词叫文本流。两者有什么区别？知乎上相关问题 HTML 的文档流和文本流分别是什么？- 知乎 的高票答案提供了一个辨析的思路：文档流是相对于盒子模型讲的，而文本流是相对于文字段落讲的。 在overflow的那篇文章中我们提到，浮动(float)是一个立体的浮动。当一个元素浮动时，它后面的元素会在它身下布局。但是文字会认为浮动元素是占据了一个区域而围绕它布局。我们可以将浮动元素想象成一个在海上浮动的人，鱼可以在他的身下，但海面上的泡沫会围绕在他周围。这时，这个元素脱离了文档流，但没有脱离文本流。 但是绝对定位(absolute)会将元素从文档流和文本流中脱离，也就是说其他元素和文本都不认同绝对定位元素占据了区域，而在它身下布局。 float、absolute和fixed三种方式定位会让元素脱离文档流。 负边距的表现当 margin-top、margin-left 为负值的时候，会把元素上移、左移，同时文档流中的位置也发生相应变化，这点与 position:relative 的元素设置top、left后元素还占据原来位置不同。 而当 margin-bottom、margin-right 设为负值的时候，元素本身没有位置变化，后面的元素会上移、左移。 负边距的实例多说无益，来看实例。我们可以利用负边距和绝对定位来实现一种经典的居中方式: 12345678910111213&lt;style&gt; .middle&#123; position: absolute; width: 200px; height: 200px; left: 50%; margin-left: -100px; &#125;&lt;/style&gt;&lt;div class=&quot;middle red&quot;&gt; middle div&lt;/div&gt; 把div设置为绝对定位，然后设置top和left为50%，这时候div的上边、左边就到了父元素（这里是页面）的50%处，再对div设置其自身高度、长度一般的负边距，使div的中心移动到页面中心，实现宽度上的居中对齐。我们当然也可以用同样的方式设置高度的居中。 关于负边距更多的应用可以看参考资料： 负边距在布局中的使用 在接下来谈到的双飞翼布局中，负边距将成为主角。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端布局知识点(1)——从overflow属性看浮动]]></title>
      <url>%2Fsomething-about-overflow%2F</url>
      <content type="text"><![CDATA[完成了 百度前端学院2015的task1 后，感觉自己之前学习CSS以及前端布局确实不太全面，有很多知识点现在才接触到，而且也很久没有用过CSS写前端布局了。查漏补缺，总结了几个以前没有注意的知识点：overflow、负边距、圣杯布局和双飞翼布局。一开始想把所有知识点总结成一篇，写着写着发现较短的篇幅不足以把这些都总结清楚，所以还是每个知识点单写一篇。 顺便推荐 学习CSS布局，很好的布局学习资料，值得反复学习。用詹俊老师的话来说就是，好文不妨一看再看！ 探究由来task1中有一道题是这样的：实现一个浮动布局，红色容器中每一行的蓝色容器数量随着浏览器宽度的变化而变化。很快写出代码如下： html代码： 1234567891011 &lt;div class=&quot;red task5&quot;&gt; &lt;div class=&quot;blue bfloat&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;blue bfloat&quot;&gt;9&lt;/div&gt;&lt;/div&gt; CSS代码： 12345678910111213141516.red&#123; background-color: red;&#125;.blue&#123; background-color: blue;&#125;.task5&#123; margin-top: 10px; height: 100px;&#125;.bfloat&#123; height: 50px; width: 90px; margin: 10px; float: left;&#125; 这里说一声，根据 OO CSS 的思想，结构和样式应该相互独立（不太了解 OO CSS 的话可以看一下我之前的博文 对几个前端相关概念的理解——OO CSS、语义化、CSS hack）。尽管对于这种小 Demo，OO CSS显得不实用且有些累赘，我还是坚持去实现。因此我单独写了 red 和 blue 两个 class 来控制皮肤。 以上代码的效果图： 可以看到，效果图中红色容器的高度没有随着蓝色容器的行数的变化而变化，与我们理想的效果有些差距。这是因为我们在task5这个class中写死了容器的高度，而设置了浮动的蓝色容器脱离了红色容器，行数的变化无法再影响到红色容器的高度。从这里我们可以看出，所谓“浮动”不只是平面上的浮动，而是一个立体的浮动。当然，如果不写高度的话连红色容器都看不到。那怎么解决这个问题呢？我当时没有想到好的解决方法。查看了别人的代码后，发现是要把 task5 这个 class 中高度删掉，再加一行： overflow: hidden; overflow 属性overflow 属性规定当内容溢出元素框时发生的事情。这个属性的默认值为 visible，这时内容不会被修剪，会呈现在元素框之外，就像之前的效果图一样；而值为 hidden 时，内容会被修剪，并且其余内容是不可见的。也就是说，如果这时height属性还设置了定值的话，超出这个定值的部分不可见。这个时候显示的效果如下(height: 100px)： 删掉height属性后，overflow: hidden 在这个案例的真正用途是清除浮动。这里清除的是立体的，可以理解为z轴上的浮动。因此，蓝色容器的高度现在可以受其内部，也就是红色容器的总体高度影响。现在显示的效果是符合我们要求的，实际效果图如下： overflow 属性的值还可以为 scroll 和 auto。值为 scroll 时，内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。而值为 auto 时，如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。两者区别是如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。 浮动元素特点17.04.14补充：摘自 回归CSS标准之Float 。 float 属性被设置为非 none 的元素： 元素被视作块级元素，相当于 display 设置为“block”； 元素具备包裹性，会根据它所包含的元素实现宽度、高度自适应； 浮动元素前后的块级兄弟元素忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过 z-index 属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素； 浮动元素前后的行内元素环绕浮动元素排列； 浮动元素之前的元素如果也是浮动元素，且方向相同，它会紧跟在它们后面；父元素宽度不够，换行展示； 浮动元素之间的水平间距不会重叠； 当包含元素中只有浮动元素时，包含元素将会高度塌陷； 浮动元素的父元素的非浮动兄弟元素，忽视浮动元素存在，覆盖浮动元素； 浮动元素的父元素的浮动兄弟元素，会跟随浮动元素布局，仿佛处在同一父元素中。 参考资料CSS overflow 属性 CSS - 清除浮动（clearfix hack） 17.02.07更新： 那些年我们一起清除过的浮动 一文中将 overflow: hidden 所带来的清除浮动的效果称为“闭合浮动”，以区别于 clear: left|right|both|none 。我们通过闭合浮动来解决 wrap 高度塌陷的问题。 17.04.07更新： Clear Float 介绍了解决浮动带来的高度塌陷问题的另外两种方法：“clear:both”和“clearfix”。 回归CSS标准之Float 百度EFE的文章，加深对 float 的理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[又是一个新学期开始了]]></title>
      <url>%2Fnew-term%2F</url>
      <content type="text"><![CDATA[大二的下学期就要开始了。在寒假里，我自学了JavaScript和jQuery，看完了极客学院这两部分以及AngularJS入门的视频，廖雪峰JS教程学到underscore为止。由于缺乏系统学习和动手实践，掌握肯定不甚牢固。寒假的充实度可以说差强人意吧。 新学期课感觉要比上学期略少一点，但都是专业课，也有一定难度。希望自己在课业不放松的同时尽力实现以下学习目标，并产出有质量的博文以进行总结： 前端：学习《JavaScript高级程序设计》以及ES6，研究React框架（这个放在后面）。 后端：继续Java的深入学习，Servlet、JSP、SSH三大框架。 算法：学习《算法(Java描述)》，搭配LintCode练习。 英语：以尽量高的分数过六级。 理论学习永远离不开实践，要经常给自己找项目。前端方面可以跟着百度前端学院2015的小项目动手试试。新学期也希望自己在包括足球、人际等各方面有所突破。 新学期，新气象。写下这篇博文给自己打气！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对几个前端相关概念的理解——OO CSS、语义化、CSS hack]]></title>
      <url>%2F8637%2F</url>
      <content type="text"><![CDATA[极客学院的视频《CSS 在工程中改变》中讲到了OO CSS这个概念，而在知乎上看到别人的回答中提到了语义化和CSS hack这两个概念。在查找了相关资料后，我对这几个概念有了一些自己的理解。 OO CSSOO CSS，全称为Object Oriented CSS，意为“面向对象的CSS”。 OO CSS是一种书写规则，看重代码的重用性、可维护性和可扩展性。OO CSS将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。 OO CSS更加适合大型网站的开发，因为大型网站用到更多的可重用组件。为了更好地维护，最好给每个组件写一份说明文档。 作用： 加强代码复用以便方便维护。 减小CSS体积。 提升渲染效率。 组件库思想、栅格布局可共用、减少选择器、方便扩展。 注意事项： 不要直接定义子节点，应把共性声明放在父类。 结构与样式相互独立。 容器和内容相互独立。 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。 往你想要扩展的对象本身增加class而不是他的父节点。 对象应保持独立性。 避免使用ID选择器，权重太高，无法重用。（ID选择器大多数为JS服务） 避免位置相关的样式。 保证选择器相同的权重。 类名应简短、清晰并保有语义。OOCSS的名字并不影响HTML语义化。 参考资料： OOCSS——概念篇 语义化语义化就是对数据和信息进行处理，使得机器可以理解。 如何在开放的网络、庞大的信息资源中找到需要的信息？我们当然需要借助包括搜索引擎、爬虫在内的智能程序的力量。而为了让这些程序能够理解内容、推演逻辑、建立索引并给予较高的权值，语义化变得越来越重要。SEO最有效的一种方法就是对网页的HTML结构进行重构，实质上就是语义化。 为了使机器能够尽可能理解内容，规范是必须的。程序肯定只会关注那些约定俗成的东西。某种规范被认可的程度越高，就越会成为机器算法的目标，人们就越可以根据它来实现各种功能。 HTML本身也是机器可读的语义信息，但由于HTML被设计的目的并不是为了机器可读，所以不尽完美。也因此，HTML规范一直在往语义化的方向上发展。HTML5更是在之前规范的基础上，将所有表现层的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。 当然，HTML5并非Web语义化唯一的规范。有很多组织都提出了有浏览器和搜索引擎支持的规范，为扩展、标准化Web语义做着自己的贡献。关于HTML5各个元素语义的描述，可参考 Semantic HTML。 参考资料： 如何理解 Web 语义化？- 知乎 CSS hack由于不同厂商的浏览器和浏览器的不同版本对CSS有不一样的支持和解析结果，导致我们需要针对不同的浏览器及同一浏览器的不同版本写特定的样式，以获得统一的页面效果。这个过程叫做CSS hack。 使用CSS hack虽然有助于实现页面表现的一致性，但滥用会造成编码过于复杂、文档混乱不堪，增加管理和维护的负担。因此，hack要少用、慎用。等到未来浏览器厂商的标准能够完全统一时，就是hack退出历史舞台的时候了。 参考资料： 史上最全的CSS hack方式一览]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text使用技巧笔记]]></title>
      <url>%2Fsublime-text-learning%2F</url>
      <content type="text"><![CDATA[作为一款主流前端开发编辑器软件，Sublime Text具有代码高亮、语法提示、自动完成，轻量级，易上手，并且支持插件扩展机制，可以说功能十分强大。 我用Sublime Text已经有一段时间了，但是只是浮于表面，没有进一步探索。作为一名准备在Web方面继续深研的软工学生，我决定对Sublime Text的使用技巧进行学习，并写下这篇笔记。 快捷键(OS X) Command + 光标 多点编辑 Command + p 快速打开文件 Command + Shift + p 打开命令行面板 Command + + / - 字体放大/缩小 Command + K + B 面板显示/隐藏 Command + ] / [ 缩进/退回一个级别 Command + L 选择当前行 Command (+ Shift) + Enter (在上一行)下一行开辟新行 Option + 鼠标左键 块选择(自动进入多点编辑) Alt(Command) + 左右键 单词(行)粒度的跳跃 Alt(Command) + Shift + 左右键 单词(行)选择(可以叠加使用多次) Command + A 全选 命令编辑器右下角可以更改语法，也可以在命令行面板输入语法名进行选择。 命令行面板输入”Key Bindings - Default”可以看到所有的快捷键设置。 “Key Bindings - User”中自己可以设置快捷键，遵循JSON语法： [ { &quot;keys&quot;: [&quot;shift+tab&quot;],&quot;command&quot;: &quot;reindent&quot;,&quot;args&quot;: {&quot;single_line&quot;:false}} ] “Reindent Lines”调整缩进（已经被我设置快捷键Shift + Tab）。 如何得到命令名和参数： Ctrl + ` 打开控制台，输入”sublime.log_commands(True)”； 再在命令行面板中输入操作； 在工作台即可看到命令名和参数； 自定制用户的设置保存在/~/Library/Application Support/Sublime Text 3/Packages/User中，写到这里的数据是不会因自动升级而被覆盖的。 推荐将这个文件夹中的内容同步到Github上。这样，在更换系统或电脑时，将文件夹clone下来进行替换，可以迅速按照自己的要求配置好。 15.05.17 更新： 把 sublime 中的 Tab 换成两个空格的缩进。方法详见 sublime text3里 修改TAB键为缩进为四个空格 。 扩展包到 https://packagecontrol.io/installation 可以看到 sublime3 中的安装方式，Control + ` 打开控制台，运行代码就可以安装上了。 Command + Shift + p 打开命令行面板，敲Install Package来搜索并安装想要的包。Remove Package卸载插件。 Packages/User/ 下面的文件 Package Control.sublime-settings 里面列出已经安装的包。 我安装的包有（不定期更新）： Git：这个包可以帮助我们在编辑器里完成git相关操作。在命令行面板中输入”Git Add Current File”、”Git Commit”、”Git Push”来完成相应操作。 emmet：Web前端开发必装包，敲 tab 键代码补齐。具体触发词参见 http://docs.emmet.io/cheat-sheet/。如果我想用标签来包裹一些内容，我就先把内容选中，然后 Ctrl-w 。这个命令也可以在命令面板上呼叫 Wrap with Abbreviation 。要是忘了快捷键了，就求助命令面板。弹出的输入框中输入后回车就可以看到效果了，语法上跟前面 tab 补齐的时候没有区别。如果要删除一层标签，用 Command + , (Remove Tag)。 快速查找文件或字符串Command + P 快捷键打开的功能叫做goto anything，见menu-&gt;Goto。支持模糊匹配，同时支持下面几种操作形式，让定位更准确： filename:lineno //定位至具体行号 filename@css-selector //定位至具体CSS选择器 filename@function //定位至具体函数 还可以直接在新打开的文件中定位字符串。 filename#searchtext Command + (Alt) + F 当前文件内查找(替换)。Enter 查找下一处，Shift-Enter 查找上一处。敲 esc 就可以停在那里进行编辑。 把光标停留在要找的单词上面，然后 Command + D 连续敲多次，就可以找出所有当前文件中的这个单词，而且是直接在多点编辑模式下，可以直接进行替换。 如果要在一个文件夹内全局查找，鼠标右击文件夹，Find in Folder 就可以了。打开下一个匹配项用 F4，上一处 Shift+F4。 Ctrl + - 跳回老位置（jump_back），Ctrl + Shift + - 反向操作跳（jump_forword） 参考资料： HappySublime 如何优雅地使用Sublime Text 牛人总结的Sublime Text的心得经验 jikeytang/sublime-text · GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BiliBili视频信息爬虫基于Java的实现]]></title>
      <url>%2FbiliInfoCrawler%2F</url>
      <content type="text"><![CDATA[大二上学期的Java实验课要求写的项目都很有意思，这里先将最后的综合大项目进行一个总结。该项目要求设计并实现一个BiliBili视频信息爬虫，并且能够将每个分类收藏数前三的视频下载至本地。 该项目使用的软件有Eclipse（IDE）、Charles（抓包工具）、MySQL（数据库）、Navicat Premium（数据库可视化工具）。以下代码截图全部基于OS X系统上自己编写的代码。 了解相关知识该实验所用到的知识有且不仅限于： HTTP请求、响应和重定向； 使用apache-httpclient来实现对服务器的请求并收到响应； 用jsoup处理html文件； 数据库设计与使用； Java IO下载视频文件； 同时，该程序使用了Maven来管理项目的依赖关系。 抓包并分析用一个抓包工具来分析浏览器打开Bilibili视频网时重要的请求与响应。这里我选用的是Charles，当然也可以使用Fiddler或者其他好用的。 可以看到，图中选中的项即为访问Bilibili视频网分类页面时服务器向浏览器发送的json文件。路径中tid后的数字代表种类，pn后的数字代表页数。可以看到访问时浏览器发出的请求参数，爬虫程序同样也要设置这些参数使服务器认为是浏览器在访问。而在每一个json文件中，有20个视频的信息，包括我们感兴趣的av号（Bilibili视频id号）、作者、种类、收藏数、硬币数等信息。我们之后将要对json文件进行处理来获得这些信息，并把它们存进数据库。 爬虫相关方法 使用apache-httpClient来实现请求并得到响应，最终得到json文件。 通过JSONArray和JSONObject两个类方法对请求到的json文件进行处理，将得到的视频信息初始化为一个Bilibili对象（Bilibili类在Bilibili.java中定义），并调用JDBC.java中定义的方法将数据存入数据库。 视频下载相关方法 通过SQL语句选出该种类中收藏数前三的视频，返回其av号及其他信息。通过www.ibilibili.com加上av号，对其发出请求，获得HTML文件。 使用jsoup，利用标签对HTML文件进行解析，获得以www.bilibilijj.com/Files/DownLoad/为开头的视频下载地址。 利用JAVA IO的相关方法编写readInputStream和getVideo方法，下载视频保存至本地指定地址。 调用方法并开多线程加速在main方法中调用之前写好的方法，并开多线程加速爬取和视频下载。 经过反复的设计、编程、测试、修改，最终的程序能够爬取Bilibili视频网音乐区7个类别约62万个视频的信息（由于校园网波动，最后只爬了62w，实际上音乐区应该不止这么多视频），将其存入数据库，并将每个类别收藏数前三的视频下载至本地，符合实验要求。 项目中参考的资料： 普通Java工程转换成maven工程 Jsoup+json-lib解析xml带中括号的数组Json数据 完整代码已经放在我的github中。由于水平有限，可能存在错误或者性能优化方面的问题，欢迎讨论。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bye,2016 AND Hello,2017]]></title>
      <url>%2Fbye2016hello2017%2F</url>
      <content type="text"><![CDATA[开始写的时候是12月30日晚上，刚刚考完的大物感觉还不错。然后马上就到了2016年的最后一天。希望能在2016年内写完这篇博文，给自己的这一年做一个回顾。更重要的是，认真地考虑一下，2017年应该去做些什么。 Goodbye,2016 从软件工程的萌新变成半萌新。感觉算是摸到了大门，往内斗胆一窥，发现这个世界广阔无垠。东瞧西瞥，还没有考虑好自己今后的发展方向，目前还是打算先以java的进阶为主，向web开发方面学习。 今年的学期感觉除了课业上按部就班外，在技术自学上没有激情。倒是暑假自学java有很大的收获。希望自己能够不忽视小块的时间去学习技术。当然，首先找到至少短期内的一个学习目标。 大一下学期进了院长实验室，但是总觉得项目安排上有点难受。外包任务让自己没什么长进。下学期看看怎么协调一下，当然也有可能下学期会参加花旗杯。 拿了一些院级活动的奖（而且基本都是产品&amp;设计方面的工作）。希望自己能做一些负责技术方面的、有价值的项目。 体测比去年同期略瘦，50米快了整整一秒。希望自己能保持锻炼，还能在院队有个位置。 Hello,2017 先顺利地过了上学期所有期末考。希望自己的绩点还能保持在3.5以上。认真复习，少浪，别懒！ 寒假先定个小目标，比如啃啃javascript，啃啃java的高级特性，啃啃lintcode，写几篇有用的技术博客，顺便把博客再折腾一下，最好买个域名。总之，要让27天的寒假过的有意义。寒假开始时再列个日程表。 早睡早起，勤奋刻苦，下学期尽量不翘课。都是专业课，认真听。还要在课余时间继续学技术。 希望能做一个真正意义上的大项目（比如花旗杯）。为了这个目标，学技术。 在自己真正的兴趣上利用时间，而不是无所事事地浪费。 每天过得健康、充实、开心！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【V家中填】飛行機雲 -full ver.-]]></title>
      <url>%2Flyrics-aircloud%2F</url>
      <content type="text"><![CDATA[在高考完的暑假，我填完了第一首可以称为“完整”的词。契机是很偶然地点进了【Shikako】飛行機雲【翻唱】。一首好听的歌加上纯真的妹子音，可惜关注度远低于作品质量所应得的。(这个up把歌传到网易云啦。如果你懒得打开网址，点击下面播放就能听) 当时B站恰巧推出了“夏日延长线”的翻唱活动，想填词＋翻唱来参加。词是以远高于一般速度地填完了（果然ddl是第一生产力w），但录制翻唱什么的，直到现在还没有尝试过。夏天终究是属于遗憾的季节。 尽管写的很快，还是花了很多心思去斟酌如何表现那种孩童时的懵懂和错过时的心酸。如果看到这的人觉得这首词填的还不错，我就很开心了。要是有唱(mei)见(zi)愿意拿这首词翻唱，那我就可以上天了ε=ε=(ノ≧∇≦)ノ当然也欢迎交流讨论。 【中文填词】飛行機雲 -full ver.- 曲：toa词：摸鱼小能手大黄菌 那时候 你决定松开手让气球飞走也松开我们之间可能有 的以后而我呢 还在原地踮着脚仰望天空看你指过的飞机云在泪水中消融 回家 在蝉鸣中难忍受 你的捉弄 挥舞拳头而你 笑着逃走我追赶 磕磕绊绊 眼泪摔落 站在分别时的十字路口我垂落的双手紧握沉默迟到的挽留总是与开口错过就像你和我 那时候 你决定松开手让气球飞走也松开我们之间可能有 的以后而我呢 还在原地踮着脚仰望天空看你指过的飞机云在泪水中消融 忽然之间 被牵住手你偏头 眼神闪躲 一字不说而我的脸已泛红转过身 闹起别扭 掩饰羞涩 那个夏天一直有风路过过往的快乐却不肯为我逗留抓不住时光匆匆流走的你我把彼此弄丢 那时候 关于未来的想象都太年幼以为长大还躲在漫长的 等待后而我呢 还在原地想念着你的笑容而你指过的飞机云再次划过天空 那时候 我们约定再见而 拉过的勾勾住的只有斑驳的 回忆和难过而我们 在物是人非后终于失去联络在世界的不同角落孤单地漂流 而我呢 还在原地想念着你的笑容想念那天归家途中见到的彩虹而你呢 在什么地方唱着熟悉的歌是否也像我偶尔望向同一片天空]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用hexo+github搭建这个博客的一点经验]]></title>
      <url>%2Fhexo-begin%2F</url>
      <content type="text"><![CDATA[博客基本算是搭好了。当然，还有很多地方可以改进，比如加上包括评论（主要是多说不知道为什么一申请就告诉我出错）在内的第三方服务，比如样式还可以再漂亮一些，而且也没有申请自己的域名（毕竟也没什么人看吧…大概）。但是一个个人博客，内容的质量应该是最重要的。从现在开始，先写点东西吧，比如，先谈谈搭建这个博客时遇到的一些问题以及解决的方案。注意，我是用mac搭建的，以下很多内容可能只适用于OS X系统。 这个博客后期做的样式等修改也会记录在这篇博文中。 初始搭建 前期准备：安装XCode、node.js，注册Github。除开node.js外都是已有的，也没遇到什么问题。 hexo的安装推荐查看hexo的官方文档，说的很详细。看网上七七八八的教程反而可能遇到一些莫名其妙的问题。整个搭建过程中花费时间最多的就是在解决DTrace错误上： [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; 按照百度的解决方法折腾半天（是真的半天！）也不奏效，最后的解决方案还是按照文档从安装hexo开始重新走了一遍，再使用命令： npm install hexo --no-optional 这才解决。果然官方文档才是坠吼的！ 然后就是主题选择了。根据知乎上有哪些好看的 Hexo 主题？－知乎问题的回答，果断选择github上star最多的NexT主题，官方文档也同样详细易懂。Muse实在太丑，开始时我选用的Scheme是Mist。后来百度看到好多大佬选用Pisces，感觉要比Mist好看一些，于是换了。其实就是改改配置文件，很简单。之后加入不蒜子统计，设置RSS（其实我并不清楚这个是干什么的…就是橙色的图标蛮好看的），加上标签、分类、关于页面、搜索功能和侧边栏社交链接。这些在官方文档写的都很清楚。 我还改了一些什么呢？第一，背景颜色。原来NexT的默认背景颜色是浅灰色，不仅沉闷，而且和其他博客的重复率太高。在网上搜到改动方法：hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _schemes -&gt; Pisces（Mist和Muse也行），找到路径下的index.styl文件，改动文件的最上方的那一行代码即可（现在这个博客改成了body { background: #bdeaf7; }）。这个方法应该也可以将背景换成图片，但是每次我用hexo server在本地看是正常的，传到github上就显示不了图片。还没找到解决方法，只好作罢。（17.04.27：解决了，现在背景图片为《言叶之庭》中的截图，CSS 代码为body { background: url(&quot;../../../images/back1.jpeg&quot;); background-repeat:no-repeat; background-attachment:fixed; background-size: 100% 100%;}） 第二，我对底部powered by的logo栏进行了更改。其实按理说这个地方作为对hexo和NexT的开发者的感谢不应该修改的…还是更想个性化一点，抱歉抱歉。修改方法参见 Hexo-Next底部powered by的logo栏更改以及注意事项（附官方文档,文末有福利链）。我把这里当作一个随时修改的心情栏了。（17.04.27：我改回来了） 后期更新 16.12.31更新：加上了鼠标点击出爱心的特效。详见 hexo引用自定义js文件和css样式。这个blog还有粒子特效的背景，说不定哪天也给自己加上。 17.02.20更新：申请了现在的域名，域名解析详见 Hexo站点之域名配置【2】。 17.02.21更新：增加多说评论并修改样式，详见 动动手指，给你的Hexo站点添加最近访客（多说篇）。 17.02.26更新：NexT主题支持自行设定CDN以加速静态资源的加载，详见 进阶设定 - NexT 使用文档。但是经过测试，感觉修改CDN后并没有实现预期的加速（也有可能是我没找到比较好的CDN）。所以现在暂时还是保持没有修改的状态。 17.03.14更新：增加复制文本自带版权信息，详见版权狗退散 — 仿知乎复制文本自带版权声明。 17.04.08更新：多说即将归西。暂无用其他评论系统替代的打算。 17.04.27更新：NexT主题更新至 5.1.1 版本，更换背景图片（好看多了w）。 大概就这些了。希望搭建这个博客能够督促我写下更多编程学习中的经验之谈。但我也没有打算只把这个博客当作一个写技术性文章的地方，随笔、填词什么的也会放在这里。欢迎大家多多来看，相互交流 :)]]></content>
    </entry>

    
  
  
</search>
