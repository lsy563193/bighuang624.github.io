<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大黄菌的个人博客</title>
  <subtitle>天下武功，无勤不破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kyonhuang.top/"/>
  <updated>2017-12-19T08:23:12.000Z</updated>
  <id>http://kyonhuang.top/</id>
  
  <author>
    <name>Kyon Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划一篇通</title>
    <link href="http://kyonhuang.top/Dynamic-programming/"/>
    <id>http://kyonhuang.top/Dynamic-programming/</id>
    <published>2017-12-18T10:23:41.000Z</published>
    <updated>2017-12-19T08:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。</p>
<p>另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，但是如果抱着只能二选一的心态去学习，只能说明自己不够勤奋。之后的学习目标是前端达到就业水平，而机器学习方面为读研打好稳固基石。</p>
<p>回到正题。这次实习考试的第一题在当时没有思路，出来后同学讨论说要用到动态规划思想。之前有听过几次这个词，但是没有去了解，恰逢这个机会（以及为之后的美赛做准备），查阅了很多资料。在此总结一下我对动态规划的了解，以及用几个例子来说明，希望能尽可能地把动态规划给弄通。</p>
<a id="more"></a>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p><strong>动态规划（Dynamic programming）</strong>是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构性质</strong>的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题，我们就称其为原问题的<strong>子问题</strong>。</p>
<p><strong>动态规划的核心</strong>是<strong>状态</strong>和<strong>状态转移方程</strong>：</p>
<ul>
<li><p><strong>状态</strong>：描述该问题的子问题的解，即根据子问题来定义状态。</p>
</li>
<li><p><strong>状态转移方程</strong>：状态和状态之间的关系式。大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态（<strong>无后效性</strong>）。</p>
</li>
</ul>
<p>能使用动态规划思想解决的问题都有最优子结构性质和重叠子问题：</p>
<ul>
<li><p><strong>最优子结构（optimal substructure）</strong>性质：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。其包含“<strong>全局最优解包含局部最优解</strong>”的思想。</p>
</li>
<li><p>重叠子问题：指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
</li>
</ul>
<h2 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h2><ol>
<li>将原问题分解为子问题；</li>
<li>确定状态：状态不是随便定义的，一般定义完就要找到状态转移方程；</li>
<li>确定一些初始状态（边界状态）的值；</li>
<li>确定状态转移方程。</li>
</ol>
<p>如果问题看起来是个动态规划问题，但是无法定义出状态，那么试着将问题规约到一个已知的 DP 问题。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>干巴巴说了这么多，来点例题实际看看！</p>
<h3 id="菜鸟级"><a href="#菜鸟级" class="headerlink" title="菜鸟级"></a>菜鸟级</h3><p>这里我选了 LeetCode 的第 70 题 Climbing Stairs。说来惭愧，我第一次做这个题的时候半天没做出来，还先跳过去了。</p>
<p>题目是这样的：假设你在爬梯子，需要 n 步爬到顶。每一次只能爬 1 或 2 格，爬到顶一共有多少种不同的方法？</p>
<p>一步步沿着前面提到的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：这里的子问题即“爬到 i 格共有多少种不同的方法（i &lt; n）”；</li>
<li>确定状态：我们通常用一个函数表达式来表示状态。这里我们可以用<code>d(i)</code>来表示“爬到 i 格共有的不同的方法数”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = 1</code>、<code>d(2) = 2</code>；</li>
<li>确定状态转移方程：当我们得知<code>d(i-2)</code>时，再往上爬一次 2 格即可到达 i 格；当我们得知<code>d(i-1)</code>时，再往上爬一次 1 格即可到达 i 格。因此有<code>d(i) = d(i - 1) + d(i - 2)</code>。没有重叠的解法，因为最后一步要么爬 1 格，要么爬 2 格，我们将这两种自然分开了。</li>
</ol>
<p>使用递归，我们写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>) + climbStairs(n-<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Submit 就可以看到红红的 Time Limit Exceeded。计算时间超了，这是因为对于每一个 i，我们重复计算了很多次子问题的答案。想要节省这些计算，我们可以采用拿空间换时间的方法，用一个大小为 n 的数组来记录子问题的计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</div><div class="line">        fill(i, arr);</div><div class="line">    <span class="keyword">return</span> arr[n];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        arr[n] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</div><div class="line">        arr[n] = <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        arr[n] = arr[n-<span class="number">1</span>] + arr[n-<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AC，Run Time 5ms。</p>
<p>也可以用递推法来解决，本质是一个 fibonacci。这里借 Discuss 里的解法一用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// base cases</span></div><div class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> one_step_before = <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> two_steps_before = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> all_ways = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</div><div class="line">    	all_ways = one_step_before + two_steps_before;</div><div class="line">    	two_steps_before = one_step_before;</div><div class="line">        one_step_before = all_ways;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> all_ways;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="普通级"><a href="#普通级" class="headerlink" title="普通级"></a>普通级</h3><p>稍微加点难度，来试一下 LeetCode 的第 198 题 House Robber。</p>
<p>题目：你是一个超高校级的小偷，唯一能阻止你的是你同一夜不能偷相邻的两家，否则警报装置会响。给一个全是非负整数的数组来代表每家有的钱，求你在不惊动警报的基础上今晚的最大收获。</p>
<p>还是一步步沿着动态规划的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：假设数组长度为 n，则这里的子问题即“有 i 家可偷时最大收获（i &lt; n）”；</li>
<li>确定状态：用<code>g(i)</code>代表第 i 家有的钱，用<code>d(i)</code>来表示“有 i 家可偷时最大收获”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = g(1)</code>、<code>d(2) = max(g(1), g(2))</code>；</li>
<li>确定状态转移方程：可以想到，到第 i（i &gt; 2）间屋子时，可能之前偷了第 i-1 间，那这间就不能偷；如果没偷第 i-1 间，那这间可以偷。于是有<code>d(i) = max(d(i-2)+g(i), d(i-1))</code>。</li>
</ol>
<p>用数组来记录偷过第 i 间屋子时最大收获，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = nums.length;</div><div class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">        fill(d, nums, i);</div><div class="line">    <span class="keyword">return</span> d[n-<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)</div><div class="line">        d[i] = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</div><div class="line">        d[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        d[i] = Math.max(d[i-<span class="number">2</span>]+nums[i], d[i-<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Run Time 接近 0，非常理想。</p>
<p>也有非常巧妙的递推方案，空间复杂度 O(1)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> prevNo = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> prevYes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</div><div class="line">        <span class="keyword">int</span> temp = prevNo;</div><div class="line">        prevNo = Math.max(prevNo, prevYes);</div><div class="line">        prevYes = n + temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(prevNo, prevYes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="挑战者级"><a href="#挑战者级" class="headerlink" title="挑战者级"></a>挑战者级</h3><p>来试试 LeetCode 的第 646 题 Maximum Length of Pair Chain。这是一道难度为 medium 的题，建议先跳过这一小节，看完“扩展”中的“<a href="http://kyonhuang.top/Dynamic-programming/#%E6%9C%80%E9%95%BF%E9%9D%9E%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89">最长非降子序列（LIS）</a>”再回来，有助于解决和理解这道题。</p>
<p>题目：给定 n 对数，每一对中前一个数总小于后一个数。现在，我们定义当且仅当<code>b &lt; c</code>时<code>(c, d)</code>可以跟在<code>(a, b)</code>后，来形成一条链。给定一系列对，求出<em>用上述方法形成的链条的最大长度</em>。不需要用完所有的给定对，而且可以以任意顺序选取。</p>
<p>可以看到，这题和 LIS 问题比较相似，但又有一些不同。由于可以以任意顺序选取，而非 LIS 问题中选取最长非降子序列的顺序固定，因此需要对一系列数对进行一个从小到大的排序。</p>
<p>状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d(i) = max&#123;1, d(j)+1&#125;，其中 j &lt; i，pairs[j][1] &lt; pairs[i][0]</div></pre></td></tr></table></figure>
<p>想要求<code>d(i)</code>，就把 i 前面的各个链中，最后一个数对的最大值不大于<code>pairs[i][0]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个链中最后一个数对的最大值都大于<code>pairs[i][0]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</div><div class="line">    Arrays.sort(pairs, (a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</div><div class="line">    <span class="keyword">int</span> len = pairs.length;</div><div class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</div><div class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        arr[i] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</div><div class="line">            <span class="keyword">if</span>(pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>] &amp;&amp; arr[j] + <span class="number">1</span> &gt; arr[i])</div><div class="line">                arr[i] = arr[j] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; l)</div><div class="line">            l = arr[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度是 O(n^2)，不是最佳解法。由于根据数对的最大值排好了序，因此可以直接用下列方法来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</div><div class="line">    Arrays.sort(pairs, (a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = pairs.length, i = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (++i &lt; n) &#123;</div><div class="line">        sum++;</div><div class="line">        <span class="keyword">int</span> curEnd = pairs[i][<span class="number">1</span>];</div><div class="line">        <span class="keyword">while</span> (i+<span class="number">1</span> &lt; n &amp;&amp; pairs[i+<span class="number">1</span>][<span class="number">0</span>] &lt;= curEnd) i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="具体实现方法总结"><a href="#具体实现方法总结" class="headerlink" title="具体实现方法总结"></a>具体实现方法总结</h2><p>经过以上三个例题的锻炼，一般难度的动态规划问题应该都能解决了。总结一下，动态规划思想具体实现有以下三种方法：</p>
<ol>
<li><p>用<strong>直接递归</strong>的方法计算状态转移方程，效率往往十分低下。其原因是<strong>相同的问题被重复计算了多次</strong>。</p>
</li>
<li><p>可以采用<strong>递推法</strong>计算状态转移方程。递推的关键是边界和计算顺序。在多数情况下，递推法的时间复杂度是：状态总数 <em> 每个状态的决策个数 </em> 决策时间。如果不同状态的决策个数不同，需具体问题具体分析。注意递归和递推的区别：一个自顶向下，一个自底向上。</p>
</li>
<li><p>也可以用<strong>记忆化（memoization）搜索</strong>的方法计算状态转移方程。当采用记忆化搜索时，不必事先确定各状态的计算顺序，但<strong>需要记录每个状态“是否已经计算过”及计算的结果</strong>。</p>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="最长非降子序列（LIS）"><a href="#最长非降子序列（LIS）" class="headerlink" title="最长非降子序列（LIS）"></a>最长非降子序列（LIS）</h3><p>给定一个序列<code>A[1]、A[2]、...、A[n]</code>，求其最长非降子序列（LIS，longest increasing subsequence）的长度。这是讲动态规划时基本都会讲到的一个问题。</p>
<p>其最小子问题即求<code>A[1]、A[2]、...、A[i]</code>的最长非降子序列的长度，其中<code>i &lt; N</code>；而状态则定义有<code>d(i)</code>表示前 i 个数中以<code>A[i]</code>结尾的最长非降子序列。</p>
<p>当要考虑初始状态（边界状态）的值时，最好是以一个实际输入为例。假定要求的序列是：<code>5, 3, 4, 8, 6, 7</code>，则有：</p>
<ul>
<li>前 1 个数的 LIS 长度<code>d(1) = 1</code>；</li>
<li>前 2 个数的 LIS 长度<code>d(2) = 1</code>（序列：3；3 前面没有比 3 小的）；</li>
<li>前 3 个数的 LIS 长度<code>d(3) = 2</code>（序列：3，4；4 前面有个比它小的 3，所以<code>d(3)=d(2)+1</code>）；</li>
<li>前 4 个数的 LIS 长度<code>d(1) = 1</code>（序列：3，4，8；8 前面比它小的有 3 个数，所以<code>d(4) = max{d(1),d(2),d(3)}+1 = 3</code>）；</li>
</ul>
<p>由此得到状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d(i) = max&#123;1, d(j) + 1&#125;，其中 i &gt; j，A[i] &gt;= A[j]</div></pre></td></tr></table></figure>
<p>想要求<code>d(i)</code>，就把 i 前面的各个子序列中，最后一个数不大于<code>A[i]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个子序列中最后一个数都大于<code>A[i]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = A.length;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        d[i] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </div><div class="line">            <span class="keyword">if</span>(A[j] &lt;= A[i])</div><div class="line">                d[i] = Math.max(d[i], d[j] + <span class="number">1</span>);</div><div class="line">        len = Math.max(d[i], len);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度为 O(n^2)，不是最优解法。可以看看<a href="https://www.felix021.com/blog/read.php?1587" target="_blank" rel="external">最长递增子序列 O(NlogN)算法</a>，有点复杂，这里就不多谈了。</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1 背包问题是最广为人知的动态规划问题之一，拥有很多变形。</p>
<p>有 n 种物品，每种只有一个。第 i 种物品的体积为 V[i]，价值为 W[i]。选一些物品装到一个容量为 C 的背包，使得背包内物品在总体积不超过 C 的前提下价值尽量大。1 &lt;= n &lt;= 100，1 &lt;= V[i] &lt;= C &lt;= 10000，1 &lt;= W[i] &lt;= 10^6。</p>
<p>将原问题分解为子问题后，状态还是比较好找的。我们可以用<code>d(i, j)</code>来表示前 i 个物品装到剩余体积为 j 的背包里能达到的最大价值。</p>
<p>对于第 i 个物品，可以装进或不装进背包。不装进背包，则背包中物品最大总价值为<code>d(i-1, j)</code>；而如果装进背包，对于前 i-1 个物品的空间就只有 j-V[i] 了。</p>
<p>由此得到状态转移方程：</p>
<p><code>d(i, j) = max{d(i-1, j), d(i-1, j-V[i]) + W[i]}</code></p>
<p>得到状态转移方程后，代码也不难写出了。这里就不贴了，有兴趣可以自己试试。</p>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>Dijkstra 算法也是以动态规划为基础的。你可以到我《算法》笔记的相关章节对 Dijkstra 算法进行进一步了解：<a href="https://github.com/bighuang624/Algorithms-notes/blob/master/%E7%AC%94%E8%AE%B0/4.4_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.md" target="_blank" rel="external">Algorithms-notes/笔记/4.4_最短路径.md
</a>（Dijkstra 算法相关内容正在添加中）。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>动态规划有着很强的理论性和实践性，可以考验出算法能力，因此经常在各类算法竞赛、面试题中出现。想要完全掌握，光搞定这一篇博客的几个例题远远不够，只有多做经典题目，才能当再碰到动态规划相关题目的时候做到游刃有余。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作参考"><a href="#写作参考" class="headerlink" title="写作参考"></a>写作参考</h3><ul>
<li><a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="external">动态规划：从新手到专家</a></li>
<li><a href="http://blog.csdn.net/baidu_28312631/article/details/47418773" target="_blank" rel="external">教你彻底学会动态规划——入门篇 - CSDN博客</a></li>
<li>《算法竞赛入门经典（第 2 版）》第 9 章</li>
</ul>
<h3 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h3><ul>
<li><a href="https://juejin.im/post/5a29d52cf265da43333e4da7" target="_blank" rel="external">漫画：什么是动态规划？ - 掘金</a>：可以借助这个漫画来理解动态规划，并了解动态规划在某些背包问题的特例上计算速度的局限性。</li>
<li><a href="http://www.hawstein.com/posts/dp-knapsack.html" target="_blank" rel="external">动态规划之背包问题（一）</a></li>
<li><a href="https://www.zhihu.com/question/23995189" target="_blank" rel="external">什么是动态规划？动态规划的意义是什么？ - 知乎</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。&lt;/p&gt;
&lt;p&gt;另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，但是如果抱着只能二选一的心态去学习，只能说明自己不够勤奋。之后的学习目标是前端达到就业水平，而机器学习方面为读研打好稳固基石。&lt;/p&gt;
&lt;p&gt;回到正题。这次实习考试的第一题在当时没有思路，出来后同学讨论说要用到动态规划思想。之前有听过几次这个词，但是没有去了解，恰逢这个机会（以及为之后的美赛做准备），查阅了很多资料。在此总结一下我对动态规划的了解，以及用几个例子来说明，希望能尽可能地把动态规划给弄通。&lt;/p&gt;
    
    </summary>
    
      <category term="算法笔记" scheme="http://kyonhuang.top/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://kyonhuang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://kyonhuang.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="DP" scheme="http://kyonhuang.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>新的终点，新的起点</title>
    <link href="http://kyonhuang.top/new-end-new-start/"/>
    <id>http://kyonhuang.top/new-end-new-start/</id>
    <published>2017-11-27T05:22:24.000Z</published>
    <updated>2017-12-04T10:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在从成都回武汉的火车上开始写这一篇博客。</p>
<p>历时共七个月的花旗杯终于结束了。作为创队元老，我从头到尾参与了这个项目，从每个组员的奇思妙想中挖掘出我们现在的选题，在一次次的争论中始终坚持它就是最好的选择。我也投入了大量的时间和精力，写完了整个网站前端开发的每一行代码。整个项目也数次从被放弃的边缘拉回来，成员也有一定的变动，可以说历经波折了。</p>
<p>到达成都后，临行前请人算了一卦的浦先生幸运地抽到答辩的最后一位，这让我们可以观摩其他队伍的答辩、对评委的关注点进行揣摩，并有较为充足的准备时间。之后，前往成都的核心队员开始昼夜不分地修改项目计划书、PPT、展示讲稿等各种材料，直到上台答辩的最后一秒。这个过程中，另外四名成员应该比我要更为辛苦，在答辩前一夜，负责算法的曹队和冯大佬更是直到凌晨三点还在讨论评委可能提出的问题（他们也确实命中了绝大部分问题，功居甚伟），而王同学也果断承担起本来属于队长的项目展示的重任。在这样的准备强度下，尽管也有遗憾，我对我们组的答辩表现可以打到 100 分。我也十分感激他们能够用尽全力来准备项目的展示。</p>
<p>最终，我们的“探方网——网络文学 IP 价值评估及预测系统”获得了第十三届“花旗杯”金融创新应用大赛的三等奖。可惜的是，我们是最后一个宣布的三等奖，也就是说离二等奖仅有一步之遥。但能在全国二十强中最终名列第四，也是大赛诸多评委老师对我们项目极大肯定。晚宴上海尔金控的李大鹏先生也表示对我们的项目有持续关注和投资的意向，我个人是比较看好这个项目，希望有机会能够继续完善它。</p>
<p>从比较现实的角度来看，这次参赛经历带给我个人大约 1000 元的奖金，以及大学期间第一个有分量、对保研有加分的奖项。当然，我还有一些对我而言更为重要的东西与看到这篇博文的每一位分享。</p>
<a id="more"></a>
<h2 id="参加比赛的经历"><a href="#参加比赛的经历" class="headerlink" title="参加比赛的经历"></a>参加比赛的经历</h2><p>在成都备战的深夜里，几名核心大佬都表示“再也不参加花旗杯这样的非技术类比赛了”。“非技术类”确实对花旗杯是一个不太正当的评价，但准备花旗的开发周期之长、团队管理之累、准备工作之繁琐，对我们这些软件工程专业的 nerd 来说，是醉心于技术的阻碍。我们花了相当比例的精力在项目的包装上，而在实际技术层面可能没有达到我们想要的高度。</p>
<p>但我还是很享受这个过程，因为比起纯粹的技术人员，我感觉可能我会更多地接触，也更为喜欢这样的项目包装、推广过程。我认为没有任何一个成功的项目能够单纯成长在技术的温室中，项目的包装是项目真正成为<strong>产品</strong>所不得不经历的工作。通过这样的工作，让技术人的智慧成果被更多人了解、使用和赏识，我认为这是十分有意义的。何况，在花旗的答辩场上，金玉其外、败絮其中的项目都被资深的评委老师们毫不留情地迅速戳破。</p>
<p>整个过程确实很累很苦，尤其是最末期，网站的前端基本上一天加好几个功能，我也很骄傲我坚持了下来。在走出答辩场地后，我们五个人在楼下花旗杯决赛的展牌前合影。在空间 po 出照片时，我配的字是“我感觉毕了业”。因为我在那一刻的感觉大概和《中国有嘻哈》欧阳靖在结束最后一次的表演时一样，如释重负，而又如获新生。</p>
<p>整个前端项目都是我的 commit，哈哈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-472d42ef0cb3ff5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="huaqi-commit.jpg"></p>
<p>这次花旗杯的参赛经历对我来说是一次十分难忘的经历。鉴于国软院有通知渠道并推荐参加的有含金量的比赛确实不多，我十分推荐学弟学妹们参加花旗杯。当然，下一届的学弟学妹如若进入决赛，大概要去东北挨冻了。另外，我也很欢迎有学弟学妹在明年联系我进入团队，作为前端、算法开发人员，或者作为项目方向、团队管理、答辩展示的一个咨询人员。</p>
<h2 id="团队开发的经验"><a href="#团队开发的经验" class="headerlink" title="团队开发的经验"></a>团队开发的经验</h2><p>这次花旗杯应该就是我本科中第一次，也是最后一次相对来说的大型团队开发项目了。数十人的团队开发在大学里是十分难得的经验，我也学到了很多，尤其是那些我们没有做的很好的环节，例如分工、沟通、日程规划等。</p>
<ul>
<li>队长应该主动和各部分负责人沟通，确定进度。</li>
<li>工作分配和修改必须要明确到人，并且利用好在线可查看可修改的备忘文件，例如石墨文档等。</li>
</ul>
<p>作为最初始的成员，我看着团队成员不断增加，也看到有些成员因为各种原因退出了这个项目。对于中途退出的成员，我虽然没有给他们前期的努力以回报，但理解他们并心存感激；但我也看到有极少部分成员对这个项目缺少投入。不论是因为确实身兼数职、分身乏术，还是企图偷懒、不劳而获，我都认为这是缺乏责任心的表现。我理解在接近七个月的项目开发中，感到怠惰、信心不足是正常的表现，我自己也有过这样的心理。但是在整个项目中，如果你所做的努力远远少于其他人，最终却分享同样的荣誉，这不但拖累了项目的进度，对整个项目组的士气更有着极其不良的影响。因此，选择团队成员也是修行的一种。对我自己来说，由于我个人的交际不是很广，没有太多的参与这次项目成员的挑选过程。通过这次经历，我也认识到广交朋友的益处，会努力在保证交友质量的前提去结识更多人。</p>
<p>另外，在以后的项目开发中，我希望在个人技术水平达标的前提下，我能够承担起组长的重任，让整个团队有更好的开发积极性和管理秩序，同时挑战自我，获得进步。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在这七个月里，我也对自己的性格缺陷进行了审视。我不太好意思向大家列举这些性格缺陷，但它们使我在包括花旗项目在内的学习过程中，甚至是在大学生涯的为人处事、个人发展等各方面遇到了不少挫折。我对未来我在性格方面的改善和转变有一些期许。我也不是很喜欢我现在的生活方式，希望能让它变得更加多彩。</p>
<p>我走到了花旗杯的终点。但对我来说，还有很多的起点。我希望在未来的日子里，我能够更加坚定、更加拼搏、更加成熟、更加不甘平庸。这很难，我希望我能够做到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在从成都回武汉的火车上开始写这一篇博客。&lt;/p&gt;
&lt;p&gt;历时共七个月的花旗杯终于结束了。作为创队元老，我从头到尾参与了这个项目，从每个组员的奇思妙想中挖掘出我们现在的选题，在一次次的争论中始终坚持它就是最好的选择。我也投入了大量的时间和精力，写完了整个网站前端开发的每一行代码。整个项目也数次从被放弃的边缘拉回来，成员也有一定的变动，可以说历经波折了。&lt;/p&gt;
&lt;p&gt;到达成都后，临行前请人算了一卦的浦先生幸运地抽到答辩的最后一位，这让我们可以观摩其他队伍的答辩、对评委的关注点进行揣摩，并有较为充足的准备时间。之后，前往成都的核心队员开始昼夜不分地修改项目计划书、PPT、展示讲稿等各种材料，直到上台答辩的最后一秒。这个过程中，另外四名成员应该比我要更为辛苦，在答辩前一夜，负责算法的曹队和冯大佬更是直到凌晨三点还在讨论评委可能提出的问题（他们也确实命中了绝大部分问题，功居甚伟），而王同学也果断承担起本来属于队长的项目展示的重任。在这样的准备强度下，尽管也有遗憾，我对我们组的答辩表现可以打到 100 分。我也十分感激他们能够用尽全力来准备项目的展示。&lt;/p&gt;
&lt;p&gt;最终，我们的“探方网——网络文学 IP 价值评估及预测系统”获得了第十三届“花旗杯”金融创新应用大赛的三等奖。可惜的是，我们是最后一个宣布的三等奖，也就是说离二等奖仅有一步之遥。但能在全国二十强中最终名列第四，也是大赛诸多评委老师对我们项目极大肯定。晚宴上海尔金控的李大鹏先生也表示对我们的项目有持续关注和投资的意向，我个人是比较看好这个项目，希望有机会能够继续完善它。&lt;/p&gt;
&lt;p&gt;从比较现实的角度来看，这次参赛经历带给我个人大约 1000 元的奖金，以及大学期间第一个有分量、对保研有加分的奖项。当然，我还有一些对我而言更为重要的东西与看到这篇博文的每一位分享。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>数据预处理及常用处理方法</title>
    <link href="http://kyonhuang.top/intro-to-data-preprocessing/"/>
    <id>http://kyonhuang.top/intro-to-data-preprocessing/</id>
    <published>2017-10-31T12:45:28.000Z</published>
    <updated>2017-11-09T03:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为互联网上最著名的数据科学竞赛平台之一，Kaggle 无疑是数据从业者和爱好者最喜欢的社区之一。最近，Kaggle 发布了 <a href="https://www.kaggle.com/amberthomas/kaggle-2017-survey-results" target="_blank" rel="external">2017 用户调查报告</a>，共有 16000 余名用户参与的这份调查可以让我们对数据工作者的各类信息有一个了解。</p>
<p>其中，对于“工作中遇到的障碍主要是什么？”这个问题，有 49.4% 的被调查者选择了“脏数据（dirty data）”这一项，占该问题所有选项的第一位。也就是说，数据科学家一般最常见的困扰就是要对手头的数据进行大量的预处理工程。</p>
<p>在业界有一句广泛流传的话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。从这句话可以看出，数据的好坏对于机器学习模型的最终效果有着极大的影响。</p>
<p>然而，现实世界中数据大体上都是不完整、不一致、含噪声的脏数据，无法直接使用，或结果差强人意。为了提高数据的质量，数据预处理技术应运而生。实际上，在一个基于机器学习模型的实际应用中，对于数据的预处理工作所需的时间和精力可能远大于模型和算法的选择和应用。</p>
<a id="more"></a>
<h2 id="数据预处理的概念"><a href="#数据预处理的概念" class="headerlink" title="数据预处理的概念"></a>数据预处理的概念</h2><p><strong>数据预处理</strong>是指对所收集数据进行分类或分组前所做的审核、筛选、排序、变换、规约、汇总等必要的处理。</p>
<h2 id="数据预处理针对的问题"><a href="#数据预处理针对的问题" class="headerlink" title="数据预处理针对的问题"></a>数据预处理针对的问题</h2><p>通过数据获取，我们能够得到未经处理的数据，这时的数据可能存在一些问题。在解决这些问题后，我们才能选择和提取合适的特征进行模型的训练。</p>
<p>这里简述了一部分问题及其解决方法，还有一些问题的解决方案会在下节展开讨论：</p>
<ul>
<li><p>不属于同一量纲：特征的规格不同，不能放在一起比较。后文提到的无量纲化可以解决这一问题。</p>
</li>
<li><p>信息不规整：由于数据收集或存储时的错误、技术问题或漏洞，以及软硬件故障等因素，可能存在一些不规整数据。这些不规整的数据需要被过滤掉。</p>
</li>
<li><p>数据点缺失：缺失或不规整的数据需要根据其他数据进行填充，方法包括用零值、全局期望或中值，或是根据相邻或类似的数据点来做插值等。需要根据数据、应用场景和个人经验来选择正确的方式。</p>
</li>
<li><p>异常值问题：异常值的主要问题在于即使它们是极值也不一定就是错的，对错非常难以分辨。异常值可被移除或是填充，但鲁棒回归等统计技术可用于处理异常值或是极值。另外，利用如对数或高斯核对异常值进行转换也有利于降低值跳跃的影响。</p>
</li>
<li><p>数据类型不合要求：对于某些类型的特征，我们可能希望将其转换为另一类型进行使用。比如，我们可以将考试分数这个数值特征转换为是否及格这个二元特征，这个可以通过二值化（设定一个阀值）实现。其他的转换也可以通过自己定义的函数实现。</p>
</li>
<li><p>数据不能直接使用：对于例如文本特征、类别特征等特定类别的特征，机器学习算法和模型不能直接使用，那么需要对其做一些转化。对于文本特征，可以使用词袋（bag-of-word）表示法；而对于类别特征，可以使用 One-hot 编码进行处理。这些方法的核心都是编码，会在下一节再出现。</p>
</li>
</ul>
<h2 id="数据预处理的常用方法"><a href="#数据预处理的常用方法" class="headerlink" title="数据预处理的常用方法"></a>数据预处理的常用方法</h2><p>除开过滤、填充等方法之外，下列方法在实际问题的数据预处理中也比较常用。</p>
<h3 id="无量纲化"><a href="#无量纲化" class="headerlink" title="无量纲化"></a>无量纲化</h3><p><strong>无量纲化</strong>使不同规格的数据转换到同一规格。常见的无量纲化方法有<strong>标准化</strong>和<strong>归一化</strong>。</p>
<p>标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布。</p>
<p>归一化利用了边界值信息，将特征的取值区间缩放到某个特点的范围，例如[0, 1]等。</p>
<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>标准化也叫 z-score 规范化（零均值规范化）。公式如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a1b64f8328595283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标准化.png"></p>
<p>其中 \mu 是样本数据的<strong>均值（mean）</strong>， \sigma 是样本数据的<strong>标准差（std）</strong>。</p>
<p>通过标准化，样本数据被变为一个均值为 0，方差为 1 的分布。标准化可以达到<strong>加速收敛</strong>的效果。</p>
<h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p><strong>归一化</strong>一般是将数据映射到指定的范围，用于<strong>去除不同维度数据的量纲以及量纲单位</strong>。</p>
<p>最常见的归一化方法就是 Min-Max 归一化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-8a1730b90c9336f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归一化.png"></p>
<p>经过归一化处理过后的数据，不会发生某一特征因维度过高而起主导作用，从而遮盖住其他特征的问题。</p>
<p><strong>注意</strong>，归一化和标准化的英文都为 Normalization，需要<strong>根据其用途（或公式）的不同去理解或翻译</strong>。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p><strong>编码</strong>将无法作为输入的原始类别特征或文本特征表示为数字形式。其思想为用一个变量的字典来实现变量到索引序号的映射。</p>
<p>编码的方式也有很多，下面介绍两个常用的编码方式－One-hot 编码和哑编码。</p>
<h4 id="One-hot-编码"><a href="#One-hot-编码" class="headerlink" title="One-hot 编码"></a>One-hot 编码</h4><p>假设变量可取的值有 k 个，如果对这些值用 1 到 k 编序，则可以用长度为 k 的二元向量来表示一个变量的取值。在这个向量里，该取值对应的序号所在的元素为 1，其他元素都为 0。</p>
<h4 id="哑编码"><a href="#哑编码" class="headerlink" title="哑编码"></a>哑编码</h4><p><strong>哑编码</strong>是一种状态编码，前文提到的词袋表示法用的是这种编码方式。将这些文本特征转化为数字时，数字与数字之间是没有大小关系的，纯粹只是分类标记，这时候就需要用哑编码对其进行编码。比如 0 用 0001，1 用 0010，2 用 0100 以此类推。有点类似文本矩阵，最终会构成一个<strong>稀疏矩阵</strong>。一份文本数据中各种词可能达数百万，因此使用稀疏矩阵表示能够节省内存和磁盘空间，以及计算时间。</p>
<h5 id="补充：稀疏矩阵"><a href="#补充：稀疏矩阵" class="headerlink" title="补充：稀疏矩阵"></a>补充：稀疏矩阵</h5><p>在矩阵中，若数值为 0 的元素数目远远多于非 0 元素的数目，并且非 0 元素分布没有规律时，则称该矩阵为<strong>稀疏矩阵</strong>；与之相反，若非 0 元素数目占大多数时，则称该矩阵为<strong>稠密矩阵</strong>。定义非零元素的总数比上矩阵所有元素的总数为<strong>矩阵的稠密度</strong>。</p>
<p>稀疏矩阵算法的最大特点是通过只存储和处理非零元素从而大幅度降低存储空间需求以及计算复杂度，代价则是必须使用专门的稀疏矩阵压缩存储数据结构。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上介绍的只是一些数据预处理中的常用方法。实际上，还有许多根据不同场合选用的效果更好的处理方法。对于这些暂时没有机会使用的处理方法，限于个人水平和文章篇幅，就不一一详谈了。</p>
<p>在进行完数据预处理后，我们还需要选择和提取有意义的特征，将其作为输入来训练机器学习的算法和模型。之后还有选择模型、调整参数、评估、交叉验证等步骤，之后会继续整理这些方面的学习成果。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/30603579?group_id=908678758198726656" target="_blank" rel="external">Kaggle发布首份数据科学&amp;机器学习从业者现状调查</a></li>
<li><a href="https://www.zhihu.com/question/29316149/answer/110159647" target="_blank" rel="external">特征工程到底是什么？ - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29957294" target="_blank" rel="external">ML 入门：归一化、标准化和正则化</a></li>
<li>《Spark 机器学习》第三章：Spark 上数据的获取、处理与准备</li>
<li><a href="http://blog.csdn.net/big_talent/article/details/53887238" target="_blank" rel="external">关于特征工程入门中的一些基本知识（整理） - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为互联网上最著名的数据科学竞赛平台之一，Kaggle 无疑是数据从业者和爱好者最喜欢的社区之一。最近，Kaggle 发布了 &lt;a href=&quot;https://www.kaggle.com/amberthomas/kaggle-2017-survey-results&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2017 用户调查报告&lt;/a&gt;，共有 16000 余名用户参与的这份调查可以让我们对数据工作者的各类信息有一个了解。&lt;/p&gt;
&lt;p&gt;其中，对于“工作中遇到的障碍主要是什么？”这个问题，有 49.4% 的被调查者选择了“脏数据（dirty data）”这一项，占该问题所有选项的第一位。也就是说，数据科学家一般最常见的困扰就是要对手头的数据进行大量的预处理工程。&lt;/p&gt;
&lt;p&gt;在业界有一句广泛流传的话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。从这句话可以看出，数据的好坏对于机器学习模型的最终效果有着极大的影响。&lt;/p&gt;
&lt;p&gt;然而，现实世界中数据大体上都是不完整、不一致、含噪声的脏数据，无法直接使用，或结果差强人意。为了提高数据的质量，数据预处理技术应运而生。实际上，在一个基于机器学习模型的实际应用中，对于数据的预处理工作所需的时间和精力可能远大于模型和算法的选择和应用。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习笔记" scheme="http://kyonhuang.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据预处理" scheme="http://kyonhuang.top/tags/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="特征工程" scheme="http://kyonhuang.top/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据分析" scheme="http://kyonhuang.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>虎山行</title>
    <link href="http://kyonhuang.top/escorts-over-tiger-hill/"/>
    <id>http://kyonhuang.top/escorts-over-tiger-hill/</id>
    <published>2017-10-22T03:43:24.000Z</published>
    <updated>2017-12-19T11:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>更新</strong>：10 月 26 日我跟朱老师进行了一次时间较长的近期学习成果展示，并且对于接下来的学习方向聊了一会。结合花旗杯进入决赛的事情，将此文做一次更新。</p>
<hr>
<p>这段时间博客更得不勤，因为实在太忙。解释器构造、系统级程序设计、Spark、公选课作业、算法、英语、大创…每天睁开眼睛就想起这么多学习任务，让人不免感觉身在虎山，危机四伏，战战兢兢。</p>
<p>只有在这种强度的学习压力下，才会发现自己的很多问题，其中最致命的就是自己的学习效率太低了，很难集中注意力去解决手头即时的任务。快速学习和解决问题的能力是程序员必备之一，我在这方面可以说不及格。再就是还有惰性心理，浮躁，不能保持健康的作息，以至于高效学习的时间不足。</p>
<p>同时，每天忙碌的同时也会胡思乱想：我真的适合读研吗？自己学习前端知识的时候还是比较开心的，和现在学习 Spark 的态度可能还是有一些差别，并且也在要不要向机器学习方向深入学习而犹豫。读研以后，不是说完全不可能，但是基本上以后就不会从事前端领域的工作了。确定喜欢的领域和确定喜欢的人一样，难以割舍的感觉似有若无。但是对我来说，父母和老师都给了很大的期望，自己也没有做好找工作的准备，争取保研是箭在弦上，不得不发。我能做的，只有将弦拉的更满，箭一发便是千钧之力，穿越更高的云霄。</p>
<p>现在确实有些迷茫，每天过的感觉不到自己有实打实的进步。希望狮子座的天性能够帮助我顺利度过这段大学最忙碌也最缥缈的时期。</p>
<h2 id="定期任务"><a href="#定期任务" class="headerlink" title="定期任务"></a>定期任务</h2><h3 id="每天"><a href="#每天" class="headerlink" title="每天"></a>每天</h3><ul>
<li>一道 LeetCode</li>
<li>六级单词</li>
</ul>
<h3 id="每周"><a href="#每周" class="headerlink" title="每周"></a>每周</h3><ul>
<li>《算法》一节</li>
<li>Coursera 华盛顿大学《机器学习基础：案例研究》课程一节（尽早刷完这个）[已完成]</li>
<li>六级练习题若干（有时间可以做一整套题）</li>
<li>一篇会议论文阅读（abstract 和 introduction）［按照标准认真读，做一些简短的笔记］</li>
<li>12 月后<a href="http://wdxtub.com/2016/04/16/thin-csapp-0/" target="_blank" rel="external">读薄 CSAPP 系列</a>每周两篇</li>
</ul>
<h2 id="学期计划"><a href="#学期计划" class="headerlink" title="学期计划"></a>学期计划</h2><p>给这个最重要的学期列一个总体的学期计划。</p>
<h3 id="课业"><a href="#课业" class="headerlink" title="课业"></a>课业</h3><p><strong>三门必修课</strong>，解释器构造实验以及系统级程序设计的理论和实验课，<strong>必须满绩</strong>。</p>
<h3 id="花旗"><a href="#花旗" class="headerlink" title="花旗"></a>花旗</h3><p>一个月的时间，逼自己尽全力去争取最好的结果。</p>
<h3 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h3><p>积极完成朱老师布置的任务，并且和他交流。也要关心组里其他同学的工作。</p>
<p>朱老师建议我先学习机器学习的应用。根据这个建议，我把对吴恩达的《机器学习》课程的学习计划暂时改为华盛顿大学《机器学习基础：案例研究》课程的学习。这门课更偏重实际应用，也可以避免我绕到数学内容里。</p>
<h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>阅读朱老师推荐的会议，积累感觉找方向。多和朱老师交流心得。</p>
<p>每周抽时间细看一篇，也算是练习英语阅读。重点读 abstract 和 introduction。可以参考 <a href="https://zhuanlan.zhihu.com/p/29568504" target="_blank" rel="external">[Paper Reading] Efficient Estimation of Word Representations in Vector Space</a> 的格式来做笔记。为了督促自己，可以考虑申请一个新的知乎专栏或者在 PaperWeekly 做笔记。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>每天一道 LeetCode 加上自己控制页数的《算法》阅读。下学期可以做九度 OJ 和北大 OJ 练手。</p>
<h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>不要放弃六级，老师们都很看重英语能力。每天还是要抽时间背背单词，有时间练习一下听力、翻译、阅读、作文等。<strong>题目重在整理，而非数量。</strong></p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>有时间自己做一些开源小项目。没时间就算了，还是以自己参与度较高的科研项目为重。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>暂时考虑按照以下路径，这个学习肯定搞不定，但是要自己把握进度：</p>
<ol>
<li>学完 Coursera 华盛顿大学《机器学习基础：案例研究》课程并完成所有作业</li>
<li>通过《利用Python进行数据分析》的阅读学习，掌握 sklearn、numpy、pandas、matplotlib 的使用</li>
<li>吴恩达《机器学习》课程：绕不开的必修课</li>
<li>建立大局观的书籍：中文：周志华老师的西瓜书《机器学习》和李航老师的《统计学习方法》；英文：《Patten Recognition and Machine Learning》，《Elements of Statistical Learning》</li>
<li>kaggle、阿里巴巴天池实战</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>组队参加美赛。抽时间了解一下赛事信息和要求。有时间点一些技能点。</li>
<li>可以考虑申请软件著作权（当然要有比较好的项目）。</li>
<li>坚持把日记给记好。</li>
</ul>
<p>忙乱时方显修为，管理好自己的时间，专心于自己的事业。自己能走多远，很大程度上取决于这个学期。</p>
<blockquote>
<p>那就继续人间游 虽说不太平<br>明知山有虎 偏向虎山行</p>
<p>—  GAI / 艾福杰尼 / Kungfu-Pen 《虎山行》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：10 月 26 日我跟朱老师进行了一次时间较长的近期学习成果展示，并且对于接下来的学习方向聊了一会。结合花旗杯进入决赛的事情，将此文做一次更新。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这段时间博客更得不勤，因为实在太忙。解释器构造、系统级程序设计、
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>理清 Spark 2.2 的概念－RDD、Dataset、MLlib</title>
    <link href="http://kyonhuang.top/spark2.2-with-old-conceptions/"/>
    <id>http://kyonhuang.top/spark2.2-with-old-conceptions/</id>
    <published>2017-10-05T02:43:16.000Z</published>
    <updated>2017-10-05T05:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据实验室的要求，现在在啃《Spark 机器学习》。这本书和市面上大多数 Spark 书籍一样，全都基于 Spark 1.x。在 Spark 版本已经升到 2.2 的今天，敲这本书上的代码可以说是遍地是坑了，很多东西都已经变更，而且很难找到正确的解决方案，弄的我很是烦躁。</p>
<p>没办法，问题要一点一点解决。我决定先从理清《Spark 机器学习》提到的某些 Spark 2.2 提供的概念、模块和配合工具下手，主要关心一下几点：</p>
<ol>
<li>RDD 是什么？在升级到 Spark2.2+ 后有什么改动？</li>
<li>Dataset 是什么？DataFrame 又是什么？</li>
<li>MLlib 是什么？在升级到 Spark2.2+ 后有没有变动？如何使用？</li>
<li>IPython 是什么？如何配合 Spark2.2+ 使用？</li>
</ol>
<a id="more"></a>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Apache Spark 是一个快速的, 多用途的集群计算系统。 它提供了 Java, Scala, Python 和 R 的高级 API，以及一个支持通用的执行图计算的优化过的引擎. 它还支持一组丰富的高级工具, 包括使用 SQL 处理结构化数据处理的 Spark SQL, 用于机器学习的 MLlib, 用于图形处理的 GraphX, 以及 Spark Streaming。</p>
<h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RDD（Resilien Distributed Dataset，弹性分布式数据集）是 Spark 的核心概念之一。一个 RDD 代表一系列的“记录”（严格来说是某种类型的对象）。这些记录被分配或分区到一个集群的多个节点上（在本地模式下，可以类似地理解为单个进程里的多个线程上）。</p>
<p>Spark 中的 RDD 具备容错性，即当某个节点或任务失败时（非用户代码错误引起，如硬件故障、网络连接失败等），RDD 会在余下的节点上自动重建，以便任务最终能够完成。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>RDD 可以从一个驱动程序中已存在的 Scala 集合创建，也可以基于 Hadoop 的输入源（任何其他 Hadoop 支持的文件系统）创建，以及通过转换（transforming）来创建。</p>
<p>RDD 支持两种类型的操作：<strong>转换（transformation）</strong>和<strong>执行（action）</strong>。一般来说，转换操作是对一个数据集里的所有记录执行某种函数，从而使记录发生改变；而执行通常是运行某些计算或聚合操作，并将结果返回给驱动程序。</p>
<p>值得注意的是，Spark 中的<strong>转换操作是懒加载的</strong>（lazy），即在 RDD 上调用一个转换操作不会立即触发相应的计算，而是会将转换操作链接起来，并在执行操作被调用时才被高效计算。</p>
<p>调用一个 RDD 的<code>cache</code>（或<code>persist</code>）函数将会告诉 Spark 将这个 RDD 缓存在集群的内存中，以加快下一次访问数据集的速度。</p>
<p>更多 RDD 功能及实际编程方法可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/rdd-programming-guide.html" target="_blank" rel="external">Spark 编程指南 - Spark 2.2.0 中文文档 - ApacheCN</a>里的相关部分。</p>
<h3 id="升级变动"><a href="#升级变动" class="headerlink" title="升级变动"></a>升级变动</h3><p>在 Spark 2.0 之前，Spark 的主要编程接口是 RDD。而在 Spark 2.0 之后，RDD 被 Dataset（数据集）替换。</p>
<p>Dataset 很像 RDD，也是强类型的，并能够使用强大的 lambda 函数。但 Dataset 在引擎盖（hood）有更好的优化，因此性能要更优于 RDD。RDD 接口仍然受支持，但是建议切换使用 Dataset。</p>
<h2 id="Dataset-和-DataFrame"><a href="#Dataset-和-DataFrame" class="headerlink" title="Dataset 和 DataFrame"></a>Dataset 和 DataFrame</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>Dataset 是一个分布式的数据集合。一个 Dataset 可以从 JVM 对象来构造并使用转换功能。Dataset API 在 Scala 和 Java 是可用的，遗憾的是，Python 暂不支持 Dataset API。但是由于 Python 的动态特性, 许多 Dataset API 的优点已经可用了。</p>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>一个 DataFrame 是一个 Dataset 组成的指定列。它的概念与一个关系型数据库中的表或者在 R/Python 中的数据帧（data frame）是相等的，但优化得更好。</p>
<p>DataFrames 可以从结构化的文本文件、Hive中的表、外部数据库，或者已经存在的 RDD 构造而来。DataFrame API 可以在 Scala、Java、Python 和 R 中实现。在 Scala 和 Java 中，一个 DataFrame 所代表的是一个多行的 Dataset。</p>
<p>更多相关信息可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/sql-programming-guide.html" target="_blank" rel="external">Spark SQL and DataFrames - Spark 2.2.0 中文文档 - ApacheCN</a>。</p>
<h2 id="MLlib"><a href="#MLlib" class="headerlink" title="MLlib"></a>MLlib</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>MLlib 是 Spark 的机器学习库。其目标是使实用的机器学习具有可扩展性并且变得容易。在较高的水平上，它提供了以下工具：</p>
<ul>
<li>ML Algorithms（ML 算法）：常用的学习算法，如分类，回归，聚类和协同过滤；</li>
<li>Featurization（特征）：特征提取，变换，降维和选择；</li>
<li>Pipelines（管道）：用于构建，评估和调整 ML Pipelines 的工具；</li>
<li>Persistence（持久性）：保存和加载算法，模型和 Pipelines；</li>
<li>Utilities（实用）：线性代数，统计学，数据处理等。</li>
</ul>
<h3 id="升级变动-1"><a href="#升级变动-1" class="headerlink" title="升级变动"></a>升级变动</h3><p>MLlib 包括基于 RDD 的 API 和基于 DataFrame 的 API。从 Spark 2.0 开始，基于 RDD 的 API 处于维护模式，这意味着这些 API 仍然被支持且会修复 bug，但不会再添加新功能。在基于 DataFrame 的 API 能够开发到相同功能时，基于 RDD 的 API 将被弃用，并预计在 Spark 3.0 中删除。</p>
<p>更多相关信息可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/ml-guide.html" target="_blank" rel="external">MLlib: 主要指南 - Spark 2.2.0 中文文档 - ApacheCN</a>。</p>
<h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>书中的 3.2 节开始也涉及到 IPython 的使用，并且在实际使用中也有一些坑。因此也需要了解一下。</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>IPython 是一个 Python 的高级交互式 shell，基于 BSD 开源，比默认的 Python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，并且内置了许多很有用的功能和函数。IPython 内置的 pylab 包括用于数值计算的 NumPy 和 SciPy，以及用于交互式绘图和可视化的 matplotlib。</p>
<h3 id="升级变动-2"><a href="#升级变动-2" class="headerlink" title="升级变动"></a>升级变动</h3><p>书中想在启动 PySpark 终端时使用 IPython 而非标准的 Python shell。启动时也可以向 IPython 传入其他参数，包括让它启动时也启动 pylab 功能。</p>
<p>但是实际操作时，在 Spark 主目录下输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IPYTHON=1 IPYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark</div></pre></td></tr></table></figure>
<p>会报错，提示信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error in pyspark startup:</div><div class="line">IPYTHON and IPYTHON_OPTS are removed in Spark 2.0+. Remove these from the environment and set PYSPARK_DRIVER_PYTHON and PYSPARK_DRIVER_PYTHON_OPTS instead.</div></pre></td></tr></table></figure>
<p><strong>解决方法：</strong></p>
<p>把输入命令变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark</div></pre></td></tr></table></figure>
<p>如果要使用 IPython 提供的 Notebook 应用，<br>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&apos;notebook&apos; ./bin/pyspark</div></pre></td></tr></table></figure>
<p>参考资料：<a href="https://stackoverflow.com/questions/42658694/starting-ipython-with-spark-2" target="_blank" rel="external">Starting Ipython with Spark 2 - Stack Overflow</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Spark 机器学习》</li>
<li><a href="http://spark.apachecn.org/docs/cn/2.2.0/" target="_blank" rel="external">概述 - Spark 2.2.0 中文文档 - ApacheCN</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据实验室的要求，现在在啃《Spark 机器学习》。这本书和市面上大多数 Spark 书籍一样，全都基于 Spark 1.x。在 Spark 版本已经升到 2.2 的今天，敲这本书上的代码可以说是遍地是坑了，很多东西都已经变更，而且很难找到正确的解决方案，弄的我很是烦躁。&lt;/p&gt;
&lt;p&gt;没办法，问题要一点一点解决。我决定先从理清《Spark 机器学习》提到的某些 Spark 2.2 提供的概念、模块和配合工具下手，主要关心一下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RDD 是什么？在升级到 Spark2.2+ 后有什么改动？&lt;/li&gt;
&lt;li&gt;Dataset 是什么？DataFrame 又是什么？&lt;/li&gt;
&lt;li&gt;MLlib 是什么？在升级到 Spark2.2+ 后有没有变动？如何使用？&lt;/li&gt;
&lt;li&gt;IPython 是什么？如何配合 Spark2.2+ 使用？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Spark 学习笔记" scheme="http://kyonhuang.top/categories/Spark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Spark" scheme="http://kyonhuang.top/tags/Spark/"/>
    
      <category term="RDD" scheme="http://kyonhuang.top/tags/RDD/"/>
    
      <category term="Dataset" scheme="http://kyonhuang.top/tags/Dataset/"/>
    
      <category term="MLlib" scheme="http://kyonhuang.top/tags/MLlib/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR v4 学习笔记（三）－特性拾遗</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-3/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-3/</id>
    <published>2017-09-25T13:12:26.000Z</published>
    <updated>2017-09-25T11:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习解释器构造和 ANTLR。在系列博文的上一篇 <a href="http://kyonhuang.top/ANTLR-learning-notes-2/">ANTLR v4 学习笔记（二）－实现变种计算器</a>，我们用 ANTLR 实现了一个变种计算器，从而对 ANTLR 语法、访问器（Visitor）机制、集成以及 ANLTR 的错误处理机制有了更深的理解。</p>
<p>上篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但没有覆盖整个 Chapter 4 的所有内容。因此这篇博文将介绍一下 Chapter 4 的剩余内容——监听器（Listener）机制、代码片段嵌入语法，以及词法分析的一些很棒的特性。</p>
<a id="more"></a>
<h2 id="监听器机制"><a href="#监听器机制" class="headerlink" title="监听器机制"></a>监听器机制</h2><p>监听器机制和访问器机制有着很多共通的特点，我们也需要通过监听语法分析树遍历器触发的“事件”来完成某些工作。它们之间最大的区别在于，监听器的方法会被 ANTLR 提供的遍历器对象自动调用，而在访问器的方法中，必须显式调用<code>visit</code>方法来访问子节点，否则对应的子树将不会被访问。</p>
<p>ANTLR 会自动生成一个接口 xxListener，它定义了 ANTLR 的运行库中的 ParseTreeWalker 类在遍历语法分析树时能够触发的全部方法。当然，和访问器机制一样，我们无需实现接口中的全部方法。ANTLR 自动生成一个名为 xxBaseListener 的类，我们可以继承这个类并只重写那些我们感兴趣的方法。</p>
<h2 id="代码片段嵌入语法"><a href="#代码片段嵌入语法" class="headerlink" title="代码片段嵌入语法"></a>代码片段嵌入语法</h2><p>监听器机制和访问器一样，能够使语法分析过程和应用程序本身保持低耦合，也让语法更具有可读性。但有时候，为了满足比较苛刻的需求，我们需要将代码片段（动作）嵌入到语法中，这些动作会被拷贝到 ANTLR 自动生成的递归下降语法分析器的代码中。</p>
<h3 id="将任意动作嵌入语法"><a href="#将任意动作嵌入语法" class="headerlink" title="将任意动作嵌入语法"></a>将任意动作嵌入语法</h3><p>拿下面这一份用于解析类表格文件的语法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">grammar Rows;</div><div class="line"></div><div class="line"><span class="meta">@parser</span>::members &#123;  <span class="comment">// 在生成的 RowsParser 中添加一些成员</span></div><div class="line">    <span class="keyword">int</span> col;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RowsParser</span><span class="params">(TokenStream input, <span class="keyword">int</span> col)</span> </span>&#123;  <span class="comment">// 自定义的构造器</span></div><div class="line">      <span class="keyword">this</span>(input);</div><div class="line">      <span class="keyword">this</span>.col = col;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">file: (row NL)+ ;</div><div class="line"></div><div class="line">row</div><div class="line">locals [<span class="keyword">int</span> i=<span class="number">0</span>]</div><div class="line">    : (   STUFF</div><div class="line">          &#123;</div><div class="line">          $i++;</div><div class="line">          <span class="keyword">if</span> ($i == col) System.out.println($STUFF.text);</div><div class="line">          &#125;</div><div class="line">      )+</div><div class="line">    ;</div><div class="line"></div><div class="line">TAB   : <span class="string">'\t'</span> -&gt; skip ;    <span class="comment">// 匹配但是不将其传递给语法分析器</span></div><div class="line">NL    : <span class="string">'\r'</span>? <span class="string">'\n'</span> ;      <span class="comment">// 匹配并将其传递给语法分析器</span></div><div class="line">STUFF : ~[\t\r\n]+ ;      <span class="comment">// 匹配除 tab 符和换行符之外的任何字符</span></div></pre></td></tr></table></figure>
<p><code>@parser::members</code>表示在生成的 RowsParser 中添加一些成员，即大括号里的所有元素（包括）会原封不动的添加到 RowsParser 类中。我们通过加入的构造器来传入希望提取的列号。</p>
<p>row 规则的<code>(...)+</code>循环放置了一些动作，访问了之前使用 locals 子句定义的局部变量<code>$i</code>。同时 row 规则也使用了<code>$STUFF.text</code>来获得刚刚匹配的 STUFF 词法符号中包含的文本。关于动作的更多内容会在 Chapter 10 深入研究。</p>
<h3 id="用语义判定改变语法分析过程"><a href="#用语义判定改变语法分析过程" class="headerlink" title="用语义判定改变语法分析过程"></a>用语义判定改变语法分析过程</h3><p>用一个读取一列整数的语法作为例子。首先看一下需求：输入的其中的一部分整数指定了接下来的多少个整数分为一组。例如输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2 8 43 3 1 4 6</div></pre></td></tr></table></figure>
<p>第一个数字 2 表示匹配接下来的两个数字 8 和 43，数字 3 表示匹配接下来的三个数字。</p>
<p>语法文件如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">grammar Data;</div><div class="line"></div><div class="line">file : group+ ;</div><div class="line"></div><div class="line">group: INT sequence[$INT.<span class="keyword">int</span>] ;</div><div class="line"></div><div class="line">sequence[<span class="keyword">int</span> n]</div><div class="line">locals [<span class="keyword">int</span> i = <span class="number">1</span>;]</div><div class="line">     : ( &#123;$i&lt;=$n&#125;? INT &#123;$i++;&#125; )*  <span class="comment">// 匹配 n 个整数</span></div><div class="line">     ;</div><div class="line"></div><div class="line">INT :   [<span class="number">0</span>-<span class="number">9</span>]+ ;     <span class="comment">// 匹配整数</span></div><div class="line">WS  :   [ \t\n\r]+ -&gt; skip ;   <span class="comment">// 丢弃所有的空白字符</span></div></pre></td></tr></table></figure>
<p>Data 语法的关键在于<code>{$i&lt;=$n}?</code>，这段动作的值是布尔类型的，它被称为一个语义判定。在匹配到 n 个输入整数之前，它的值保持为 true，其中 n 是 sequence 语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 时，<code>(...)*</code>循环终止，从 sequence 规则返回。</p>
<h2 id="词法分析特性"><a href="#词法分析特性" class="headerlink" title="词法分析特性"></a>词法分析特性</h2><p>ANTLR 有三个与词法符号有关非常棒的特性。</p>
<h3 id="孤岛语法：处理同一文件中的不同格式"><a href="#孤岛语法：处理同一文件中的不同格式" class="headerlink" title="孤岛语法：处理同一文件中的不同格式"></a>孤岛语法：处理同一文件中的不同格式</h3><p>有很多常见的文件格式包含了多重语言，例如 Java 文件中有注释和 Java 代码，ejs 等模板引擎有模板语言表达式和文本。不同格式的语言需要按照不同的方式进行处理，这样的现象被称为<strong>“孤岛语法”</strong>。</p>
<p>ANTLR 提供了一个名为<strong>词法分析模式（lexical modes）</strong>的词法分析器特性，帮助我们方便地处理混合了不同格式数据的文件。它的基本思想是，当遇到特殊的“哨兵”字符序列时，执行不同模式的切换。</p>
<p>我们不妨以 XML 作为例子。一个 XML 解析器会将除标签和实体转义（例如<code>&amp;pound;</code>）之外的内容全部当作普通文本。当看到<code>&lt;</code>时，词法分析器会切换到 “INSIDE” 模式；当看到<code>&gt;</code>或者<code>/&gt;</code>时，它就切换回默认模式。</p>
<p>下面的语法展示了 XML 解析器的工作方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Define a lexer grammar called XMLLexer</div><div class="line"> */</div><div class="line">lexer grammar XMLLexer;</div><div class="line"></div><div class="line"><span class="comment">// 默认模式：所有在标签之外的东西</span></div><div class="line">OPEN        : <span class="string">'&lt;'</span>                 -&gt; pushMode(INSIDE) ;</div><div class="line">COMMENT     : <span class="string">'&lt;!--'</span> .*? <span class="string">'--&gt;'</span>    -&gt; skip ;</div><div class="line">EntityRef   : <span class="string">'&amp;'</span> [a-z]+ <span class="string">';'</span> ;</div><div class="line">TEXT        : ~(<span class="string">'&lt;'</span>|<span class="string">'&amp;'</span>)+ ;           <span class="comment">// 匹配任意除 &lt; 和 &amp; 之外的 16 位字符</span></div><div class="line"></div><div class="line"><span class="comment">// ----------------------    所有在标签之内的东西    ----------------------</span></div><div class="line">mode INSIDE;</div><div class="line">CLOSE       : <span class="string">'&gt;'</span>                 -&gt; popMode ;  <span class="comment">// 回到默认模式</span></div><div class="line">SLASH_CLOSE : <span class="string">'/&gt;'</span>                -&gt; popMode ;</div><div class="line">EQUALS      : <span class="string">'='</span> ;</div><div class="line">STRING      : <span class="string">'"'</span> .*? <span class="string">'"'</span> ;</div><div class="line">SlashName   : <span class="string">'/'</span> Name ;</div><div class="line">Name        : ALPHA (ALPHA|DIGIT)* ;</div><div class="line">S           : [ \t\r\n]           -&gt; skip ;</div><div class="line"></div><div class="line">fragment</div><div class="line">ALPHA       : [a-zA-Z] ;</div><div class="line"></div><div class="line">fragment</div><div class="line">DIGIT       : [<span class="number">0</span>-<span class="number">9</span>] ;</div></pre></td></tr></table></figure>
<p>提供一份如下所示的样例输入文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tools</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tool</span> <span class="attr">name</span>=<span class="string">"ANTLR"</span>&gt;</span>A parser generator<span class="tag">&lt;/<span class="name">tool</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tools</span>&gt;</span></div></pre></td></tr></table></figure>
<p>测试步骤与结果如下所示：</p>
<p><img src="/images/antlr/note3/XMLLexer.jpg"></p>
<p>值得一提的是，在上述启动测试组件的命令行中，使用的参数是 XML tokens，在正常情况下，这里应该是一个语法名加一个起始规则名。如果需要令测试组件只运行词法分析器而不运行语法分析器，我们可以指定参数为语法名加上一个特殊的规则名<code>tokens</code>。</p>
<h3 id="重写输入流"><a href="#重写输入流" class="headerlink" title="重写输入流"></a>重写输入流</h3><p>我们可以通过 TokenStreamRewriter 对象对输入流进行修改，然后再加以输出，从而实现对源代码插桩或重构。例如，我们可以通过以下代码实现一个监听器，来给每个类定义中加上一行序列化版本标示符（serialVersionUID）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStream;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStreamRewriter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSerialIDListener</span> <span class="keyword">extends</span> <span class="title">JavaBaseListener</span> </span>&#123;</div><div class="line">    TokenStreamRewriter rewriter;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsertSerialIDListener</span><span class="params">(TokenStream tokens)</span> </span>&#123;</div><div class="line">        rewriter = <span class="keyword">new</span> TokenStreamRewriter(tokens);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterClassBody</span><span class="params">(JavaParser.ClassBodyContext ctx)</span> </span>&#123;</div><div class="line">        String field = <span class="string">"\n\tpublic static final long serialVersionUID = 1L;"</span>;</div><div class="line">        rewriter.insertAfter(ctx.start, field);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后，我们在 main 程序中初始化一个 InsertSerialIDListener，并当遍历结束时打印词法符号流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();  <span class="comment">// 新建一个标准的遍历器</span></div><div class="line">InsertSerialIDListener extractor = <span class="keyword">new</span> InsertSerialIDListener(tokens);</div><div class="line">walker.walk(extractor, tree);  <span class="comment">// 使用监听器初始化对语法分析树的遍历</span></div><div class="line"></div><div class="line"><span class="comment">// 打印出修改后的词法符号流</span></div><div class="line">System.out.println(extractor.rewriter.getText());</div></pre></td></tr></table></figure>
<p>注意，TokenStreamRewriter 实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。因此每次我们调用<code>getText()</code>的时候，rewriter 对象都会执行上述队列中的指令。</p>
<h3 id="将-Tokens-送入不同通道"><a href="#将-Tokens-送入不同通道" class="headerlink" title="将 Tokens 送入不同通道"></a>将 Tokens 送入不同通道</h3><p>语法分析器只处理一个通道，因此当我们想要忽略但保留某些 tokens 时（例如注释和空白字符），我们可以通过在语法文件书写特殊的指令，来将其送入其他通道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">COMMENT</div><div class="line">    :    <span class="string">'/*'</span> .*? <span class="string">'*/'</span>    -&gt; channel(HIDDEN)  <span class="comment">// 匹配 /* 和 */ 之间的任何东西</span></div><div class="line">    ;</div><div class="line">WS  :    [ \r\t\u000c\n]+ -&gt; channel(HIDDEN)</div><div class="line">    ;</div></pre></td></tr></table></figure>
<p><code>-&gt;channel(HIDDEN)</code>和<code>-&gt;skip</code>类似，也是一个词法分析器指令。在这里，它设置了这些 tokens 的通道号。这样，这些 tokens 就会被语法分析器忽略。token 流中仍然保存着这些原始的 tokens 序列，但在向语法分析器提供数据时忽略了那些处于已关闭通道的 tokens。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ANTLR 学习的第三篇笔记到这里就结束了。尽管这一篇笔记很短，但是涵盖了 ANTLR 实践中一些比较现实的问题的解决方式。之后，我们将进入 Part II，正式展开对使用 ANTLR 开发语言类应用程序的学习。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习解释器构造和 ANTLR。在系列博文的上一篇 &lt;a href=&quot;http://kyonhuang.top/ANTLR-learning-notes-2/&quot;&gt;ANTLR v4 学习笔记（二）－实现变种计算器&lt;/a&gt;，我们用 ANTLR 实现了一个变种计算器，从而对 ANTLR 语法、访问器（Visitor）机制、集成以及 ANLTR 的错误处理机制有了更深的理解。&lt;/p&gt;
&lt;p&gt;上篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但没有覆盖整个 Chapter 4 的所有内容。因此这篇博文将介绍一下 Chapter 4 的剩余内容——监听器（Listener）机制、代码片段嵌入语法，以及词法分析的一些很棒的特性。&lt;/p&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR v4 学习笔记（二）－实现变种计算器</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-2/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-2/</id>
    <published>2017-09-21T11:25:56.000Z</published>
    <updated>2017-09-23T02:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习解释器构造和 ANTLR。在系列博文的上一篇 <a href="http://kyonhuang.top/ANTLR-learning-notes-1/">ANTLR v4 学习笔记（一）－ANTLR 初体验</a>，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。</p>
<p>我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。</p>
<p>这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。</p>
<a id="more"></a>
<h2 id="计算器描述"><a href="#计算器描述" class="headerlink" title="计算器描述"></a>计算器描述</h2><p>计算器接受四则运算表达式为输入（如下所示）。如果表达式语法正确，则输出计算结果，否则报错，指出错误位置及原因。</p>
<p>例子1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input <span class="number">1</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-a/<span class="number">2</span>;    print(b);    print(a);Output <span class="number">1</span>:    <span class="number">5246.04</span>    <span class="number">3497.36</span></div></pre></td></tr></table></figure>
<p>例子2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input <span class="number">2</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-c/<span class="number">2</span>;    print(b);Output <span class="number">2</span>:    Error(line <span class="number">2</span>,position <span class="number">6</span>): undefined identifier.</div></pre></td></tr></table></figure>
<p>以上两个示例包含了这个计算器的全部特性：</p>
<ol>
<li>每个语句需要以“<code>;</code>”结束；</li>
<li>涉及的操作符只要求加减乘除；支持括号；</li>
<li>操作数为整数或浮点数；</li>
<li>变量不需要先声明，可直接赋值，它的类型由右边表达式的类型决定；每个变量在使用之前必须要已经有赋值；</li>
<li>变量名可以是由数字和字母组成，但首字符必须是字母； </li>
<li>输出语句使用<code>print()</code>函数，输出并换行；</li>
<li><code>print()</code>函数不仅可以输出变量，还可以直接输出表达式的值，例如<code>print(1+2)</code>；</li>
<li>尽量考虑周全，顾及corner cases。例如除零；</li>
<li>程序不需要 GUI，接受一个源文件路径为命令行参数。</li>
</ol>
<h2 id="匹配运算表达式的语法"><a href="#匹配运算表达式的语法" class="headerlink" title="匹配运算表达式的语法"></a>匹配运算表达式的语法</h2><p>在经过之前的学习后，我们可以比较轻松地写出一份匹配运算表达式的 ANTLR 语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a grammar called Calculator</div><div class="line"> */</div><div class="line">grammar Calculator;</div><div class="line">// 程序起始规则，语法分析的起点</div><div class="line">program : stat+;</div><div class="line"></div><div class="line">stat: define NEWLINE?            # defineStat</div><div class="line">    | print NEWLINE?             # printStat</div><div class="line">    | NEWLINE                    # blank</div><div class="line">    ;</div><div class="line">// 声明</div><div class="line">define: VAR '=' expr ';';</div><div class="line">// 计算表达式</div><div class="line">expr: expr op=('*'|'/') expr     # MulDiv </div><div class="line">     | expr op=('+'|'-') expr    # AddSub</div><div class="line">     | '('expr')'                # parens</div><div class="line">     | NUMBER                    # number</div><div class="line">     | VAR                       # var</div><div class="line">     ;</div><div class="line"></div><div class="line">// 输出</div><div class="line">print: 'print''('VAR')'';'       # printVAR</div><div class="line">      | 'print''('expr')'';'     # printExpr </div><div class="line">      ;</div><div class="line">// 操作数类别</div><div class="line">NUMBER: INT|FLOAT;</div><div class="line">VAR : [a-zA-Z][a-zA-Z0-9]*;</div><div class="line">INT : [0-9]+;</div><div class="line">FLOAT : [0-9]+'.'[0-9]+;</div><div class="line">NEWLINE: '\r'? '\n'? ;</div><div class="line">WS : [ \t]+ -&gt; skip;</div><div class="line">MUL : '*' ;  </div><div class="line">DIV : '/' ;  </div><div class="line">ADD : '+' ;  </div><div class="line">SUB : '-' ;</div></pre></td></tr></table></figure>
<p>这份语法有一些值得注意的地方：</p>
<ul>
<li>语法分析器的规则以小写字母开头；</li>
<li>词法分析器的规则以大写字母开头；</li>
<li>我们使用<code>|</code>来分隔同一个语言规则的若干备选分支，并使用圆括号把一些符号组合成子规则；</li>
<li>WS 词法规则中，<code>-&gt; skip</code>是一条指令，告诉词法分析器匹配并丢弃空白字符；</li>
<li>你也许会注意到一些<code>#</code>开头的标签。如果备选分支上没有标签，ANTLR 就只为每条规则生成一个方法；</li>
<li>我们为运算符等词法符号定义了一些名字，这样，在之后访问器的编写中，我们可以将这些词法符号的名字当作常量使用，使代码更加清晰。</li>
</ul>
<p>现在我们已经可以通过 ANTLR 内置的测试组件来进行测试。由于 Eclipse 的最新版本 ANTLR 插件里的 ANTLR 版本仍然是 4.4（官网的 ANTLR 包已到 4.7 版本），所以我们还是自己通过命令行生成 java 文件并编译：</p>
<p><img src="/images/antlr/note2/cal1.jpg"></p>
<p>添加的<code>-gui</code>参数使我们可以看到关于输入的语法分析树：</p>
<p><img src="/images/antlr/note2/caltree.jpg"></p>
<p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复。例如，我们的输入少一个<code>;</code>，语法分析器会自动输出错误信息：</p>
<p><img src="/images/antlr/note2/cal1-error.jpg"></p>
<p>添加<code>-gui</code>参数生成的可视化语法分析树会将错误节点自动标红：</p>
<p><img src="/images/antlr/note2/caltree-error.jpg"></p>
<h3 id="语法优化"><a href="#语法优化" class="headerlink" title="语法优化"></a>语法优化</h3><p>这里的“优化”不是指对语法本身，而是对 ANTLR 语法文件，即<code>.g4</code>作为扩展名的文件。ANTLR 允许我们将非常大的语法拆分为多个部分，根据习惯，我们将其分为语法分析器的语法和词法分析器的语法两部分。</p>
<p>这样做的好处是对于两种词法规则或者语法规则相同的语言，我们可以复用这些“模块”来构建语法分析器。</p>
<p>词法规则文件 CalculatorLexerRules.g4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意开头是 "lexer grammer"</span></div><div class="line">lexer grammar CalculatorLexerRules;</div><div class="line"></div><div class="line"><span class="comment">// 操作数类别</span></div><div class="line">NUMBER: INT|FLOAT;</div><div class="line">VAR : [a-zA-Z][a-zA-Z0-<span class="number">9</span>]*;</div><div class="line">INT : [<span class="number">0</span>-<span class="number">9</span>]+;</div><div class="line">FLOAT : [<span class="number">0</span>-<span class="number">9</span>]+<span class="string">'.'</span>[<span class="number">0</span>-<span class="number">9</span>]+;</div><div class="line">NEWLINE: <span class="string">'\r'</span>? <span class="string">'\n'</span>? ;</div><div class="line">WS : [ \t]+ -&gt; skip;</div><div class="line">MUL : <span class="string">'*'</span> ;  </div><div class="line">DIV : <span class="string">'/'</span> ;  </div><div class="line">ADD : <span class="string">'+'</span> ;  </div><div class="line">SUB : <span class="string">'-'</span> ;</div></pre></td></tr></table></figure>
<p>语法规则文件 CalculatorExpr.g4，之前语法中的词法规则全部通过 import 语句导入：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a grammar called CalculatorExpr</div><div class="line"> */</div><div class="line">// 注意 grammer 要和文件名相同</div><div class="line">grammar CalculatorExpr;</div><div class="line">// 引入词法规则</div><div class="line">import CalculatorLexerRules;</div><div class="line">// 程序起始规则，语法分析的起点</div><div class="line">program : stat+;</div><div class="line"></div><div class="line">stat: define NEWLINE?            # defineStat</div><div class="line">    | print NEWLINE?             # printStat</div><div class="line">    | NEWLINE                    # blank</div><div class="line">    ;</div><div class="line">// 声明</div><div class="line">define: VAR '=' expr ';';</div><div class="line">// 计算表达式</div><div class="line">expr: expr op=('*'|'/') expr     # MulDiv </div><div class="line">     | expr op=('+'|'-') expr    # AddSub</div><div class="line">     | '('expr')'                # parens</div><div class="line">     | NUMBER                    # number</div><div class="line">     | VAR                       # var</div><div class="line">     ;</div><div class="line"></div><div class="line">// 输出</div><div class="line">print: 'print''('VAR')'';'       # printVAR</div><div class="line">      | 'print''('expr')'';'     # printExpr </div><div class="line">      ;</div></pre></td></tr></table></figure>
<p>要生成 java 文件，我们只需要对语法文件使用<code>antlr4</code>命令即可。这样我们就得到了和之前一样的 java 文件（测试就不贴图了）：</p>
<p><img src="/images/antlr/note2/import-java.jpg"></p>
<p>import 语句赋予我们编写模块化语法的能力，这使得 ANTLR 语法文件的耦合度降低，复用性提高。</p>
<h2 id="使用-Visitor-构建计算器"><a href="#使用-Visitor-构建计算器" class="headerlink" title="使用 Visitor 构建计算器"></a>使用 Visitor 构建计算器</h2><p>我们最终的目的是将生成的语法分析器集成到程序中，因此我们需要写一些 Java 代码。我们会用 Visitor（访问者模式）来实现我们的变种计算器。</p>
<p>由于我的实现代码基于 Calculator.g4 生成的 java 文件，而非拆分后的 CalculatorExpr.g4，所以之后的文件名、类名和方法名还是会以 Calculator 开头。当然，所有功能都是相同的，使用哪份语法文件生成的 java 文件都不会有影响。</p>
<p>我们通过以下命令来让 ANTLR 生成 Visitor 而非 Listener：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antlr4 -no-listener -visitor -encoding UTF-8 Calculator.g4</div></pre></td></tr></table></figure>
<p>这样，ANTLR 会自动生成一个访问器接口文件 CalculatorVisitor.java，以及该访问器的一个默认实现类 CalculatorBaseVisitor。实现时，我们需要自己写一个 Visitor 的子类，继承<br>CalculatorBaseVisitor<float>（这样表达式的计算结果都是浮点数），并重写其中的方法，以实现变量键值对存储、计算、打印等需求。</float></p>
<p>以下是我们实现的 Visitor 子类 MainVisitor 的完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainVisitor</span> <span class="keyword">extends</span> <span class="title">CalculatorBaseVisitor</span>&lt;<span class="title">Float</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 声明一个 map，存放变量与值的键值对</span></div><div class="line">    Map&lt;String, Float&gt; memory = <span class="keyword">new</span> HashMap&lt;String, Float&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * define: VAR '=' expr ';';</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitDefine</span><span class="params">(CalculatorParser.DefineContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">float</span> value = visit(ctx.expr());</div><div class="line">        memory.put(var, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * expr op=('*'|'/') expr</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitMulDiv</span><span class="params">(CalculatorParser.MulDivContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</div><div class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.MUL)</div><div class="line">            <span class="keyword">return</span> left * right;</div><div class="line">        <span class="keyword">return</span> left / right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * expr op=('+'|'-') expr</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitAddSub</span><span class="params">(CalculatorParser.AddSubContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</div><div class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.ADD)</div><div class="line">            <span class="keyword">return</span> left + right;</div><div class="line">        <span class="keyword">return</span> left - right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * NUMBER</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitNumber</span><span class="params">(CalculatorParser.NumberContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Float.valueOf(ctx.NUMBER().getText());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * VAR</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitVar</span><span class="params">(CalculatorParser.VarContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">if</span> (memory.containsKey(var))</div><div class="line">            <span class="keyword">return</span> memory.get(var);</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>) <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * '('expr')'</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitParens</span><span class="params">(CalculatorParser.ParensContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> visit(ctx.expr());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * print: ('print''('VAR')'';');</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintVAR</span><span class="params">(CalculatorParser.PrintVARContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">if</span> (memory.containsKey(var))</div><div class="line">            System.out.println(memory.get(var));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            System.err.println(<span class="string">"undefined identifier"</span>);</div><div class="line">        <span class="keyword">return</span> visitChildren(ctx);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * print: ('print''('expr')'';');</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> </span>&#123;</div><div class="line">        System.out.println(visit(ctx.expr()));</div><div class="line">        <span class="keyword">return</span> visitChildren(ctx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我们需要写一个 Calculator.java 来新建所需要的所有对象，并针对 program 规则启动语法分析器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        </div><div class="line">        String inputFile = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Usage:\n\tjava -jar Calculator.jar [sourceFile]"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</div><div class="line">            inputFile = args[<span class="number">0</span>];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.err.println(<span class="string">"The file path cannot be recognized"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        InputStream instream = System.in;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(inputFile != <span class="keyword">null</span>)</div><div class="line">            instream = <span class="keyword">new</span> FileInputStream(inputFile);</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(instream);</div><div class="line">        <span class="comment">// 新建词法分析器对象</span></div><div class="line">        CalculatorLexer lexer = <span class="keyword">new</span> CalculatorLexer(input);</div><div class="line">        <span class="comment">// 新建词法符号流管道</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        <span class="comment">// 新建语法分析器对象</span></div><div class="line">        CalculatorParser parser = <span class="keyword">new</span> CalculatorParser(tokens);</div><div class="line">        <span class="comment">// 启动语法分析器，从 program 规则开始进行语法分析</span></div><div class="line">        ParseTree tree = parser.program();</div><div class="line">        </div><div class="line">        MainVisitor cal = <span class="keyword">new</span> MainVisitor();</div><div class="line">        </div><div class="line">        cal.visit(tree);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，现在我们的变种计算器就有了一个初步版本。打包成 jar 包后，我们可以看一下效果：</p>
<p><img src="/images/antlr/note2/Calculator-effect.jpg"></p>
<p>我觉得可以。</p>
<h2 id="继续完善"><a href="#继续完善" class="headerlink" title="继续完善"></a>继续完善</h2><p>那么这时候，一般就会有人跳出来说：“我觉得不行。我觉得很普通。”</p>
<p>其实我也是这么认为的（阿黄真的很严格！）。</p>
<p>实际上，我们这个计算器还有一些需要继续完善的地方。比如下面这种情况：</p>
<p><img src="/images/antlr/note2/exception.jpg"></p>
<p>可以看到并未赋值的变量 c 被当作 0。然而在我们的要求中，这样的变量应该当作未初始化，使用时要报错。另外，当被除数为 0 时，输出的结果会是 “Infinity”，而我们还是希望这种情况发生时会报错。以上情况说明<strong>我们定义的语法没有覆盖到所有设想中的错误</strong>。</p>
<p>另外，ANTLR 自带的错误报告采用以下的语句，基本算是直接输出了行号、错误信息等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.err.println(<span class="string">"line "</span> + line + <span class="string">":"</span> + charPositionInLine + <span class="string">" "</span> + msg);</div></pre></td></tr></table></figure>
<p>说实话，不是很显眼。我还是喜欢错误报告开头有一些比较明显的标示，比如<code>Error(line 2,position 6): undefined identifier</code>感觉就要好一些。</p>
<p>不幸的是，Chapter 4 尚未涉及到 ANTLR 的错误处理机制。这部分内容在 Chapter 9 Error Reporting and Recovery 中。为了不用麻烦糖糖先记着，我们不妨先对这部分内容进行一些学习。</p>
<h3 id="错误报告格式优化"><a href="#错误报告格式优化" class="headerlink" title="错误报告格式优化"></a>错误报告格式优化</h3><p>先从错误报告格式优化开始。ANTLR 的错误报告通过 ANTLRErrorListener 接口，由 ConsoleErrorListener 实现，输出信息比较简单。</p>
<p>ANTLRErrorListener 包含四个方法：<strong>syntaxError</strong>、reportAmbiguity、reportAttemptingFullContext、reportContextSensitivity。其中 syntaxError 顾名思义用于处理语法错误，而后三个用于二义性处理。</p>
<p>ANTLR 也内置了一些 ANTLRErrorListener 的实现。除开默认采用的 ConsoleErrorListener，还有一个空实现 <strong>BaseErrorListener</strong>。我们可以 new 一个 BaseErrorListener 来自定义一些错误的处理方法，然后通过 addErrorListener 把它添加到语法分析器上。</p>
<p>根据以上思路，我们可以在 Calculator.java 中新建语法分析器对象的语句后加上几行代码，用于移除 ANTLR 默认的错误处理，以及添加一个我们自定义的错误监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除默认的错误处理</span></div><div class="line">parser.removeErrorListeners();</div><div class="line"><span class="comment">// 添加自定义错误监听器</span></div><div class="line">parser.addErrorListener(<span class="keyword">new</span> BaseErrorListener() &#123;</div><div class="line">    <span class="comment">//出现语法错误</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syntaxError</span><span class="params">(Recognizer&lt;?, ?&gt; recognizer, Object offendingSymbol, <span class="keyword">int</span> line, <span class="keyword">int</span> charPositionInLine, String msg, RecognitionException e)</span> </span>&#123;</div><div class="line">        System.err.println(<span class="string">"Error(line "</span> + line + <span class="string">", position "</span> + charPositionInLine + <span class="string">"): "</span> + msg);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在的错误报告看起来就更加有条理了：</p>
<p><img src="/images/antlr/note2/newErrorReport.jpg"></p>
<h3 id="部分错误特例的处理方式"><a href="#部分错误特例的处理方式" class="headerlink" title="部分错误特例的处理方式"></a>部分错误特例的处理方式</h3><p>不幸的是，读完了 Chapter 9，我仍然没有找到关于调用未初始化变量、被除数为 0 时报错应该怎么写。<br>现在我的权宜之计是直接<code>System.err.println</code>，也就是跳过错误机制。由于上下文对象会记录根据规则识别词组时产生的所有信息，可以通过<code>ctx.start.getLine()</code>获得<code>ctx.start.getCharPositionInLine()</code>错误出现的行数和行内具体位置。</p>
<p><img src="/images/antlr/note2/undefined-error.jpg"></p>
<p>可以看到所显示的位置好像并不是特别准确，个人认为是 ctx 给出的位置会追溯到所在规则开始的地方。也许随着学习更加深入，我会找到比较优雅的实现方法。</p>
<h2 id="计算器运行截图"><a href="#计算器运行截图" class="headerlink" title="计算器运行截图"></a>计算器运行截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-952930bcab492aee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-891de540a356c539.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result2.jpg"></p>
<h2 id="计算器实现中遇到的问题"><a href="#计算器实现中遇到的问题" class="headerlink" title="计算器实现中遇到的问题"></a>计算器实现中遇到的问题</h2><p>实现这个变种计算器的过程当然也不是一帆风顺的，尤其我是先动手摸索再看的 Chapter 4。以下几个小坑可能还会有新司机踩上，特此写明：</p>
<ul>
<li>开始的语法写输出语句为<code>print: (&#39;print&#39;&#39;(&#39;VAR|expr&#39;)&#39;&#39;;&#39;);</code>没有在<code>VAR|expr</code>外加一层括号，导致后续开发匹配错误。当然，我认为现在开两个备选分支的写法应该更好。</li>
<li>第一次实现时，没有给备选分支加上标签，之后实现 Visitor 时很多方法就需要自己写 if 判断，十分麻烦。通过标签来对每种输入都获得一个不同的事件是坠吼的。</li>
<li>开始的语法写的是<code>WS : [ \t\r\n]+ -&gt; skip;</code>。后来测试时感觉直接跳过换行符好像有时对错误定位会有影响，于是改成现在的样子。</li>
</ul>
<h2 id="我对-ANTLR-的理解"><a href="#我对-ANTLR-的理解" class="headerlink" title="我对 ANTLR 的理解"></a>我对 ANTLR 的理解</h2><p>那么到现在为止，我已经使用 ANTLR 写了几个示例，并完成了一个小项目。经过实际体验，ANTLR 真的可以使我们开发语言类应用程序时，少做很多繁琐的工作。</p>
<p>只要输入一份合法的语法（当然用户需要自行保证语法的准确性），无论多复杂，ANTLR 的语法分析器都能够自动识别，并在运行时以<strong>动态方式</strong>对语法执行分析。相比静态分析必须考虑所有可行的输入序列，动态分析使得我们不必为了适应底层的语法分析策略而扭曲我们语法，从而省略了很多不必要的工作。这是 ANTLR 4 相比其他语法分析器的一个很大的优势。</p>
<p>举个例子，选择使用 ANTLR 进行编译相关的开发工作有一个重要的原因，是它能够自动处理直接左递归（间接左递归暂时不能够）。</p>
<p>我们知道，左递归指某个语言规则在某个备选分支的起始位置调用了自身。由于含有左递归的文法必然不是 LL(1) 文法，也就不可能使用确定的自顶向下分析法。然而，允许使用左递归的文法来表示语言规则又要简洁的多。ANTLR 可以将直接左递归规则自动重写为等价的非左递归形式，省却了不少麻烦。</p>
<p>此外，ANLTR 语法文件独立于程序。在生成的所需的语法分析器之后，我们只需要用熟悉的 Java 来实现我们所需要的语法分析树遍历器（重写部分方法），以符合我们的要求即可。不需要自己去写词法分析器、语法分析器，ANLTR 大大降低了语言类应用程序开发的门槛。</p>
<p>当然，无论工具有多方便，终究只能帮助人完成事务、减少工作量，而非完全替代。想要使用好 ANTLR，还是得对编译原理有透彻的理解。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ANTLR 学习的第二篇笔记到这里就结束了。在这之后我会继续学习解释器构造，阅读《The Definitive ANTLR 4 Reference》，并博客上持续记录学习过程中的一点心得。敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/yuexiang321/article/details/52770283" target="_blank" rel="external">antlr入门实例——计算器 - Yue Xiang - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习解释器构造和 ANTLR。在系列博文的上一篇 &lt;a href=&quot;http://kyonhuang.top/ANTLR-learning-notes-1/&quot;&gt;ANTLR v4 学习笔记（一）－ANTLR 初体验&lt;/a&gt;，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。&lt;/p&gt;
&lt;p&gt;我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。&lt;/p&gt;
&lt;p&gt;这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。&lt;/p&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>yuki-目录文档生成工具</title>
    <link href="http://kyonhuang.top/yuki-intro/"/>
    <id>http://kyonhuang.top/yuki-intro/</id>
    <published>2017-09-14T13:56:35.000Z</published>
    <updated>2017-09-14T15:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。<br>——沃兹基硕德</p>
</blockquote>
<p>受到掘金上看到的 <a href="https://github.com/kenshinji/yddict" target="_blank" rel="external">yddict：一个命令行查单词的工具</a> 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。</p>
<p>看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 <a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a>，蕴含了我个人满满的宅趣味。</p>
<p><img src="/images/yuki/Yuki.jpg"></p>
<p>幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。</p>
<p>这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。</p>
<a id="more"></a>
<h2 id="关于-yuki"><a href="#关于-yuki" class="headerlink" title="关于 yuki"></a>关于 yuki</h2><p>使用 Node.js 开发的项目目录管理工具，能够将项目内文件结构自动映射并生成为 README.md</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/yuki/master/example.gif"></p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">bighuang624/yuki</a></p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>当一份 README.md 的主体内容是项目目录，而你又厌倦了每次增加、修改、删除项目中文件时都要对 README 进行维护，那么不妨试试 yuki！</p>
<p>它可以在极短时间内帮你生成符合要求的 README.md 文档。你更可以通过配置一份 yuki.config.json 来满足你的以下需求：</p>
<ul>
<li>固定文档标题</li>
<li>目录前后增加固定内容</li>
<li>映射时忽略指定文件夹、文件、扩展名</li>
<li>根据指定扩展名选择是否去掉文件名的扩展名或加上书名号</li>
<li>让每个文件都带上 Github 的链接以方便在线跳转查看</li>
</ul>
<p>你可以用 yuki 帮助你轻松维护 github 上类似博客、笔记、代码汇总等项目！</p>
<h3 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h3><p>我的<a href="https://github.com/bighuang624/Algorithms-notes" target="_blank" rel="external">《算法》笔记及代码</a>项目的 README.md 完全通过 yuki 生成。你可以点击以查看效果。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>请确认你使用的电脑有 Node 环境，越新越好。</p>
<h4 id="安装-yuki"><a href="#安装-yuki" class="headerlink" title="安装 yuki"></a>安装 yuki</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g yuki</div></pre></td></tr></table></figure>
<h4 id="进入需要生成-README-md-的文件夹"><a href="#进入需要生成-README-md-的文件夹" class="headerlink" title="进入需要生成 README.md 的文件夹"></a>进入需要生成 README.md 的文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 请将 &lt;dirname&gt; 换为文件夹路径</span></div><div class="line"><span class="built_in">cd</span> &lt;dirname&gt;</div></pre></td></tr></table></figure>
<h4 id="创建-yuki-config-json（可选）"><a href="#创建-yuki-config-json（可选）" class="headerlink" title="创建 yuki.config.json（可选）"></a>创建 yuki.config.json（可选）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch yuki.config.json</div></pre></td></tr></table></figure>
<h4 id="配置-yuki-config-json（可选）"><a href="#配置-yuki-config-json（可选）" class="headerlink" title="配置 yuki.config.json（可选）"></a>配置 yuki.config.json（可选）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  // README.md的大标题（h1），默认为所在文件夹名</div><div class="line">  &quot;title&quot;: &quot;《算法（第4版）》笔记及代码&quot;,</div><div class="line">  // github库地址，如果配置了这项会给每个文件加上超链接</div><div class="line">  // 如果配置，请保证index填写无误，且所有文件名不含空格（否则链接无法正确表示）</div><div class="line">  // branch默认为master</div><div class="line">  &quot;repository&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;https://github.com/bighuang624/Algorithms-notes&quot;,</div><div class="line">    &quot;branch&quot;: &quot;master&quot;</div><div class="line">  &#125;,</div><div class="line">  // 目录开始的标题等级</div><div class="line">  // 默认为2，即该目录下的文件夹名等级从3开始，随层级深入递减</div><div class="line">  &quot;startLevel&quot;: 2,</div><div class="line">  // 需要忽略的目录、扩展名和文件，都以数组表示</div><div class="line">  &quot;ignore&quot;: &#123;</div><div class="line">    &quot;dir&quot;: [&quot;.git&quot;],</div><div class="line">    &quot;extname&quot;: [&quot;.json&quot;],</div><div class="line">    &quot;file&quot;: [</div><div class="line">      &quot;yuki.config.json&quot;,</div><div class="line">      &quot;.gitignore&quot;,</div><div class="line">      &quot;README.md&quot;,</div><div class="line">      &quot;.DS_Store&quot;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  // 根据扩展名选择对展示的文件名做一些处理</div><div class="line">  // 每个扩展名的配置需要单独一个对象</div><div class="line">  // 目前支持省略扩展名&quot;withoutExt&quot;: true</div><div class="line">  // 和加上书名号&quot;withBookmark&quot;: true</div><div class="line">  &quot;format&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;extname&quot;: &quot;.md&quot;,</div><div class="line">      &quot;withoutExt&quot;: true,</div><div class="line">      &quot;withBookmark&quot;: true</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  // 在大标题之后，目录之前添加的内容</div><div class="line">  // 每个对象可选择包含标题、标题等级和内容</div><div class="line">  // 其中，标题和标题等级需在一个对象中一同填写</div><div class="line">  &quot;prefix&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;content&quot;: &quot;[![作者](https:\//img.shields.io\/badge/%E4%BD%9C%E8%80%85-KyonHuang-7AD6FD.svg)](http:\//kyonhuang.top)&quot;</div><div class="line">    &#125;, &#123;</div><div class="line">      &quot;title&quot;: &quot;目录&quot;,</div><div class="line">      &quot;level&quot;: &quot;2&quot;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  // 在README.md末尾添加的内容</div><div class="line">  // 和prefix相同，每个对象可选择包含标题、标题等级和内容</div><div class="line">  &quot;append&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;title&quot;: &quot;维护&quot;,</div><div class="line">      &quot;level&quot;: &quot;2&quot;,</div><div class="line">      &quot;content&quot;: &quot;本文档由 [yuki](https://github.com/bighuang624/yuki) 维护&quot;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 JSON 标准中不含注释，请在使用时将注释去掉。项目中也提供一份不带注释、可供修改使用的 yuki.config.json 模版。</p>
<p>不需要的配置选项请全部删除。</p>
<h4 id="创建-README-md"><a href="#创建-README-md" class="headerlink" title="创建 README.md"></a>创建 README.md</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yuki</div></pre></td></tr></table></figure>
<h3 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h3><p><a href="https://github.com/bighuang624/yuki/blob/master/LICENSE" target="_blank" rel="external">Apache License 2.0</a></p>
<h2 id="开发中的那些事"><a href="#开发中的那些事" class="headerlink" title="开发中的那些事"></a>开发中的那些事</h2><h3 id="Cli-命令工具开发的准备工作"><a href="#Cli-命令工具开发的准备工作" class="headerlink" title="Cli 命令工具开发的准备工作"></a>Cli 命令工具开发的准备工作</h3><p>我们来了解一下围绕 NPM 开发的准备工作。第一步自然是在文件夹下使用命令<code>npm init</code>生成 package.json 文件。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>可以通过以下命令在 NPM 资源库中注册用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm adduser</div></pre></td></tr></table></figure>
<p>之后跟着要求填写 Username、Password、Email 就 ok 了。项目发布前可能需要<code>npm login</code>一下。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>NPM 使用语义版本号来管理代码。语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：</p>
<ul>
<li>如果只是修复 bug，需要更新 Z 位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新 Y 位。</li>
<li>如果有大变动，向下不兼容，需要更新 X 位。</li>
</ul>
<p>当然我这个小项目比较随便，bug 修的多了次版本号看心情也往上升一次。</p>
<p>你可以用<code>npm view &lt;pkg&gt; version</code>来查看你发布到 NPM 项目的现在版本号。</p>
<h4 id="测试小窍门"><a href="#测试小窍门" class="headerlink" title="测试小窍门"></a>测试小窍门</h4><p>这两个小窍门可以节省你在一边开发一边测试的时间（没发现之前，3 天的开发时间花在这上面的不少…）。</p>
<ul>
<li><p>在 package.json 所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;pkg&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
</ul>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><p>想要在全局使用你编写的 cli 工具，你需要在 package.json 加一个 bin 属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"bin": &#123;</div><div class="line">  "yuki": "./index.js"</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>yuki 换做你启动这个程序所要在命令行输入的命令。属性的值是项目的入口文件。添加这个属性后，在命令行执行<code>yuki</code>就等同于执行<code>node ./index.js</code>。</p>
<h4 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h4><p>项目写了一个版本准备发布，先在 package.json 所在目录下用<code>npm version</code>看一下版本号，然后就可以 publish 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> yuki</div><div class="line">npm version</div><div class="line">npm publish</div></pre></td></tr></table></figure>
<p>之后就可以通过全局安装来使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g yuki</div></pre></td></tr></table></figure>
<h3 id="获得程序运行的路径"><a href="#获得程序运行的路径" class="headerlink" title="获得程序运行的路径"></a>获得程序运行的路径</h3><p>说实话，一个我很不擅长的东西就是 API，哪怕是那些非常常用的。这次我一开始就遇到了麻烦：如何获得程序开始遍历的“根目录”路径？</p>
<p>在查找的同时顺便了解了一下获得各种路径的方法，有以下几种：</p>
<ul>
<li><p><code>process.cwd()</code>获得 Node.js 进程当前工作的路径（即执行命令行时候的路径，而非代码路径。例如在根目录下执行<code>node ./xxx/xxx/example.js</code>，则<code>process.cwd()</code>返回的是根目录地址）；</p>
</li>
<li><p><code>__dirname</code>: 获得代码存放的位置（例如运行位于<code>/usr/a</code>目录下的<code>example.js</code>文件：<code>node example.js</code>，则<code>__dirname</code>返回<code>/usr/a</code>）；</p>
</li>
<li><p><code>process.execPath</code>: 返回返回启动 Node.js 进程的可执行文件所在的绝对路径（也就是当前执行的 Node 自身的路径，例如：<code>/usr/local/bin/node</code>）。</p>
</li>
</ul>
<p>根据查询结果和实际需求，应该使用<code>process.cwd()</code>（我们要求在 package.json 所在目录下使用 yuki）。不过实际上使用的是<code>path.resolve()</code>。<code>path.resolve()</code>不含参数时，返回返回当前工作目录的绝对路径，也符合要求。</p>
<p>yuki 的编写也帮助我熟悉了 Node 里的很多 API，尤其是和 path 和 fs 相关的。</p>
<h3 id="先遍历文件再深度遍历文件夹"><a href="#先遍历文件再深度遍历文件夹" class="headerlink" title="先遍历文件再深度遍历文件夹"></a>先遍历文件再深度遍历文件夹</h3><p>开发的过程中发现一个问题：遍历文件夹 a 下的所有文件时，经常先深度遍历了其中的文件夹，导致文件排在这些文件夹深度遍历的结果之后，在生成的 README 中无法看出其准确位置。</p>
<p>解决方法还比较简单，就是在每一次递归的遍历方法中都建立一个队列，遍历到文件夹先推入队列，遍历到文件则展示。所有文件遍历结束后，将队列中的文件夹依次取出并遍历。这样既满足了要求，也没有对深度优先遍历造成影响。</p>
<p>更好的是，JS 的数组原生支持了<code>push</code>方法，使得我不用再写一个队列的实现。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管只是一个微不足道的小工具，我还是很开心能够根据自己的实际需求开发了 yuki，更开心有机会开发一个能在名字中夹私货的项目（早在看到 vue 的版本名时我就一直心心念念了）。</p>
<p>如果你觉得这个小工具还不错，或者使用时觉得很方便、减轻了重复的工作负担，那么不妨为 <a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a> 点一个 star，因为我憧憬着能在毕业前拥有一个自己的 100+ star 项目。</p>
<p><img src="/images/yuki/give-him-first.jpg"></p>
<p>当然，我更希望这些 star 是凭借我自己的开发创意和技术所得到的认可的。而我的开发经验确实不太足，所以如果你觉得这个工具不太好使、代码糟糕、发现了 bug，或是有可以增加的功能，也欢迎你开 issue 或者提交 PR 来告知我。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。&lt;br&gt;——沃兹基硕德&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;受到掘金上看到的 &lt;a href=&quot;https://github.com/kenshinji/yddict&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yddict：一个命令行查单词的工具&lt;/a&gt; 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。&lt;/p&gt;
&lt;p&gt;看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 &lt;a href=&quot;https://github.com/bighuang624/yuki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yuki&lt;/a&gt;，蕴含了我个人满满的宅趣味。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/yuki/Yuki.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。&lt;/p&gt;
&lt;p&gt;这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="开源小项目" scheme="http://kyonhuang.top/categories/%E5%BC%80%E6%BA%90%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="yuki" scheme="http://kyonhuang.top/tags/yuki/"/>
    
      <category term="NPM" scheme="http://kyonhuang.top/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s start Python!</title>
    <link href="http://kyonhuang.top/lets-start-Python/"/>
    <id>http://kyonhuang.top/lets-start-Python/</id>
    <published>2017-09-11T15:03:19.000Z</published>
    <updated>2017-09-20T11:20:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！</p>
<p>今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，Python 这方面的生态环境还是要比 Node 强大不少。当然我也希望不丢掉之前的 JS 和 Node 基础，要时常写点东西或者看看书保持状态。</p>
<p>顺便谈一下，朱老师让我学 Python 2.7，大概是有一些历史遗留问题。但是我在知乎上查了一下，还是决定先看廖雪峰 3.x 版本的 Python 教程。我觉得知乎里一个回答给的建议不错，摘抄一下：</p>
<ul>
<li>学习 Python 前，先了解在 Python 3 里面已经弃用的 Python 2 语法，对这些部分简单带过不要花太多时间；</li>
<li>使用 Python 2，不要使用 Python 2.7 以前的版本；</li>
<li>使用 Python 3，不要使用 Python 3.4 以前的版本；</li>
<li>多了解 Python 2 的<code>__future__</code>库；</li>
<li>对同一份代码，不要为 Python 2 和 Python 3 分别维护分支，努力在一套代码中兼容 Python 2 和 Python 3。</li>
</ul>
<p>根据以上建议，我在 Anaconda 配置了 2.7.13 和 3.6.0 的两种版本。当然这份回答里最重要的还有一句话：</p>
<p><strong>stop talking, just do it！</strong></p>
<p>这一篇大概就讲这么些废话。人生苦短，我用 Python，常听到这句话，现在我就来体验啦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！&lt;/p&gt;
&lt;p&gt;今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，P
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="http://kyonhuang.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR v4 学习笔记（一）－ANTLR 初体验</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-1/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-1/</id>
    <published>2017-09-06T07:34:19.000Z</published>
    <updated>2017-09-21T07:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。</p>
<p>课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。</p>
<p>ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。</p>
<p>更新记录：</p>
<ul>
<li>17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布</li>
<li>17.09.11 Chapter 3 阅读完毕，增加动手上路章节。</li>
<li>17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译</li>
</ul>
<a id="more"></a>
<h2 id="我对编译技术的认识"><a href="#我对编译技术的认识" class="headerlink" title="我对编译技术的认识"></a>我对编译技术的认识</h2><p>在正式进行 ANTLR 的学习前，先让我们聊一聊在经过上学期《编译技术及应用》的学习，以及查阅了有关资料后，我对编译技术和编译工具的一点认识。</p>
<p>说实话，如果单单是谈在《编译技术及应用》这门课上的认识的话，我可能只能像孔乙己一样，接连便是难懂的话，什么“上下文无关文法”，什么“LL(1)”，引得各位都哄笑起来，屏幕内外充满了快活的空气…  </p>
<p>尽管经过了计算器和 JSONCompiler 两次实验，但我们可能对编译技术的应用还没有什么认识，觉得编译器的唯一用处就是写一个能把 xx 语言翻译成 xx 然后再运行成功…</p>
<p>基于写这篇博文的契机，我查了一下编译技术的各种应用，才发现其实“编译”这个概念应用还是很广泛的。</p>
<p>比如我的博客是用 hexo 这个博客框架搭建的，而你现在看到的这篇博文是 hexo 将我写的 markdown 文件解析成 html 生成的，这其中自然有编译模块的功劳（感兴趣可见 <a href="http://www.jianshu.com/p/ef88b5bbb914" target="_blank" rel="external">大前端-5分钟带你读懂Hexo源码设计模式 - 简书</a>）。</p>
<p>再比如作为一个前端，有不少我使用过或日常接触的工具、框架其实都是编译相关知识的应用：Babel 作为 ES 6 的所有新特性还没有在主流浏览器全面推广的一个暂时的解决方法，将 ES 6 编译成 ES 5 等浏览器能够运行的 JavaScript 代码；在 Vue 中频繁出现的模版引擎、<code>v-for=&quot;item in list&quot;</code>等也有编译的身影。如果真正对编译原理理解透彻，大概可以去摸摸 v8 ，帮助提高一下 Node.js 的运行效率。</p>
<p>编程，本质上是程序员通过语言来控制计算机按照人的意志去进行各种运算和操作。自 20 世纪 50 年代早期，第一个只能进行单目运算的编译程序诞生起，编译技术一直作为人与计算机之间的传声筒，支撑着计算机语言的发展，使其更加系统化、合理化。</p>
<p>在知乎上“编译原理学了有什么用？”这个提问下，有答主贴了一幅《C 编译器解剖》序的照片，其中有一段话：</p>
<blockquote>
<p>操作系统和编译器就如武侠小说中的“九阴真经”，没看过“九阴真经”的侠客也可以行走江湖，但看过并练成九阴真经的人最终才更有机会登上华山之巅。</p>
</blockquote>
<p>怀着对程序员之巅的心向往之，我也对编译原理更生敬畏。</p>
<p>当然，如何让这门古老的屠龙术落地，而不至于成为学生心中虚无缥缈的空中楼阁。我个人认为可以再开设一些相关的新课题，让学生能够充分了解编译技术的实用性，从而能够自主学习、实践。我也希望《解释器构造实践》能成为一个不错的起点。</p>
<h2 id="初识-ANTLR"><a href="#初识-ANTLR" class="headerlink" title="初识 ANTLR"></a>初识 ANTLR</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 1 Meet ANTLR。书里的这一章主要是介绍 ANTLR 的下载安装方法，并运行了一个简单的 demo。</p>
</blockquote>
<h3 id="安装-ANTLR"><a href="#安装-ANTLR" class="headerlink" title="安装 ANTLR"></a>安装 ANTLR</h3><p>ANTLR 是用 Java 编写的，所以就算你想使用 C# 或者 C++ 来配合 ANTLR 生成解释器，安装 ANTLR 前也需要有 Java 环境。</p>
<p>之后需要下载 antlr-4.x-complete.jar（越新越好，4.x 指最新版本的版本号）并把它放在你记得住的地方。这个 jar 包包含了运行 ANTLR 工具所需要的所有依赖，还包含两个支持库：一个树状排版库，以及 StringTemplate，一个用于生成代码以及其他结构化文本的模版引擎。</p>
<p>安装的具体步骤请直接看<a href="http://www.antlr.org/" target="_blank" rel="external">官网</a>的 Quick Start，在此不作展示。</p>
<h2 id="ANTLR-全貌"><a href="#ANTLR-全貌" class="headerlink" title="ANTLR 全貌"></a>ANTLR 全貌</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 2 The Big Picture，书中这一章介绍了从字符流到语法分析树的过程、ANTLR 运行流程中的一些重要术语，以及ANTLR 自带的 Listener、Visitor 这两种遍历树的机制。</p>
</blockquote>
<p>想要实现一种语言，我们就需要构建读取句子的应用，并对输入的元素做出正确的反应。</p>
<p>如果一个应用可以计算或执行句子，我们就叫它<strong>解释器（interpreter）</strong>。包括计算器、配置文件读取器、Python 解释器都属于解释器。</p>
<p>而如果一个应用将句子转换成另一种语言，我们就叫它<strong>翻译器（translator）</strong>。例如 Java 到 C# 的翻译器和<strong>编译器</strong>都属于翻译器。</p>
<p>不管是解释器还是翻译器，想要正确运行，应用首先都要识别出所有有效的句子、词组、字词组等，识别语言的程序就叫<strong>解析器（parser）</strong>或<strong>语法分析器（syntax analyzer）</strong>。</p>
<p>完全 DIY 一个解析器非常麻烦，所以我们需要 ANTLR 的帮助。ANTLR 是一种能写出程序的程序，只需编写 ANTLR 的语法（grammars）文件，描述我们要解析的语言的语法，ANTLR 就能够自动生成用来解析这种语言的解析器。而用来声明我们语言的ANTLR语言的语法，就是<strong>元语言（meta-language）</strong>。</p>
<h3 id="最基本的解析过程"><a href="#最基本的解析过程" class="headerlink" title="最基本的解析过程"></a>最基本的解析过程</h3><p>为了简单起见，我们将解析分为两个阶段，第一阶段是<strong>词法分析（lexical analysis）</strong>，对应的分析程序叫做<strong>词法分析器（lexer）</strong>，负责将符号（token）分组成<strong>符号类（token class or token type）</strong>。而第二阶段就是真正的<em>语法分析</em>，默认 ANTLR 会构建出一棵<strong>语法分析树（parse tree / syntax tree）</strong>。下图展示了一个简单的赋值表达式的解析过程：</p>
<p><img src="/images/antlr/note1/antlr1.jpg"></p>
<p>语法树的叶子是输入的 token，而上级结点是包含其孩子结点的词组名（phase），线性的句子其实是语法树的序列化。最终生成语法树的好处是：</p>
<ol>
<li>树形结构易于遍历和处理，并且容易被程序员理解，方便了应用代码做进一步处理。</li>
<li>多种解释或翻译的应用代码都可以重用一个解析器。但 ANTLR 也支持像传统解析器生成器那样，将应用处理代码直接嵌入到语法中。</li>
<li>对于因为计算依赖而需要多趟处理的翻译器来说，比起多次调用解析器去解析，遍历语法树多次更加高效。</li>
</ol>
<h3 id="深入-ANTLR-的解析过程"><a href="#深入-ANTLR-的解析过程" class="headerlink" title="深入 ANTLR 的解析过程"></a>深入 ANTLR 的解析过程</h3><p>ANTLR 生成的解析器叫做<strong>递归下降语法分析器（recursive-descent parser）</strong>，属于自顶向下语法分析器（top-down parser）的一种。</p>
<p>顾名思义，递归下降指的就是解析过程是从语法树的根开始，向叶子（token）递归。还是以前面的赋值表达式解析为例，其递归下降语法分析器的代码大概是下面这个样子：</p>
<p><img src="/images/antlr/note1/antlr2.jpg"></p>
<p>很酷的一点是<code>stat()</code>、<code>assign()</code>、<code>expr()</code>等方法调用所形成的调用栈能与语法分析树的内部节点一一对应。<code>match()</code>的调用对应树的叶子，而<code>assign()</code>方法直接顺序读取输入字符，而不用做任何选择。相比之下，<code>stat()</code>方法要复杂一些，因为在解析时，它需要<strong>向前看（lookahead）</strong>一些字符才能确认走哪个代码分支，有时甚至要读取完所有输入才能得出预测结果。</p>
<p>虽然 ANTLR 默默地为我们处理了这整个过程，但对这个选择过程有一个基本的了解会使得对生成的解析器进行 debug 变得更加容易。</p>
<h3 id="用语法分析树构建语言应用"><a href="#用语法分析树构建语言应用" class="headerlink" title="用语法分析树构建语言应用"></a>用语法分析树构建语言应用</h3><p>在内部，ANTLR 的数据结构会尽可能地共享数据来节约内存。如下图所示，语法分析树的叶子节点指向 token 流中的 token，而 token 中的起止字符索引指向字符流，并不拷贝子字符串。而像空格这种不与任何 token 相关的字符会直接被 Lexer 丢弃掉。</p>
<p><img src="/images/antlr/note1/antlr3.jpg"></p>
<p>ANTLR 为每条规则都会生成一个 RuleNode，叫做<strong>上下文（Context）对象</strong>，它会记录根据规则识别词组时产生的所有上下文信息。每一个上下文对象都知道已经识别的短语的起始 token 和结束 token，并且提供了对这些短语的访问。例如，<code>AssignContext</code>提供<code>ID()</code>和<code>expr()</code>方法来访问标识符节点和表达式子树。</p>
<h3 id="语法分析树的-Listener-和-Visitor-机制"><a href="#语法分析树的-Listener-和-Visitor-机制" class="headerlink" title="语法分析树的 Listener 和 Visitor 机制"></a>语法分析树的 Listener 和 Visitor 机制</h3><p>ANTLR 在其运行库提供了 Listener 和 Visitor 两种语法分析树遍历机制。</p>
<h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>Listener 的特点是全自动化，我们不必写一个语法分析树的遍历器，ANTLR 会生成一个 ParseTreeWalker 的子类来主导深度优先遍历过程，我们只需处理各种事件就可以了。例如当遍历器遍历到<code>assign</code>规则的节点时，会触发<code>enterAssign()</code>并向其传递<code>AssignContext</code>参数；而当遍历器遍历完<code>assign</code>节点的所有子节点时，触发<code>exitAssign()</code>。下图展示了 ParseTreeWalker 如何进行深度优先遍历：</p>
<p><img src="/images/antlr/note1/antlr4.jpg"></p>
<p>而下图展示了 ParseTreeWalker 的完整监听器方法调用队列：</p>
<p><img src="/images/antlr/note1/antlr5.jpg"></p>
<h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h4><p>而 Visitor 则提供了可控的遍历方式，我们可以自行决定是否将子结点作为参数调用<code>visit()</code>方法。</p>
<p>在使用 ANTLR 生成时加上参数<code>-visitor</code>，会生成带有默认实现的 Visitor 实现类。我们不必实现接口中的每一个方法，只需要覆盖我们感兴趣的方法。</p>
<p><img src="/images/antlr/note1/antlr6.jpg"></p>
<h2 id="动手上路"><a href="#动手上路" class="headerlink" title="动手上路"></a>动手上路</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 3 A Starter ANTLR Project。</p>
</blockquote>
<h3 id="ANTLR-工具，运行时类库和生成代码"><a href="#ANTLR-工具，运行时类库和生成代码" class="headerlink" title="ANTLR 工具，运行时类库和生成代码"></a>ANTLR 工具，运行时类库和生成代码</h3><p>ANTLR 分为两个重要的部分：ANLTR 工具自身和 ANTLR 运行时（runtime） API。运行 ALTLR 工具会生成能够辨认语法所描述语言的句子的代码（词法分析程序和语法分析程序）；而运行时类库提供了生成代码所需的一系列类与方法，例如 Parser, Lexer 和 token。</p>
<p>我们先对一份语法运行 ANTLR，然后借助 jar 包中的运行时类库（runtime classes in the jar）对生成的代码进行编译。最后，编译得到的应用与运行库结合着运行。</p>
<p>《The Definitive ANTLR 4 Reference》（后文可能简写为《Reference》）给出了一份简单的示例，让我们可以快速了解 ANTLR 所需语法的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Grammers always start with a grammer header. This grammer */</span></div><div class="line"><span class="comment">/** is called ArrayInit and must match the filename: ArrayInit.g4 */</span></div><div class="line">grammar ArrayInit;</div><div class="line"></div><div class="line"><span class="comment">/** A rule called init that that matches comma-separated values between &#123;...&#125; */</span></div><div class="line">init : <span class="string">'&#123;'</span> value (<span class="string">','</span> value)* <span class="string">'&#125;'</span> ;  <span class="comment">// must match at least one value</span></div><div class="line"></div><div class="line"><span class="comment">/** A value can be either a nested array/struct or a simple integer (INT) */</span></div><div class="line">value : init</div><div class="line">      | INT</div><div class="line">      ;</div><div class="line">      </div><div class="line"><span class="comment">// parser rules start with lowercase letters, lexer rules with uppercase</span></div><div class="line">INT :  [<span class="number">0</span>-<span class="number">9</span>]+ ;              <span class="comment">// Define Token INT as one or more digits</span></div><div class="line">WS  :  [ \t\r\n]+ -&gt; skip ;  <span class="comment">// Define whitespace rule, toss it out</span></div></pre></td></tr></table></figure>
<p>之后通过命令行运行<code>antlr4 ArrayInit.g4</code>，ANTLR 为我们生成很多一般需要我们自己手写的文件：</p>
<p><img src="/images/antlr/note1/antlr-generation.jpg"></p>
<p>这些文件的功能如下：</p>
<ul>
<li>ArrayInitParser.java：包含了专用于 ArrayInit 语法的解析器（parser）类的定义。</li>
<li>ArrayInitLexer.java：包含专用的词法分析程序（lexer）类的定义。</li>
<li>ArrayInit.Tokens：对于我们定义的每个 token，ANTLR 分配了一个 token 类型码（token type number）并将这些值保存在 ArrayInit.tokens。因为这个文件的存在，当我们将较大规模的语法分割为各种小型的语法表达时，ANTLR 能够使同种 token 的类型码保持一致。</li>
<li>ArrayInitListener.java, ArrayInitBaseListener.java：ANTLR 生成的解释器会默认根据输入构建一棵树。通过遍历这棵树，一个遍历器可以将事件（回调函数）传递给我们提供的监听者对象（listener object）。ArrayInitListener 是描述我们可以实现的回调函数的接口，而ArrayInitBaseListener 是默认空实现的集合，使我们可以方便的重写（override）那些我们感兴趣的回调函数。通过<code>-visitor</code>命令行参数，ANTLR 也可以为我们生成树的 visitors。</li>
</ul>
<h3 id="测试生成的解析器"><a href="#测试生成的解析器" class="headerlink" title="测试生成的解析器"></a>测试生成的解析器</h3><p>之后，我们通过<code>javac *.java</code>来编译 ANTLR 生成的所有代码。UNIX 系统用户可以将以下代码写入<code>.bash_profile</code>或其他启动脚本，以免每次都要在命令行输入一遍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> CLASSPATH=<span class="string">".:/usr/local/lib/antlr-4.7-complete.jar:<span class="variable">$CLASSPATH</span>"</span></div><div class="line"><span class="built_in">alias</span> antlr4=<span class="string">'java -jar /usr/local/lib/antlr-4.7-complete.jar'</span></div><div class="line"><span class="built_in">alias</span> grun=<span class="string">'java org.antlr.v4.gui.TestRig'</span></div></pre></td></tr></table></figure>
<p>之后就可以通过<code>grun</code>命令来测试生成的解析器了。注意输入要以 EOF（Unix 系统 Ctrl + D，Windows 系统 Ctrl + Z）作为结束。加上<code>-tokens</code>命令行参数，输出的每一行会展示一个单独的 token 及其所有信息：</p>
<p><img src="/images/antlr/note1/grun-the-example1.jpg"></p>
<p><code>-tree</code>会生成一个 Lisp 风格的简单语法分析树：</p>
<p><img src="/images/antlr/note1/grun-the-example2.jpg"></p>
<p>而<code>-gui</code>会生成一个展示语法分析树的 GUI 界面：</p>
<p><img src="/images/antlr/note1/grun-the-example3.jpg"></p>
<p><img src="/images/antlr/note1/grun-the-example4.jpg"></p>
<p>根据我们定义的语法规则，ANTLR 自动生成了这棵语法分析树。之后我们会利用 ANTLR 内置的遍历器触发<code>enterInit()</code>和<code>enterValue()</code>等各种回调函数。</p>
<h3 id="将生成的解析器集成进-Java-程序"><a href="#将生成的解析器集成进-Java-程序" class="headerlink" title="将生成的解析器集成进 Java 程序"></a>将生成的解析器集成进 Java 程序</h3><p>我们来写一个简单的 Java <code>main()</code>方法来集成生成的解析器，并打印出和使用<code>-tree</code>参数一样的语法分析树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import ANTLR's runtime libraries</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// create a CharStream that reads from standard input</span></div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</div><div class="line">        </div><div class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></div><div class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</div><div class="line">        </div><div class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        </div><div class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></div><div class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</div><div class="line">        </div><div class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></div><div class="line">        System.out.println(tree.toStringTree(parser));  <span class="comment">// print LISP-style tree</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果如下。语法错误也可以被报告：</p>
<p><img src="/images/antlr/note1/integrating-test.jpg"></p>
<h3 id="构建语言应用"><a href="#构建语言应用" class="headerlink" title="构建语言应用"></a>构建语言应用</h3><p>我们的目标不仅仅是识别，还想做一些翻译工作。最简单的方法是利用 ANTLR 内置的语法分析树遍历器，这样我们不需要自己去进行树遍历，大大减少了工作量。</p>
<p>我们给 ArrayInit 加一个新需求：将 short 数组<code>{99, 3, 451}</code>翻译为字符串<code>\u0063\u0003\u01c3</code>。实现这个需求，我们只需要继承<code>ArrayInitBaseListener</code>，来实现其中的一些监听器方法。</p>
<p>我们在 ShortToUnicodeString.java 中实现我们的监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Convert short array inits like &#123;1, 2, 3&#125; to "\u0001\u0002\u0003" */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToUnicodeString</span> <span class="keyword">extends</span> <span class="title">ArrayInitBaseListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">'"'</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">'"'</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterValue</span><span class="params">(ArrayInitParser.ValueContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> value = Integer.valueOf(ctx.INT().getText());</div><div class="line">        System.out.printf(<span class="string">"\\u%04x"</span>, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们不需要覆盖每一个<code>enter/exit</code>方法，只需要实现我们需要的那些。代码里<code>ctx.INT()</code>代表上下文对象请求已经匹配的整数 INT 的值。记住我们之前提到的，上下文对象会记录根据规则识别词组时产生的所有信息。</p>
<p>接下来，我们要创建一个主程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import ANTLR's runtime libraries</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// create a CharStream that reads from standard input</span></div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</div><div class="line">        </div><div class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></div><div class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</div><div class="line">        </div><div class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        </div><div class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></div><div class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</div><div class="line">        </div><div class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></div><div class="line">        </div><div class="line">        <span class="comment">// Create a generic parse tree walker that can trigger callbacks</span></div><div class="line">        ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</div><div class="line">        </div><div class="line">        <span class="comment">// Walk the tree created during the parse, trigger callbacks</span></div><div class="line">        walker.walk(<span class="keyword">new</span> ShortToUnicodeString(), tree);</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比起上一节的主程序，我们多创建了一个树遍历器（<code>ParseTreeWalker walker</code>），并用它来遍历语法分析器返回的语法分析树，它会触发<code>ShortToUnicodeString</code>中的回调方法。</p>
<p>javac 进行编译后就可以使用了：</p>
<p><img src="/images/antlr/note1/translate-test.jpg"></p>
<p>我们可以通过传入不同的监听器来产生完全不同的输出。监听器将语法和我们的语言应用很大程度上解耦了，使语法具有了更大的重用性。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>第一篇笔记到这里就结束了。我们聊了一下我对编译技术的一点看法，并阅读了《The Definitive ANTLR 4 Reference》的前三章。而书的 Part I: Introducing ANTLR and Computer Languages 还剩第四章 A Quick Tour，根据实验课的要求，这一章我会单独写一篇学习笔记，示例与内容也会和书上有一些区别。在这之后我会继续学习解释器构造，并继续写这本书的阅读笔记，敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/dc_726/article/details/45399371" target="_blank" rel="external">Antlr v4入门教程和实例 - 西代零零发 - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。&lt;/p&gt;
&lt;p&gt;课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。&lt;/p&gt;
&lt;p&gt;ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。&lt;/p&gt;
&lt;p&gt;更新记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布&lt;/li&gt;
&lt;li&gt;17.09.11 Chapter 3 阅读完毕，增加动手上路章节。&lt;/li&gt;
&lt;li&gt;17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Node 异步 I/O</title>
    <link href="http://kyonhuang.top/async-IO-in-Node/"/>
    <id>http://kyonhuang.top/async-IO-in-Node/</id>
    <published>2017-09-02T12:43:16.000Z</published>
    <updated>2017-09-20T07:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。</p>
<p>Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。</p>
<p>因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。</p>
<p>这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。</p>
<a id="more"></a>
<h2 id="选择异步的原因"><a href="#选择异步的原因" class="headerlink" title="选择异步的原因"></a>选择异步的原因</h2><p>选择异步的原因包括用户体验和资源分配两个方面。</p>
<p>从用户体验的角度分析，浏览器中 JavaScript 在单线程上执行，并且与 UI 渲染共用一个线程。因此采用异步请求将使下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为。</p>
<p>而从资源分配角度来看，当遇到一组互不相关的任务需要完成的场景时，主流选择有以下两种：</p>
<ul>
<li>单线程串行依次执行：容易导致阻塞，硬件资源难以有效利用；</li>
<li>多线程并行：创建线程和执行期线程上下文切换的开销较大，且经常面临锁、状态同步等问题（但多线程在多核 CPU 上能够有效提升 CPU 的利用率）；</li>
</ul>
<p>而 Node 给出的解决方案是：利用<strong>单线程</strong>，远离多线程死锁、状态同步等问题；利用<strong>异步 I/O</strong>，让单线程远离阻塞以更好地利用 CPU。</p>
<p>而为了弥补单线程无法有效利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效利用 CPU 和 I/O。</p>
<h2 id="从操作系统看异步-I-O"><a href="#从操作系统看异步-I-O" class="headerlink" title="从操作系统看异步 I/O"></a>从操作系统看异步 I/O</h2><p>Node 的异步 I/O 不可否认地受到操作系统中异步 I/O 实现的启发。</p>
<p>要强调的是，从计算机内核 I/O 而言，<strong>异步/同步和阻塞/非阻塞实际上是两回事</strong>。</p>
<h3 id="阻塞-非阻塞-I-O"><a href="#阻塞-非阻塞-I-O" class="headerlink" title="阻塞/非阻塞 I/O"></a>阻塞/非阻塞 I/O</h3><p>在调用<strong>阻塞 I/O</strong> 时，应用程序需要等待 I/O 完成时才返回结果。特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束，因此造成 <strong>CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用</strong>。</p>
<p>与阻塞 I/O 完成整个获取数据的过程相比，<strong>非阻塞 I/O</strong> 则<strong>不带数据直接返回</strong>，要获取数据还需要通过<strong>文件描述符</strong>再次读取。非阻塞 I/O 返回之后，CPU 的时间片可以用来处理其他事务。</p>
<p>但由于完整的 I/O 并没有完成，非阻塞 I/O 立即返回的仅仅是当前调用的状态。为了获取完整数据，需要<strong>轮询</strong>这种重复调用以判断操作是否完成的技术。</p>
<p>现存的轮询技术包括 <strong>read</strong>（通过重复调用检查 I/O 状态，性能最低，CPU 一直等待）、<strong>select</strong>（通过对文件描述符上的事件状态进行判断）、<strong>poll</strong>（比 select 有所改进，但性能仍较低）、<strong>epoll</strong>（Linux 下<strong>效率最高</strong>的 I/O 事件通知机制，进入轮询时休眠，直到事件发生将其唤醒）和<strong>kqueue</strong>（与 epoll 类似，仅在 FreeBSD 系统存在）。</p>
<p>虽然轮询技术能够满足了非阻塞 I/O 确保获取完整数据的需求，但应用程序依旧花费了很多时间来等待 I/O 完全返回。等待期间，CPU 要么用于<strong>遍历文件描述符的状态</strong>，要么用于<strong>休眠等待事件发生</strong>。因此，<strong>它仍然只能算是一种同步</strong>。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>在看廖雪峰的 Python 教程的异步 IO 这一章时，在评论区看到一个对于阻塞/非阻塞和同步/异步非常精妙的解释，十分容易理解和记忆，特摘录如下：</p>
<blockquote>
<p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p>
<p>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻</p>
<p>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</p>
<p>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大</p>
<p>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p>
<p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p>
<p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</blockquote>
<h3 id="异步-I-O-的实现"><a href="#异步-I-O-的实现" class="headerlink" title="异步 I/O 的实现"></a>异步 I/O 的实现</h3><p>我们期望的完美异步 I/O 应该是：应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序即可。</p>
<p>Linux 原生提供 AIO 这种符合要求的异步 I/O 方式，但只有 Linux 下有，且其无法利用系统缓存。因此现实情况下，想在单线程场景完美实现异步 I/O 有些难度。</p>
<p>而在<strong>多线程</strong>，通过<strong>让部分线程进行阻塞 I/O 或者非阻塞 I/O 加载轮询技术来完成数据获取，让一个线程进行计算处理，再通过线程间的通信将 I/O 得到的数据进行传递</strong>，可以模拟异步 I/O。</p>
<p>*nix 平台，Node 自行实现了线程池来完成异步 I/O；Windows 平台则采用 IOCP 实现。Node 提供了 libuv 作为抽象封装层，平台兼容性由这一层完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。</p>
<p>Node 在<strong>编译期间判断平台条件</strong>，选择性编译 unix 目录或 win 目录下的源文件到目标程序中。</p>
<ul>
<li>我们常说的“Node 是单线程的”里的“单线程”仅指 <strong>JavaScript 执行在单线程</strong>。而内部完成 I/O 任务的另有线程池，只是 I/O 线程使用的 CPU 较少。</li>
<li>除了用户代码无法并行执行外，所有的 I/O （磁盘 I/O 和网络 I/O 等）可以并行。</li>
</ul>
<h2 id="Node-的异步-I-O"><a href="#Node-的异步-I-O" class="headerlink" title="Node 的异步 I/O"></a>Node 的异步 I/O</h2><p><strong>事件循环</strong>、<strong>观察者</strong>、<strong>请求对象</strong>、<strong>I/O 线程池</strong>一同构成了 Node 异步 I/O 模型的基本要素。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>每执行一次循环体的过程被称为 <strong>Tick</strong>，查看是否有事件待处理，若有则取出事件及相关回调函数。如果存在关联的回调函数，就执行它们。直到没有事件，进入下个循环。</p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>每个事件循环中有一个或者多个观察者，<strong>判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</strong>。</p>
<p>事件循环是一个典型的<strong>生产者/消费者模型</strong>。<em>异步 I/O、网络请求</em>是事件的<em>生产者</em>，事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。<strong>观察者相当于事件池</strong>。</p>
<p>在 Windows 下，这个循环基于 IOCP 创建，而在 *unix 下基于多线程创建。</p>
<h3 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h3><p>请求对象是从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中的重要<strong>中间产物</strong>。所有的状态都保存在这个对象中，包括<strong>送入 I/O 线程池等待执行</strong>以及 I/O 操作完毕后的回调处理。</p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><p>组装好请求对象、送入 I/O 线程池等待执行，构成了异步 I/O 的第一部分。而回调通知是第二部分。</p>
<p>线程池中的 I/O 操作调用完毕后，会调用方法向 IOCP 提交执行状态，并将线程归还线程池。</p>
<p>在每次 Tick 的执行中，I/O 观察者会调用方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。</p>
<p>整个异步 I/O 流程图如下：</p>
<p><img src="/images/async IO model.jpg"></p>
<h2 id="非-I-O-的异步-API"><a href="#非-I-O-的异步-API" class="headerlink" title="非 I/O 的异步 API"></a>非 I/O 的异步 API</h2><p>Node 中还存在一些与 I/O 无关的异步 API：<code>setTimeout()</code>、<code>setInterval()</code>、<code>setImmediate()</code>、<code>process.nextTick()</code>。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><code>setTimeout()</code>和<code>setInterval()</code>与浏览器 API 一致，创建的定时器会被插入到<strong>定时器观察者内部的一个红黑树</strong>中。每次 Tick 执行时，会从该红黑树中<strong>迭代</strong>取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件并执行其回调函数。注意：由于事件循环自身特点，定时器并非精确的。</p>
<h3 id="process-nextTick-amp-setImmediate"><a href="#process-nextTick-amp-setImmediate" class="headerlink" title="process.nextTick() &amp; setImmediate()"></a>process.nextTick() &amp; setImmediate()</h3><p>两者都可用于将回调函数延迟执行，以异步执行一个任务。两者的区别如下：</p>
<ul>
<li><p>优先级：<code>process.nextTick()</code>中回调函数执行优先级要高于<code>setImmediate()</code>，原因在于<strong>事件循环对观察者的检查是有先后顺序的</strong>，idle 观察者（<code>process.nextTick()</code>） &gt; I/O 观察者 &gt; check 观察者（<code>setImmediate()</code>）。</p>
</li>
<li><p>具体实现：<code>process.nextTick()</code>的回调函数保存在一个<em>数组</em>中，<code>setImmediate()</code>保存在<em>链表</em>中。</p>
</li>
<li><p>行为：<code>process.nextTick()</code>在每轮循环中会将数组中的回调函数<em>全部执行</em>完，而<code>setImmediate()</code>在每轮循环中执行链表中的<em>一个</em>回调函数。这样的设计是为了保证每轮循环能够较快地执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。</p>
</li>
</ul>
<h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p>事件驱动的实质：通过<strong>主循环加事件触发</strong>的方式来运行程序。</p>
<p>几种经典的服务器模型各有其优缺点：</p>
<ul>
<li><strong>同步式</strong>：对于同步式的服务，一次只能处理一个请求，并且其他请求都处于等待状态。</li>
<li><strong>每进程/每请求</strong>：为每个请求启动一个进程，这样可以处理多个请求，但因为系统资源有限而不具备扩展性。</li>
<li><strong>每线程/每请求</strong>：为每个请求启动一个线程来处理。扩展性强于每进程/每请求，但由于每个线程都占用一定内存，大并发到来时内存还是会很快用光。</li>
</ul>
<p>Apache 目前还采用每线程/每请求，而 Nginx 采用事件驱动。</p>
<p>Nginx 与 Node 比较：</p>
<ul>
<li>Nginx 采用纯 C 写成，性能较高，但仅适合做 Web 服务器，用于反向代理或负载均衡等服务，在处理具体业务方面欠缺；</li>
<li>Node 是一套高性能平台，没有 Nginx 在 Web 服务器方面那么专业，但场景更大，可以处理各种具体业务。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入浅出Node.js》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。&lt;/p&gt;
&lt;p&gt;Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。&lt;/p&gt;
&lt;p&gt;因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。&lt;/p&gt;
&lt;p&gt;这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS 学习笔记" scheme="http://kyonhuang.top/categories/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="异步 I/O" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5-I-O/"/>
    
  </entry>
  
  <entry>
    <title>夏天就要过去</title>
    <link href="http://kyonhuang.top/summer-time-gone/"/>
    <id>http://kyonhuang.top/summer-time-gone/</id>
    <published>2017-08-29T10:22:33.000Z</published>
    <updated>2017-09-02T12:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=587963&auto=0&height=66"></iframe>

<p>现在是 2017 年的 8 月 29 号，离 9 月还有 2 天。大三近在咫尺，而夏天就要过去。</p>
<p>前几天的 ASL 舞台上，平野绫、茅原实里、后藤邑子三人毫无征兆地重新聚首，演唱了《凉宫春日的忧郁》的 ED《ハレ晴レユカイ（晴天好心情）》。06 年的最强动画，我最爱的动画，11 年后再看到这些人，恍如隔世。</p>
<p><img src="/images/forever-SOS.jpg"></p>
<p>过去是体育场旁的石板路，现在是教学楼到二食堂的小道，低头时摇曳的叶影把光束割出形状，抬头看到的是一成不变的蓝天白云。闻着空气里隐约弥漫着躁动的气息，你会产生错觉，真的以为八月是漫无止境的，度过的每一天会被慷慨归还。</p>
<p>只是在那个古老的不再回来的夏日，所有的结局都已写好，所有的泪水也都已启程。</p>
<p>“夏天就要过去”这句话念来，总有淡淡的感伤。也许正因如此，我才喜欢上夏天。</p>
<a id="more"></a>
<h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><h3 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h3><p>好了，矫情完毕。暑假还是老毛病，后期学习效率不高。目前成果和暑假计划写的还是有些差距。</p>
<p>《深入浅出 Node.js》读了几章，感觉确实有些深，很多章节涉及到操作系统的知识，而且没有大量实践经验可能很难领会其精髓。所以将前四章（主要是异步 I/O 和异步编程）总结成一个笔记，然后根据需要看一下第八章-构建 Web 应用后，就先暂停这本书的阅读。</p>
<p>之后看《你不知道的 JavaScript（中卷）》。这本因为前两章讲繁琐的强制转换的知识，看的我晕头转向（JS 里的各种显隐式转换至少从表面上看毫无规律，为人诟病），所以当时停下来了。现在还是要啃完，之后还有下卷。这一系列书还是将 JS 的细节讲的比较全面的。</p>
<p>看完以上之后可以考虑啃《JavaScript 设计模式与开发实践》。不过可能下学期时间不太够，量力而行。还要啃一下《计算机网络－自顶向下方法》的前几章，虽然是课本，也做笔记和脑图。</p>
<h3 id="项目练习"><a href="#项目练习" class="headerlink" title="项目练习"></a>项目练习</h3><ul>
<li>做了一个简单的<a href="http://kyonhuang.top/resume/">在线个人简历</a>，只用到了 vue 和 axios；</li>
<li>上手了 electron，将上述的个人简历包装成桌面程序扔到了 Github 上：<a href="https://github.com/bighuang624/electron-demo" target="_blank" rel="external">bighuang624/electron-demo
</a>。十分粗糙，而且在 mac 上的程序大小达到 122 MB。如果有时间和兴趣可以深入研究，最好是再拿一个前后端项目来做小白鼠；</li>
<li>今天想用 Node.js 重写之前的基于 Java 的 BiliBili 视频爬虫。不过折腾半天，感觉 B 站有了更严的反爬机制，还没有研究出怎么爬（估计之前的那个爬虫现在也不能用了）…</li>
<li>跟着教程摸了摸 express 和 koa。准备写一个有后台的项目，成功了就买一个服务器折腾折腾挂上去。</li>
</ul>
<p>可以看到项目练习这一块也不算特别满意。要求自己在夏令营之前有两到三个还（neng）不（hu）错（ren）的项目。</p>
<h3 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h3><p>要开始准备保研了。</p>
<ul>
<li>这学期要准备一下六级，争取考到 600 分以上，才不至于掉底子；</li>
<li>找一个实验室干点活，找不到靠谱的就算了；</li>
<li>想办法看科研和竞赛能不能有些东西；</li>
<li>保持绩点。这学期一定不能翘课，全部争取满分。而且要稍微多选一点课，尽量不留选修课。</li>
<li>慢慢读《算法》，一天 5 面吧。天杨说笔试蛮关键的，什么数据结构与算法、操作系统、机组等知识大三下学期都要重新捡起来。</li>
</ul>
<p>虽然没有企望过，但也许我可以走的稍微远一点。那就开始努力吧，因为夏天就要过去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=587963&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;现在是 2017 年的 8 月 29 号，离 9 月还有 2 天。大三近在咫尺，而夏天就要过去。&lt;/p&gt;
&lt;p&gt;前几天的 ASL 舞台上，平野绫、茅原实里、后藤邑子三人毫无征兆地重新聚首，演唱了《凉宫春日的忧郁》的 ED《ハレ晴レユカイ（晴天好心情）》。06 年的最强动画，我最爱的动画，11 年后再看到这些人，恍如隔世。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/forever-SOS.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;过去是体育场旁的石板路，现在是教学楼到二食堂的小道，低头时摇曳的叶影把光束割出形状，抬头看到的是一成不变的蓝天白云。闻着空气里隐约弥漫着躁动的气息，你会产生错觉，真的以为八月是漫无止境的，度过的每一天会被慷慨归还。&lt;/p&gt;
&lt;p&gt;只是在那个古老的不再回来的夏日，所有的结局都已写好，所有的泪水也都已启程。&lt;/p&gt;
&lt;p&gt;“夏天就要过去”这句话念来，总有淡淡的感伤。也许正因如此，我才喜欢上夏天。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>再探前端自动化－持续集成</title>
    <link href="http://kyonhuang.top/start-CI/"/>
    <id>http://kyonhuang.top/start-CI/</id>
    <published>2017-08-23T00:47:28.000Z</published>
    <updated>2017-08-24T08:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文承接前端工程自动化入门系列的第一篇：<a href="http://kyonhuang.top/start-front-end-test/">《初探前端自动化测试–以 Vue 为例》</a>。</p>
<p>传统开发模式中，项目经理等待所有模块都开发完成后再进行集成，出现 bug 则记录并分配责任人进行修改，之后再进行集成，直到通过测试为止持续循环。这个过程可能会出现如下问题：</p>
<ol>
<li>bug 总在最后才被发现（尤其是模块之间的依赖导致的 bug），并且越到项目后期，随着项目规模的膨胀，bug 变得愈发难以修复；</li>
<li>各个环节无效的等待时间较长，加上程序需要经常变更，导致软件交付时机无法保障；</li>
<li>用户无法随时看到项目演示原型，满意度低。</li>
</ol>
<p>为了解决这些问题，<strong>“持续集成”（Continuous Integration）</strong>的概念被提出。</p>
<a id="more"></a>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>持续集成</strong>（CI）是指将所有开发者工作副本频繁地（每天多次）合并到主干，始终保持可发布状态的做法。而<strong>持续集成服务器</strong>就是能够采用自动化的手段，实现项目持续集成的工具。</p>
<p>持续集成的具体工作流程：</p>
<ol>
<li><strong>本地开发（developing）</strong></li>
<li><strong>静态代码检查（linting）</strong></li>
<li><strong>单元测试（testing）</strong>：代码仓库对 commit 操作配置钩子（hook），只要提交代码或者合并进入主干，就会跑自动化测试。这一轮可以先只跑单元测试。</li>
<li><strong>合并进入主干（merging）</strong></li>
<li><strong>自动构建（building）</strong>：将源码经过安装依赖、配置各种资源（CSS、JS、images），转换为可以运行的实际代码。之后会跑全面的测试。</li>
<li><strong>自动发布（publishing）</strong>：将可以直接部署的版本打包，发到生产服务器以启动应用。</li>
</ol>
<p>持续集成之后还有<strong>持续交付</strong>和<strong>持续部署</strong>，分别强调代码在任何时候都是可交付和可部署的。</p>
<h2 id="持续集成的优点"><a href="#持续集成的优点" class="headerlink" title="持续集成的优点"></a>持续集成的优点</h2><ol>
<li>自动化部署工作解放了重复性劳动，并减少手工集成的错误；</li>
<li>防止分支大幅偏离主干，而导致以后的集成难度变大，甚至难以集成；</li>
<li>持续集成缩短了开发、集成、测试、部署等各个环节的时间，从而减少等待时间，同时可以更快地发现、定位、修复问题并交付成果，使得产品可以快速迭代；</li>
<li>集成服务器一般都提供 Code review、代码质量检测等功能，帮助开发人员提高产品质量。</li>
</ol>
<h2 id="持续集成服务平台-Travis"><a href="#持续集成服务平台-Travis" class="headerlink" title="持续集成服务平台 - Travis"></a>持续集成服务平台 - Travis</h2><p>很多 PaaS 平台都提供了持续集成服务。Travis CI 是其中最著名的一个，对于开源项目可以免费使用。</p>
<p>每次跑测试时，Travis 提供的都是一个空白的环境。这个环境只有  Linux 基本的<code>build-essential</code>和<code>wget</code>、<code>git</code>那些依赖。连 Node.js 的运行时都是现跑现安装的。因为 Travis 默认带有的依赖都是每个用户的机器上都会有的，所以一旦应用能在 Travis 上跑通，别的用户就都能安装上。</p>
<p>Travis 的使用方法如下：</p>
<p>首先，在官网 <a href="https://travis-ci.org/" target="_blank" rel="external">https://travis-ci.org/</a> 注册后选择需要开启集成测试的仓库。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-046bd7b6765f890e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="travis.png"></p>
<p>然后，需要在项目的根目录放一份配置文件<code>.travis.yml</code>来告诉 Travis 需要用什么版本的 Node 跑，以及跑测试的命令等信息。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">//</span> <span class="string">一份简单的</span> <span class="string">.travis.yml</span></div><div class="line"></div><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet"> -</span> <span class="string">'4.2.5'</span></div><div class="line"><span class="bullet"> -</span> <span class="string">'7.5.0'</span></div><div class="line"></div><div class="line"><span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></div></pre></td></tr></table></figure>
<p>如果有用到数据库，则<code>.travis.yml</code>还需要添加一些内容。详细内容参考 <a href="https://docs.travis-ci.com/user/database-setup/" target="_blank" rel="external">Setting up Databases - Travis CI</a>。</p>
<p>之后将这份配置文件 push 上 github，Travis 就会被自动触发。下图是正在进行集成测试的 <a href="https://github.com/bighuang624/resume" target="_blank" rel="external">我的简历项目</a>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-b96ac611cef2c347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CItesting.png"></p>
<p>P.S. e2e 测试需要装 chrome 浏览器这个坑又出现了…简直阴魂不散。是不是要用 PhantomJS 才行啊…</p>
<p>我们先只跑单元测试好了。把<code>.travis.yml</code>更改一下：<code>script: npm run unit</code>，再 push 到 github 上。过一会就看到测试通过了。可以把 BlingBling 的 build 徽章加进项目的 README.md 中，来显示项目的构建状态了（徽章添加方案可见参考资料）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-c8621de29eb8b3c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="badage-sample.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作资料"><a href="#写作资料" class="headerlink" title="写作资料"></a>写作资料</h3><p><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成是什么？ - 阮一峰的网络日志</a></p>
<p><a href="https://juejin.im/post/599a3366518825241e221138" target="_blank" rel="external">为什么我们迫切需要持续集成？</a></p>
<p><a href="https://github.com/alsotang/node-lessons/tree/master/lesson13" target="_blank" rel="external">《持续集成平台：travis》</a></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://efe.baidu.com/blog/front-end-continuous-integration-tools/" target="_blank" rel="external">前端开源项目持续集成三剑客 | EFE Tech</a>：添加徽章步骤，可以说是非常具体了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文承接前端工程自动化入门系列的第一篇：&lt;a href=&quot;http://kyonhuang.top/start-front-end-test/&quot;&gt;《初探前端自动化测试–以 Vue 为例》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;传统开发模式中，项目经理等待所有模块都开发完成后再进行集成，出现 bug 则记录并分配责任人进行修改，之后再进行集成，直到通过测试为止持续循环。这个过程可能会出现如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bug 总在最后才被发现（尤其是模块之间的依赖导致的 bug），并且越到项目后期，随着项目规模的膨胀，bug 变得愈发难以修复；&lt;/li&gt;
&lt;li&gt;各个环节无效的等待时间较长，加上程序需要经常变更，导致软件交付时机无法保障；&lt;/li&gt;
&lt;li&gt;用户无法随时看到项目演示原型，满意度低。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决这些问题，&lt;strong&gt;“持续集成”（Continuous Integration）&lt;/strong&gt;的概念被提出。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端工程" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="持续集成" scheme="http://kyonhuang.top/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>用 Vue 撸一份线上简历有哪些坑</title>
    <link href="http://kyonhuang.top/make-a-resume/"/>
    <id>http://kyonhuang.top/make-a-resume/</id>
    <published>2017-08-21T04:52:16.000Z</published>
    <updated>2017-09-09T08:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。</p>
<ul>
<li>项目地址：<a href="https://github.com/bighuang624/resume" target="_blank" rel="external">bighuang624/resume
</a></li>
<li>在线预览地址：<a href="http://kyonhuang.top/resume/">http://kyonhuang.top/resume/</a></li>
</ul>
<p>目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。</p>
<a id="more"></a>
<h2 id="在-Vue-中使用-sass"><a href="#在-Vue-中使用-sass" class="headerlink" title="在 Vue 中使用 sass"></a>在 Vue 中使用 sass</h2><p>这个步骤之前已经总结过，现在再在博客上记录一次，方便之后查找。</p>
<p>在 Webpack 中，所有的预处理器需要匹配相应的 loader。因此要使用 sass 或 scss，首先下载依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sass-loader node-sass --save-dev</div></pre></td></tr></table></figure>
<p>然后在单文件组件中的<code>&lt;style&gt;</code>标签中加上<code>lang=&quot;sass&quot;</code>。<code>vue-loader</code>会根据<code>lang</code>属性推断出要使用的 loaders，并将内容交给相应的 loaders 处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style lang=&quot;sass&quot;&gt;</div><div class="line">  /* write sass here */</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>与名称相反，sass-loader 默认解析 scss 语法，因此如果想使用 sass 语法，还需要在 build/vue-loader.conf.js 配置 vue-loader 的选项：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-0e5c5d774fa3e00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:vue-loader.conf.png"></p>
<p>这样的修改不会影响 scss 的使用，记得修改<code>&lt;style&gt;</code>标签中为<code>lang=&quot;scss&quot;</code>即可。</p>
<h2 id="项目资源无法加载"><a href="#项目资源无法加载" class="headerlink" title="项目资源无法加载"></a>项目资源无法加载</h2><p>直接<code>npm run build</code>得到的项目，默认引用资源文件的路径为<code>/static/js/app.js</code>。所以程序若不在根目录下，就会出现资源文件引用错误的情况。</p>
<p>最简单的解决方案就是改动 webpack 的配置文件。将<code>/config</code>文件夹中的 index.js 文件中的<code>assetsPublicPath: &#39;/&#39;</code>改为<code>assetsPublicPath: &#39;./&#39;</code>即可，截图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-52590cfcce2b12ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config:index.png"></p>
<p>如果你还使用了 vue-router，你需要在 router 的配置中加上一行<code>base: &#39;/[项目所在文件夹的名字]/&#39;</code>，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e6de7fc323ef16e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router.png"></p>
<p>注意：如果启用了 vue-router 的 history 模式，你需要跟着 <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">vue-router 官方文档的后端配置例子</a> 对服务器进行一定的配置。</p>
<p>这是因为在 history 模式下，router 只是通过 JS 操作 window.history 来改变浏览器地址栏里的路径，并没有发起 http 请求。但是直接在地址栏中输入形如<code>http://www.example.com/example/item/1</code>这样的地址时，就一定先要对服务器发起 http 请求。此目标在服务器上不存在，于是会返回 404。修改服务器的配置，以将所有的请求全部转发到<code>index.html</code>上。</p>
<p>当然，这意味着单纯使用 Github Pages 的在线预览功能没办法进行这样的配置。你也可以关注知乎上的这个问题 <a href="https://www.zhihu.com/question/64173754" target="_blank" rel="external">怎样为Github pages Hack使用了vue-router history模式的vue应用？ - 知乎</a> 来看别人的解决方法。</p>
<h2 id="iconfont-无法加载"><a href="#iconfont-无法加载" class="headerlink" title="iconfont 无法加载"></a>iconfont 无法加载</h2><p>字体图标无法正确加载。参考 <a href="https://github.com/vuejs-templates/webpack/issues/166" target="_blank" rel="external">https://github.com/vuejs-templates/webpack/issues/166</a> ，得到的解决方法是修改 build/utils.js 文件，增加一行<code>publicPath: &#39;../../&#39;</code>，如截图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-4154f0ddd63f0953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:utils.png"></p>
<p>保存后，<code>npm run build</code>打包得到的项目中 iconfont 就可以正常显示了。</p>
<h2 id="实现-Github-Pages-在线预览"><a href="#实现-Github-Pages-在线预览" class="headerlink" title="实现 Github Pages 在线预览"></a>实现 Github Pages 在线预览</h2><p>参考 <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="external">Configuring a publishing source for GitHub Pages - User Documentation</a>，实现 Github Pages 在线预览功能有好几种方法，可以设置从<code>master</code>分支、<code>gh-pages</code>分支或者<code>master</code>分支下的<code>/docs</code>文件夹中读取。我就选择了最简单的一种方法，把<code>npm run build</code>打包下来的<code>/dist</code>文件夹改名为<code>/docs</code>。</p>
<p>之后，在 Github 项目主页的 Settings 下的 Github pages 下进行设置 Source 为<code>master branch /docs folder</code>即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-ec745a361c794183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="githubpage.png"></p>
<p>如果你之前使用过 Github Pages 并绑定了一个域名，那么这个项目的预览地址会像<code>http://kyonhuang.top/resume/</code>这样在这个域名下，看起来很爽。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://vue-loader.vuejs.org/zh-cn/configurations/pre-processors.html" target="_blank" rel="external">预处理器 · vue-loader</a></p>
<p><a href="http://upyang.com/2017/07/25/Vue项目上传github并预览/" target="_blank" rel="external">Vue项目打包上传到github预览</a></p>
<p><a href="https://www.zhihu.com/question/46630687/answer/157166318" target="_blank" rel="external">vuejs怎么在服务器部署？ - 知乎</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>撸这份简历，是一个总结，也是一个激励。</p>
<p>真正撸完简历，才发现自己在技术层面上的项目经历少的可怜，而技术也不敢说有什么掌握。以后看到这份简历，会让我非常想写一些拿得出手的开源项目，然后对项目经历进行修改。</p>
<p>读完《你不知道的JavaScript（中卷）》，就给 JS 的技能条涨 5 个百分点；用 Node 开发一个支持登录注册的后台，就给 Node 的技能条涨 5 个百分点；或者再点亮一个新的技能。</p>
<p>随着我的不断学习，希望这份简历越来越吸引人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;https://github.com/bighuang624/resume&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bighuang624/resume
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线预览地址：&lt;a href=&quot;http://kyonhuang.top/resume/&quot;&gt;http://kyonhuang.top/resume/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="开源小项目" scheme="http://kyonhuang.top/categories/%E5%BC%80%E6%BA%90%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="简历" scheme="http://kyonhuang.top/tags/%E7%AE%80%E5%8E%86/"/>
    
      <category term="Vue" scheme="http://kyonhuang.top/tags/Vue/"/>
    
      <category term="github 预览" scheme="http://kyonhuang.top/tags/github-%E9%A2%84%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>初探前端自动化测试--以 Vue 为例</title>
    <link href="http://kyonhuang.top/start-front-end-test/"/>
    <id>http://kyonhuang.top/start-front-end-test/</id>
    <published>2017-08-16T01:14:28.000Z</published>
    <updated>2017-08-24T08:49:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高；但对于稳定、多次复用以及需要长期维护的项目，自动化测试就尤为重要。</p>
<p>现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。</p>
<p>前端的测试类型分为<strong>单元测试（unit testing）</strong>、<strong>集成测试（integration testing）</strong>和<strong>端到端测试（e2e testing）</strong>。</p>
<ul>
<li><strong>单元测试</strong>将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作；</li>
<li><strong>集成测试</strong>是针对产品的某个功能的测试，又称功能测试；</li>
<li><strong>e2e 测试</strong>则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。</li>
</ul>
<a id="more"></a>
<h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>先绕点路，了解一下 TDD、BDD等<strong>以测试为导向的开发模式</strong>，有助于我们更深入地理解自动化测试。</p>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p>TDD（Test Driven Development），即<strong>测试驱动开发</strong>。其先针对每个功能点抽象出接口代码，然后编写单元测试用例代码。之后实现接口，运行单元测试代码进行测试，循环往复直至所有单元测试通过。</p>
<p>TDD 要求测试先于编写功能代码。测试用例不仅是对于代码的验证，更成为对代码的规范与约束，确保在开发以及未来进行修改时能够极大程度地保证该模块行为仍然是正确的。</p>
<h3 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h3><p>BDD（Behavior Driven Development），即<strong>行为驱动开发</strong>。BDD 和 TDD 一样，都要求先写测试，再写代码。可以认为 BDD 是 TDD 的一个子集或分支，是测试驱动开发的扩展。</p>
<p>TDD 基于开发者角度，重点测试函数的输入输出；而 BDD 更侧重于使用者角度，重点测试对用户行为的反应。</p>
<p>BDD 测试中，客户与开发者共同考虑系统该如何运行，然后用通用的语言抽象描述系统的行为，使得双方从技术层面和业务需求都能理解，避免沟通障碍。</p>
<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="测试管理工具"><a href="#测试管理工具" class="headerlink" title="测试管理工具"></a>测试管理工具</h3><p>用来组织和运行整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行被测试代码进行测试。</p>
<p>可选择的有 Karma、Selenium、Mocha（Mocha既是测试工具，也是测试框架）。</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>测试框架是单元测试的核心，提供了单元测试所需的各种API，并对测试用例分组。测试框架会抓取到代码抛出的 AssertionError 并提供附加信息。</p>
<p>选择较多，有名的有 Mocha、Jasmine等。不过 Mocha 既支持 TDD 也支持 BDD 的测试语法，Jasmine 只支持 BDD。</p>
<h3 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h3><p>断言库提供了很多语义化的方法来对值做各种判断。当然也可以不用断言库，Node.js 中也可以直接使用原生 assert 库。</p>
<p>可供选择的断言库也很多，包括 should.js、expect.js、chai.js等。</p>
<h3 id="测试浏览器"><a href="#测试浏览器" class="headerlink" title="测试浏览器"></a>测试浏览器</h3><p>前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持调用和运行本地浏览器来进行测试，但如果测试仅仅是针对函数和模块的单元测试，则完全可以使用一款无界面的 webkit 内核浏览器：PhantomJS。</p>
<h3 id="测试覆盖率统计工具"><a href="#测试覆盖率统计工具" class="headerlink" title="测试覆盖率统计工具"></a>测试覆盖率统计工具</h3><p>测试覆盖率工具为代码在语法级分支上打点，之后运行代码，并在运行结束后根据收集到的信息统计出当前测试用例对源码的覆盖情况。</p>
<p>一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。</p>
<h2 id="vue-cli-的配置"><a href="#vue-cli-的配置" class="headerlink" title="vue-cli 的配置"></a>vue-cli 的配置</h2><p>vue-cli 的 webpack 模版内置了开箱即用的 Karma + Jasmine 单元测试配置，以及 Nightwatch + Selenium E2E 测试配置，<code>npm run test</code>即可测试自带的一个初始测试用例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-50166ab65032fdd5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-unit-test.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-298692df753ab061.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-e2e-test.jpg"></p>
<p>有坑请注意：</p>
<ol>
<li>建议使用 cnpm 对 vue-cli 项目进行依赖安装，否则可能有些东西装不上。</li>
<li>自带的 e2e 测试要求装有 chrome 浏览器，否则报错<code>Error retrieving a new session from the selenium server</code>。我被这个坑折腾了半天…</li>
</ol>
<h2 id="开始编写测试代码"><a href="#开始编写测试代码" class="headerlink" title="开始编写测试代码"></a>开始编写测试代码</h2><p><a href="https://github.com/bighuang624/resume" target="_blank" rel="external">我的简历项目</a> 是我花了一天时间写的一个 vue-cli 初始化、只用了 Vue 的一个小项目，我们拿这个简单的小项目来入门测试代码的编写。我们直接利用 vue-cli 的初始配置，即用 Karma + Jasmine 进行单元测试，Nightwatch + Selenium 进行 E2E 测试。</p>
<p>你可以将我的项目 clone 下来进行测试代码的编写练习，不过项目里的测试代码可能已经因为更新而何下面的示例不一样了。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><code>/test/unit/index.js</code>中可以看到，单元测试的测试代码是<code>/specs</code>文件夹下以<code>.spec.js</code>结尾的文件。将自带的<code>Hello.spec.js</code>改写为<code>LeftNav.spec.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</div><div class="line"><span class="keyword">import</span> LeftNav <span class="keyword">from</span> <span class="string">'@/components/LeftNav'</span>;</div><div class="line"></div><div class="line">describe(<span class="string">'LeftNav.vue'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> Constructor = Vue.extend(LeftNav);</div><div class="line">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Constructor().$mount();</div><div class="line"></div><div class="line">  it(<span class="string">'should render correct name'</span>, () =&gt; &#123;</div><div class="line">    expect(vm.$el.querySelector(<span class="string">'.leftNav h1'</span>).textContent)</div><div class="line">      .to.equal(<span class="string">'Kyon Huang'</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'should render correct title'</span>, () =&gt; &#123;</div><div class="line">    expect(vm.$el.querySelector(<span class="string">'.leftNav h3'</span>).textContent)</div><div class="line">      .to.equal(<span class="string">'Web 开发工程师'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="E2E-测试"><a href="#E2E-测试" class="headerlink" title="E2E 测试"></a>E2E 测试</h3><p>同理，将<code>/test/e2e/specs/test.js</code>改写为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// For authoring Nightwatch tests, see</span></div><div class="line"><span class="comment">// http://nightwatchjs.org/guide#usage</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="string">'default e2e tests'</span>: <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">browser</span>) </span>&#123;</div><div class="line">    <span class="comment">// automatically uses dev Server port from /config.index.js</span></div><div class="line">    <span class="comment">// default: http://localhost:8080</span></div><div class="line">    <span class="comment">// see nightwatch.conf.js</span></div><div class="line">    <span class="keyword">const</span> devServer = browser.globals.devServerURL;</div><div class="line"></div><div class="line">    browser</div><div class="line">      .url(devServer)</div><div class="line">      .waitForElementVisible(<span class="string">'#app'</span>, <span class="number">5000</span>)</div><div class="line">      .assert.elementPresent(<span class="string">'.leftNav'</span>)</div><div class="line">      .assert.containsText(<span class="string">'h1'</span>, <span class="string">'Kyon Huang'</span>)</div><div class="line">      .assert.elementCount(<span class="string">'img'</span>, <span class="number">1</span>)</div><div class="line">      .end();</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-bd0c6382e613c281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unit-test-result.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-dbd1bfcc046e28fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e2e-test-result.png"></p>
<p>可以看到，我们的单元测试和 e2e 测试都通过了。不过单元测试的覆盖率有点低，只有 25%。如何写好测试代码，需要进一步的学习。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端工程自动化入门系列下一篇：<a href="http://kyonhuang.top/start-CI/">《再探前端自动化－持续集成》</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作资料"><a href="#写作资料" class="headerlink" title="写作资料"></a>写作资料</h3><p><a href="http://www.cnblogs.com/bigdataZJ/p/AutoTesting1.html" target="_blank" rel="external">开发人员看测试之TDD和BDD - JackieZheng - 博客园</a></p>
<p><a href="http://www.jianshu.com/p/6726c0410650" target="_blank" rel="external">前端自动化单元测试初探 - 简书</a></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://www.infoq.com/cn/articles/virtual-panel-tdd-bdd#" target="_blank" rel="external">虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发</a></p>
<p><a href="https://www.qcloud.com/community/article/743451001489391682" target="_blank" rel="external">PhantomJS 基础及示例 - 腾云阁 - 腾讯云</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高；但对于稳定、多次复用以及需要长期维护的项目，自动化测试就尤为重要。&lt;/p&gt;
&lt;p&gt;现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。&lt;/p&gt;
&lt;p&gt;前端的测试类型分为&lt;strong&gt;单元测试（unit testing）&lt;/strong&gt;、&lt;strong&gt;集成测试（integration testing）&lt;/strong&gt;和&lt;strong&gt;端到端测试（e2e testing）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单元测试&lt;/strong&gt;将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成测试&lt;/strong&gt;是针对产品的某个功能的测试，又称功能测试；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;e2e 测试&lt;/strong&gt;则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端工程" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="测试" scheme="http://kyonhuang.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6 的异步操作 - Generator 和 async</title>
    <link href="http://kyonhuang.top/Generator-and-async/"/>
    <id>http://kyonhuang.top/Generator-and-async/</id>
    <published>2017-08-03T10:10:53.000Z</published>
    <updated>2017-09-20T06:59:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：<strong>回调函数、事件监听器模式（发布/订阅模式）、流程控制库和 Promise/Deferred 模式</strong>。为了使异步操作更加清晰、简洁、方便，ES6 引入了 <strong>Generator 函数</strong>，而 ES2017 标准引入了 <strong>async 函数</strong>作为 Generator 函数的语法糖。</p>
<p>由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。</p>
<p>本博文在 <a href="http://kyonhuang.top/promise/">Promise 对象 | 大黄菌的个人博客</a> 之后食用最佳。</p>
<p><strong>注</strong>：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。</p>
<a id="more"></a>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-92dc7055c94c75cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Generator.png"></p>
<h3 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h3><p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为<strong>协程（coroutine）</strong>。</p>
<p>Generator 函数是 ES6 对协程的不完全实现，因为只有 Generator 函数的调用者才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<h3 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h3><p>Generator 是一个异步操作的容器。想让 Generator <strong>自动执行</strong>，即需要当异步操作有结果时能够自动交回执行权。两种方法：</p>
<ol>
<li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里交回执行权。</li>
<li>Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</li>
</ol>
<p>其中，JavaScript 中的 <strong>Thunk 函数</strong>指将多参数函数替换成的一个只接受回调函数作为参数的单参数函数。任何参数有回调函数的函数，都能写成 Thunk 函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6 版本的简单 Thunk 函数转换器</span></div><div class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前者的实现可用 Thunkify 模块，后者可用 co 模块。了解更多请看 <a href="http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0" target="_blank" rel="external">Generator 函数的异步应用 - ECMAScript 6入门</a>。暂时用不到的工具就不进一步消耗脑细胞了。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="通过-Generator-函数部署-Ajax-操作"><a href="#通过-Generator-函数部署-Ajax-操作" class="headerlink" title="通过 Generator 函数部署 Ajax 操作"></a>通过 Generator 函数部署 Ajax 操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">'http://some.url'</span>);</div><div class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</div><div class="line">  <span class="built_in">console</span>.log(resp.value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">  makeAjaxCall(url, (response) =&gt; &#123;</div><div class="line">    it.next(response);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = main();</div><div class="line">it.next();</div></pre></td></tr></table></figure>
<h4 id="使用-yield-语句遍历完全二叉树"><a href="#使用-yield-语句遍历完全二叉树" class="headerlink" title="使用 yield* 语句遍历完全二叉树"></a>使用 yield* 语句遍历完全二叉树</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.left = left;</div><div class="line">  <span class="keyword">this</span>.label = label;</div><div class="line">  <span class="keyword">this</span>.right = right;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 中序（inorder）遍历函数</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(t) &#123;</div><div class="line">    <span class="keyword">yield</span>* inoreder(t.left);</div><div class="line">    <span class="keyword">yield</span> t.label;</div><div class="line">    <span class="keyword">yield</span>* inorder(t.right);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成二叉树</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="comment">// 判断是否为叶节点</span></div><div class="line">  <span class="keyword">if</span>(array.length === <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</div><div class="line"></div><div class="line"><span class="comment">// 遍历二叉树</span></div><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> inoreder(tree))&#123;</div><div class="line">  result.push(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line">result</div><div class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></div></pre></td></tr></table></figure>
<h4 id="利用-Generator-函数部署-Iterator-接口"><a href="#利用-Generator-函数部署-Iterator-接口" class="headerlink" title="利用 Generator 函数部署 Iterator 接口"></a>利用 Generator 函数部署 Iterator 接口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    <span class="keyword">let</span> key = keys[i];</div><div class="line">    <span class="keyword">yield</span> [key, obj[key]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">bar</span>: <span class="number">7</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// foo 3</span></div><div class="line"><span class="comment">// bar 7</span></div></pre></td></tr></table></figure>
<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-532436b8fe3212f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="async+函数.png"></p>
<p>感觉前面的知识短时间内都消化不了，就没有看处于提案的异步遍历器。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h3 id="异步获取股票报价"><a href="#异步获取股票报价" class="headerlink" title="异步获取股票报价"></a>异步获取股票报价</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockStmbol(name);</div><div class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</div><div class="line">  <span class="keyword">return</span> stockPrice;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="并发发出远程请求"><a href="#并发发出远程请求" class="headerlink" title="并发发出远程请求"></a>并发发出远程请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInorder</span>(<span class="params">urls</span>) </span>&#123;</div><div class="line">  <span class="comment">// 并发读取远程 URL</span></div><div class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</div><div class="line">    <span class="keyword">return</span> response.text();</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="comment">// 按次序输出</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过学习，我感觉 async 函数真的为一组资源依次异步加载等实际开发场景提供了一种非常简便的处理方案。不过想要运用好 async 函数，深究其实现原理，就必须也要对 Generator 函数有清晰的认知。</p>
<p>异步编程不管是在浏览器还是在服务器端的开发都很重要，知识量也很大，一时半会大概消化不过来。在总结完这些知识后，还需要时常复习，并在实际开发过程中探索更好的实践。</p>
<h2 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a>：帮助加深对同步、异步执行机制的认识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：&lt;strong&gt;回调函数、事件监听器模式（发布/订阅模式）、流程控制库和 Promise/Deferred 模式&lt;/strong&gt;。为了使异步操作更加清晰、简洁、方便，ES6 引入了 &lt;strong&gt;Generator 函数&lt;/strong&gt;，而 ES2017 标准引入了 &lt;strong&gt;async 函数&lt;/strong&gt;作为 Generator 函数的语法糖。&lt;/p&gt;
&lt;p&gt;由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。&lt;/p&gt;
&lt;p&gt;本博文在 &lt;a href=&quot;http://kyonhuang.top/promise/&quot;&gt;Promise 对象 | 大黄菌的个人博客&lt;/a&gt; 之后食用最佳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="异步编程" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 入门笔记</title>
    <link href="http://kyonhuang.top/start-to-learn-NodeJS/"/>
    <id>http://kyonhuang.top/start-to-learn-NodeJS/</id>
    <published>2017-07-30T14:29:41.000Z</published>
    <updated>2017-09-02T01:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 <a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJS</a> 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。</p>
<p>在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。</p>
<p>虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。</p>
<p>更新记录：</p>
<ul>
<li>17.08.30 根据《深入浅出 Node.js》的笔记，对”NodeJS 应用领域及特点”部分进行文字补充。</li>
<li>17.09.02 根据《深入浅出 Node.js》的笔记，对”模块”部分进行文字补充。</li>
</ul>
<a id="more"></a>
<h2 id="NodeJS-应用领域及特点"><a href="#NodeJS-应用领域及特点" class="headerlink" title="NodeJS 应用领域及特点"></a>NodeJS 应用领域及特点</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-81b14861f2bc2943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Node.js+概念一览.png"></p>
<p>设计高性能 Web 服务器的要点：<strong>事件驱动、非阻塞 I/O</strong>。</p>
<p>Node 从 Ryan Dahl 一开始设想的 Web 服务器，发展成一个<strong>强制不共享任何资源的单线程、单进程系统</strong>，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施的<strong>网络应用平台</strong>。</p>
<h3 id="Node-与浏览器的异同"><a href="#Node-与浏览器的异同" class="headerlink" title="Node 与浏览器的异同"></a>Node 与浏览器的异同</h3><p>Chrome 浏览器除了 V8 作为 JavaScript 引擎外，还有一个 WebKit 布局引擎。</p>
<p>Node 的结构和 Chrome 十分相似，都是<strong>基于事件驱动的异步架构</strong>。浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。</p>
<h3 id="Node-的特点"><a href="#Node-的特点" class="headerlink" title="Node 的特点"></a>Node 的特点</h3><h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><h4 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h4><p>事件的编程方式具有<strong>轻量级</strong>、<strong>松耦合</strong>、<strong>只关注事务点</strong>等优势，但是在多个异步任务的场景下，各事件之间各自独立，如何协作是一个问题。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>保持了 JS 在浏览器中单线程的特点。在 Node 中，JS 与其余线程无法共享状态。</p>
<p>好处：</p>
<ol>
<li>不用在意状态同步问题；</li>
<li>没有死锁；</li>
<li>没有线程上下文交换带来的性能开销；</li>
</ol>
<p>弱点：</p>
<ol>
<li>无法利用多核 CPU；</li>
<li>错误会引起整个应用退出，应用的健壮性值得考验；</li>
<li>大量计算占用 COU 导致无法继续调用异步 I/O。</li>
</ol>
<p>浏览器端，Web Workers 能够创建工作线程进行计算。为了不阻塞主线程，工作线程采用<strong>消息传递</strong>的方式来传递运行结果，使得工作线程不能访问主线程的 UI。</p>
<p>Node 采用同样的思路解决单线程中大计算量的问题：<strong>child_process</strong>。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息传递结果。</p>
<p>子进程的出现，意味着 Node 可以从容应对单线程在健壮性和无法利用多核 CPU 方面的问题。</p>
<h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p>操作系统与 Node 上层模块之间构建了一层平台层架构，即<strong>libuv</strong>。</p>
<h3 id="Node-的应用场景"><a href="#Node-的应用场景" class="headerlink" title="Node 的应用场景"></a>Node 的应用场景</h3><h4 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h4><p>Node 面向网络且擅长并行 I/O，能够有效组织更多的硬件资源。</p>
<p>I/O 密集的优势在于<strong>Node 利用事件循环的处理能力</strong>（而非为每一个服务启动一个线程），资源占用极少。</p>
<h4 id="不擅长-CPU-密集型业务？"><a href="#不擅长-CPU-密集型业务？" class="headerlink" title="不擅长 CPU 密集型业务？"></a>不擅长 CPU 密集型业务？</h4><p>由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将导致 CPU 时间片不能释放，使得后续 I/O 无法发起。<strong>适当调整和分解大型运算任务</strong>能使运算适时释放，不阻塞 I/O 调用的发起。</p>
<h4 id="与遗留系统和平共处"><a href="#与遗留系统和平共处" class="headerlink" title="与遗留系统和平共处"></a>与遗留系统和平共处</h4><p>可以将稳定的旧有系统作为后端接口与中间件，而让 Node 将该数据源作为数据接口，发挥异步并行的优势。</p>
<h4 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h4><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a1f50c7c0c750605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模块.png"></p>
<h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ol>
<li>大大提高代码的可维护性；</li>
<li>可以随时引用；</li>
<li>避免函数名和变量名冲突；</li>
</ol>
<h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><p>CommonJS 主要是在 <strong>Node 服务器端</strong>的规范。意义在于将类聚的方法与变量限定在私有的作用域中，使得用户完全不必考虑变量污染。</p>
<p>CommonJS 对模块的定义主要分为模块引用、模块定义、模块标识三个部分：</p>
<h4 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h4><p>一个模块要引用其他模块暴露的变量，用<code>var foo = require(&#39;module_name&#39;)</code>就拿到了引用模块的变量。</p>
<h4 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h4><p>上下文提供了 <strong>exports 对象</strong>用于导出当前模块的方法或者变量，并且它是唯一的出口。</p>
<p>在模块中，还存在一个 <strong>module 对象</strong>，代表<strong>模块自身</strong>，而 exports 是 module 的<strong>属性</strong>。</p>
<p>一个模块要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>。</p>
<h4 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h4><p>即传递给<code>require()</code>方法的参数。</p>
<h3 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h3><p>在 Node 中引入模块，需要经历如下三个步骤：</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<p>在 Node 中，模块分为 Node 提供的<strong>核心模块</strong>和用户编写的<strong>文件模块</strong>。</p>
<p><strong>核心模块</strong>部分在 Node 源代码的编译过程中，编译进了<strong>二进制执行文件</strong>。在 Node 进程启动时，部分核心模块就直接加载进内存中。因此可以省略文件定位和编译执行两个步骤，且在路径分析中优先判断，<strong>加载速度最快</strong>。</p>
<p><strong>文件模块</strong>在<strong>运动时动态加载</strong>，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</p>
<h4 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h4><p><strong>模块加载会有缓存</strong>，且其根据<strong>绝对路径识别</strong>。因此同样的模块名放在不同的路径之中多次 require 不会重新加载。</p>
<p>Node 对引入过的模块都会以<strong>编译和执行后的对象</strong>的形式进行缓存。核心模块和文件模块都采用缓存优先进行二次加载，核心模块的缓存检查先于文件模块。</p>
<h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h4><p><strong>模块路径</strong>是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。</p>
<p>其生成规则为从当前文件目录下的 node_modules 目录开始，沿路径向上逐级递归，直到根目录下的 node_modules 目录。</p>
<p>Node 在当前目录下查找 package.json，通过<code>JSON.parse()</code>解析出包描述对象，从中取出<code>main</code>属性制定的文件名进行定位。</p>
<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><ul>
<li>.js 文件。通过 fs 模块同步读取文件后编译执行。</li>
<li>.node 文件。这是用 C/C++ 编写的扩展文件，通过<code>dlopen()</code>方法加载最后编译生成的文件。</li>
<li>.json 文件。通过 fs 模块同步读取文件后，用<code>JSON.parse()</code>解析返回结果。</li>
<li>其余扩展名。它们都被当作 .js 文件载入。</li>
</ul>
<p>每一个编译成功的模块都会将其<strong>文件路径作为索引</strong>缓存在 <strong>Module._cache 对象</strong>上，以提高二次引入的性能。</p>
<p><strong>如果要达成 require 引入一个类的效果，请赋值给 module.exports 对象。</strong></p>
<h3 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h3><p>浏览器端的 JavaScript 需要经历从同一个服务器端分发到多个客户端执行，瓶颈在于<strong>带宽</strong>；而服务器端 JavaScript 则是相同的代码需要多次执行，瓶颈在于 <strong>CPU 和内存等资源</strong>。</p>
<p>CommonJS 是<strong>同步加载</strong>的，在服务器端模块文件一般存放在本地，再加上有缓存，加载速度很快。而在浏览器端就可能导致“假死”，因此浏览器端采用另一种异步加载方式 - AMD（Asynchronous Module Definition，异步模块定义）规范。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> exports = &#123;&#125;</div><div class="line">  exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Hello from module: '</span> + <span class="built_in">module</span>.id)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> exports</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到 AMD 的模块定义与 Node 模块相似，不同之处在于 <strong>AMD 模块需要用</strong><code>define</code><strong>来明确定义一个模块</strong>，而在 Node 实现中是隐式包装的；以及内容需要通过<strong>返回</strong>的方式实现导出。</p>
<p>想要进一步了解，可参考 <a href="www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">Javascript模块化编程（二）：AMD规范 - 阮一峰的网络日志</a>。</p>
<h3 id="深入了解模块原理"><a href="#深入了解模块原理" class="headerlink" title="深入了解模块原理"></a>深入了解模块原理</h3><p>Node.js 的“模块”功能利用了 JavaScript 函数式编程的特性，通过<strong>闭包</strong>实现。</p>
<h2 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-829fee6dc736dbd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码的组织和部署.png"></p>
<h3 id="包描述文件中的部分属性"><a href="#包描述文件中的部分属性" class="headerlink" title="包描述文件中的部分属性"></a>包描述文件中的部分属性</h3><ul>
<li>maintainers。包维护者列表，npm 通过该属性进行权限认证。</li>
<li>bin。将包作为命令行工具使用，需配置好 bin 字段，通过<code>npm install package_name -g</code>命令将脚本添加到执行路径中。之后可以在命令行中直接执行。例如：<code>&quot;bin&quot;: { &quot;express&quot;: &quot;./bin/express&quot; }</code></li>
</ul>
<h3 id="全局模式安装"><a href="#全局模式安装" class="headerlink" title="全局模式安装"></a>全局模式安装</h3><p><code>-g</code>将一个包安装为全局可用的可执行命令。通过全局模式安装的所有模块包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.resolve(process.execPath, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'lib'</span>, <span class="string">'node_modules'</span>);</div></pre></td></tr></table></figure>
<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a0e8821626a2e3cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本模块.png"></p>
<p>Node.js 内置的常用模块是为了实现基本的服务器功能，底层代码是用 C/C++ 在 Node.js 运行环境中实现。</p>
<h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>Node.js 环境中唯一的全局变量。</p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>代表当前 Node.js 进程。</p>
<h3 id="判断-JavaScript-执行环境"><a href="#判断-JavaScript-执行环境" class="headerlink" title="判断 JavaScript 执行环境"></a>判断 JavaScript 执行环境</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(<span class="built_in">window</span>) === <span class="string">'undefined'</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'node.js'</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'browser'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-f46374c76abbbe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件操作.png"></p>
<h3 id="不同系统下路径的标准化"><a href="#不同系统下路径的标准化" class="headerlink" title="不同系统下路径的标准化"></a>不同系统下路径的标准化</h3><p>标准化之后的路径里的斜杠在 Windows 系统下是<code>\</code>，而在 Linux 系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径。</p>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步遍历获取某一文件夹下的所有文件，用 callback 处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>)</span>&#123;</div><div class="line">  fs.readdirSync(dir).forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> pathname = path.join(dir, file);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(fs.statSync(pathname).isDirectory())&#123;</div><div class="line">      travel(pathname, callback)；</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback(pathname);</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 异步遍历</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback, finish</span>)</span>&#123;</div><div class="line">  fs.readdir(dir, (err, files) =&gt; &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(i &lt; files.length) &#123;</div><div class="line">        <span class="keyword">var</span> pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">        fs.stat(pathname, (err, stats) =&gt; &#123;</div><div class="line">          <span class="keyword">if</span>(stats.isDirectory())&#123;</div><div class="line">            travel(pathname, callback, () =&gt; &#123;</div><div class="line">              next(i + <span class="number">1</span>);</div><div class="line">            &#125;);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            callback(pathname, () =&gt; &#123;</div><div class="line">              next(i + <span class="number">1</span>);</div><div class="line">            &#125;)</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        finish &amp;&amp; finish();</div><div class="line">      &#125;</div><div class="line">    &#125;)(<span class="number">0</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-439f836f1c5033bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络操作.png"></p>
<h3 id="监听端口的权限问题"><a href="#监听端口的权限问题" class="headerlink" title="监听端口的权限问题"></a>监听端口的权限问题</h3><p>在 Linux 系统下，监听 1024 以下端口需要 root 权限。因此，如果想监听 80 或 443 端口的话，需要使用 sudo 命令启动程序。</p>
<h3 id="URL-的完整组成"><a href="#URL-的完整组成" class="headerlink" title="URL 的完整组成"></a>URL 的完整组成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                           href</div><div class="line"> -----------------------------------------------------------------</div><div class="line">                            host              path</div><div class="line">                      --------------- ----------------------------</div><div class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</div><div class="line"> -----    ---------   --------   ---- -------- ------------- -----</div><div class="line">protocol     auth     hostname   port pathname     search     hash</div><div class="line">                                                ------------</div><div class="line">                                                   query</div></pre></td></tr></table></figure>
<h3 id="网络操作常见问题"><a href="#网络操作常见问题" class="headerlink" title="网络操作常见问题"></a>网络操作常见问题</h3><ul>
<li><p>问： 为什么通过<code>headers</code>对象访问到的 HTTP 请求头或响应头字段不是驼峰的？</p>
<p>  答： 从规范上讲，HTTP 请求头和响应头字段都应该是驼峰的。但现实中不是每个 HTTP 服务端或客户端程序都严格遵循规范，所以 NodeJS 在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers[&#39;content-length&#39;]</code>。</p>
</li>
<li><p>问： 为什么<code>http</code>模块创建的 HTTP 服务器返回的响应是<code>chunked</code>传输方式的？</p>
<p>  答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用<code>.end</code>方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后 NodeJS 就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>
</li>
<li><p>问： 为什么使用<code>http</code>模块发起 HTTP 客户端请求时，有时候会发生<code>socket hang up</code>错误？</p>
<p>  答： 发起客户端 HTTP 请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许5个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过<code>https.globalAgent.maxSockets</code>属性来处理。</p>
</li>
</ul>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-d48f8689170c4f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程管理.png"></p>
<h3 id="降权"><a href="#降权" class="headerlink" title="降权"></a>降权</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 降权</span></div><div class="line">http.createServer(callback).listen(<span class="number">80</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">var</span> env = process.env,</div><div class="line">      uid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_UID'</span>] || process.getuid(), <span class="number">10</span>);</div><div class="line">      gid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_GID'</span>] || process.getgid(), <span class="number">10</span>);</div><div class="line"></div><div class="line">  process.setgid(gid);</div><div class="line">  process.setuid(uid);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li><p>如果是通过<code>sudo</code>获取 root 权限的，运行程序的用户的 UID 和 GID 保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取 root 权限的，运行程序的用户的 UID 和 GID 可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</p>
</li>
<li><p><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</p>
</li>
<li><p>降权时必须先降 GID 再降 UID，否则顺序反过来的话就没权限更改程序的 GID 了。</p>
</li>
</ol>
<h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><p>如果父子进程都是 NodeJS 进程，就可以通过 IPC（进程间通讯）双向传递数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* parent.js */</span></div><div class="line"><span class="comment">// 在 options.stdio 字段中通过 ipc 开启一条 IPC 通道</span></div><div class="line"><span class="keyword">var</span> child = child_process.spawn(<span class="string">'node'</span>, [<span class="string">'child.js'</span>], &#123;</div><div class="line">  <span class="attr">stdio</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'ipc'</span>]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(<span class="string">'message'</span>, (msg) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(msg);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 给子进程发送消息</span></div><div class="line">child.send(&#123; <span class="attr">hello</span>: <span class="string">'hello'</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">/* child.js */</span></div><div class="line">process.on(<span class="string">'message'</span>, (msg) =&gt; &#123;</div><div class="line">  msg.hello = msg.hello.toUpperCase();</div><div class="line">  process.send(msg);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 守护子进程</span></div><div class="line"><span class="comment">/* daemon.js */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">mainModule</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> worker = child_process.spawn(<span class="string">'node'</span>, [mainModule]);</div><div class="line"></div><div class="line">  worker.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(code !== <span class="number">0</span>)&#123;</div><div class="line">      spawn(mainModule);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(<span class="string">'worker.js'</span>);</div></pre></td></tr></table></figure>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-57c2d4c89e36c4d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步编程.png"></p>
<h3 id="domain-捕获异常"><a href="#domain-捕获异常" class="headerlink" title="domain 捕获异常"></a>domain 捕获异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">request, callback</span>)</span>&#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">  asyncA(request, (data) =&gt; &#123;</div><div class="line">    <span class="comment">// Do something</span></div><div class="line">    asyncB(request, (data) =&gt; &#123;</div><div class="line">      <span class="comment">// Do something</span></div><div class="line">      asyncC(request, (data) =&gt; &#123;</div><div class="line">        <span class="comment">// Do something</span></div><div class="line">        callback(data);</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">var</span> d = domain.create();</div><div class="line"></div><div class="line">  d.on(<span class="string">'error'</span>, () =&gt; &#123;</div><div class="line">    response.writeHead(<span class="number">500</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  d.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">async</span>(request, (data) =&gt; &#123;</div><div class="line">      response.writeHead(<span class="number">200</span>);</div><div class="line">      response.end(data);</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了 C/C++ 部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是 JS 本身的异常，不用担心上述问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJS 的学习其实主要分为三块：</p>
<ol>
<li>JavaScript 语言本身。要学会借助 <a href="https://www.ecma-international.org/publications/standards/Standard.htm" target="_blank" rel="external">ECMAScript 规范</a> 加深自己的理解。</li>
<li>NodeJS 的 API。要熟悉官方 API 文档，主要是熟悉 NodeJS 提供的功能以及知道该查询文档的哪块地方。不推荐死记硬背，因为新版本会更改和弃用部分 API。</li>
<li>生态圈中的各种三方库。要学习检索、过滤、去其糟粕取其精华，利用但不迷信。</li>
</ol>
<p>而在 NodeJS 开发时，首先要有一个全局的设计，再再实现的过程中对之间忽略掉的细节进行设计上的改进，为二次迭代做准备。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>除开文章开头提到的资料，结语部分参考了 <a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=1&amp;sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&amp;chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&amp;mpshare=1&amp;scene=1&amp;srcid=0727qbaSu9gx8oduOdFPTUoU#" target="_blank" rel="external">当我们学习 Node.js 时，我们在学习什么？</a>。</p>
<h3 id="下一步学习"><a href="#下一步学习" class="headerlink" title="下一步学习"></a>下一步学习</h3><p><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="external">《Node.js 包教不包会》 by alsotang</a></p>
<p>《深入浅出Node.js》</p>
<p>自己撸个爬虫</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 &lt;a href=&quot;http://nqdeng.github.io/7-days-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;七天学会NodeJS&lt;/a&gt; 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。&lt;/p&gt;
&lt;p&gt;在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。&lt;/p&gt;
&lt;p&gt;虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。&lt;/p&gt;
&lt;p&gt;更新记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;17.08.30 根据《深入浅出 Node.js》的笔记，对”NodeJS 应用领域及特点”部分进行文字补充。&lt;/li&gt;
&lt;li&gt;17.09.02 根据《深入浅出 Node.js》的笔记，对”模块”部分进行文字补充。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NodeJS 学习笔记" scheme="http://kyonhuang.top/categories/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="脑图" scheme="http://kyonhuang.top/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>《你不知道的 JavaScript（上卷）》脑图</title>
    <link href="http://kyonhuang.top/You-Dont-Know-JS-notes-1/"/>
    <id>http://kyonhuang.top/You-Dont-Know-JS-notes-1/</id>
    <published>2017-07-27T08:47:12.000Z</published>
    <updated>2017-07-27T12:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。</p>
  <a id="more"></a>
<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作用域和闭包.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">作用域和闭包.png</a></p>
<h2 id="this-和对象原型"><a href="#this-和对象原型" class="headerlink" title="this 和对象原型"></a>this 和对象原型</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="this和对象原型.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">this和对象原型.png</a></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>补一张来自 <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">JavaScript深入之从原型到原型链</a>  的图，来直观地表现原型链。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-d73fdcc0c25efd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链.png"></p>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="脑图" scheme="http://kyonhuang.top/tags/%E8%84%91%E5%9B%BE/"/>
    
      <category term="《你不知道的 JavaScript》" scheme="http://kyonhuang.top/tags/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JavaScript%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>初探人工智能</title>
    <link href="http://kyonhuang.top/start-to-know-AI/"/>
    <id>http://kyonhuang.top/start-to-know-AI/</id>
    <published>2017-07-23T02:17:25.000Z</published>
    <updated>2017-09-24T03:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？</p>
<ol>
<li>发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。</li>
<li>随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。</li>
<li>确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。</li>
</ol>
<p>何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。</p>
<p>这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。</p>
<p>不要拒绝未来的任何可能性。</p>
<a id="more"></a>
<h2 id="相关概念脑图"><a href="#相关概念脑图" class="headerlink" title="相关概念脑图"></a>相关概念脑图</h2><p>一直感觉纯文字的笔记比较难以记忆，导致自己的学习吸收率不高。看到别人的读书笔记是总结了一张脑图，条理比较清晰。这里也试着用 Xmind 总结一张相关概念的脑图（P.S.使用感觉百度脑图比 Xmind 条理清晰+好用）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a64a6eb143122930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="人工智能相关概念.png"></p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>学习算法的输入数据，叫<strong>“训练数据”</strong>。训练数据的每一行称为一个<strong>“训练样本”（Training Sample）</strong>，通常简称“样本”（Sample）。</p>
<p>样本的各种属性称为<strong>“特征”（Feature）</strong>。而希望学得的模型可以用来预判的信息称为样本的<strong>“标注”（Label）</strong>。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>机器学到的模型是一个映射。</p>
<h3 id="映射的输入"><a href="#映射的输入" class="headerlink" title="映射的输入"></a>映射的输入</h3><p>每个样本 xi 的特征组成一个<strong>“特征向量” (Feature Vector)</strong>。所有特征向量的集合就是总的输入集合，称为<strong>“样本空间” (Sample Space)</strong>。</p>
<h3 id="映射的输出"><a href="#映射的输出" class="headerlink" title="映射的输出"></a>映射的输出</h3><p>第 i 个样本的标注记作 yi。同理有<strong>“标注空间”(Label Space)</strong>。</p>
<h3 id="映射的表示"><a href="#映射的表示" class="headerlink" title="映射的表示"></a>映射的表示</h3><p>机器学习模型就是输入空间 X 到输出空间 Y 的一个映射，将映射用符号 g 表示，则模型记作 g: X -&gt; Y。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><strong>学习算法 (Learning Algorithm)</strong> 根据训练数据，从<strong>假设集合 (Hypothesis Set) </strong>中选出最优的那个映射 g 作为最终学得的模型，使得 g 越接近上帝真相 f 越好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>不是所有的机器学习问题都需要标注。根据训练数据是否有标注，机器学习问题大致划分为<strong>监督学习（Supervised Learning）</strong>和<strong>无监督学习（Unsupervised Learning）</strong>两大类（还有半监督学习、增强学习等）。</p>
<ul>
<li>监督学习：每个输入样本都<strong>有标注</strong>。大致分成两类：<ol>
<li><strong>分类（Classification）</strong>问题：标注是<strong>离散值</strong>，比如用户”点击“和”不点击“。如果标注只有两个值，则称为二分类，如果标注有多个值，则称为多分类。</li>
<li><strong>回归（Regression）</strong>问题：标注是<strong>连续值</strong>，比如如果问题是预测北京市房屋的价格，价格作为标注就是一个连续值，属于回归问题。</li>
</ol>
</li>
<li>无监督学习：训练样本<strong>不需要标注</strong>。这类模型试图学习或是提取数据背后的结构，或从中抽取最为重要的特征。无监督学习解决的典型问题是<strong>聚类（clustering）问题</strong>，比如对一个网站的用户进行聚类，根据用户特征进行分组，看看这个网站用户的大致构成，分析下每类用户群的特点是什么。</li>
</ul>
<p>以上总结为脑图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e14be3cf5133d5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="机器学习.png"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>把听上去最高端的“神经网络”放到最后介绍。</p>
<h3 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h3><p>一组大致模仿人类大脑构造设计的算法，用于识别模式。神经网络通过机器感知系统解释传感器数据，能够对原始输入进行标记或聚类等操作。</p>
<p>神经网络所能识别的模式是数值形式，因此图像、声音、文本、时间序列等一切现实世界的数据必须转换为数值。</p>
<h3 id="感知器、权重与阈值"><a href="#感知器、权重与阈值" class="headerlink" title="感知器、权重与阈值"></a>感知器、权重与阈值</h3><p>大家都在高中的生物课上学过，人类大脑思考的基础是神经元（神经细胞）。如果能够人工制造神经元，就能组成人工神经网络来模拟思考。</p>
<p>上世纪六十年代，科学家们提出了最早的“人造神经元”，并将其称为<strong>“感知器”（perceptron）</strong>。感知器接受一些因素，这些因素根据不同的重要性（决定性因素与次要因素）获得不同的<strong>权重（weight）</strong>。因素的条件成立为 1，不成立为 0，乘以权重的总和大于指定的<strong>阈值（threshold）</strong>，感知器便输出 11，否则输出 0。</p>
<h3 id="决策模型"><a href="#决策模型" class="headerlink" title="决策模型"></a>决策模型</h3><p>单个的感知器构成一个简单的决策模型。而实际的决策模型是由多个感知器组成的多层网络。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png" alt="多层网络"></p>
<p>每一个节点层在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂，因为每一层会整合并重组前一层的特征。</p>
<p>而在“递归神经网络”中，上下层的感知器的输入与输出还可能发生循环传递。</p>
<h3 id="神经网络运作过程"><a href="#神经网络运作过程" class="headerlink" title="神经网络运作过程"></a>神经网络运作过程</h3><p>一个神经网络的搭建，需要满足三个条件：</p>
<ol>
<li>输入和输出</li>
<li>权重（w）和阈值（b）</li>
<li>多层感知器的结构</li>
</ol>
<p>最困难的部分就是确定权重和阈值。我们通过试错法，即保证其他参数不变，对 w 或 b 进行微小变动，然后观察输出的变化。通过不断重复这个过程来得到最精确的那组 w 和 b。这个过程即被称为<strong>模型的训练</strong>。</p>
<p>因此，神经网络的运作过程如下：</p>
<ol>
<li>确定输入和输出</li>
<li>找到一种或多种算法，可以从输入得到输出</li>
<li>找到一组已知答案的数据集，用来训练模型，估算 w 和 b</li>
<li>一旦新的数据产生，输入模型，就可以得到结果，同时对 w 和 b 进行校正</li>
</ol>
<p>整个过程需要海量计算，所以需要使用专门为机器学习定制的 GPU。</p>
<h3 id="输出的连续性"><a href="#输出的连续性" class="headerlink" title="输出的连续性"></a>输出的连续性</h3><p>为了保证模型的敏感，要将 0、1 输出改造为连续性函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">z = wx + b</div><div class="line">σ(z) = 1 / (1 + e^(-z))</div></pre></td></tr></table></figure>
<p>这样，当 z 趋向正无穷（表示感知器强烈匹配）时，σ(z) → 1；如果 z 趋向负无穷（表示感知器强烈不匹配），σ(z) → 0。</p>
<p>同时，Δσ 满足下面的公式：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png" alt="Δσ 公式"></p>
<p>即 Δσ 和 Δw 和 Δb 之间是线性关系，变化率是偏导数。这就有利于精确推算出 w 和 b 的值了。</p>
<h2 id="基于-JavaScript-的机器学习"><a href="#基于-JavaScript-的机器学习" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h2><p>尽管确实是第一选择，机器学习不一定要用 Python。为什么不试试神奇的 JavaScript 呢？</p>
<p>JavaScript 开发者们已经开源了不少基于 Node.js 的机器学习库：</p>
<ol>
<li><a href="https://github.com/harthur-org/brain.js" target="_blank" rel="external">brain.js</a> (神经网络)</li>
<li><a href="https://github.com/cazala/synaptic" target="_blank" rel="external">Synaptic</a> (神经网络)</li>
<li><a href="https://github.com/NaturalNode/natural" target="_blank" rel="external">Natural</a> (自然语言处理)</li>
<li><a href="http://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="external">ConvNetJS</a> (卷积神经网络)</li>
<li><a href="https://github.com/mljs" target="_blank" rel="external">mljs</a> (一系列具有多个函数方法的 AI 库)</li>
<li>Neataptic (神经网络)</li>
<li><a href="https://github.com/mil-tokyo/webdnn" target="_blank" rel="external">Webdnn</a> (深度学习)</li>
</ol>
<p>你可以从 github 的这个项目：<a href="https://github.com/abhisheksoni27/machine-learning-with-js" target="_blank" rel="external">abhisheksoni27/machine-learning-with-js</a> 中获得一些实例的源码，目前作者实现了线性规划和 KNN 算法。你也可以在参考资料的对应章节找到翻译版本进行阅读。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>emmm，如果你看了之后的参考资料中的每一篇，你会发现这篇博文只是一个拙劣的归纳总结。这是因为我确实对相关领域没有什么了解。但我对此兴致勃勃，也已经关注了不少数据挖掘和机器学习的知乎专栏及收藏夹。希望自己将来会有相关方面有价值的产出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="相关概念部分"><a href="#相关概念部分" class="headerlink" title="相关概念部分"></a>相关概念部分</h3><ul>
<li><a href="http://blog.csdn.net/feichizhongwu888/article/details/52727958" target="_blank" rel="external">简单理解：人工智能、数据挖掘、模式识别、机器学习、深度学习 - feichizhongwu888的博客 - CSDN博客</a></li>
<li><a href="http://36kr.com/p/5052482.html" target="_blank" rel="external">一篇文章讲清楚人工智能、机器学习和深度学习的区别</a></li>
</ul>
<h3 id="数据、模型部分"><a href="#数据、模型部分" class="headerlink" title="数据、模型部分"></a>数据、模型部分</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25439997" target="_blank" rel="external">写给大家看的机器学习书（第二篇） - 知乎专栏</a></li>
</ul>
<h3 id="神经网络部分"><a href="#神经网络部分" class="headerlink" title="神经网络部分"></a>神经网络部分</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank" rel="external">神经网络入门 - 阮一峰的网络日志</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25358695" target="_blank" rel="external">写给大家看的机器学习书（第三篇）</a></li>
</ul>
<h3 id="基于-JavaScript-的机器学习-1"><a href="#基于-JavaScript-的机器学习-1" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h3><ul>
<li><a href="https://blog.fundebug.com/2017/07/03/javascript-machine-learning-regression/" target="_blank" rel="external">JavaScript机器学习之线性回归</a></li>
<li><a href="https://blog.fundebug.com/2017/07/10/javascript-machine-learning-knn/" target="_blank" rel="external">JavaScript机器学习之KNN算法</a></li>
</ul>
<h3 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h3><ul>
<li><a href="http://www.cnblogs.com/subconscious/p/5058741.html" target="_blank" rel="external">神经网络浅讲：从神经元到深度学习</a></li>
<li><a href="https://yanqiangmiffy.github.io/2017/07/26/Python28-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BD%BF%E7%94%A8Python%E5%92%8CR%E4%BB%A3%E7%A0%81%EF%BC%89/" target="_blank" rel="external">机器学习算法的基本知识（使用Python和R代码）</a>：带有 Python 和 R 语言代码实例</li>
<li><a href="https://exacity.github.io/deeplearningbook-chinese/" target="_blank" rel="external">Deep Learning 中文翻译</a></li>
<li><a href="http://blog.csdn.net/baihuaxiu123/article/details/69488610" target="_blank" rel="external">[机器学习]机器学习笔记整理全解</a></li>
<li><a href="https://zhuanlan.zhihu.com/dteratech" target="_blank" rel="external">DT新纪元 - 知乎专栏</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。&lt;/p&gt;
&lt;h2 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么&quot;&gt;&lt;/a&gt;为什么&lt;/h2&gt;&lt;p&gt;为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。&lt;/li&gt;
&lt;li&gt;随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。&lt;/li&gt;
&lt;li&gt;确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。&lt;/p&gt;
&lt;p&gt;这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。&lt;/p&gt;
&lt;p&gt;不要拒绝未来的任何可能性。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习笔记" scheme="http://kyonhuang.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人工智能" scheme="http://kyonhuang.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://kyonhuang.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://kyonhuang.top/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>暑假计划进行中</title>
    <link href="http://kyonhuang.top/summer-plan/"/>
    <id>http://kyonhuang.top/summer-plan/</id>
    <published>2017-07-05T13:42:53.000Z</published>
    <updated>2017-08-06T00:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>出征前內心忐忑<br>鋒利的匕首反握<br>準備殺死對手前先讓我來殺死懶惰</p>
<p>— 艾福杰尼 / Killa4nia《酒精》</p>
</blockquote>
<p>简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感兴趣的知识，并且认真做学习笔记和总结。</p>
<p>07.20 更新：暑假已经过去了半个月。对暑期计划进行一些变更使其更加合理。最重要的是提高效率。</p>
<p>08.06 更新：暑假快过了 2/3 了，对计划进行一些修正。</p>
<h4 id="读书计划（脑图整理知识点）"><a href="#读书计划（脑图整理知识点）" class="headerlink" title="读书计划（脑图整理知识点）"></a>读书计划（脑图整理知识点）</h4><p>[Finished] 7月23日为 deadline，看完《你不知道的 JavaScript（上卷）》。</p>
<p>8月8日为deadline， 看完《你不知道的 JavaScript（中卷）》。</p>
<p>8月读《Node.js 深入浅出》。</p>
<p>争取暑假读完《JavaScript 设计模式与开发实践》。</p>
<h4 id="整个暑假："><a href="#整个暑假：" class="headerlink" title="整个暑假："></a>整个暑假：</h4><ul>
<li>每天 12 点前睡觉，8 点前起床。</li>
<li>前端各类练习题。每天 2 - 3 道原生 js 实例题。学累了刷刷 <a href="https://www.nowcoder.com/5257175" target="_blank" rel="external">牛客网</a>。</li>
<li>每天 2 面六级单词。</li>
</ul>
<h4 id="想做的练习："><a href="#想做的练习：" class="headerlink" title="想做的练习："></a>想做的练习：</h4><ul>
<li><a href="http://www.cnblogs.com/coco1s/p/6802374.html" target="_blank" rel="external">谈谈一些有趣的CSS题目</a></li>
<li><a href="http://www.fgm.cc/learn/" target="_blank" rel="external">原生JavaScript学习-实例索引</a></li>
<li><a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a>［可缓］</li>
</ul>
<h4 id="七月："><a href="#七月：" class="headerlink" title="七月："></a>七月：</h4><ul>
<li>写花旗杯项目前端。</li>
<li>Vue 全家桶及相关技术实践。</li>
</ul>
<h4 id="八月："><a href="#八月：" class="headerlink" title="八月："></a>八月：</h4><ul>
<li>Node.js学习。首先是廖雪峰的入门教程，争取一天看完 [08.06：koa 有点难理解…先从 express 学习好了]。接下来选一本书看看（据说朴灵的《Node.js 深入浅出》不错…）</li>
<li>完成一个类似 <a href="https://juejin.im/post/59857c616fb9a03c5c6ffa91" target="_blank" rel="external">带你用 Vue 全家桶和 Node.js 完成一个聚合应用</a> 的 demo。</li>
<li>如果还有时间，试试 Electron 或者 <a href="https://lavas.baidu.com/guide" target="_blank" rel="external">Lavas</a></li>
</ul>
<p>天下武功，唯勤不破！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;出征前內心忐忑&lt;br&gt;鋒利的匕首反握&lt;br&gt;準備殺死對手前先讓我來殺死懶惰&lt;/p&gt;
&lt;p&gt;— 艾福杰尼 / Killa4nia《酒精》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
</feed>
