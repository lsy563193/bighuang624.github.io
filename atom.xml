<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大黄菌的个人博客</title>
  <subtitle>To be a better man</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kyonhuang.top/"/>
  <updated>2017-07-27T12:38:03.000Z</updated>
  <id>http://kyonhuang.top/</id>
  
  <author>
    <name>Kyon Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《你不知道的 JavaScript（上卷）》脑图</title>
    <link href="http://kyonhuang.top/You-Dont-Know-JS-notes-1/"/>
    <id>http://kyonhuang.top/You-Dont-Know-JS-notes-1/</id>
    <published>2017-07-27T08:47:12.000Z</published>
    <updated>2017-07-27T12:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。</p>
  <a id="more"></a>
<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作用域和闭包.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">作用域和闭包.png</a></p>
<h2 id="this-和对象原型"><a href="#this-和对象原型" class="headerlink" title="this 和对象原型"></a>this 和对象原型</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="this和对象原型.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">this和对象原型.png</a></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>补一张来自 <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">JavaScript深入之从原型到原型链</a>  的图，来直观地表现原型链。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-d73fdcc0c25efd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链.png"></p>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《你不知道的 JavaScript》" scheme="http://kyonhuang.top/tags/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JavaScript%E3%80%8B/"/>
    
      <category term="脑图" scheme="http://kyonhuang.top/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>初探人工智能</title>
    <link href="http://kyonhuang.top/start-to-know-AI/"/>
    <id>http://kyonhuang.top/start-to-know-AI/</id>
    <published>2017-07-23T02:17:25.000Z</published>
    <updated>2017-07-27T08:31:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？</p>
<ol>
<li>发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。</li>
<li>随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。</li>
<li>确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。</li>
</ol>
<p>何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。</p>
<p>这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。</p>
<p>不要拒绝未来的任何可能性。</p>
<a id="more"></a>
<h2 id="相关概念脑图"><a href="#相关概念脑图" class="headerlink" title="相关概念脑图"></a>相关概念脑图</h2><p>一直感觉纯文字的笔记比较难以记忆，导致自己的学习吸收率不高。看到别人的读书笔记是总结了一张脑图，条理比较清晰。这里也试着用 Xmind 总结一张相关概念的脑图（P.S.使用感觉百度脑图比 Xmind 条理清晰+好用）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a64a6eb143122930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="人工智能相关概念.png"></p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>学习算法的输入数据，叫<strong>“训练数据”</strong>。训练数据的每一行称为一个<strong>“训练样本”（Training Sample）</strong>，通常简称“样本”（Sample）。</p>
<p>样本的各种属性称为<strong>“特征”（Feature）</strong>。而希望学得的模型可以用来预判的信息称为样本的<strong>“标注”（Label）</strong>。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>机器学到的模型是一个映射。</p>
<h3 id="映射的输入"><a href="#映射的输入" class="headerlink" title="映射的输入"></a>映射的输入</h3><p>每个样本 xi 的特征组成一个<strong>“特征向量” (Feature Vector)</strong>。所有特征向量的集合就是总的输入集合，称为<strong>“样本空间” (Sample Space)</strong>。</p>
<h3 id="映射的输出"><a href="#映射的输出" class="headerlink" title="映射的输出"></a>映射的输出</h3><p>第 i 个样本的标注记作 yi。同理有<strong>“标注空间”(Label Space)</strong>。</p>
<h3 id="映射的表示"><a href="#映射的表示" class="headerlink" title="映射的表示"></a>映射的表示</h3><p>机器学习模型就是输入空间 X 到输出空间 Y 的一个映射，将映射用符号 g 表示，则模型记作 g: X -&gt; Y。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><strong>学习算法 (Learning Algorithm)</strong> 根据训练数据，从<strong>假设集合 (Hypothesis Set) </strong>中选出最优的那个映射 g 作为最终学得的模型，使得 g 越接近上帝真相 f 越好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>不是所有的机器学习问题都需要标注。根据训练数据是否有标注，机器学习问题大致划分为<strong>监督学习（Supervised Learning）</strong>和<strong>无监督学习（Unsupervised Learning）</strong>两大类（还有半监督学习、增强学习等）。</p>
<ul>
<li>监督学习：每个输入样本都<strong>有标注</strong>。大致分成两类：<ol>
<li><strong>分类（Classification）</strong>问题：标注是<strong>离散值</strong>，比如用户”点击“和”不点击“。如果标注只有两个值，则称为二分类，如果标注有多个值，则称为多分类。</li>
<li><strong>回归（Regression）</strong>问题：标注是<strong>连续值</strong>，比如如果问题是预测北京市房屋的价格，价格作为标注就是一个连续值，属于回归问题。</li>
</ol>
</li>
<li>无监督学习：训练样本<strong>没有标注</strong>，无监督学习解决的典型问题是<strong>聚类（clustering）问题</strong>。比如对一个网站的用户进行聚类，看看这个网站用户的大致构成，分析下每类用户群的特点是什么。</li>
</ul>
<p>以上总结为脑图（感觉百度脑图看起来条理稍微清晰一些）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e14be3cf5133d5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="机器学习.png"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>把听上去最高端的“神经网络”放到最后介绍。</p>
<h3 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h3><p>一组大致模仿人类大脑构造设计的算法，用于识别模式。神经网络通过机器感知系统解释传感器数据，能够对原始输入进行标记或聚类等操作。</p>
<p>神经网络所能识别的模式是数值形式，因此图像、声音、文本、时间序列等一切现实世界的数据必须转换为数值。</p>
<h3 id="感知器、权重与阈值"><a href="#感知器、权重与阈值" class="headerlink" title="感知器、权重与阈值"></a>感知器、权重与阈值</h3><p>大家都在高中的生物课上学过，人类大脑思考的基础是神经元（神经细胞）。如果能够人工制造神经元，就能组成人工神经网络来模拟思考。</p>
<p>上世纪六十年代，科学家们提出了最早的“人造神经元”，并将其称为<strong>“感知器”（perceptron）</strong>。感知器接受一些因素，这些因素根据不同的重要性（决定性因素与次要因素）获得不同的<strong>权重（weight）</strong>。因素的条件成立为 1，不成立为 0，乘以权重的总和大于指定的<strong>阈值（threshold）</strong>，感知器便输出 11，否则输出 0。</p>
<h3 id="决策模型"><a href="#决策模型" class="headerlink" title="决策模型"></a>决策模型</h3><p>单个的感知器构成一个简单的决策模型。而实际的决策模型是由多个感知器组成的多层网络。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png" alt="多层网络"></p>
<p>每一个节点层在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂，因为每一层会整合并重组前一层的特征。</p>
<p>而在“递归神经网络”中，上下层的感知器的输入与输出还可能发生循环传递。</p>
<h3 id="神经网络运作过程"><a href="#神经网络运作过程" class="headerlink" title="神经网络运作过程"></a>神经网络运作过程</h3><p>一个神经网络的搭建，需要满足三个条件：</p>
<ol>
<li>输入和输出</li>
<li>权重（w）和阈值（b）</li>
<li>多层感知器的结构</li>
</ol>
<p>最困难的部分就是确定权重和阈值。我们通过试错法，即保证其他参数不变，对 w 或 b 进行微小变动，然后观察输出的变化。通过不断重复这个过程来得到最精确的那组 w 和 b。这个过程即被称为<strong>模型的训练</strong>。</p>
<p>因此，神经网络的运作过程如下：</p>
<ol>
<li>确定输入和输出</li>
<li>找到一种或多种算法，可以从输入得到输出</li>
<li>找到一组已知答案的数据集，用来训练模型，估算 w 和 b</li>
<li>一旦新的数据产生，输入模型，就可以得到结果，同时对 w 和 b 进行校正</li>
</ol>
<p>整个过程需要海量计算，所以需要使用专门为机器学习定制的 GPU。</p>
<h3 id="输出的连续性"><a href="#输出的连续性" class="headerlink" title="输出的连续性"></a>输出的连续性</h3><p>为了保证模型的敏感，要将 0、1 输出改造为连续性函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">z = wx + b</div><div class="line">σ(z) = 1 / (1 + e^(-z))</div></pre></td></tr></table></figure>
<p>这样，当 z 趋向正无穷（表示感知器强烈匹配）时，σ(z) → 1；如果 z 趋向负无穷（表示感知器强烈不匹配），σ(z) → 0。</p>
<p>同时，Δσ 满足下面的公式：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png" alt="Δσ 公式"></p>
<p>即 Δσ 和 Δw 和 Δb 之间是线性关系，变化率是偏导数。这就有利于精确推算出 w 和 b 的值了。</p>
<h2 id="基于-JavaScript-的机器学习"><a href="#基于-JavaScript-的机器学习" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h2><p>尽管确实是第一选择，机器学习不一定要用 Python。为什么不试试神奇的 JavaScript 呢？</p>
<p>JavaScript 开发者们已经开源了不少基于 Node.js 的机器学习库：</p>
<ol>
<li><a href="https://github.com/harthur-org/brain.js" target="_blank" rel="external">brain.js</a> (神经网络)</li>
<li><a href="https://github.com/cazala/synaptic" target="_blank" rel="external">Synaptic</a> (神经网络)</li>
<li><a href="https://github.com/NaturalNode/natural" target="_blank" rel="external">Natural</a> (自然语言处理)</li>
<li><a href="http://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="external">ConvNetJS</a> (卷积神经网络)</li>
<li><a href="https://github.com/mljs" target="_blank" rel="external">mljs</a> (一系列具有多个函数方法的 AI 库)</li>
<li>Neataptic (神经网络)</li>
<li><a href="https://github.com/mil-tokyo/webdnn" target="_blank" rel="external">Webdnn</a> (深度学习)</li>
</ol>
<p>你可以从 github 的这个项目：<a href="https://github.com/abhisheksoni27/machine-learning-with-js" target="_blank" rel="external">abhisheksoni27/machine-learning-with-js</a> 中获得一些实例的源码，目前作者实现了线性规划和 KNN 算法。你也可以在参考资料的对应章节找到翻译版本进行阅读。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>emmm，如果你看了之后的参考资料中的每一篇，你会发现这篇博文只是一个拙劣的归纳总结。这是因为我确实对相关领域没有什么了解。但我对此兴致勃勃，也已经关注了不少数据挖掘和机器学习的知乎专栏及收藏夹。希望自己将来会有相关方面有价值的产出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="相关概念部分"><a href="#相关概念部分" class="headerlink" title="相关概念部分"></a>相关概念部分</h3><p><a href="http://blog.csdn.net/feichizhongwu888/article/details/52727958" target="_blank" rel="external">简单理解：人工智能、数据挖掘、模式识别、机器学习、深度学习 - feichizhongwu888的博客 - CSDN博客</a></p>
<p><a href="http://36kr.com/p/5052482.html" target="_blank" rel="external">一篇文章讲清楚人工智能、机器学习和深度学习的区别</a></p>
<h3 id="数据、模型部分"><a href="#数据、模型部分" class="headerlink" title="数据、模型部分"></a>数据、模型部分</h3><p><a href="https://zhuanlan.zhihu.com/p/25439997" target="_blank" rel="external">写给大家看的机器学习书（第二篇） - 知乎专栏</a></p>
<h3 id="神经网络部分"><a href="#神经网络部分" class="headerlink" title="神经网络部分"></a>神经网络部分</h3><p><a href="http://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank" rel="external">神经网络入门 - 阮一峰的网络日志</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25358695" target="_blank" rel="external">写给大家看的机器学习书（第三篇）</a></p>
<h3 id="基于-JavaScript-的机器学习-1"><a href="#基于-JavaScript-的机器学习-1" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h3><p><a href="https://blog.fundebug.com/2017/07/03/javascript-machine-learning-regression/" target="_blank" rel="external">JavaScript机器学习之线性回归</a></p>
<p><a href="https://blog.fundebug.com/2017/07/10/javascript-machine-learning-knn/" target="_blank" rel="external">JavaScript机器学习之KNN算法</a></p>
<h3 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h3><p><a href="http://www.cnblogs.com/subconscious/p/5058741.html" target="_blank" rel="external">神经网络浅讲：从神经元到深度学习</a></p>
<p><a href="https://yanqiangmiffy.github.io/2017/07/26/Python28-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BD%BF%E7%94%A8Python%E5%92%8CR%E4%BB%A3%E7%A0%81%EF%BC%89/" target="_blank" rel="external">机器学习算法的基本知识（使用Python和R代码）</a>：带有 Python 和 R 语言代码实例</p>
<p><a href="https://exacity.github.io/deeplearningbook-chinese/" target="_blank" rel="external">Deep Learning 中文翻译</a></p>
<p><a href="http://blog.csdn.net/baihuaxiu123/article/details/69488610" target="_blank" rel="external">[机器学习]机器学习笔记整理全解</a></p>
<p><a href="https://zhuanlan.zhihu.com/dteratech" target="_blank" rel="external">DT新纪元 - 知乎专栏</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。&lt;/p&gt;
&lt;h2 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么&quot;&gt;&lt;/a&gt;为什么&lt;/h2&gt;&lt;p&gt;为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。&lt;/li&gt;
&lt;li&gt;随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。&lt;/li&gt;
&lt;li&gt;确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。&lt;/p&gt;
&lt;p&gt;这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。&lt;/p&gt;
&lt;p&gt;不要拒绝未来的任何可能性。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习笔记" scheme="http://kyonhuang.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人工智能" scheme="http://kyonhuang.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://kyonhuang.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://kyonhuang.top/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的 Vue 实践（持续更新）</title>
    <link href="http://kyonhuang.top/vue-project-practice/"/>
    <id>http://kyonhuang.top/vue-project-practice/</id>
    <published>2017-07-17T13:03:42.000Z</published>
    <updated>2017-07-27T08:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我阅读了 Vue、Vue-router、Vuex 的官方文档并进行了一定的实践来体会，使用了 Element 和 Axios。那么在这段时间的学习基础上，我做了或者正在做一些规模较大的、基于 Vue 全家桶的项目，一方面巩固自己所学知识，另一方面继续学习一些大规模项目中要用到的工具、库、插件等等。</p>
<p>项目之一地址：<a href="https://github.com/bighuang624/vip" target="_blank" rel="external">bighuang624/vip</a>。技术栈（到目前为止项目中引入的）：Vue + Vue-router + vuex + axios + Element…</p>
<p>这篇博文会记录我在这些项目中技术选型考量、使用细节和坑、项目中某些设计的缘由，等等…</p>
  <a id="more"></a>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="mock-js-axios-mock-adapter"><a href="#mock-js-axios-mock-adapter" class="headerlink" title="mock.js + axios-mock-adapter"></a>mock.js + axios-mock-adapter</h3><p>在 vip 项目里使用了这一套作为 mock 的工具。</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li><p>mock.js：根据数据模板生成模拟数据<br><a href="http://mockjs.com/examples.html#Image" target="_blank" rel="external">mock.js 方法示例</a></p>
</li>
<li><p>axios-mock-adapter：axios 与 mock 配置器，二者合一方便使用<br><a href="https://github.com/ctimmerm/axios-mock-adapter" target="_blank" rel="external">ctimmerm/axios-mock-adapter</a></p>
</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><p>安装 mock axios</p>
<pre><code>npm install mockjs axios
</code></pre></li>
<li><p>安装 axios-mock-adapter</p>
<pre><code>npm install axios-mock-adapter --save-dev
</code></pre></li>
</ul>
<h4 id="创建-mock-数据"><a href="#创建-mock-数据" class="headerlink" title="创建 mock 数据"></a>创建 mock 数据</h4><p>src/mock/data/user.js 初始化数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span></div><div class="line"><span class="keyword">let</span> User = Mock.mock(&#123;</div><div class="line">  <span class="attr">id</span>: <span class="regexp">/\d&#123;5,8&#125;/</span>,</div><div class="line">  <span class="attr">username</span>: Mock.Random.cname(),</div><div class="line">  <span class="attr">avatar</span>: Mock.Random.image(<span class="string">'100x100'</span>, <span class="string">'#6eb8ba'</span>, <span class="string">'Hello'</span>)</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> User</div></pre></td></tr></table></figure>
<p>src/mock/userMock.js 模拟 ajax 请求的接口，生成并返回模拟数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></div><div class="line"><span class="keyword">import</span> MockAdapter <span class="keyword">from</span> <span class="string">'axios-mock-adapter'</span></div><div class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./data/user'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  start () &#123;</div><div class="line">    <span class="keyword">let</span> mock = <span class="keyword">new</span> MockAdapter(axios)</div><div class="line">    <span class="comment">// 登录</span></div><div class="line">    mock.onPost(<span class="string">'/user/login'</span>).reply(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> [<span class="number">200</span>, User]</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 注册</span></div><div class="line">    mock.onPost(<span class="string">'/user/register'</span>).reply(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> [<span class="number">200</span>, <span class="string">'success'</span>]</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>src/mock/index.js 对同级目录下所有 mock 文件做一个索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> userMock <span class="keyword">from</span> <span class="string">'./userMock'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> userMock</div></pre></td></tr></table></figure>
<p>src/main.js 中全局加载 mock 并执行初始化函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'./mock'</span>; <span class="comment">// 引入mock模块</span></div><div class="line">Mock.start(); <span class="comment">//并且执行初始化函数</span></div></pre></td></tr></table></figure>
<h4 id="封装-api-函数"><a href="#封装-api-函数" class="headerlink" title="封装 api 函数"></a>封装 api 函数</h4><p>新建 src/api 文件夹以独立取出所有调用接口的函数，方便管理和维护。</p>
<p>src/api/userApi.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> axios.post(<span class="string">'/user/login'</span>, params)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> register = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> axios.post(<span class="string">'/user/register'</span>, params)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &#123;login&#125; from &apos;../../api/userApi.js&apos;</div></pre></td></tr></table></figure>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://yangyi1024.com/2017/06/14/%E5%AD%A6%E4%B9%A0%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84vue4:mock%E4%B8%8Eaxios%E5%AE%9E%E6%88%981/" target="_blank" rel="external">学习不一样的vue4:mock与axios实战1</a></p>
<h2 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h2><h3 id="vuex-和-localStorage-解决登录问题"><a href="#vuex-和-localStorage-解决登录问题" class="headerlink" title="vuex 和 localStorage 解决登录问题"></a>vuex 和 localStorage 解决登录问题</h3><p>在 vip 项目中做了一个简单的登录系统，依靠 mock 返回的用户数据，还没有涉及到安全性。</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>模块化的 store 目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">|-store/                   // 存放vuex代码</div><div class="line">|   |-modules          </div><div class="line">|   |   |-user         // 用户模块</div><div class="line">|   |   |   |-index.js       // 方便起见，没有单独拆为 state、actions、mutations、getters 个一个文件</div><div class="line">|   |-index.js              // vuex的核心，创建一个store</div><div class="line">|   |-function.js           // 存放 localStorage 中取数据等方法</div></pre></td></tr></table></figure>
<p>所有组件都是调用 actions ，分发 mutation 去修改state，然后 state 经过 getter 又更新到各个组件里。state 又通过 localStorage 存储数据到本地，下次重新打开时再读取保存的数据。</p>
<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>注意 localStorage 原生不支持过期时间。在 src/store/modules/function.js 中对 localStorage 的相关方法做了一个封装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> LocalEvent = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = localStorage.getItem(item) ? <span class="built_in">JSON</span>.parse(localStorage.getItem(item)) : <span class="string">''</span></div><div class="line">    <span class="keyword">if</span> (obj.time) &#123;</div><div class="line">      <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - obj.startTime) &gt; obj.time) &#123;</div><div class="line">        <span class="keyword">this</span>.clear()</div><div class="line">        alert(<span class="string">'登录过期，请重新登录'</span>)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> obj.val</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> obj</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">    localStorage.setItem(item, <span class="built_in">JSON</span>.stringify(obj))</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.setWithTime = <span class="function"><span class="keyword">function</span> (<span class="params">obj, time</span>) </span>&#123;  <span class="comment">// 自行封装过期时间</span></div><div class="line">    <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</div><div class="line">    <span class="keyword">let</span> objWithTime = &#123;</div><div class="line">      <span class="attr">val</span>: obj,</div><div class="line">      <span class="attr">time</span>: time,</div><div class="line">      <span class="attr">startTime</span>: startTime</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.set(objWithTime)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    localStorage.removeItem(item)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> localUser = <span class="keyword">new</span> LocalEvent(<span class="string">'vip-user'</span>)</div></pre></td></tr></table></figure>
<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>src/store/modules/user/index.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;localUser&#125; <span class="keyword">from</span> <span class="string">'../../function'</span></div><div class="line"><span class="keyword">import</span> &#123;login, logout&#125; <span class="keyword">from</span> <span class="string">'../../../api/login'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line">  <span class="attr">user</span>: localUser.get() || &#123;</div><div class="line">    <span class="attr">id</span>: <span class="literal">undefined</span>,</div><div class="line">    <span class="attr">username</span>: <span class="string">''</span>,</div><div class="line">    <span class="attr">avatar</span>: <span class="string">''</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">login</span>: localUser.get() !== <span class="string">''</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> getters = &#123;</div><div class="line">  <span class="attr">user</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user,</div><div class="line">  <span class="attr">login</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.login,</div><div class="line">  <span class="attr">id</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.id,</div><div class="line">  <span class="attr">username</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.username,</div><div class="line">  <span class="attr">avatar</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.avatar</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mutations = &#123;</div><div class="line">  <span class="attr">SET_LOGIN_STATE</span>: <span class="function">(<span class="params">state, loginState</span>) =&gt;</span> &#123;</div><div class="line">    state.login = loginState</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">SET_ID</span>: <span class="function">(<span class="params">state, id</span>) =&gt;</span> &#123;</div><div class="line">    state.user.id = id</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">SET_USERNAME</span>: <span class="function">(<span class="params">state, username</span>) =&gt;</span> &#123;</div><div class="line">    state.user.username = username</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">SET_AVATAR</span>: <span class="function">(<span class="params">state, avatar</span>) =&gt;</span> &#123;</div><div class="line">    state.user.avatar = avatar</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">LOGOUT_USER</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</div><div class="line">    state.user = &#123;</div><div class="line">      <span class="attr">id</span>: <span class="literal">undefined</span>,</div><div class="line">      <span class="attr">username</span>: <span class="string">''</span>,</div><div class="line">      <span class="attr">avatar</span>: <span class="string">''</span></div><div class="line">    &#125;</div><div class="line">    state.login = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> actions = &#123;</div><div class="line">  login (&#123;commit, state&#125;, userInfo, IsRemembered) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      login(userInfo).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">        commit(<span class="string">'SET_ID'</span>, response.data.id)</div><div class="line">        commit(<span class="string">'SET_USERNAME'</span>, response.data.username)</div><div class="line">        commit(<span class="string">'SET_AVATAR'</span>, response.data.avatar)</div><div class="line">        commit(<span class="string">'SET_LOGIN_STATE'</span>, <span class="literal">true</span>)</div><div class="line">        localUser.setWithTime(state.user, (IsRemembered ? <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> : <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>))</div><div class="line">        resolve()</div><div class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">        reject(error)</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  logout (&#123;commit, state&#125;) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      logout(state.user.id).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        commit(<span class="string">'LOGOUT_USER'</span>)</div><div class="line">        localUser.clear()</div><div class="line">        resolve()</div><div class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">        reject(error)</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> userModule = &#123;</div><div class="line">  state,</div><div class="line">  getters,</div><div class="line">  actions,</div><div class="line">  mutations</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> userModule</div></pre></td></tr></table></figure>
<h4 id="登录具体代码"><a href="#登录具体代码" class="headerlink" title="登录具体代码"></a>登录具体代码</h4><p>src/components/Login/index.vue，点击登录按钮后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">register(<span class="keyword">this</span>.registerForm).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (res.data === <span class="string">'success'</span>) &#123;</div><div class="line">    alert(<span class="string">'注册成功，请登录'</span>)</div><div class="line">    <span class="keyword">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">'/'</span>&#125;)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="string">'注册失败，请重新注册'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="根据登录状态切换-nav-bar-部件"><a href="#根据登录状态切换-nav-bar-部件" class="headerlink" title="根据登录状态切换 nav-bar 部件"></a>根据登录状态切换 nav-bar 部件</h4><p>src/components/TopNav/topNav.vue：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class="top-nav"&gt;</div><div class="line">    &lt;component :is="login?'loggedIn':'loginAndRegister'"&gt;&lt;/component&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  import loggedIn from './isLogin/loggedIn'</div><div class="line">  import loginAndRegister from './isLogin/loginAndRegister'</div><div class="line">  import &#123;mapGetters&#125; from 'vuex'</div><div class="line">  export default &#123;</div><div class="line">    name: 'topNav',</div><div class="line">    data () &#123;</div><div class="line">      return &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    components: &#123;</div><div class="line">      loggedIn: loggedIn,</div><div class="line">      loginAndRegister: loginAndRegister</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">      ...mapGetters(['login'])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>src/components/TopNav/IsLogin/loggedIn.vue：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class="loggedIn"&gt;</div><div class="line">    &lt;img :src="avatar" class="avatar"&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;a href="" v-text="username"&gt;&lt;/a&gt;</div><div class="line">      &lt;a @click="logout"&gt;退出&lt;/a&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'loggedIn'</span>,</div><div class="line">    data () &#123;</div><div class="line">      <span class="keyword">return</span> &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">      logout () &#123;</div><div class="line">        <span class="keyword">this</span>.$store.dispatch(<span class="string">'logout'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          alert(<span class="string">'已退出'</span>)</div><div class="line"><span class="comment">//          location.reload()</span></div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">computed</span>: &#123;</div><div class="line">      ...mapGetters([<span class="string">'avatar'</span>, <span class="string">'username'</span>])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>坑：返回的 response 中 data 才是数据</p>
<p>另外，关于用户权限验证与安全性还没有过多考虑。之后会参照<a href="https://juejin.im/post/591aa14f570c35006961acac" target="_blank" rel="external">手摸手，带你用vue撸后台 系列二(登录权限篇)</a>来尝试实现。</p>
<h4 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="http://www.w3cplus.com/javascript/web-storage.html" target="_blank" rel="external">Web 存储机制</a>：关于 localStorage 的用法</li>
<li><a href="https://github.com/lin-xin/blog/issues/5" target="_blank" rel="external">Vuex 模块化实现待办事项的状态管理</a></li>
<li><a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="external">PanJiaChen/vue-element-admin</a>：对相关部分的代码进行了学习</li>
</ul>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="vue-SPA-和-fullPage-js-配合使用"><a href="#vue-SPA-和-fullPage-js-配合使用" class="headerlink" title="vue SPA 和 fullPage.js 配合使用"></a>vue SPA 和 fullPage.js 配合使用</h3><p>花旗杯的现在设计要求首页引入 fullPage.js（因此也需要引入 jQuery）。引入 jQuery 的经验很多，但是没有找到在 vue 中引入 fullPage.js 的方法，自己折腾又弄出了一些 bug。</p>
<p>最后用的是比较傻的方法，用关键词在 github 上搜项目的代码，最后在某个 vue SPA 做的简历项目中得到一些提示。但是这个项目没有引入 vue-router，而我在开发中当 router 切换时又有一些 fullPage.js 初始化导致的 bug。最后自己找到了一个解决方法。</p>
<h4 id="vue-中引入-jQuery"><a href="#vue-中引入-jQuery" class="headerlink" title="vue 中引入 jQuery"></a>vue 中引入 jQuery</h4><h4 id="vue-中引入-fullPage-js"><a href="#vue-中引入-fullPage-js" class="headerlink" title="vue 中引入 fullPage.js"></a>vue 中引入 fullPage.js</h4><h3 id="在-vue-SPA-中使用-scss"><a href="#在-vue-SPA-中使用-scss" class="headerlink" title="在 vue SPA 中使用 scss"></a>在 vue SPA 中使用 scss</h3><p><strong>不能将定义的变量和 mixin 等全局样式放在一个 scss 文件中，然后在 main.js 或 App.vue 中导入以试图导入一次而全局可用</strong>。它们不能被其他 vue 文件使用。想要使用，只能每个组件都引入一次。</p>
<h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到目前为止，我阅读了 Vue、Vue-router、Vuex 的官方文档并进行了一定的实践来体会，使用了 Element 和 Axios。那么在这段时间的学习基础上，我做了或者正在做一些规模较大的、基于 Vue 全家桶的项目，一方面巩固自己所学知识，另一方面继续学习一些大规模项目中要用到的工具、库、插件等等。&lt;/p&gt;
&lt;p&gt;项目之一地址：&lt;a href=&quot;https://github.com/bighuang624/vip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bighuang624/vip&lt;/a&gt;。技术栈（到目前为止项目中引入的）：Vue + Vue-router + vuex + axios + Element…&lt;/p&gt;
&lt;p&gt;这篇博文会记录我在这些项目中技术选型考量、使用细节和坑、项目中某些设计的缘由，等等…&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://kyonhuang.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>暑假计划进行中</title>
    <link href="http://kyonhuang.top/summer-plan/"/>
    <id>http://kyonhuang.top/summer-plan/</id>
    <published>2017-07-05T13:42:53.000Z</published>
    <updated>2017-07-27T08:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>出征前內心忐忑<br>鋒利的匕首反握<br>準備殺死對手前先讓我來殺死懶惰</p>
<p>— 艾福杰尼 / Killa4nia《酒精》</p>
</blockquote>
<p>简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感兴趣的知识，并且认真做学习笔记和总结。</p>
<p>07.20 更新：暑假已经过去了半个月。对暑期计划进行一些变更使其更加合理。最重要的是提高效率。</p>
<h4 id="读书计划（脑图整理知识点）"><a href="#读书计划（脑图整理知识点）" class="headerlink" title="读书计划（脑图整理知识点）"></a>读书计划（脑图整理知识点）</h4><p>7月23日为 deadline，看完《你不知道的 JavaScript（上卷）》。</p>
<p>8月8日为deadline， 看完《你不知道的 JavaScript（中卷）》。</p>
<p>8月读一本 Node 方面的书。</p>
<p>争取暑假读完《JavaScript 设计模式与开发实践》。</p>
<h4 id="整个暑假："><a href="#整个暑假：" class="headerlink" title="整个暑假："></a>整个暑假：</h4><ul>
<li>每天 12 点前睡觉，8 点前起床。</li>
<li>前端各类练习题。每天 2 - 3 道原生 js 实例题。学累了刷刷 <a href="https://www.nowcoder.com/5257175" target="_blank" rel="external">牛客网</a>。</li>
<li>每天 2 面六级单词。</li>
</ul>
<h4 id="想做的练习："><a href="#想做的练习：" class="headerlink" title="想做的练习："></a>想做的练习：</h4><ul>
<li><a href="http://www.cnblogs.com/coco1s/p/6802374.html" target="_blank" rel="external">谈谈一些有趣的CSS题目</a></li>
<li><a href="http://www.fgm.cc/learn/" target="_blank" rel="external">原生JavaScript学习-实例索引</a></li>
<li><a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a>［可缓］</li>
</ul>
<h4 id="七月："><a href="#七月：" class="headerlink" title="七月："></a>七月：</h4><ul>
<li>写花旗杯项目前端。</li>
<li>Vue 全家桶及相关技术实践。</li>
</ul>
<h4 id="八月："><a href="#八月：" class="headerlink" title="八月："></a>八月：</h4><ul>
<li>Node.js学习。首先是廖雪峰的入门教程，争取一天看完。接下来选一本书看看（据说朴灵的《Node.js 深入浅出》不错…）</li>
<li>如果还有时间，试试 Electron 或者 <a href="https://lavas.baidu.com/guide" target="_blank" rel="external">Lavas</a></li>
</ul>
<p>天下武功，唯勤不破！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;出征前內心忐忑&lt;br&gt;鋒利的匕首反握&lt;br&gt;準備殺死對手前先讓我來殺死懶惰&lt;/p&gt;
&lt;p&gt;— 艾福杰尼 / Killa4nia《酒精》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Promise 对象</title>
    <link href="http://kyonhuang.top/promise/"/>
    <id>http://kyonhuang.top/promise/</id>
    <published>2017-06-17T13:38:13.000Z</published>
    <updated>2017-06-17T13:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。</p>
<p>特点：</p>
<ol>
<li><strong>对象的状态不受外界影响</strong>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成，又称 Fulfilled）和<code>Rejected</code>（已失败）。只有异步操作的结果可以决定当前是哪一种状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。<code>Promise</code>对象的状态改变只有两种可能：从<code>Pending</code>变为<code>Resovled</code>和从<code>Pending</code>变为<code>Rejected</code>。</li>
</ol>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>缺点：</p>
<ol>
<li>无法取消<code>Promise</code>，一旦新建就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，<code>Promise</code>内部抛出的错误不会反映到外部。</li>
<li>当处于<code>Pending</code>状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。</li>
</ol>
<a id="more"></a>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>一个栗子，用<code>Promise</code>对象实现 Ajax 操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    client.open(<span class="string">"GET"</span>, url);</div><div class="line">    client.onreadystagechange = handler;</div><div class="line">    client.responseType = <span class="string">"json"</span>;</div><div class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.readyState !== <span class="number">4</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="number">200</span>)&#123;</div><div class="line">        resolve(<span class="keyword">this</span>.response);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(<span class="string">"/post.json"</span>).then(</div><div class="line">  <span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json), </div><div class="line">  error =&gt; <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error)</div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>resolve</code>和<code>reject</code>函数由 JavaScript 引擎提供，不用自己部署。两者在改变 <code>Promise</code>对象的状态的同时，将异步操作的结果或报出的错误<strong>作为参数</strong>传递出去。</p>
<p><code>then</code>方法可以接受两个回调函数作为参数，第一个在<code>Promise</code>对象状态变为<code>Resolved</code>时调用，第二个（可省）在<code>Promise</code>对象状态变为<code>Rejected</code>时调用，都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个<code>Promise</code>实例（决定前一个<code>Promise</code>对象的状态），表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a><code>Promise.prototype.then()</code></h4><p><code>then</code>方法返回一个<strong>新的</strong><code>Promise</code>实例。链式写法调用<code>then</code>方法时，前一个回调函数将返回结果作为参数，传入第二个回调函数。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a><code>Promise.prototype.catch()</code></h4><p><code>reject</code>方法的作用，等同于抛出错误。如果<code>Promise</code>状态已经变成<code>Resolved</code>，在<code>resolve</code>语句后再抛出错误是无效的，因为状态不会再改变了。</p>
<p>一般来说，不要在<code>then</code>方法中定义<code>Reject</code>状态的回调函数，<strong>总是使用<code>catch</code>方法</strong>。因为<code>catch</code>可以捕获之前所有<code>then</code>方法执行中的错误，也更接近同步的<code>try/catch</code>写法。</p>
<p><code>catch</code>方法返回的也是一个<code>Promise</code>对象。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h4><p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例（否则调用<code>Promise.resolve</code>方法再处理），包装成一个新的<code>Promise</code>实例。接受一个具有<code>Iterator</code>接口，且返回的每个成员都是<code>Promise</code>实例的参数（一般为数组）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>只有每个成员的状态都为<code>Resolved</code>，p 的状态才为<code>Resolved</code>，所有返回值组成一个参数传递给 p 的回调函数；否则只要有一个成员被<code>rejected</code>，p 的状态为<code>Rejected</code>，第一个被<code>reject</code>的实例的返回值被传递给 p 的回调函数。</p>
<p>如果作为参数的<code>Promise</code>实例自身定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>p 的状态随第一个改变状态的成员而做相同改变，该成员返回值传递给 p 的回调函数。其他与<code>Promise.all</code>方法一致。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a><code>Promise.resolve()</code></h4><p>将现有对象转为<code>Promise</code>对象。根据参数分为四种情况：</p>
<ol>
<li><code>Promise</code>实例：不作任何修改，直接返回该实例；</li>
<li><code>thenable</code>对象（具有<code>then</code>方法的对象）：转为<code>Promise</code>对象，然后在立即调用其<code>then</code>方法的同时状态变为<code>Resolved</code>；</li>
<li>不符合以上情况的任何参数：返回状态为<code>Resolved</code>的<code>Promise</code>对象，参数传给回调函数；</li>
<li>不带有任何参数：返回状态为<code>Resolved</code>的<code>Promise</code>对象。</li>
</ol>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a><code>Promise.reject()</code></h4><p>返回一个新的<code>Promise</code>实例，状态为<code>Rejected</code>。方法的参数会作为<code>reject</code>的理由，变成后续方法的参数。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>加载图片：加载完成时<code>Promise</code>的状态发生变化。</li>
<li>Generator 函数与 Promise 的结合：使用<code>Generator</code>函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>写作：</p>
<p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">Promise 对象 - ECMAScript 6入门</a></p>
<p>进阶（之后阅读）：</p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象的状态不受外界影响&lt;/strong&gt;。&lt;code&gt;Promise&lt;/code&gt;对象代表一个异步操作，有三种状态：&lt;code&gt;Pending&lt;/code&gt;（进行中）、&lt;code&gt;Resolved&lt;/code&gt;（已完成，又称 Fulfilled）和&lt;code&gt;Rejected&lt;/code&gt;（已失败）。只有异步操作的结果可以决定当前是哪一种状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一旦状态改变，就不会再变，任何时候都可以得到这个结果&lt;/strong&gt;。&lt;code&gt;Promise&lt;/code&gt;对象的状态改变只有两种可能：从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Resovled&lt;/code&gt;和从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Rejected&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了&lt;code&gt;Promise&lt;/code&gt;对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，&lt;code&gt;Promise&lt;/code&gt;对象提供统一的接口，使得控制异步操作更加容易。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法取消&lt;code&gt;Promise&lt;/code&gt;，一旦新建就会立即执行，无法中途取消。&lt;/li&gt;
&lt;li&gt;如果不设置回调函数，&lt;code&gt;Promise&lt;/code&gt;内部抛出的错误不会反映到外部。&lt;/li&gt;
&lt;li&gt;当处于&lt;code&gt;Pending&lt;/code&gt;状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何给终端安上炫酷的皮神黄皮肤？</title>
    <link href="http://kyonhuang.top/pikachu-iterm/"/>
    <id>http://kyonhuang.top/pikachu-iterm/</id>
    <published>2017-06-10T09:11:32.000Z</published>
    <updated>2017-06-17T13:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-17d0934182abb9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pokemon-Terminal，已经有 1200+ star"></p>
<p>给终端安上超几把炫酷的皮神黄皮肤！<br>作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？</p>
<p>一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-bc1f7d006fb2f0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="感觉又能元气满满地查 bug 了呢"></p>
<p>如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。</p>
<a id="more"></a>
<h3 id="从零开始的项目安装"><a href="#从零开始的项目安装" class="headerlink" title="从零开始的项目安装"></a>从零开始的项目安装</h3><p>打开 <a href="https://github.com/LazoCoder/Pokemon-Terminal" target="_blank" rel="external">Pokemon-Terminal 项目的 github 主页</a>，我发现安装前有两个要求：</p>
<ol>
<li>3.5及以上版本的 python；</li>
<li>已安装 iTerm2。</li>
</ol>
<p>巧了，这两个要求我都不符合！</p>
<p>iTerm2 我从来没有接触过，根本不知道是什么。而比较久远的时候，我在试图将 OS X 系统自带的 python 2.+ 升级为 3.+ 时，跟着网上不知道靠不靠谱的教程误操作，以致 2.+ 删掉了 3.+ 却没安好，依赖于 python 的以 Xcode 为首的一系列软件全部罢工（而且过了一周左右才查出来是这个原因），最后灰溜溜地又下了一遍 2.+，从此留下了对 python 的心理阴影（但是我们这篇教程还是很靠谱的）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-cbaa6148775a471f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="吃瘪了"></p>
<p>没关系，作为（准）程序员，要勇于折腾！我们一步一步的搞起。</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p>我是先下载的 iTerm2，<a href="http://www.iterm2.com/" target="_blank" rel="external">官网</a>在此，下载即可。</p>
<p>iTerm2 是 OS X 系统下很好用的一款命令行工具，至于具体怎么好用，敬请百度了解。因为我现在只是为了皮神黄皮肤。当然之后我也会进一步学习使用。</p>
<h3 id="python-3-5"><a href="#python-3-5" class="headerlink" title="python 3.5+"></a>python 3.5+</h3><p>昨晚吃瘪后的我心有不甘，发了一条说说。然后幸得初中同学救驾：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-6bbe74dae5518c8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="向蔡老师低头"></p>
<p>这个允许用户方便地安装不同版本的 python 并可以快速切换的 anaconda 帮助我解决了问题。<a href="https://www.continuum.io/downloads/" target="_blank" rel="external">官网</a>提供了图形化安装和命令行安装两种方式，根据自己的专业程度选择下载即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-7a10e852f127c605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择 3.6 版本，安装后会自动帮你把 python 版本切换为3.6"></p>
<p>这个 anaconda 据说也是 python 开发的利器之一，不过我也不会 python。也许之后机缘巧合会深入学习（想了解可以参照这篇文章<a href="http://www.jianshu.com/p/2f3be7781451#" target="_blank" rel="external">Anaconda使用总结</a>）。说实话为了给终端换个皮肤，让我本不宽裕的存储空间又少了 1G 左右，有些心疼。但是折腾还是给了我很多乐趣，也许之后有用呢。</p>
<p>那么要求都满足了。按照项目 README 要求，在 iTerm 2 中输入以下三条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Pokemon Installation</div><div class="line">git clone https://github.com/LazoCoder/Pokemon-Terminal $HOME/.Pokemon-Terminal</div><div class="line">echo PATH=&quot;$HOME/.Pokemon-Terminal:$&#123;PATH&#125;&quot; &gt;&gt; ~/.bash_profile</div><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>安装完毕，皮神我来了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pokemon pikachu</div></pre></td></tr></table></figure>
<p>然后…出现以下报错提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.Pokemon-Terminal/./Scripts/background.scpt:39:46: script error: Expected end of line but found identifier. (-2741)</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-31f620e842cc120a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错了，就很难受"></p>
<h3 id="翻越最后一座-bug-高山"><a href="#翻越最后一座-bug-高山" class="headerlink" title="翻越最后一座 bug 高山"></a>翻越最后一座 bug 高山</h3><p>想去给作者提一个 issue，就发现作者对于这个 bug 已经给出了<a href="https://github.com/LazoCoder/Pokemon-Terminal/issues/15" target="_blank" rel="external">解决方法</a>。</p>
<p>按照解决方法，我们需要对 .Pokemon-Terminal/scripter.py 文件进行一些修改（当然，不一定每个人都碰上了这个 bug）。其实我也不太会用 vim，所以以下操作参照了这篇文章<a href="http://blog.csdn.net/bruce0532/article/details/7842384" target="_blank" rel="external">修改文件内容 vi命令</a>。</p>
<p>用以下命令在终端打开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi .Pokemon-Terminal/scripter.py</div></pre></td></tr></table></figure>
<p>然后按一下 i，从命令行模式进入插入模式。找到函数<code>__terminal_script</code>（在比较靠上的位置），将：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">content = &quot;tell application \&quot;iTerm\&quot;\n&quot;</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">content = &quot;tell application \&quot;iTerm2\&quot;\n&quot;</div></pre></td></tr></table></figure></p>
<p>按 Esc 键进入命令行模式，再按<code>:wq</code>保存退出。大功告成！</p>
<p>再在 iTerm2 中输入<code>pokemon pikachu</code>，就会发现黑漆漆（或者白晃晃）的背景变成了皮神黄！</p>
<h3 id="深度使用"><a href="#深度使用" class="headerlink" title="深度使用"></a>深度使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">    pokemon [parameter]</div><div class="line"></div><div class="line">Parameters:</div><div class="line">    [name]        -   Change the terminal background to the specified Pokemon.</div><div class="line">    [index]       -   Change the terminal background to a Pokemon by its index.</div><div class="line">    [region]      -   List all the Pokemon of the specified region.</div><div class="line">    [one letter]  -   List all Pokemon who&apos;s names begin with a particular letter.</div><div class="line">    [two letters] -   List all Pokemon who&apos;s names begin with those two letters.</div><div class="line"></div><div class="line">Other Parameters:</div><div class="line">    pokemon all             -   List all the Pokemon supported.</div><div class="line">    pokemon regions         -   List all the available regions.</div><div class="line">    pokemon extra           -   List all the Pokemon from the &apos;Extra&apos; folder.</div><div class="line">    pokemon random          -   Change the terminal background to a random Pokemon.</div><div class="line">    pokemon random-kanto    -   Change the terminal background to a random Pokemon from the specified region.</div><div class="line">    pokemon ?               -   Identify the current Pokemon in the terminal.</div><div class="line">    pokemon _pikachu        -   Change the wallpaper to the specified Pokemon.</div><div class="line">    pokemon _random         -   Change the wallpaper to a random Pokemon.</div><div class="line">    pokemon _random-kanto   -   Change the wallpaper to a random Pokemon from the specified region.</div><div class="line">    pokemon _?              -   Identify the current Pokemon in the wallpaper.</div><div class="line">    pokemon slideshow       -   Iterate through each Pokemon.</div><div class="line">    pokemon slideshow-kanto -   Iterate through each Pokemon in the specified region.</div><div class="line">    pokemon help            -   Display this menu.</div></pre></td></tr></table></figure>
<p>以上是作者提供的用法。可以通过口袋妖怪的英文名或者编号切换皮肤，或者用<code>pokemon random</code>来切换成随机的皮肤。</p>
<p>我们现在还得每次打开 iTerm 后输入命令来切换皮肤。作者同样提供了点开就换的方法，只用在 iTerm 的 Preferences 里做一点配置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e7b439a27bbb15e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可以去掉; clear以使终端界面不自己下滑来隐藏这条命令"></p>
<p>想一想，通过配置为<code>pokemon random</code>，每次打开都是不同皮肤说不定更爽到。</p>
<p>最后作者建议你改变一下透明度之类的，使皮神看起来更酷炫有范：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-f45392ab4550af00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作者的配置"></p>
<p>我的配置是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-1d60fdcb28354450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的配置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-16299e1b9b28d546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再看一次"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实一个皮肤也没有那么重要（还是有那么一点爽的啦），重要的是通过这一番折腾，接触到了很多常规学习中可能不会接触的东西，包括 iTerm 和 anaconda。这也是我第一次有目的性地去看项目的 issue。希望自己以后能多一点这样地非常规学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2702529-17d0934182abb9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Pokemon-Terminal，已经有 1200+ star&quot;&gt;&lt;/p&gt;
&lt;p&gt;给终端安上超几把炫酷的皮神黄皮肤！&lt;br&gt;作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？&lt;/p&gt;
&lt;p&gt;一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2702529-bc1f7d006fb2f0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;感觉又能元气满满地查 bug 了呢&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿喜欢折腾" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%96%9C%E6%AC%A2%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="终端" scheme="http://kyonhuang.top/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端学习之路上的暂歇思考</title>
    <link href="http://kyonhuang.top/relax-and-think/"/>
    <id>http://kyonhuang.top/relax-and-think/</id>
    <published>2017-06-05T07:22:33.000Z</published>
    <updated>2017-06-05T07:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。</p>
  <a id="more"></a>
<p>到现在为止，我的前端学习之路大概插了这些旗帜：</p>
<ol>
<li>对前端生态有了一个大致的了解，对例如 Webpack、Babel 等常用的工具有使用经验或者大概知道是干什么的。</li>
<li>在知乎和微博上关注了前端大佬，养成每天在掘金上看技术文章以及不时逛一些较为优秀的技术博客的习惯。</li>
<li>看了一些前端书籍，大多是 JavaScript 相关。</li>
<li>大致啃完了 Vue.js 的文档，正在学习 Vue-router。同时也对 i-View 等相关项目有一些了解。</li>
</ol>
<p>在之前的前端学习中也有一些问题：</p>
<ol>
<li>最大的问题是不太重视基础。看张鑫旭对前端的要求中，光是“掌握JS中的字符串、函数、对象、数组、字面量等基本概念，熟记所有内置的方法（包括参数和返回值）”这一条就足够我汗颜了。看的书籍虽然有笔记，但也感觉是没有过心。<strong>之后会将博客中的读书笔记再按照知识点，辅以自己的进一步学习成果拆分细化</strong>。虽然这是一个比较大的工程，但我觉得这是一个很有必要的工作。</li>
<li>经典书籍读的不够多。像《你不知道的 JavaScript》、《JavaScript 设计模式与开发实践》等书都没有看。</li>
<li>某些时候还是有些懒惰，没有抽出空余时间来学习。或者是在学习过程中在知乎、贴吧、空间、微博耗费了注意力，导致学习效率不高。</li>
<li>包括博文和项目在内的学习产出还是不多，博文也没有特别有价值的内容。<strong>毕业前要在 github 上有一个 100+ star 的项目，还要部署到 npm 上</strong>。博客考虑备案和 SEO，以激励自己写出更有价值的文章。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>单页面程序及组件化相关笔记</title>
    <link href="http://kyonhuang.top/SPA-learning-notes/"/>
    <id>http://kyonhuang.top/SPA-learning-notes/</id>
    <published>2017-04-29T03:12:53.000Z</published>
    <updated>2017-04-29T03:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 <a href="https://github.com/xufei/blog" target="_blank" rel="external">xufei</a> 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。</p>
<a id="more"></a>
<p>提高开发效率的两个主要途径：</p>
<ul>
<li>加快开发速度：少造轮子。</li>
<li>减少变更代价：清理模块之间的关系，合理分层。</li>
</ul>
<h2 id="单页面程序"><a href="#单页面程序" class="headerlink" title="单页面程序"></a>单页面程序</h2><p>SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。</p>
<h3 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h3><p>高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。</p>
<p>实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。</p>
<h3 id="代码合并与加载策略"><a href="#代码合并与加载策略" class="headerlink" title="代码合并与加载策略"></a>代码合并与加载策略</h3><p>典型特征：部分加载。</p>
<p>一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的<strong>异步加载机制</strong>去运行时加载。</p>
<p>因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。</p>
<h3 id="需要考虑的点"><a href="#需要考虑的点" class="headerlink" title="需要考虑的点"></a>需要考虑的点</h3><h4 id="路由与状态的管理"><a href="#路由与状态的管理" class="headerlink" title="路由与状态的管理"></a>路由与状态的管理</h4><p>界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。</p>
<h4 id="缓存与本地存储"><a href="#缓存与本地存储" class="headerlink" title="缓存与本地存储"></a>缓存与本地存储</h4><p>动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。</p>
<p>在本地存储一些临时数据可以用 localStorage。</p>
<h4 id="服务器通信"><a href="#服务器通信" class="headerlink" title="服务器通信"></a>服务器通信</h4><p>WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。</p>
<p>例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。</p>
<h3 id="困难与缺陷"><a href="#困难与缺陷" class="headerlink" title="困难与缺陷"></a>困难与缺陷</h3><p>SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。</p>
<p>缺陷：不利于 SEO；要注意内存管理。</p>
<h2 id="样式规划"><a href="#样式规划" class="headerlink" title="样式规划"></a>样式规划</h2><h3 id="基准样式的分离"><a href="#基准样式的分离" class="headerlink" title="基准样式的分离"></a>基准样式的分离</h3><p>包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。</p>
<h3 id="组件样式的划分"><a href="#组件样式的划分" class="headerlink" title="组件样式的划分"></a>组件样式的划分</h3><p>组件样式应当尽量减少相互依赖，各组件的样式允许冗余。</p>
<h3 id="堆叠次序的管理"><a href="#堆叠次序的管理" class="headerlink" title="堆叠次序的管理"></a>堆叠次序的管理</h3><p>在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。</p>
<p>职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。</p>
<ul>
<li>HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。</li>
<li>JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。</li>
<li>CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。</li>
</ul>
<h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>jQuery 轻量、灵活，但对代码缺乏约束。</p>
<p>需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。</p>
<p>因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。</p>
<p>AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。</p>
<p>React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。</p>
<p>依赖注入： </p>
<ul>
<li>核心理念：通过配置来实例化所依赖的组件。</li>
<li>缺点：性能以及跟踪调试的便利性上的损失。</li>
<li>优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。</li>
<li>应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。</li>
</ul>
<h3 id="MV-框架的基本原理"><a href="#MV-框架的基本原理" class="headerlink" title="MV*框架的基本原理"></a>MV*框架的基本原理</h3><p>充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在<strong>配置文件</strong>（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动：</p>
<ul>
<li>初始化自身（bootstrap）</li>
<li>异步加载可能尚未引入的 JavaScript 代码（require）</li>
<li>解析定义在 HTML 上的规则（template parser）</li>
<li>实例化模型（scopr）</li>
<li>创建模型和 DOM 的关联关系（binding, injection）</li>
</ul>
<p>这些是主线流程，还有一些支线，比如：</p>
<ul>
<li>解析 url 的 search 字符串，恢复状态（route）</li>
<li>加载 HTML 部件模板（template url）</li>
<li>部件模板和模型的关联（binding）</li>
</ul>
<h2 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h2><p>指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。</p>
<p>Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>博文参考资料：</p>
<p><a href="https://github.com/xufei/blog/issues/6" target="_blank" rel="external">Web应用的组件化（一）——基本思路</a></p>
<p><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a></p>
<p><a href="https://github.com/xufei/blog/issues/33" target="_blank" rel="external">关于新框架的学习</a></p>
<p>延伸阅读资料：</p>
<p><a href="https://github.com/xufei/blog/issues/7" target="_blank" rel="external">Web应用的组件化（二）——管控平台</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 &lt;a href=&quot;https://github.com/xufei/blog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xufei&lt;/a&gt; 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://kyonhuang.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="SPA" scheme="http://kyonhuang.top/tags/SPA/"/>
    
      <category term="单页面程序" scheme="http://kyonhuang.top/tags/%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="组件化" scheme="http://kyonhuang.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>最近在干以及打算干些什么</title>
    <link href="http://kyonhuang.top/recent-and-will/"/>
    <id>http://kyonhuang.top/recent-and-will/</id>
    <published>2017-04-26T10:22:33.000Z</published>
    <updated>2017-06-23T13:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。</p>
<p><img src="/images/QinSir.jpg"></p>
<p>在干什么：</p>
<ul>
<li>写花旗杯项目前端第一版。</li>
<li>开始看 Vue.js 的文档。</li>
<li>看一些关于前端工程化的博文。</li>
</ul>
<p>打算干什么：</p>
<ul>
<li>继续看完 Vue.js 的文档并且找一个 Demo 做一做。</li>
<li>尽早看完 ES 6 新特性。</li>
<li>看一看 Grid。</li>
</ul>
<p>最近看的优秀文章：</p>
<ul>
<li><a href="http://www.alloyteam.com/2017/03/getting-started-with-css-modules-and-react-in-practice/" target="_blank" rel="external">CSS Modules 入门及 React 中实践</a></li>
<li><a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="external">玩转 npm</a>：介绍了常用的 npm 命令。</li>
<li><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a>：理解单页 Web 应用。我想这篇文章我还会再看至少两遍。</li>
<li><a href="https://github.com/lin-xin/blog/issues/11" target="_blank" rel="external">HTML5 高级系列：web Storage</a>：了解如何通过 localStorage 和 sessionStorage 存储一些数据。</li>
<li><a href="https://juejin.im/entry/56e1a95b731956005da35c24?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github" target="_blank" rel="external">[译] 人人须知的 jQuery 技巧</a>：介绍了一些 jQuery 代码片段，包括预加载图片、禁用输入字段、简单的手风琴效果等。建议自己整理一份类似的代码片段库。</li>
<li><a href="https://aotu.io/notes/2016/11/22/figlet/" target="_blank" rel="external">FIGlet初识</a>：了解一下 FIGlet，不实用，但还有点意思。</li>
<li><a href="http://www.w3cplus.com/css3/autoprefixer-css-vender-prefixes.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">如何处理CSS3属性前缀</a>：介绍了 Autoprefixer，用于处理 CSS 3 属性前缀的问题。</li>
<li><a href="https://huangxuan.me/js-module-7day/#/2" target="_blank" rel="external">JavaScript Modularization Journey</a>：JS 模块化发展史。还得再看几遍…等我到了该接触 Webpack 的时候。</li>
</ul>
<p>看到的好玩意：</p>
<ul>
<li><strong><a href="https://www.awesomes.cn/" target="_blank" rel="external">Awesomes - Web前端开发资源库</a></strong>：全是前端的开源项目，遍地的轮子啊。关键是文档很多都翻译成中文了。</li>
<li><a href="https://www.npmjs.com/package/pkg" target="_blank" rel="external">pkg</a>：帮助你将你的 Node.js 程序打包成即使在没有 node 环境的设备上也能运行。</li>
<li><a href="https://www.awesomes.cn/repo/mzabriskie/axios" target="_blank" rel="external">Axios</a>：基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用。这个貌似很常用，看看能不能用在现在的项目中。</li>
<li><a href="https://www.awesomes.cn/css/123" target="_blank" rel="external">一个有趣的 CSS 按钮效果</a></li>
<li><a href="https://www.awesomes.cn/repo/IanLunn/hover" target="_blank" rel="external">Hover.css</a>：Hover.css 是一个 CSS3 的鼠标悬停效果集合，可用于超链接，按钮，logo，SVG，推荐图片等等。能够很简单地运用到我们的元素中。</li>
</ul>
<p>之后想做的练习（时间好少QAQ）：</p>
<ul>
<li><a href="http://www.cnblogs.com/coco1s/p/6802374.html" target="_blank" rel="external">谈谈一些有趣的CSS题目</a></li>
<li><a href="http://www.fgm.cc/learn/" target="_blank" rel="external">原生JavaScript学习-实例索引</a></li>
<li><a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/QinSir.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在干什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写花旗杯项目前端第一版。&lt;/li&gt;
&lt;li&gt;开始看 V
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(二)</title>
    <link href="http://kyonhuang.top/es6-2-notes/"/>
    <id>http://kyonhuang.top/es6-2-notes/</id>
    <published>2017-04-24T10:36:13.000Z</published>
    <updated>2017-04-28T07:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">ECMAScript 6 入门</a>》。希望能早日啃完，想去看 Vue.js 了…</p>
<p>此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。</p>
  <a id="more"></a>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>1.ES 6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>)</span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(<span class="string">'Hello'</span>)  <span class="comment">// Hello World</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">'Kyon'</span>)  <span class="comment">// Hello Kyon</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>)  <span class="comment">// Hello</span></div><div class="line"></div><div class="line"><span class="comment">// 与解构赋值默认值结合使用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)  <span class="comment">// 1, 5</span></div><div class="line">foo()  <span class="comment">// TypeeError: Cannot read property 'x' of undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数没有参数的情况</span></div><div class="line">m1() <span class="comment">// [0, 0]</span></div><div class="line">m2() <span class="comment">// [0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// x有值，y无值的情况</span></div><div class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></div><div class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></div><div class="line"></div><div class="line"><span class="comment">// x和y都无值的情况</span></div><div class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></div><div class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></div></pre></td></tr></table></figure>
<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明；使用参数默认值时，函数不能有同名参数。</p>
<p>定义了默认值的参数通常应该为函数的尾参数。</p>
<p>2.函数的<code>length</code>属性：将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，后面的参数也不会被计入。</p>
<p>3.作用域：一旦<strong>设置了参数的默认值</strong>，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，作用域消失。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数foo内部声明的内部变量与参数不是同一个作用域</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123; x = <span class="number">2</span>; &#125;)&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">    y();</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 3</span></div><div class="line">x  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123; x = <span class="number">2</span>; &#125;)&#123;</div><div class="line">    x = <span class="number">3</span>;</div><div class="line">    y();</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 2</span></div><div class="line">x  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>4.函数参数默认值的应用：可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeprovided = throwIfMissing(</span>))</span>&#123;</div><div class="line">    <span class="keyword">return</span> mustBeProvided;</div><div class="line">&#125;</div><div class="line"><span class="comment">// throwIfMissing函数名之后有一对圆括号</span></div><div class="line"><span class="comment">// 表明参数的默认值不是在定义时执行，而是在运行时执行</span></div><div class="line"><span class="comment">// 即如果参数已经赋值，默认值中的函数就不会运行</span></div><div class="line"></div><div class="line">foo()  <span class="comment">// Error: Missing parameter</span></div></pre></td></tr></table></figure>
<p>可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<p>5.rest 参数：形式为”…变量名”，用于获取函数的多余参数。rest 参数中的变量代表一个数组。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</div></pre></td></tr></table></figure>
<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,...b</span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h3 id="函数参数的默认值-1"><a href="#函数参数的默认值-1" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>6.扩展运算符：<code>...</code>，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">35</span>];</div><div class="line">add(...numbers) <span class="comment">// 39</span></div><div class="line"></div><div class="line"><span class="comment">// 不再需要 apply 方法将数组转为函数参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>)</span>&#123;&#125;</div><div class="line">f(...args);</div></pre></td></tr></table></figure>
<p>7.扩展运算符的应用：</p>
<ul>
<li><p>合并数组：提供了新写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];</div><div class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line"></div><div class="line">arr1.concat(arr2, arr3);  <span class="comment">// ES 5</span></div><div class="line">[...arr1, ...arr2, ...arr3]  <span class="comment">// ES 6</span></div></pre></td></tr></table></figure>
</li>
<li><p>与解构赋值结合：用于生成数组（只能放在参数最后一位）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">first <span class="comment">// 1</span></div><div class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> [first, ...rest] = [];</div><div class="line">first <span class="comment">// undefined</span></div><div class="line">rest  <span class="comment">// []:</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];</div><div class="line">first  <span class="comment">// "foo"</span></div><div class="line">rest   <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>函数的返回值：为函数提供一种返回多个值的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从数据库取出一行数据，通过扩展运算符，直接传入构造函数Date</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> dateFields = readDateFields(database);</div><div class="line"><span class="keyword">var</span> d = newDate(...dateFields);</div></pre></td></tr></table></figure>
</li>
<li><p>字符串：扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</div><div class="line"></div><div class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></div><div class="line"></div><div class="line">[...str].reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现了 Iterator 接口的对象：可以通过扩展运算符转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"><span class="keyword">var</span> array = [...nodeList];</div></pre></td></tr></table></figure>
</li>
<li><p>Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符。Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Map结构</span></div><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</div><div class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</div><div class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// Generator 函数</span></div><div class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[...go()] <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>8.函数内部严格模式：ES 5 时函数内部可以设定为严格模式；ES 6 规定只要函数参数使用了<strong>默认值、解构赋值或者扩展运算符</strong>，则函数内部不能显式设定为严格模式，否则报错。</p>
<p>原因：只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>
<p>两种规避方法：全局性严格模式，将函数包在一个无参数的立即执行函数里。</p>
<p>9.name 属性：返回该函数的函数名。</p>
<p>如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ES 5、ES 6</span></div><div class="line">bar.name <span class="comment">// "baz"</span></div></pre></td></tr></table></figure>
<p><code>Function</code>构造函数返回的函数实例，name 属性的值为 <code>anonymous</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></div></pre></td></tr></table></figure>
<p><code>bind</code>返回的函数，name属性值会加上<code>bound</code>前缀。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></div></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>10.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 箭头函数与变量解构结合使用</span></div><div class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 简化回调函数</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>11.箭头函数使用注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象就是<strong>定义时所在对象</strong>，而不是使用时所在对象。</li>
<li>不可当作构造函数（即不可使用<code>new</code>命令），否则抛出错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
<p><code>this</code>指向的固定化，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。也正因如此，箭头函数不能用作构造函数，也不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>
<p>除了<code>this</code>，<code>arguments</code>、<code>super</code>、<code>new.target</code>在箭头函数中也是不存在的，指向外层函数的对应变量。</p>
<p>12.嵌套的箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES 5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span>(<span class="params">afterValue</span>) </span>&#123;</div><div class="line">      array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</div><div class="line">      <span class="keyword">return</span> array;</div><div class="line">    &#125;&#125;;</div><div class="line">  &#125;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// ES 6</span></div><div class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</div><div class="line">  array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;&#125;)&#125;);</div><div class="line"></div><div class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>13.函数绑定运算符：<code>::</code>，左边为对象，右边为函数。该运算符自动将左边的对象作为上下文环境（即 this 对象），绑定到右边的函数上。用来取代<code>call</code>、<code>apply</code>、<code>bind</code>调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.apply(foo, <span class="built_in">arguments</span>);</div></pre></td></tr></table></figure>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> method = obj::obj.foo;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> method = ::obj.foo;</div><div class="line"></div><div class="line"><span class="keyword">var</span> log = ::<span class="built_in">console</span>.log;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</div></pre></td></tr></table></figure>
<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; find, html &#125; = jake;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">"div.myClass"</span>)</div><div class="line">::find(<span class="string">"p"</span>)</div><div class="line">::html(<span class="string">"hahaha"</span>);</div></pre></td></tr></table></figure>
<p>该语法为已被 Babel 转码器支持的一个 ES 7 提案。</p>
<p>14.尾调用：某个函数的最后一步是调用另一个函数。</p>
<p>To be continued…</p>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>1.属性的简洁表示法：ES 6 允许直接写入变量和函数，作为对象的属性和方法。这时，属性名为变量名，属性值为变量值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line">baz  <span class="comment">// &#123;foo: "bar"&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  method()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  * m()&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>2.属性名表达式：ES 6 允许字面量定义对象时，把表达式放在方括号内。表达式也可用于定义方法名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [propKey]: <span class="literal">true</span>,</div><div class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 表达式用于定义方法名</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.hello()  <span class="comment">// hi</span></div></pre></td></tr></table></figure>
<p>但<strong>属性名</strong>表达式与简洁表达式不能同时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> bar = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123; [foo] &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</div></pre></td></tr></table></figure>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>（即不要这么用）。</p>
<p>3.方法的 name 属性：返回函数名。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<p>4.<code>Object.is()</code>：比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致（不同之处为<code>+0</code>不等于<code>-0</code>，以及<code>NaN</code>等于自身）。</p>
<p>5.<code>Object.assign()</code>：用于对象的合并，将源对象的所有可枚举属性复制到目标对象。第一个参数是目标对象，其他参数是源对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target  <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div></pre></td></tr></table></figure>
<p>如果多个对象有同名属性，后面的属性会覆盖前面的。</p>
<p>如果只有一个参数将直接返回（参数不是对象会先转成对象）。无法转成对象的源对象将被跳过。<code>undefined</code>和<code>null</code>无法转成对象，所以不能作为目标对象（否则报错）。其他相关注意事项见文档。</p>
<p>实行浅拷贝，即源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。对于嵌套对象，一旦遇到同名属性会被替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span>&#125; &#125;;</div><div class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source);  <span class="comment">// &#123;a: &#123; b: 'hello' &#125;&#125;</span></div></pre></td></tr></table></figure>
<p><code>Object.assign()</code>有很多用处，其中包括为对象添加属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加属性</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</div><div class="line">  someMethod(arg1, arg2)&#123; ... &#125;,</div><div class="line">  anotherMethod()&#123; ... &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; ... &#125;;</div><div class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;;</div></pre></td></tr></table></figure>
<h3 id="属性的可枚举性与遍历"><a href="#属性的可枚举性与遍历" class="headerlink" title="属性的可枚举性与遍历"></a>属性的可枚举性与遍历</h3><p>6.<code>Object.getOwnPropertyDescriptor</code>：对象的每个属性都有一个描述对象，用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获得该属性的描述对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   value: 123,</span></div><div class="line"><span class="comment">//   writable: true,</span></div><div class="line"><span class="comment">//   enumerable: true,</span></div><div class="line"><span class="comment">//   configurable: true</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>ES 7 引入<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</div><div class="line">  get bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   foo: &#123;</span></div><div class="line"><span class="comment">//     value: 123,</span></div><div class="line"><span class="comment">//     writable: true,</span></div><div class="line"><span class="comment">//     enumerable: true,</span></div><div class="line"><span class="comment">//     configurable: true</span></div><div class="line"><span class="comment">//   &#125;,</span></div><div class="line"><span class="comment">//   bar: &#123;</span></div><div class="line"><span class="comment">//     get: [Function: bar],</span></div><div class="line"><span class="comment">//     set: undefined,</span></div><div class="line"><span class="comment">//     enumerable: true,</span></div><div class="line"><span class="comment">//     configurable: true</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>7.属性的可枚举性：描述对象的<code>enumerable</code>属性，成为“可枚举性”。ES 5 有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性：</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和<strong>继承的</strong>可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
</ul>
<p>ES 6 新增<code>Object.assign()</code>，会忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</p>
<p><strong>当只关心对象自身的属性时，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</strong></p>
<p>8.<code>Object.keys()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键名</strong>。ES 2017 引入配套的<code>Object.values</code>和<code>Object.entries</code>作为遍历一个对象的补充手段。</p>
<p><code>Object.values()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值</strong>（不含 Symbol 属性）。参数为字符串时返回各个字符组成的一个数组，参数为数值或布尔值时返回空数组（与包装对象有关）。</p>
<p><code>Object.entries()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值对数组</strong>（不含 Symbol 属性）。</p>
<p>9.属性的遍历：ES 6 共有5种遍历对象的方法。</p>
<ol>
<li><code>for...in</code>：循环遍历对象<strong>自身的</strong>和<strong>继承的</strong>可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但<strong>包括不可枚举属性</strong>）。</li>
<li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的<strong>所有 Symbol 属性</strong>。</li>
<li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有属性（无论是否可枚举或者属性名是 Symbol 还是字符串）。</li>
</ol>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则（之前一些遍历的方法也遵循此规则）。</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<h3 id="proto-属性及相关方法"><a href="#proto-属性及相关方法" class="headerlink" title="__proto__属性及相关方法"></a><code>__proto__</code>属性及相关方法</h3><p>10.<code>__proto__</code>属性：用于读取或设置当前对象的<code>prototype</code>对象。内部属性，不是正式对外 API。建议使用<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototype()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>如果一个对象本身部署了<code>__proto__</code>属性，则该属性的值就是对象的原型。</p>
<p>11.<code>Object.setPrototypeOf()</code>：作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</div><div class="line"></div><div class="line"><span class="comment">// 用法</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>如果第一个参数不是对象，会自动转为对象（由于返回的还是第一个参数，故无效果）；是<code>undefined</code>或<code>null</code>则报错（无法转为对象）。</p>
<p>12.<code>Object.getPrototypeOf()</code>：用于读取一个对象的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</div></pre></td></tr></table></figure>
<p>如果参数不是对象，会被自动转为对象；是<code>undefined</code>或<code>null</code>则报错。</p>
<p>13.对象的扩展运算符：ES 2017 将<code>...</code>引入对象。主要用途有：</p>
<ul>
<li>解构赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;x, y, ...z&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line">x  <span class="comment">// 1</span></div><div class="line">y  <span class="comment">// 2</span></div><div class="line">z  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>
<p>注意解构赋值的拷贝是浅拷贝，且不会拷贝继承自原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 扩展某个函数的参数，引入其他操作</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// 使用x和y参数进行操作</span></div><div class="line">  <span class="comment">// 其余参数传给原始函数</span></div><div class="line">  <span class="keyword">return</span> baseFunction(restConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>扩展运算符：取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于<code>Object.assign</code>方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</div><div class="line">n  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> n = <span class="built_in">Object</span>.assign(&#123;&#125;, z);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 用于合并两个对象</span></div><div class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</div></pre></td></tr></table></figure>
<p>如果用户自定义的属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。因此可用于修改现有对象部分的部分属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newVersion = &#123;</div><div class="line">  ...previousVersion,</div><div class="line">  <span class="attr">name</span>: <span class="string">'New Name'</span>  <span class="comment">// Override the name property</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</div></pre></td></tr></table></figure>
<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<p>14.Null 传导运算符：<code>?.</code>，用于判断对象及其内部属性是否存在。仅为提案，详见文档。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>1.概述：ES 6 引入的新的原始数据类型，表示独一无二的值。至此，JS 共有七种数据类型：</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>布尔值（Boolean）</li>
<li>字符串（String）</li>
<li>数值（Number）</li>
<li>对象（Object）</li>
<li>Symbol</li>
</ul>
<p>Symbol 值通过<code>Symbol</code>函数生成。即对象的属性名有两种类型：原来就有的字符串，和新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就是独一无二的，不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> s</div><div class="line"><span class="comment">// "symbol"</span></div></pre></td></tr></table></figure>
<p>生成的 Symbol 是一个原始类型的值，不是对象。因此<code>Symbol</code>函数前不能使用<code>new</code>命令（否则报错），Symbol 值也不能添加属性。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。但相同参数的<code>Symbol</code>函数的返回值是<strong>不相等</strong>的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</div><div class="line"></div><div class="line">s1  <span class="comment">// Symbol(foo)</span></div><div class="line">s2  <span class="comment">// Symbol(bar)</span></div><div class="line"></div><div class="line">s1.toString()  <span class="comment">// "Symbol(foo)"</span></div><div class="line">s2.toString()  <span class="comment">// "Symbol(bar)"</span></div></pre></td></tr></table></figure>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后生成一个 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  toString()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'kyon'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</div><div class="line">sym  <span class="comment">// Symbol(abc)</span></div></pre></td></tr></table></figure>
<p>Symbol 值不能与其他类型的值进行运算（会报错），但可以显式转为字符串和布尔值。</p>
<p>2.作为属性名的Symbol：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="comment">// 第一种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 第二种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  [mySymbol]: <span class="string">'Hello!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 第三种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello'</span>! &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 以上写法都得到同样结果</span></div><div class="line">a[mySymbol]  <span class="comment">// "Hello!"</span></div></pre></td></tr></table></figure>
<p>Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"></div><div class="line">a.mySymbol = <span class="string">'Hello!'</span>;</div><div class="line">a[mySymbol]  <span class="comment">// undefined</span></div><div class="line">a[<span class="string">'mySymbol'</span>]  <span class="comment">// "Hello!"</span></div></pre></td></tr></table></figure>
<p>Symbol 值作为属性名时，该属性是<strong>公开属性</strong>而非私有属性。</p>
<p>3.魔术字符串：在代码中多次出现、与代码形成强耦合的某一个具体的字符串或数值。应尽量消除而改用含义清晰的变量代替。</p>
<p><code>Symbol</code>可用于消除魔术字符串。</p>
<p>4.属性名的遍历：Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。这个特性可被用于为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<p><code>Reflect.ownKeys(obj)</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</div><div class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</div><div class="line"><span class="comment">// ["enum", "nonEnum", Symbol(my_key)]</span></div></pre></td></tr></table></figure>
<p>5.<code>Symbol.for()</code>、<code>Symbol.keyFor()</code>：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2;  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的<code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>Symbol.keyFor</code>方法返回一个<strong>已登记</strong>的 Symbol 类型值的<code>key</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s1);  <span class="comment">// "foo"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>)</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s2);  <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>6.Singleton 模式：指调用一个类，任何时候返回的都是同一个实例。</p>
<p>Node 中，模块文件可以看作一个类。可以使用 Symbol，通过把实例放到顶层对象<code>global</code>来实现 Singleton 模式。</p>
<h3 id="内置的-Symbol-值-暂且略过"><a href="#内置的-Symbol-值-暂且略过" class="headerlink" title="内置的 Symbol 值(暂且略过)"></a>内置的 Symbol 值(暂且略过)</h3><p>7.<code>Symbol.hasInstance</code>属性：指向一个内部方法。</p>
<p>8.<code>Symbol.isConcatSpreadable</code>属性：</p>
<p>9.<code>Symbol.species</code></p>
<p>10.<code>Symbol.match</code></p>
<p>11.<code>Symbol.replace</code></p>
<p>12.<code>Symbol.search</code></p>
<p>13.<code>Symbol.split</code></p>
<p>14.<code>Symbol.iterator</code></p>
<p>15.<code>Symbol.toPrimitive</code></p>
<p>16.<code>Symbol.toStringTag</code></p>
<p>17.<code>Symbol.unscopables</code></p>
<h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>1.基本用法：Set 结构不会添加重复的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 3 5 4</span></div></pre></td></tr></table></figure>
<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。因此有一种去除数组重复成员的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...new <span class="built_in">Set</span>(array)]</div></pre></td></tr></table></figure>
<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，类似精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身（<code>===</code>认为<code>NaN</code>不等于自身）。另外，两个对象总是不相等的。</p>
<p>2.Set 实例的属性和方法：</p>
<p>实例属性：</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>操作方法：</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个表示删除是否成功的布尔值。</li>
<li><code>has(value)</code>：返回一个布尔值。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>遍历方法（Set 结构中，键名和键值是同一个值）：</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>3.含义：与 Set 类似，但成员只能是对象，且都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>ES 6 规定，WeakSet 不可遍历。</p>
<p>4.语法：有<code>add</code>、<code>delete</code>、<code>has</code>方法；没有<code>size</code>属性。</p>
<p>5.用处：是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>6.含义和基本用法：为了解决 Object 的只能用字符串当作键名的问题，ES 6 提供了 Map 数据结构。各种类型的值（包括对象）都可以当作键。</p>
<p>有<code>set(key, value)</code>、<code>get(key)</code>、<code>has(key)</code>、<code>delete(key)</code>、<code>clear()</code>方法。</p>
<p>作为构造函数，Map 可以接受一个数组作为参数，该数组的成员是一个个<strong>表示键值对的数组</strong>。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值；如果读取一个未知的键，则返回<code>undefined</code>。</p>
<p>7.与其他数据结构的互相转换：</p>
<ul>
<li>Map 转为数组：使用扩展运算符（<code>...</code>）。</li>
<li>数组转为 Map：使用 Map 构造函数。</li>
<li>Map 转为对象：如果所有 Map 的键都是字符串，可以转为对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap)&#123;</div><div class="line">    obj[k] = v;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);</div><div class="line">strMapToObj(myMap);</div><div class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>对象转为 Map：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;</div><div class="line">    strMap.set(k, obj[k]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> strMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Map 转为 JSON：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况一：Map 的键名都是字符串</span></div><div class="line"><span class="comment">// 可以转换为对象 JSON</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况二：Map 的键名有非字符串</span></div><div class="line"><span class="comment">// 可以转换为数组 JSON</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJSON</span>(<span class="params">map</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>JSON 转为 Map：逆操作。</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>8.含义：与 Map 类似，用于生成键值对。但只接受对象作为键名（<code>null</code>除外），且键名所指向的对象不计入垃圾回收机制。</p>
<p>专用场合：它的键所对应的对象可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>9.语法：没有遍历操作，无法清空。只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<p>10.用处：DOM 节点作为键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个例子</span></div><div class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</div><div class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</div><div class="line"></div><div class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</div><div class="line">  logoData.timesClicked++;</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险</span></div></pre></td></tr></table></figure>
<p>注册监听事件的<code>listener</code>对象，就很适合用 WeakMap 实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> listener = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line">listener.set(element1, handler1);</div><div class="line">listener.set(element2, handler2);</div><div class="line"></div><div class="line">element1.addEventListener(<span class="string">'click'</span>, listener.get(element1), <span class="literal">false</span>);</div><div class="line">element2.addEventListener(<span class="string">'click'</span>, listener.get(element2), <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一旦DOM对象消失，跟它绑定的监听函数也会自动消失</span></div></pre></td></tr></table></figure>
<p>WeakMap 的另一个用处是部署私有属性。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>暂时跳过。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>暂时跳过。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;》。希望能早日啃完，想去看 Vue.js 了…&lt;/p&gt;
&lt;p&gt;此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《精通jQuery》读书笔记</title>
    <link href="http://kyonhuang.top/jQuery-master-notes/"/>
    <id>http://kyonhuang.top/jQuery-master-notes/</id>
    <published>2017-04-21T06:50:27.000Z</published>
    <updated>2017-04-28T07:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。</p>
<p>感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。</p>
  <a id="more"></a>
<h2 id="了解-jQuery"><a href="#了解-jQuery" class="headerlink" title="了解 jQuery"></a>了解 jQuery</h2><h3 id="jQuery-核心库的工作"><a href="#jQuery-核心库的工作" class="headerlink" title="jQuery 核心库的工作"></a>jQuery 核心库的工作</h3><p>通过处理浏览器加载 HTML 时动态创建的 DOM（文档对象模型），达到动态修改页面内容的目标。</p>
<h2 id="HTML-入门"><a href="#HTML-入门" class="headerlink" title="HTML 入门"></a>HTML 入门</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>一个事件在它的生命周期中要经历 3 个阶段：<strong>捕获</strong>、处理<strong>目标元素</strong>和<strong>冒泡</strong>。</p>
<p>目标元素：触发事件的元素。</p>
<h2 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h2><h3 id="反选择器"><a href="#反选择器" class="headerlink" title="反选择器"></a>反选择器</h3><p><code>:not(&lt;selector&gt;)</code>：选取不匹配指定选择器的元素。</p>
<h3 id="样式层叠"><a href="#样式层叠" class="headerlink" title="样式层叠"></a>样式层叠</h3><p>浏览器查找样式元素值的顺序：</p>
<ol>
<li>行内样式（定义在元素 style 属性中的样式）；</li>
<li>内嵌样式（定义在 style 元素中的样式）；</li>
<li>外部样式（使用 link 元素导入的样式）；</li>
<li>用户样式（用户自己定义的样式）；</li>
<li>浏览器样式（浏览器提供的默认样式）。</li>
</ol>
<p>前三个又合称为作者样式。</p>
<h4 id="important-规则"><a href="#important-规则" class="headerlink" title="important 规则"></a>important 规则</h4><p>在样式声明的末尾追加<code>!important</code>可以把改值标识为<strong>重要样式</strong>。浏览器会给重要样式以优先权，而不再考虑这个样式的定义位置。</p>
<p>唯一能优先于作者样式中重要样式的样式是定义在用户样式表中的重要样式。对于普通样式来说，作者样式优先于用户样式。但对于重要样式，浏览器的做法恰恰相反。</p>
<h4 id="“专一程度”"><a href="#“专一程度”" class="headerlink" title="“专一程度”"></a>“专一程度”</h4><p>浏览器根据以下 3 个特征计算样式的“专一程度”：</p>
<ol>
<li>选择器中出现的 id 值个数；</li>
<li>选择器中出现的其他属性和伪类个数；</li>
<li>选择器中出现的元素名字和伪元素名字个数。</li>
</ol>
<p>以 a-b-c 这种形式评估样式规则的“专一”程度，逐位比较，每一位上数字越大表示越专一。例如，1-0-0 比 0-5-5 更专一。</p>
<p>如果有多条样式规则的专一程度相同，那么浏览器会选择最后定义的那条规则。专一程度规则仅在同一层叠级别有效。</p>
<h3 id="样式单位"><a href="#样式单位" class="headerlink" title="样式单位"></a>样式单位</h3><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><ul>
<li>em：相对于元素字号的高度；</li>
<li>ex：相对于元素字体中小写字母 x 的高度；</li>
<li>rem：相对于根元素的高度；</li>
<li>px：CSS 像素（假定位于一个 96dpi 的显示设备上，实际上是绝对单位，不会改变大小）；</li>
<li>%：另一属性值的百分比。</li>
</ul>
<h2 id="jQuery-基础"><a href="#jQuery-基础" class="headerlink" title="jQuery 基础"></a>jQuery 基础</h2><h3 id="使用-CDN-版的-jQuery"><a href="#使用-CDN-版的-jQuery" class="headerlink" title="使用 CDN 版的 jQuery"></a>使用 CDN 版的 jQuery</h3><p>CDN（Content Delivery Network）：内容分发网络。当用户请求其数据时，CDN 能智能地分配离用户最近的服务器提供服务。</p>
<p>使用 CDN 的两个优点：(1)用户体验更好（速度通常更快）；(2)节省了传输 jQuery 库所需带宽。</p>
<p>CDN 不适合内联网应用程序。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="$ 函数"></a>$ 函数</h3><p><code>jQuery.noConflict</code>方法让 jQuery 放弃使用 $ 符号。也可将该方法的返回值赋给一个变量以自定义 jQuery 简写符号。</p>
<h3 id="延迟-ready-事件的触发时间"><a href="#延迟-ready-事件的触发时间" class="headerlink" title="延迟 ready 事件的触发时间"></a>延迟 ready 事件的触发时间</h3><p><code>$.holdReady(true)</code>必须在 ready 事件触发之前调用，<code>$.holdReady(false)</code>告诉 jQuery 触发 ready 事件。可以多次调用，但在 ready 事件被真正触发之前，使用 true 参数调用次数要等于使用 false 参数调用次数。 </p>
<h3 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h3><p><img src="/images/jQueryMaster/jquery-selector1.jpg"></p>
<p><img src="/images/jQueryMaster/jquery-selector2.jpg"></p>
<h4 id="使用上下文限制搜索范围"><a href="#使用上下文限制搜索范围" class="headerlink" title="使用上下文限制搜索范围"></a>使用上下文限制搜索范围</h4><p>多给 $ 函数提供一个参数以限制搜索的范围。如果提供的上下文选择器匹配多个元素，将会把匹配上下文选择器的元素收集在一起，然后再匹配主选择器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"img:odd"</span>, $(<span class="string">".drow"</span>))</div><div class="line"><span class="comment">// img:odd选择器会应用在.drow选择器的结果上</span></div></pre></td></tr></table></figure>
<h4 id="确定选择结果"><a href="#确定选择结果" class="headerlink" title="确定选择结果"></a>确定选择结果</h4><p><img src="/images/jQueryMaster/jquery-selector3.jpg"></p>
<h2 id="数据模版"><a href="#数据模版" class="headerlink" title="数据模版"></a>数据模版</h2><p>介绍了模板库 Handlebars。</p>
<h3 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h3><p>数据模板库的核心是<strong>数据模板</strong>——包含着占位符的 HTML 元素。</p>
<p>p268</p>
<h2 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h2><p>介绍了 jQuery 插件 Validation，它专门处理表单验证问题。</p>
<p><a href="http://code.ciaoca.com/jquery/validation-engine/" target="_blank" rel="external">jQuery Validation Engine 表单验证</a></p>
<p>p297</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>p331</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。&lt;/p&gt;
&lt;p&gt;感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jQuery" scheme="http://kyonhuang.top/tags/jQuery/"/>
    
      <category term="《精通jQuery》" scheme="http://kyonhuang.top/tags/%E3%80%8A%E7%B2%BE%E9%80%9AjQuery%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(一)</title>
    <link href="http://kyonhuang.top/es6-1-notes/"/>
    <id>http://kyonhuang.top/es6-1-notes/</id>
    <published>2017-04-06T08:21:52.000Z</published>
    <updated>2017-05-12T02:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">ECMAScript 6 入门</a>。将知识点简便地总结一下，以供后续使用时参考或复习。</p>
<p>此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。</p>
  <a id="more"></a>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><p>1.<code>let</code>：<code>let</code>声明的变量仅在块级作用域内有效。不存在变量提升；存在暂时性死区，只能在声明的位置后面获取和使用；相同作用域内不可重复声明。</p>
<p>2.块级作用域：外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。</p>
<p>3.根据ES 6附录B的规定，在浏览器的ES 6环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。应避免在块级作用域内声明函数，或用函数表达式代替函数声明语句。</p>
<p>4.do 表达式：在块级作用域之前加上<code>do</code>，使其变为表达式（可以返回值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量x得到整个块级作用域的返回值</span></div><div class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> t = f();</div><div class="line">    t * t + <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>5.<code>const</code>：声明一个只读常量。一旦声明，就必须立即初始化。和<code>let</code>一样，只在声明所在的块级作用域内有效；声明的常量不提升；存在暂时性死区；不可重复声明。</p>
<p><code>const</code>保证变量指向的内存地址不可改动。因此将对象声明为常量时，不可变的只是地址，对象本身可变，可以为其添加新属性。</p>
<p>如果真想将对象冻结，应用<code>Object.freeze()</code>方法（对象本身和 其属性都应冻结）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">Object</span>.freeze(obj);</div><div class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            constantize(obj[key]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>6.顶层对象的属性：<code>let</code>、<code>const</code>、<code>class</code>声明的全局变量不属于顶层对象的属性。</p>
<p>补充资料：<a href="https://blog.fundebug.com/2017/05/04/why-you-should-not-use-var/" target="_blank" rel="external">ES6之”let”能替代”var”吗?</a></p>
<h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>1.解构：按照一定模式，从数组和对象中提取值，对变量进行赋值。解构不成功，变量的值就等于<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line">third <span class="comment">// "baz"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</div><div class="line">foo <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>2.不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<p>3.解构赋值允许指定默认值。ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值不会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></div></pre></td></tr></table></figure>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的（用到时才会求值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x能取到值，所以函数f根本不会执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>4.要将一个已经声明的变量用于解构赋值时，将大括号写在行首会导致JavaScript引擎将其解释为代码块，从而发生语法错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"><span class="comment">// 错误写法</span></div><div class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;  <span class="comment">// SyntaxError: syntax error</span></div><div class="line"><span class="comment">// 正确写法</span></div><div class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h3><p>5.对象的解构：属性没有次序，变量取值由名称决定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; bar, foo&#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo  <span class="comment">// "aaa"</span></div><div class="line">bar  <span class="comment">// "bbb"</span></div></pre></td></tr></table></figure>
<p>如果变量名与属性名不一致，须写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz&#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</div><div class="line">baz  <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</div><div class="line">f  <span class="comment">// 'hello'</span></div><div class="line">l  <span class="comment">// 'world'</span></div></pre></td></tr></table></figure>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p>6.解构也可用于嵌套结构的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">p</span>: [</div><div class="line">        <span class="string">'Hello'</span>,</div><div class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;]&#125; = obj;</div><div class="line">x  <span class="comment">// "Hello"</span></div><div class="line">y  <span class="comment">// "World"</span></div><div class="line"><span class="comment">// 这时p是模式，不是变量，因此不会被赋值。</span></div><div class="line">p  <span class="comment">// error: p is undefined</span></div></pre></td></tr></table></figure>
<h3 id="字符串的结构赋值"><a href="#字符串的结构赋值" class="headerlink" title="字符串的结构赋值"></a>字符串的结构赋值</h3><p>7.此时字符串被转化成一个类似数组的对象，且具有<code>length</code>属性（可以针对此属性解构赋值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a  <span class="comment">// "h"</span></div><div class="line">e  <span class="comment">// "o"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len  <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h3 id="数值、布尔值的结构赋值"><a href="#数值、布尔值的结构赋值" class="headerlink" title="数值、布尔值的结构赋值"></a>数值、布尔值的结构赋值</h3><p>8.解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。<code>undefined</code>和<code>null</code>无法转为对象，所以对它们解构赋值都会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure>
<h3 id="函数参数的结构赋值"><a href="#函数参数的结构赋值" class="headerlink" title="函数参数的结构赋值"></a>函数参数的结构赋值</h3><p>9.为函数<code>move</code>的参数指定默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, 0]</span></div><div class="line">move(&#123;&#125;);  <span class="comment">// [0, 0]</span></div><div class="line">move();  <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure>
<p>为变量<code>x</code>和<code>y</code>指定默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y:<span class="number">0</span>&#125;</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, undefined]</span></div><div class="line">move(&#123;&#125;);  <span class="comment">// [undefined, undefined]</span></div><div class="line">move();  <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure>
<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>10.ES6规定，只要可能导致解构歧义，就不得使用圆括号。由于这条规则不易辨别，因此建议尽量不要在模式中放置圆括号。</p>
<p>11.以下三种解构赋值不得使用圆括号。</p>
<ul>
<li>变量声明语句中，不能带有圆括号。</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</li>
</ul>
<p>12.可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。</p>
<p><strong>用途</strong></p>
<ul>
<li>交换变量的值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<ul>
<li>从函数中返回多个值：将返回的数组或对象中的值取出</li>
<li>函数参数的定义：方便地将无序的参数与变量名对应</li>
<li>提取JSON数据：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">24</span>,</div><div class="line">  <span class="attr">status</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="attr">data</span>: [<span class="number">424</span>, <span class="number">5920</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 24, "OK", [424, 5920]</span></div></pre></td></tr></table></figure>
<ul>
<li>函数参数的默认值</li>
<li>遍历Map结构：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div></pre></td></tr></table></figure>
<ul>
<li>输入模块的指定方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>1.字符的Unicode表示法：将码点放入大括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\u&#123;20BB7&#125;"</span>  <span class="comment">// "𠮷"</span></div><div class="line"></div><div class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span>  <span class="comment">// "ABC"</span></div></pre></td></tr></table></figure>
<p>2.新增一些方法：</p>
<ul>
<li><code>codePointAt()</code>：能够正确处理4个字节储存的字符，返回一个字符的码点。是测试一个字符由两个字节还是由四个字节组成的最简单方法。</li>
<li><code>String.fromCodePoint()</code>：用于从码点返回对应字符，可识别Unicode编号大于0xFFFF的码点（32位的UTF-16字符）。</li>
<li><code>at()</code>（提案）：返回字符串给定位置的字符，可识别Unicode编号大于0xFFFF的码点。</li>
<li><code>repeat(n)</code>：返回一个新字符串，表示将原字符串重复n次。</li>
<li><code>normalize()</code>：将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
<li><code>padStart()</code>：如果某个字符串不够指定长度，会在头部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串（默认为空格）。</li>
<li><code>padEnd()</code>：同上，用于尾部补全。</li>
</ul>
<p>3.模版字符串：常用于定义多行字符串，或者在字符串中嵌入变量。用反引号（`）标识。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Kyon"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure>
<p>模板字符串中嵌入变量，要将变量名卸载<code>${}</code>中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，也可以调用函数。</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串（例如对象调用<code>toString</code>方法）。</p>
<p>4.标签模板（功能）：函数调用的一种特殊形式。模板字符串作为参数紧跟在一个函数名后，该函数被调用以处理该模板字符串。常用于转义特殊字符和多语言转换（国际化处理）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log<span class="string">`Kyon`</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Kyon'</span>)</div></pre></td></tr></table></figure>
<p>模板字符有变量时，先把模板字符串处理成多个参数。处理得到的第一个参数是一个数组，包含那些没有变量替换的部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">tag([<span class="string">'Hello'</span>, <span class="string">' world'</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性，保存转义后的原字符串。</p>
<p>5.<code>String.raw()</code>：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串；如果原字符串的斜杠已经转义，则不会做任何处理。常用于处理模板字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">3</span>+<span class="number">4</span>&#125;</span>!`</span>;</div><div class="line"><span class="comment">// "Hi\\n7!"</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</div><div class="line"><span class="comment">// 'Hi\\u000A!'</span></div></pre></td></tr></table></figure>
<p>也可作为正常函数使用，第一个参数应是具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应是一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// 't0e1s2t'</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>6.模板字符串的限制（提案）：放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>
<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><p>1.<code>u</code>修饰符：Unicode 模式，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。对于码点大于<code>\uFFFF</code>的 Unicode 字符，点字符(<code>.</code>，除了换行符外的任意单个字符)、Unicode 字符表示法（使用大括号表示 Unicode 字符）、量词、预定义模式（<code>\S</code>，匹配所有不是空格的字符）必须加上<code>u</code>修饰符才能识别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>)</div><div class="line"><span class="comment">// false</span></div><div class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>2.<code>y</code>修饰符：“粘连”修饰符，全局匹配，但须确保匹配必须从剩余的第一个位置开始。一个应用是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</div><div class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</div><div class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</div><div class="line"></div><div class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></div><div class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></div><div class="line"></div><div class="line">r1.exec(s) <span class="comment">// ["aa"]</span></div><div class="line">r2.exec(s) <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>3.ES 6 的正则对象新增了<code>sticky</code>属性和<code>flags</code>属性，分别表示是否设置了<code>y</code>修饰符以及返回正则表达式的修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</div><div class="line">r.sticky  <span class="comment">// true</span></div><div class="line">r.flags  <span class="comment">// 'y'</span></div></pre></td></tr></table></figure>
<p>4.有一些提案。因为我暂时对正则不太熟悉，所以略过。</p>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>1.二进制、八进制表示法：分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。用<code>Number()</code>方法将其转化为十进制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>)  <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>2.新增 Number 对象上的一些方法：</p>
<ul>
<li><code>Number.isFinite()</code>：用于检查一个数值是否为有限的。</li>
<li><code>Number.isNaN()</code>：用于检查一个值是否为<code>NaN</code>。</li>
</ul>
<p>与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>
<ul>
<li>将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到 Number 对象上，行为完全保持不变，目的是逐步减少全局性方法，使得语言逐步模块化。</li>
<li><code>Number.isInteger()</code>：用于判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是同样的储存方法，这个方法都会返回 true。</li>
</ul>
<p>3.<code>Number.EPSILON</code>：极小的常量，表示一个可以接受的误差范围。浮点数计算误差小于<code>Number.EPSILON</code>时可以认为得到正确结果。</p>
<p>4.<code>Number.isSafeInteger()</code>：JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围的值无法精确表示。<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量用来表示这个范围的上下限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<p>5.Math 对象的扩展：所有新增方法都是静态方法，只能在 Math 对象上调用。</p>
<ul>
<li><code>Math.trunc()</code>：用于去除一个数的小数部分，返回整数部分。对于非数值内部使用<code>Number</code>方法将其先转为数值；对于空值和无法截取整数的值，返回 NaN。</li>
<li><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。它会返回五种值：参数为正数，返回+1；负数返回-1；0返回0；-0返回-0；其他值返回NaN。</li>
<li><code>Math.cbrt</code>：用于计算一个数的立方根。</li>
</ul>
<p>此外，还有一些对数方法和三角函数方法。</p>
<p>6.指数运算符（<code>**</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span> ** <span class="number">2</span>  <span class="comment">// 4</span></div><div class="line"><span class="number">2</span> ** <span class="number">3</span>  <span class="comment">// 8</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</div><div class="line">a **= <span class="number">3</span>;</div><div class="line"><span class="comment">// 等同于 a = a * a * a;</span></div></pre></td></tr></table></figure>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>1.<code>Array.from()</code>：将类数组对象（本质特征是有<code>length</code>属性）和可遍历对象（部署了 Iterator 接口的数据结构，包括 ES 6新增的 Set 和 Map）转化为真正的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123;</div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr1 = <span class="built_in">Array</span>.from(arrayLike);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>);</div><div class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></div></pre></td></tr></table></figure></p>
<p>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组；如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from()</code>的第三个参数，用来绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</div><div class="line"><span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure>
<p>2.<code>Array.of()</code>：返回参数值组成的数组（没有参数则返回空数组）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>)  <span class="comment">// [3]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></div></pre></td></tr></table></figure>
<p>3.数组实例的<code>copyWithin()</code>：在当前数组内部，将指定位置的成员复制到其他位置（覆盖原有成员），然后返回当前数组。</p>
<p>接受三个参数（都为数值，否则自动转换）：</p>
<ul>
<li>target（必需）：从该位置开始替换数据；</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>4.数组实例的<code>find()</code>和<code>findIndex()</code>：</p>
<p><code>find()</code>用于找出第一个符合条件的数组成员。其参数为一个回调函数（可以接收三个参数：当前的值，当前的位置和原数组），所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员，否则返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</div><div class="line"><span class="comment">// -5</span></div></pre></td></tr></table></figure>
<p><code>findIndex()</code>类似，返回第一个符合条件的数组成员的位置，否则返回<code>-1</code>。</p>
<p>5.数组实例的<code>fill()</code>：用给定值填充一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组中原有的元素将被覆盖</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line"><span class="comment">// 还可以接受两个参数，用于指定填充的起始位置和结束位置</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// ['a', 7, 'c']</span></div></pre></td></tr></table></figure>
<p>6.数组实例的<code>keys()</code>、<code>values()</code>和<code>entries()</code>：用于遍历数组。都返回一个遍历器对象，可以用<code>for..of</code>循环进行遍历；区别为分别对键名、键值、键值对遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys())&#123;</div><div class="line">    <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values())&#123;</div><div class="line">    <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries())&#123;</div><div class="line">    <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure>
<p>7.数组实例的<code>includes()</code>（属于ES 7 但 Babel 转码器已经支持）：返回一个布尔值，表示某个数组是否包含给定的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);  <span class="comment">// true</span></div><div class="line">[<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);  <span class="comment">// false</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>8.数组的空位：和<code>undefined</code>不同，数组的空位没有任何值。ES 5 对空位的处理规则很不一致（大多数情况会忽略）；而 ES 6 明确将空位转为<code>undefined</code>。尽管如此，建议避免出现空位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;。将知识点简便地总结一下，以供后续使用时参考或复习。&lt;/p&gt;
&lt;p&gt;此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>探究伪元素及其用途</title>
    <link href="http://kyonhuang.top/pseudo_elements/"/>
    <id>http://kyonhuang.top/pseudo_elements/</id>
    <published>2017-04-05T10:43:45.000Z</published>
    <updated>2017-06-18T03:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。</p>
  <a id="more"></a>
<h2 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h2><p>伪元素(Pseudo-elements)容易与伪类(Pseudo-classes)混淆。在 w3c 定义中，伪类用于向某些选择器添加特殊的效果，而伪元素用于将特殊的效果添加到某些选择器。可以看到从定义上来说，二者确实不好分辨。不过在种类上可以看出二者的一些不同。</p>
<p>伪类包括：</p>
<ul>
<li><code>:link</code>：向未被访问的链接添加样式。</li>
<li><code>:visited</code>：向已被访问的链接添加样式。</li>
<li><code>:hover</code>：当鼠标悬浮在元素上方时，向元素添加样式。</li>
<li><code>:active</code>：向被激活的元素添加样式。</li>
<li><code>:focus</code>：向拥有键盘输入焦点的元素添加样式。</li>
<li><code>:first-child</code>：向元素的第一个子元素添加样式。</li>
<li><code>:lang</code>：向带有指定 lang 属性的元素添加样式。</li>
</ul>
<p>其中前四个因为用不同的方式显示链接的不同状态，被称为“锚伪类”。在 CSS 定义中，<code>a:hover</code>必须被置于 <code>a:link</code>和<code>a:visited</code>之后，而<code>a:active</code>必须被置于<code>a:hover</code>之后才是有效的。</p>
<p>伪元素包括：</p>
<ul>
<li><code>:before</code>：在元素之前添加内容。</li>
<li><code>:after</code>：在元素之后添加内容。</li>
<li><code>:first-letter</code>：向文本的第一个字母添加特殊样式。</li>
<li><code>:first-line</code>：向文本的首行添加特殊样式。</li>
</ul>
<p>其中前两个无疑是用的最多的。后两个也可以用于实现一些特殊效果，例如通过<code>:first-letter</code>实现段落首字母加粗或变色。</p>
<p>两者的<strong>根本区别</strong>是：伪类可以通过<strong>直接添加一个实际的类样式</strong>达到同等效果；而伪元素的效果则需要<strong>先添加一个实际的元素，再在元素上添加样式</strong>才能达到。</p>
<p>在 CSS 3 中修订后的伪元素使用两个冒号（<code>::</code>）以与伪类进行区分。但无论使用单冒号还是双冒号，浏览器都能识别。并且 IE 8 只支持单冒号的写法。因此为了更广泛的浏览器兼容性，还是推荐使用单冒号的写法。</p>
<h2 id="伪元素的优点"><a href="#伪元素的优点" class="headerlink" title="伪元素的优点"></a>伪元素的优点</h2><p>最常使用的两种伪元素——<code>:before</code>和<code>:after</code>可以在内容元素的前后插入额外的元素。通过伪元素，在实现很多炫酷的视觉效果时，我们不必修改现有的 HTML 文档结构。因为 HTML 文档本身仅仅应该包含内容，而不应该包含样式，所以伪元素更应该被提倡。</p>
<h2 id="伪元素的应用"><a href="#伪元素的应用" class="headerlink" title="伪元素的应用"></a>伪元素的应用</h2><p>鉴于伪元素应用很多时候代码相对专一，建议配合 Sass，通过设置 mixin 来使用以提高复用性（你可以通过我的上一篇博文 <a href="http://kyonhuang.top/1478/">初见Sass－便捷的CSS预处理器</a> 来了解Sass）。</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>这大概是伪元素最为常见的应用了。比起插入额外的非语义标记来清除内联元素的浮动，这种俗称“clearfix”的方式更语义化。</p>
<p><strong>CSS</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.group:before,</div><div class="line">.group:after &#123;</div><div class="line">  content:&quot;&quot;;</div><div class="line">  display:table;</div><div class="line">&#125;</div><div class="line">.group:after &#123;</div><div class="line">  clear:both;</div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div><div class="line">.group &#123;</div><div class="line">  zoom:1; /* For IE 6/7 (trigger hasLayout) */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Sass</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@mixin clearfix &#123; </div><div class="line">  @if $legacy-support-for-ie &#123; </div><div class="line">    *zoom: 1; </div><div class="line">  &#125; </div><div class="line">  &amp;:before, </div><div class="line">  &amp;:after &#123; </div><div class="line">    content: &quot;&quot;; </div><div class="line">    display: table; </div><div class="line">  &#125; </div><div class="line">  &amp;:after &#123; </div><div class="line">    clear: both; </div><div class="line">    overflow: hidden; </div><div class="line">  &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过 @include 方法调用</div></pre></td></tr></table></figure>
<h3 id="实现样式效果"><a href="#实现样式效果" class="headerlink" title="实现样式效果"></a>实现样式效果</h3><p>能够借助伪元素实现的样式效果数不胜数。这里举一个简单而常用的例子。</p>
<p>很多时候我们会在每一节的标题下做一个类似下划线效果，用来强调。使用伪元素可以让我们不必添加额外的元素来实现这个效果。</p>
<p><img src="/images/section-title.png" width="264px" height="88px"></p>
<p>Sass 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@mixin section-title() &#123;</div><div class="line">  font-size: 2em;</div><div class="line">  padding: 2em 0;</div><div class="line">  text-transform: uppercase;</div><div class="line">  color: #55a2dd;</div><div class="line"></div><div class="line">  &amp;:after &#123;</div><div class="line">    display: block;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    background-color: #cccccc;</div><div class="line">    width: 2em;</div><div class="line">    height: .2em;</div><div class="line">    margin: .4em auto;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h3><p>有时我们想给一张大图设置透明度，却发现其子元素都会被继承这个透明度。以往想要消除这个属性总让我头大。现在通过伪元素，我们就可以分别为文字和图片设置不同的透明度。</p>
<p>Sass 代码如下（来自<a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/design_your_own_site/index.html" target="_blank" rel="external">第3周：设计你自己的页面</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">.hero &#123;</div><div class="line">  width: 100%;</div><div class="line">  min-height: 50em;</div><div class="line">  position: relative;</div><div class="line">  background-color: $mask-color;</div><div class="line">  z-index: 1;</div><div class="line"></div><div class="line">  &amp;:after &#123;</div><div class="line">    background: url(&apos;../images/hero-1-resized.jpg&apos;);</div><div class="line">    background-size: cover;</div><div class="line">    position: absolute;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    z-index: -1;</div><div class="line">    opacity: .2;</div><div class="line">    width: 100%;</div><div class="line">    height: 100%;</div><div class="line">    top: 0;</div><div class="line">    left: 0;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  h2 &#123;</div><div class="line">    font-size: 6em;</div><div class="line">    font-weight: bold;</div><div class="line">    padding: 3em 0 1em 0;</div><div class="line">    text-transform: uppercase;</div><div class="line">    color: white;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  p &#123;</div><div class="line">    max-width: 70%;</div><div class="line">    font-size: 1.5em;</div><div class="line">    font-weight: lighter;</div><div class="line">    color: #cecece;</div><div class="line">    line-height: 1.4;</div><div class="line">    margin: 0 auto;</div><div class="line">    padding: 1em 0 8em 0;</div><div class="line">    span &#123;</div><div class="line">      color: $heading-color;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 .hero 这个 section，我们将其背景设置为灰色，并将 position 设置为 relative。然后为其添加了一个伪元素，这个伪元素上包含了实际的图片，并为图片设置了透明度 .2。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.w3school.com.cn/css/css_pseudo_elements.asp" target="_blank" rel="external">CSS 伪元素 - W3School</a></p>
<p>你可以从这篇文章中了解更多伪元素的应用：<a href="http://www.w3cplus.com/css3/pseudo-element-roundup.html" target="_blank" rel="external">大放异彩的伪元素——可以做什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://kyonhuang.top/tags/HTML/"/>
    
      <category term="CSS" scheme="http://kyonhuang.top/tags/CSS/"/>
    
      <category term="伪元素" scheme="http://kyonhuang.top/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>初见Sass－便捷的CSS预处理器</title>
    <link href="http://kyonhuang.top/sass-begin/"/>
    <id>http://kyonhuang.top/sass-begin/</id>
    <published>2017-04-03T11:21:22.000Z</published>
    <updated>2017-04-25T10:47:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现自己又找到一本关于前端实践的优质开源书<a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/index.html" target="_blank" rel="external">《3周3页面》</a>。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。”</p>
<a id="more"></a>
<h2 id="什么是Sass"><a href="#什么是Sass" class="headerlink" title="什么是Sass"></a>什么是Sass</h2><p>为了给 CSS 加入编程元素，人们发明了Sass。Sass 是一个 CSS3 的扩展语言，它提供了嵌套样式，变量定义，扩展，mixin等丰富的特性，使得编写样式更加容易，节省了开发者的时间。</p>
<h2 id="Sass基础语法"><a href="#Sass基础语法" class="headerlink" title="Sass基础语法"></a>Sass基础语法</h2><p>这里只记录我觉得比较关键的语法作为备忘。可以查看 <a href="http://www.w3cplus.com/sassguide/" target="_blank" rel="external">sass十分钟入门</a> 或者 <a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="external">SASS用法指南</a> 以较为全面地入门。</p>
<ul>
<li>变量：以<code>$</code>开头。如果变量需要镶嵌在字符串之外，需要写在<code>#{}</code>中。</li>
<li>嵌套：用<code>&amp;</code>引用父元素。</li>
<li>继承：使用<code>@extend</code>命令。</li>
<li>Mixin：使用<code>@mixin</code>命令定义一个代码块，使用<code>@include</code>命令调用。可以指定参数和缺省值。</li>
<li>插入文件：使用<code>@import</code>命令。</li>
<li>自定义函数：使用<code>@function</code>和<code>@return</code>。</li>
<li>此外支持条件语句和循环语句。</li>
</ul>
<h2 id="WebStorm中使用Sass"><a href="#WebStorm中使用Sass" class="headerlink" title="WebStorm中使用Sass"></a>WebStorm中使用Sass</h2><p>注意，本节内容针对 OS X 环境。可能部分内容也兼容其他平台，但我没试过。</p>
<p>WebStorm 支持 Sass 的自动编译。在 WebStorm 的 Preferences 中，Tools 下选择 File Watchers。配置 Sass 和 SCSS（最新版的 Sass 后缀）需要有相应的 Program。</p>
<p><img src="/images/webstorm_sass.jpg"></p>
<p>因为 Sass 依赖 ruby，所以要先安装 ruby。不过 OS X 好像自带 ruby（至少我没有什么时候安装过的印象…）。之后建议安装 Compass：<code>sudo gem install compass</code>，Sass 和 SCSS 的 Program 会被一并安装，WebStorm 也会检测到，之后点击 OK 即可。</p>
<p>之后，WebStorm 会自动监测 Sass 文件的改动，并时刻编译为同名 CSS 文件，保存在同一文件夹下，非常方便。</p>
<h2 id="Sass实现媒体查询"><a href="#Sass实现媒体查询" class="headerlink" title="Sass实现媒体查询"></a>Sass实现媒体查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 定义两个 break-point</div><div class="line">$break-small: 320px;</div><div class="line">$break-large: 1024px;</div><div class="line"></div><div class="line">// 定义一个 mixin，接收三个可能的参数</div><div class="line">// 分别代表不同的设备——手机、平板和桌面显示器</div><div class="line">@mixin respond-to($media) &#123;</div><div class="line">  @if $media == handhelds &#123;</div><div class="line">    @media only screen and (max-width: $break-small) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">  @else if $media == medium-screens &#123;</div><div class="line">    @media only screen and (min-width: $break-small + 1) and (max-width: $break-large) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">  @else if $media == wide-screens &#123;</div><div class="line">    @media only screen and (min-width: $break-large) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">  @include respond-to(medium-screens) &#123;</div><div class="line">    //...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式使用起来更方便，也便于后期统一修改变量的具体数值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《3周3页面》的作者同样推荐了 Compass。这是一个使用了 Sass 的库，将很多常用样式打包成了一些模块以供使用。因为安装时出现了一些我还没解决的 error，我还没有使用过。可以查看 <a href="http://www.ruanyifeng.com/blog/2012/11/compass.html" target="_blank" rel="external">Compass用法指南</a> 以获得更多了解。</p>
<p>此外，推荐 <a href="http://www.w3cplus.com/preprocessor/ten-best-common-mixins.html" target="_blank" rel="external">SASS基础——十个常见的Mixins</a>。这篇文章总结了一些常用的 Mixin，更重要的是，通过这些Mixin，对 CSS 可以获得更深入的理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现自己又找到一本关于前端实践的优质开源书&lt;a href=&quot;https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《3周3页面》&lt;/a&gt;。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。”&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SASS" scheme="http://kyonhuang.top/tags/SASS/"/>
    
      <category term="WebStorm" scheme="http://kyonhuang.top/tags/WebStorm/"/>
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>神奇的CSS动画</title>
    <link href="http://kyonhuang.top/css-animation/"/>
    <id>http://kyonhuang.top/css-animation/</id>
    <published>2017-03-25T07:58:01.000Z</published>
    <updated>2017-04-29T07:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。</p>
<p>通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。</p>
<p>17.04.03更新：补充打字机动效。</p>
<a id="more"></a>
<h2 id="transition-属性"><a href="#transition-属性" class="headerlink" title="transition 属性"></a>transition 属性</h2><p>transition 是一个速记属性，有以下四个属性：</p>
<ol>
<li>transition-property：指定 CSS 属性的 name, transition 效果；</li>
<li>transition-duration：transition 效果需要指定多少秒（或毫秒）才能完成；</li>
<li>transition-timing-function：指定 transition 效果的转速曲线，包括五个模式：ease（渐慢，默认）、linear（匀速）、ease-in（加速）、ease-out（减速）、cubic-bezier 函数（自定义速度模式，可使用<a href="http://cubic-bezier.com/" target="_blank" rel="external">工具网站</a>定制）；</li>
<li>transition-delay：定义 transition 效果开始的时候。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 简写</div><div class="line">img&#123;</div><div class="line">    transition: 1s 1s height ease;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 单独定义</div><div class="line">img&#123;</div><div class="line">    transition-property: height;</div><div class="line">    transition-duration: 1s;</div><div class="line">    transition-delay: 1s;</div><div class="line">    transition-timing-function: ease;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中必须指定 transition-duration 属性，否则持续时间默认为 0 ，没有任何效果。</p>
<p>transition 的局限：</p>
<ul>
<li>需要事件触发，没法在网页加载时自动发生；</li>
<li>一次性，除非一再触发，否则不能重复发生；</li>
<li>只能定义开始状态和结束状态（即只有两个状态），不能定义中间状态；</li>
<li>需要明确知道开始状态和结束状态的具体<strong>数值</strong>，才能计算中间状态；</li>
<li>一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ul>
<h2 id="keyframes（关键帧）"><a href="#keyframes（关键帧）" class="headerlink" title="keyframes（关键帧）"></a>keyframes（关键帧）</h2><p>animation 属性可以利用 keyframes 关键字定义动画的各个状态，将指定时间段内的动画划分的更为精细。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@keyframes rainbow &#123;</div><div class="line">  0% &#123; background: #c00; &#125;</div><div class="line">  50% &#123; background: orange; &#125;</div><div class="line">  100% &#123; background: yellowgreen; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">div:hover &#123;</div><div class="line">    animation: 1s rainbow infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0% 可以用 from 表示，100% 可以用 to 表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@keyframes rainbow &#123;</div><div class="line">  from &#123; background: #c00; &#125;</div><div class="line">  50% &#123; background: orange; &#125;</div><div class="line">  to &#123; background: yellowgreen; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果省略某个状态，浏览器会自动推算中间状态。也可将多个状态写在一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 以下都为合法的写法</div><div class="line"></div><div class="line">@keyframes rainbow &#123;</div><div class="line">  50% &#123; background: orange &#125;</div><div class="line">  to &#123; background: yellowgreen &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@keyframes rainbow &#123;</div><div class="line">  to &#123; background: yellowgreen &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@keyframes pound &#123;</div><div class="line">  from，to &#123; transform: none; &#125;</div><div class="line">  50% &#123; transform: scale(1.2); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从一个状态向另一个状态过渡，浏览器默认为平滑过渡。steps 函数可以实现分布过渡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div:hover &#123;</div><div class="line">  animation: 1s rainbow infinite steps(10);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="animation-常用属性"><a href="#animation-常用属性" class="headerlink" title="animation 常用属性"></a>animation 常用属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 简写</div><div class="line">div:hover &#123;</div><div class="line">    animation: 1s 1s rainbow linear 3 forwards normal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 单独定义</div><div class="line">div:hover&#123;</div><div class="line">    animation-name: rainbow;</div><div class="line">    animation-duration: 1s;</div><div class="line">    ainmation-timing-function: linear;</div><div class="line">    animation-delay: 1s;</div><div class="line">    animation-fill-mode: forwards;</div><div class="line">    animation-direction: normal;</div><div class="line">    animation-iteration-count: 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>animation 有以下常用属性（其余和 transition 大致相似）：</p>
<p><strong>animation-iteration-count</strong>：指定动画播放次数，可指定为数值或 infinite（无限次）。</p>
<p><strong>animation-direction</strong>：指定动画播放方向，默认为 normal。其他可选值有 reverse，alternate 和 alternate-reverse（后两种浏览器支持情况不佳）。</p>
<p><strong>animation-fill-mode</strong>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。有四个可选值：</p>
<ol>
<li>forwards：让动画停留在结束状态；</li>
<li>none：回到动画没开始的状态；</li>
<li>backwards：让动画回到第一帧的状态；</li>
<li>both：根据 animation-direction 轮流应用 forwards 和 backwards 规则。</li>
</ol>
<p><strong>animation-play-state</strong>：指定动画播放突然终止时的状态，默认行为是跳回动画的开始状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 让动画保持突然终止时的状态</div><div class="line"></div><div class="line">div &#123;</div><div class="line">    animation: spin 1s linear infinite;</div><div class="line">    animation-play-state: paused;</div><div class="line">&#125;</div><div class="line"></div><div class="line">div:hover &#123;</div><div class="line">    animation-play-state: running;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>IE 10、Firefox 16.0、Chrome 43.0、Safari 9.0、Opera 30.0 以上支持没有前缀的 animation。详见 <a href="http://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="external">CSS3 animation（动画） 属性
</a> “浏览器支持”部分。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="打字机动效"><a href="#打字机动效" class="headerlink" title="打字机动效"></a>打字机动效</h3><p>依照 <a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/animate_your_page/index.html" target="_blank" rel="external">让页面动起来</a> 实现的打字机动效。图片素材为自制，因此部分数据与参照有出入。素材及代码见 <a href="https://github.com/bighuang624/Front-end_Learning/tree/master/%E6%89%93%E5%AD%97%E6%9C%BA%E5%8A%A8%E6%95%88" target="_blank" rel="external">bighuang624/Front-end_Learning/打字机动效</a>。</p>
<p><img src="/images/type-writer.jpg"></p>
<p>（gif图没搞好…）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="external">CSS动画简介 - 阮一峰的网络日志</a></p>
<p><a href="http://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="external">CSS3 animation（动画） 属性
</a></p>
<p><a href="https://github.com/junruchen/junruchen.github.io/wiki/CSS-%E5%8F%98%E6%8D%A2-%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" target="_blank" rel="external">CSS 变换 过渡 动画使用案例</a></p>
<p>补充：</p>
<p><a href="https://aotu.io/notes/2016/11/28/css3-animation-properties/" target="_blank" rel="external">css3 animation 属性众妙</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。&lt;/p&gt;
&lt;p&gt;通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。&lt;/p&gt;
&lt;p&gt;17.04.03更新：补充打字机动效。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS动画" scheme="http://kyonhuang.top/tags/CSS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>探究JS中的词法作用域</title>
    <link href="http://kyonhuang.top/js-lexical-scope/"/>
    <id>http://kyonhuang.top/js-lexical-scope/</id>
    <published>2017-03-22T13:58:50.000Z</published>
    <updated>2017-07-26T06:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 <a href="https://github.com/qibaoguang/Study-Step-by-Step/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/javascript_the_good_parts.md" target="_blank" rel="external">JavaScript 语言精粹</a> 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 <a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="external">箭头函数</a> 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。”</p>
<p>这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。</p>
<a id="more"></a>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>《JavaScript 权威指南》第5章“8.8.1 词法作用域”中对“词法作用域”的解释如下：</p>
<p>“JavaScript 中的函数是通过词法来划分作用域的，而不是动态地划分作用域的。这意味着它们在定义它们的作用域里运行，而不是在执行它们的作用域里运行。当定义了一个函数，当前的作用域链就保存起来，并且成为函数的内部状态的一部分。”</p>
<p>当然，这几句话还是玄之又玄，摸不着头脑。它还是没有具体解释“词法作用域”中的“词法”二字代表什么。不过我这学期的《编译原理》课程上经常见到这个词：编译过程被划分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成 6 个阶段（清华大学出版社《编译原理》）。在查阅资料后，我确信这个概念确实与编译有关。</p>
<p>JavaScript 引擎在代码执行前会对其进行编译，而所谓的词法作用域指作用域是由书写代码时<strong>函数声明的位置</strong>决定，在词法解析阶段就已经确定，之后不会改变。也就是说，JS 中的“词法作用域”等同于静态作用域，即与动态作用域（运行时确定）相对。</p>
<p>词法作用域关注函数在<strong>何处声明</strong>；而动态作用域关注函数从<strong>何处调用</strong>，其作用域链是基于运行时的调用栈的。换言之，在遇到既不是形参也不是函数内部定义的局部变量的变量时，词法作用域的函数会去函数<strong>定义</strong>时的环境中查询；而动态作用域的函数会到函数调用时的环境中查询。</p>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    print a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar()&#123;</div><div class="line">    var a = 1;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line">bar();</div></pre></td></tr></table></figure>
<p>采用词法作用域的语言会从函数定义位置开始向上层查找，最后输出 2。</p>
<p>而采用动态作用域的语言会输出 1。</p>
<p>顺便一提，在 JS 中<code>eval</code>和<code>with</code>可以产生动态作用域的效果。但《JavaScript 高级程序设计》不推荐使用此二者。</p>
<h2 id="强调与补充"><a href="#强调与补充" class="headerlink" title="强调与补充"></a>强调与补充</h2><p>函数的作用域基于函数<strong>定义</strong>的位置。</p>
<p>为了去实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数逻辑的代码，除此之外还包含当前作用域链的引用。函数对象可以通过这个作用域链相互关联起来。</p>
<p>如此，函数体内部的变量都可以保存在函数的作用域内，在程序语言范畴内这被称为<strong>闭包</strong>。而我们常说的闭包是指<strong>让外部函数访问到内部的变量</strong>，也就是说，按照一般的做法，是<strong>使内部函数返回一个函数，然后操作其中的变量</strong>。这样做的话一是可以读取函数内部的变量，二是可以让这些变量的值始终保存在内存中。</p>
<p>这时，调用函数的时候闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.zhihu.com/question/20032419" target="_blank" rel="external">动态作用域和词法域的区别是什么？- 知乎</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="external">JavaScript深入之词法作用域和动态作用域 · Issue #3 · mqyqingfeng/Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 &lt;a href=&quot;https://github.com/qibaoguang/Study-Step-by-Step/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/javascript_the_good_parts.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript 语言精粹&lt;/a&gt; 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 &lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;箭头函数&lt;/a&gt; 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。”&lt;/p&gt;
&lt;p&gt;这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="概念理解" scheme="http://kyonhuang.top/tags/%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    
      <category term="JavaScript" scheme="http://kyonhuang.top/tags/JavaScript/"/>
    
      <category term="词法作用域" scheme="http://kyonhuang.top/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>在把玩中学习——typewriter.js</title>
    <link href="http://kyonhuang.top/typewriter/"/>
    <id>http://kyonhuang.top/typewriter/</id>
    <published>2017-03-17T03:28:32.000Z</published>
    <updated>2017-04-25T10:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。</p>
<p>好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。</p>
<p><img src="/images/typewriter.jpg"></p>
<a id="more"></a>
<p>这个有打字和仿光标闪烁效果的 <a href="http://www.jq22.com/jquery-info6035" target="_blank" rel="external">typewriter.js</a> 好像是我在看什么“程序员表白利器”时加到收藏夹里的。现在学习了 js，敢看看源码了，发现 js 代码只有20行不到。作者说：“原生JavaScript就是这么牛。”确实是这样的。虽然效果也很简单，但也能从里面学到一些东西。</p>
<p>HTML 源代码（大致结构）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;mainDiv&quot;&gt;</div><div class="line">        &lt;div id=&quot;content&quot;&gt;</div><div class="line">            &lt;div id=&quot;code&quot;&gt;</div><div class="line">                &lt;span class=&quot;comments&quot;&gt;/**&lt;/span&gt;&lt;br /&gt;</div><div class="line">                &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* We are both XXX Unversity  business administration and programmers,&lt;/span&gt;&lt;br /&gt;</div><div class="line">                &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* so I write some code to show my love to you.&lt;/span&gt;&lt;br /&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"> document.getElementById(&quot;code&quot;).typewriter();</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>JavaScript 源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Element.prototype.typewriter=function(a)&#123;</div><div class="line">			var d = this,</div><div class="line">				c = d.innerHTML,</div><div class="line">				b = 0;</div><div class="line">			d.innerHTML=&quot;&quot;;</div><div class="line">			var e = setInterval(function() &#123;</div><div class="line">				var f = c.substr(b, 1);</div><div class="line">				if (f == &quot;&lt;&quot;) &#123;</div><div class="line">					b = c.indexOf(&quot;&gt;&quot;, b) + 1</div><div class="line">				&#125; else &#123;</div><div class="line">					b++</div><div class="line">				&#125;</div><div class="line">				d.innerHTML=c.substring(0, b) + (b &amp; 1 ? &quot;_&quot; : &quot;&quot;);</div><div class="line">				if (b &gt;= c.length) &#123;</div><div class="line">					clearInterval(e)</div><div class="line">				&#125;</div><div class="line">			&#125;, 75)</div><div class="line">		return this</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在这份 js 代码中可以学习的点：</p>
<ol>
<li><strong>原型模式定义方法</strong>：给 Element 添加实例方法<code>typewriter()</code>（在 html 文件中调用），这里有一个参数 a，实际上没什么用。顺便一说，源码在 head 处引入了 js 文件，这是为了先加载 js 文件。如果按照代码规范将引入放在 body 部分的最后，则有一瞬间所有字先出现再消失，不符合效果要求。可见代码规范也要根据实际来遵守。</li>
<li>声明三个变量，d 保存当前对象（”code”）。这个操作是必要的，因为后面要给 “code” 的 innerHTML 赋值的时候有时在函数作用域中，this 取不到 “code”。</li>
<li>代码逻辑很清晰，包括对标签的处理、光标效果的实现和定时器的清除等。要对自己想要实现的效果有一个全面的认知和大致的构思再开始写代码。</li>
<li>末尾<code>return this</code>以<strong>支持链式操作</strong>。</li>
</ol>
<p>想要用功能强大的JavaScript实现一些小效果不难，但是怎样一步步规划、修改到实现对现在的我来说还是比较有挑战性的。希望自己能在欣赏、借鉴、吸收的过程中去实现一些有趣的 demo，重拾对代码的兴趣和创造力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。&lt;/p&gt;
&lt;p&gt;好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/typewriter.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（五）</title>
    <link href="http://kyonhuang.top/JS-notes-5/"/>
    <id>http://kyonhuang.top/JS-notes-5/</id>
    <published>2017-03-15T02:43:51.000Z</published>
    <updated>2017-07-12T06:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了看LESS。前端要研究的东西确实有点多，压力有点大。而且发现自己动手写代码的水平也有待提高。从今天开始理论学习要给实践让让路了，加油加油。</p>
<p>这篇博文总结了《JavaScript高级程序设计》的20~21章：JSON、AJAX与Comet。此外，关于CORS的部分还参考了廖雪峰的JavaScript教程。</p>
  <a id="more"></a>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是一种数据格式。虽然有相同的语法形式，但JSON不从属于JavaScript。很多编程语言都有针对JSON的解析器和序列化器。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>1.JSON的语法可以表示三种类型的值：简单值、对象、数组。</p>
<p>2.简单值：可表示字符串、数值、布尔值和 null，但不支持 undefined。JSON字符串必须使用双引号。</p>
<p>3.对象：表示一组无序的键值对。没有声明变量（JSON中没有变量概念），没有末尾分号，对象属性名必须加双引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;Kyon&quot;,</div><div class="line">    &quot;age&quot;: 20,</div><div class="line">    &quot;school&quot;: &#123;</div><div class="line">        &quot;name&quot;: &quot;Wuhan University&quot;,</div><div class="line">        &quot;major&quot;: &quot;Software Engineering&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.数组：表示一组有序的值的列表，可以通过数值索引来访问其中的值。</p>
<h3 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h3><p>5.JSON对象有两个方法：<code>stringify()</code>把JavaScript对象序列化为JSON字符串，<code>parse()</code>把JSON字符串解析为原生JavaScript值。</p>
<p>6.<code>JSON.stringify()</code>还可以接收另外两个参数：第一个参数是个过滤器（数组：结果中只包含数组列出的属性；函数：传入的函数接收两个参数，属性名和属性值，根据属性名判断如何处理属性）；第二个参数控制结果中的缩进和空白符，数值表示缩进空格数，字符串被用作缩进字符。</p>
<p>7.<code>toJSON</code>：自定义序列化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    &quot;name&quot;: &quot;Kyon&quot;,</div><div class="line">    age: 20,</div><div class="line">    toJSON: function()&#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var jsonText = JSON.stringify(person);</div></pre></td></tr></table></figure>
<p>8.<code>JSON.parse()</code>还可以接受一个参数：将在每个键值对上调用的还原函数（与<code>JSON.stringify()</code>的过滤函数相同）。</p>
<h2 id="AJAX与Comet"><a href="#AJAX与Comet" class="headerlink" title="AJAX与Comet"></a>AJAX与Comet</h2><p>Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR）。可以使用 XHR对象取得新数据，然后再通过 DOM 将新数据插入到页面中，无须刷新页面即可从服务器取得数据。</p>
<h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>1.用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">    if(xhr.readState === 4)&#123;</div><div class="line">        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123;</div><div class="line">            console.log(xhr.responseText);</div><div class="line">        &#125; else &#123;</div><div class="line">            console.log(&apos;Request was unsuccessful: &apos; + xhr.status);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// GET请求</div><div class="line">xhr.open(&apos;get&apos;, &apos;example.php&apos;);</div><div class="line">xhr.send(null);</div><div class="line"></div><div class="line">// POST请求</div><div class="line">xhr.open(&apos;open&apos;, &apos;postexample.php&apos;);</div><div class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</div><div class="line">var form = document.getElementById(&apos;user-info&apos;);</div><div class="line">xhr.send(serialize(form));</div><div class="line">// 将ID为user-info的表单中数据序列化后发送给服务器</div></pre></td></tr></table></figure>
<ul>
<li>创建XHR对象：<code>new XMLHttpRequest()</code>;</li>
<li><code>open()</code>：启动一个请求以备发送。接收三个参数：请求类型（”get”、”post”等）、请求的URL、是否异步发送请求（默认是true，一定不能为false，否则必须等到服务器响应后再继续执行）。</li>
<li><code>send()</code>：发送请求。GET请求不需要参数，POST请求要把body部分字符串或者<code>FormData</code>对象传进去。</li>
</ul>
<p>2.XHR对象的属性：</p>
<ul>
<li>responseText：返回的文本；</li>
<li>status：响应的HTTP状态；</li>
</ul>
<p>3.HTTP状态码：</p>
<ul>
<li>2xx：成功；</li>
<li>3xx：重定向，304 Not Modified 表示请求的资源没有被修改，可以直接用浏览器缓存的版本，302 Found 表示请求的资源现在临时从不同的URI响应请求；</li>
<li>4xx：客户端错误，403 Forbidden，404 NotFound；</li>
<li>5xx：服务器错误，500 Internal Server Error，503 Service Unavailable。</li>
</ul>
<p>4.XHR的 readyState 属性：表示请求/响应过程的当前活动阶段：</p>
<ul>
<li>0：未初始化；</li>
<li>1：启动，已调用<code>open()</code>，未发送；</li>
<li>2：发送，已调用<code>send()</code>，未收到响应；</li>
<li>3：接收到部分响应数据；</li>
<li>4：接收到全部响应数据。</li>
</ul>
<p>5.readystatechange事件：readystate属性的值由一个值变成另一个值，都会触发readystatechange事件。</p>
<h3 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h3><p>6.跨域安全策略：XHR对象只能访问与包含它的页面位于同一个域的资源（域名、协议、端口号都要相同）。</p>
<p>7.CORS（跨源资源共享）：HTML5规范定义的如何跨域访问资源。当JavaScript 向外域发起请求后，浏览器收到响应后首先检查<code>Access-Control-Allow-Origin</code>是否包含本域。如果不是，请求失败，JavaScript 无法获取到响应的任何数据。</p>
<p>跨域是否成功，取决于对方服务器是否给本域设置一个正确的<code>Access-Control-Allow-Origin</code>。</p>
<p>以上“简单请求”包括GET、HEAD和POST（POST的Content-Type类型仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头。</p>
<p>对于PUT、DELETE以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">OPTIONS /path/to/resource HTTP/1.1</div><div class="line">Host: bar.com</div><div class="line">Origin: http://my.com</div><div class="line">Access-Control-Request-Method: POST</div></pre></td></tr></table></figure>
<p>服务器必须响应并明确指出允许的Method：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Access-Control-Allow-Origin: http://my.com</div><div class="line">Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS</div><div class="line">Access-Control-Max-Age: 86400</div></pre></td></tr></table></figure>
<p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>
<h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h3><p>8.图像Ping：与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。</p>
<p>对于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.onload = img.onerror = function()&#123;</div><div class="line">    console.log(&quot;Done!&quot;);</div><div class="line">&#125;;</div><div class="line">// onload和onerror事件处理程序指定为同一函数，请求完成时无关响应得到通知</div><div class="line">img.src = &quot;http://www.example.com/test?name=Nicholas&quot;;</div><div class="line">// 请求从设置src属性那一刻开始</div></pre></td></tr></table></figure>
<p>两个主要缺点：只能发送GET请求；无法访问服务器的响应文本。因此只能用于浏览器与服务器间的单向通信。</p>
<p>9.JSONP（JSON with padding）：包含在函数调用中的JSON。由回调函数和数据组成。只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上利用了浏览器允许跨域引用JavaScript资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 得到的返回</div><div class="line">refreshPrice(&#123;&quot;0000001&quot;:&#123;&quot;code&quot;:&quot;0000001&quot;, ...&#125;&#125;);</div><div class="line"></div><div class="line">// 在页面中准备好回调函数</div><div class="line">function refreshPrice(data)&#123;</div><div class="line">    var p = document.getElementById(&apos;test-jsonp&apos;);</div><div class="line">    p.innerHTML = &apos;当前价格：&apos; + data[&apos;0000001&apos;].name + &quot;：&quot; + data[&apos;0000001&apos;].price;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 触发</div><div class="line">function getPrice()&#123;</div><div class="line">    var </div><div class="line">        js = document.createElement(&apos;script&apos;),</div><div class="line">        head = document.getElementByTagName(&apos;head&apos;)[0];</div><div class="line">        self = document.getElementById(&apos;dynamic-jsonp&apos;);</div><div class="line">    if(self)&#123;</div><div class="line">        var parent = self.parentElement;</div><div class="line">        parent.removeChild(self);</div><div class="line">    &#125;</div><div class="line">    js.id = &apos;dynamic-jsonp&apos;;</div><div class="line">    js.src = &apos;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&apos;;</div><div class="line">    head.appendChild(js);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：从其他域中加载代码执行，安全性不可靠；不易确定请求是否失败。</p>
<p>10.Comet：对AJAX的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现Comet的手段主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，只有部分浏览器原生支持HTTP流。</p>
<p>补充：轮询是指通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器是否有新消息。缺点：(1)实时性不够；(2)频繁请求会给服务器带来极大压力。</p>
<p>11.SSE（服务器发送事件）：一种实现Comet交互的浏览器API，既支持长轮询，也支持HTTP流。</p>
<p>12.Web Sockets：目标是在一个单独的持久连接上提供全双工、双向通信。使用一种专为快速传输小数据设计的自定义协议。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>13.为确保通过XHR访问的URL安全，通行做法是验证发送请求者是否有权限访问响应的资源。有下列方式：</p>
<ul>
<li>要求以SSL连接来访问可以通过XHR请求的资源。</li>
<li>要求每一次请求都要附带经过相应算法计算得到的验证码。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了看LESS。前端要研究的东西确实有点多，压力有点大。而且发现自己动手写代码的水平也有待提高。从今天开始理论学习要给实践让让路了，加油加油。&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的20~21章：JSON、AJAX与Comet。此外，关于CORS的部分还参考了廖雪峰的JavaScript教程。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（四）</title>
    <link href="http://kyonhuang.top/JS-notes-4/"/>
    <id>http://kyonhuang.top/JS-notes-4/</id>
    <published>2017-03-12T04:13:51.000Z</published>
    <updated>2017-07-12T06:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>花旗杯的团队已经组好了。自己要加快学习进度，保证不拖组织的后腿。全力以赴，尽善尽美，希望最后能够有好的成绩。</p>
<p>这篇博文总结了《JavaScript高级程序设计》的13~14章：事件，表单脚本。</p>
  <a id="more"></a>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>1.<strong>事件流</strong>描述从页面接收事件的顺序。IE提出事件冒泡流，Netscape提出事件捕获流。</p>
<p>2.<strong>事件冒泡</strong>：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p>
<p>3.事件捕获：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。由于老版本浏览器不支持，不推荐使用。</p>
<p>4.“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。</p>
<h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><p>5.HTML事件处理程序：扩展作用域，在函数内部可以像访问局部变量一样访问document及该元素本身的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(value)&quot;&gt;</div></pre></td></tr></table></figure>
<p>如果是一个表单输入元素，则作用域中还会包含访问表单元素的入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;post&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt;</div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;Echo username&quot; onclick=&quot;console.log(username.value)&quot;&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>缺点：(1)存在时差问题，函数被解析之前就触发事件会引发错误；(2)扩展处理程序的作用域链在不同浏览器中会导致不同结果；(3)HTML和JavaScript代码紧密耦合。</p>
<p>6.DOM0级事件处理程序：每个元素都有自己的事件处理程序属性，将其设置为一个函数，就可以指定事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绑定事件处理程序</span></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);  <span class="comment">// "myBtn"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 删除事件处理程序</span></div><div class="line">btn.onclick = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</p>
<p>7.DOM2级事件处理程序：<code>addEventListener()</code>和<code>removeEventListener()</code>，接受3个参数：要处理的事件名、事件处理程序函数和一个布尔值（true表示在捕获阶段调用事件处理程序，默认为false表示冒泡阶段调用）。</p>
<p>移除时传入的参数与添加处理程序时使用的参数相同，意味着通过<code>addEventListener()</code>添加的匿名函数无法移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">byn.addEventListener(&quot;click&quot;, handler, false);</div><div class="line">...</div><div class="line">btn.removeEventListener(&quot;click&quot;, handler, false);  // 有效</div></pre></td></tr></table></figure>
<p>8.IE事件处理程序：<code>attachEvent()</code>和<code>detachEvent()</code>，接收两个参数：要处理的事件名、事件处理程序函数。事件处理程序被添加到冒泡阶段，在全局作用域中运行（this 等于 window）。支持IE事件处理程序的浏览器有 IE 和 Opera。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>9.在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息。只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。</p>
<p>10.属性/方法：</p>
<ul>
<li>currentTarget：正在处理事件的那个元素。</li>
<li>target：事件的目标。</li>
<li>type：事件类型。</li>
<li>cancelable：可以阻止特定事件的默认行为。</li>
<li>preventDefault()：阻止特定事件的默认行为。</li>
<li>stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。</li>
<li>eventPhase：调用事件处理程序的阶段：捕获阶段为1，处于目标对象为2，冒泡阶段为3。</li>
</ul>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>11.“DOM3级事件”规定了以下几类事件：</p>
<ul>
<li>UI（用户界面）事件，当用户与页面上的元素交互时触发：<code>load</code>、<code>unload</code>、<code>resize</code>、<code>scroll</code>。</li>
<li>焦点事件，当元素获得或失去焦点时触发。</li>
<li>鼠标与滚轮事件：<code>click</code>、<code>dblclick</code>、<code>mousedown</code>、<code>mouseenter</code>、<code>mouseleave</code>、<code>mouseout</code>、<code>mouseover</code>、<code>mouseup</code>。</li>
<li>键盘与文本事件：<code>keydown</code>、<code>keypress</code>、<code>keyup</code>、<code>textInput</code>。</li>
<li>复合事件，用于处理IME（输入法编辑器，让用户输入在物理键盘上找不到的字符）的输入序列。</li>
<li>变动事件，当DOM中的某一部分发生变化时给出提示。</li>
</ul>
<h3 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h3><p>to be continued..</p>
<h2 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h2><p>to be continued..</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花旗杯的团队已经组好了。自己要加快学习进度，保证不拖组织的后腿。全力以赴，尽善尽美，希望最后能够有好的成绩。&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的13~14章：事件，表单脚本。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（三）</title>
    <link href="http://kyonhuang.top/JS-notes-3/"/>
    <id>http://kyonhuang.top/JS-notes-3/</id>
    <published>2017-03-10T02:23:02.000Z</published>
    <updated>2017-07-12T06:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>稍微大致翻了一下这本书后续的内容。为了尽快的进入ES6以及框架部分的学习，决定暂时跳过某些章节的学习。后面打算学习的章节有6、7、13、14、20、21、22、24章，剩下的章节等到用到或者时间富余的时候再看。</p>
<p>这篇博文总结了《JavaScript高级程序设计》的6~7章：面向对象的程序设计，以及函数表达式。</p>
  <a id="more"></a>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><p>1.ECMAScript中有两种属性：数据属性和访问器属性。</p>
<p>特性：描述属性的各种特征。目的是实现JavaScript，因此在JavaScript中不能直接访问。为了表示特性是内部值，放在两对方括号中，例如<code>[[Enumerable]]</code>。</p>
<p>2.数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。</p>
<ul>
<li><code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。</li>
<li><code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。默认为 true。</li>
<li><code>[[Writable]]</code>：表示能否修改属性的值。默认为 true。</li>
<li><code>[[Value]]</code>：包含这个属性的数据值。默认为 undefined。</li>
</ul>
<p><code>Object.defineProperty()</code>方法可以修改属性默认的特性。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable、enumerable、writable 和 value 中的一或多个。</p>
<p>3.访问器属性：</p>
<ul>
<li><code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。</li>
<li><code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。默认为 true。</li>
<li><code>[[Get]]</code>：在读取属性时调用的函数。默认为 undefined。</li>
<li><code>[[Set]]</code>：在写入属性时调用的函数。默认为 undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">_year</span>: <span class="number">2016</span>,  <span class="comment">// 下划线表示只能通过对象方法访问的属性</span></div><div class="line">    edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">       <span class="keyword">if</span>(newValue &gt; <span class="number">2016</span>) &#123;</div><div class="line">           <span class="keyword">this</span>._year = newValue;</div><div class="line">           <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);  <span class="comment">// year 是访问器属性</span></div><div class="line"></div><div class="line">book.year = <span class="number">2017</span>;</div><div class="line"><span class="built_in">console</span>.log(book.edition);  <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>4.定义多个属性可用<code>Object.defineProperties()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var book = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperties(book, &#123;</div><div class="line">    _year: &#123;</div><div class="line">        value: 2016</div><div class="line">    &#125;,</div><div class="line">    edition: &#123;</div><div class="line">        value: 1</div><div class="line">    &#125;,</div><div class="line">    year: &#123;</div><div class="line">        get: function()&#123;</div><div class="line">            return this._year;</div><div class="line">        &#125;,</div><div class="line">        set: function(newValue)&#123;</div><div class="line">            if(newValue &gt; 2016)&#123;</div><div class="line">                this._year = newValue;</div><div class="line">                this.edition += newValue - 2016;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyDescriptor()</code>方法可以取得给定属性的描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);</div><div class="line">console.log(descriptor.value);  // 2016</div><div class="line">console.log(descriptor.configurable);  // false</div><div class="line">console.log(typeof descriptor.get);  // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>5.工厂模式：虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age, job) &#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = function () &#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line">var p1 = createPerson(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">var p2 = createPerson(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);</div></pre></td></tr></table></figure>
<p>6.构造函数模式：以大写字母开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);</div><div class="line"></div><div class="line">// 对象的constructor属性指向其构造函数</div><div class="line">console.log(p1.constructor);  // function Person(name, age, job)&#123;...</div></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。</p>
<p>也可以使用<code>call()</code>（或者<code>apply()</code>）在某个特殊对象的作用域中调用构造函数，调用后这个对象就拥有了所有属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div><div class="line">Person.call(o, &apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">o.sayName();  // &apos;Kyon&apos;</div></pre></td></tr></table></figure>
<p>使用构造函数的主要问题：每个方法都要在每个实例上重新创建一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(p1.sayName === p2.sayName);  // false</div></pre></td></tr></table></figure>
<p>7.原型模式：每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向函数的原型对象。这个对象包含可以由该类型的所有实例共享的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line">console.log(p1.sayName === p2.sayName);  // true</div></pre></td></tr></table></figure>
<ul>
<li><p>理解原型对象：</p>
<p> – 只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，指向函数的原型对象。</p>
<p> – 默认所有原型对象都会获得一个 constructor 属性，指向 prototype 属性所在函数。</p>
<p> – 当调用构造函数创建一个新实例后，实例将有一个 <code>__proto__</code>属性，指向构造函数的原型对象，指针叫<code>[[Prototype]]</code>，默认原型指向Object。</p>
<p> – 实例和构造函数没有直接关系。</p>
<p> <img src="/images/jsNotes/proto.jpg"></p>
<p> – 读取属性：搜索先从对象实例本身开始，如果没找到，搜索原型对象。</p>
<p> – 使用<code>isPrototype()</code>来检测构造函数和实例之间是否有关系。</p>
<p> – <code>Object.getPrototypeOf()</code>返回<code>[[Prototype]]</code>的值。</p>
<p> – 使用<code>hasOwnProperty()</code>来检测属性存在于实例中还是原型中。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &apos;Kyon&apos;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &apos;Software Engineer&apos;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var p1 = new Person();</div><div class="line">var p2 = new Person();</div><div class="line"></div><div class="line">console.log(Person.prototype.isPrototypeOf(p1));  // true</div><div class="line"></div><div class="line">console.log(Object.getPrototypeOf(p1) === Person.prototype);  // true</div><div class="line">console.log(Object.getPrototypeOf(p1).name);  // &apos;Kyon&apos;</div><div class="line"></div><div class="line">console.log(p1.hasOwnProperty(&quot;name&quot;));  // false</div><div class="line"></div><div class="line">p1.name = &quot;someone&quot;;</div><div class="line">console.log(p1.hasOwnProperty(&quot;name&quot;));  // true</div><div class="line"></div><div class="line">delete p1.name;</div><div class="line">console.log(p1.hasOwnProperty(&quot;name&quot;));  // false</div></pre></td></tr></table></figure>
<ul>
<li>原型与 in 操作符：在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;name&apos; in p1);  // true</div></pre></td></tr></table></figure>
<ul>
<li>更简单的原型语法：用一个包含所有属性和方法的对象字面量来重写整个原型对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor: Person,  // 默认的 prototype 对象被重写，需设置</div><div class="line">    name: &apos;Kyon&apos;,</div><div class="line">    age: 20,</div><div class="line">    job: &apos;Software Engineer&apos;,</div><div class="line">    sayName: function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍是最初的原型。</p>
<p><img src="/images/jsNotes/yuanxingchongxie.jpg"></p>
<ul>
<li>原生对象的原型：通过原生对象的原型可以定义新方法。不推荐，可能导致命名冲突或意外重写原生方法。</li>
<li>原型对象的问题：包含引用类型值的属性会被共享。</li>
</ul>
<p>8.<strong>组合使用构造函数模式和原型模式</strong>：创建自定义类型最常见方式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 组合使用构造函数模式与原型模式</div><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.friends = [&quot;Sam&quot;, &quot;Judie&quot;];</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor: Person,</div><div class="line">    sayName: function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);</div><div class="line"></div><div class="line">p1.friends.push(&quot;Vue&quot;);</div><div class="line">console.log(p1.friends);  // &quot;Sam, Judie, Vue&quot;</div><div class="line">console.log(p2.friends);  // &quot;Sam, Judie&quot;</div><div class="line">console.log(p1.sayName === p2.sayName);  // true</div></pre></td></tr></table></figure>
<p>9.动态原型模式、寄生构造函数模式、稳妥构造函数模式</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>10.许多OO语言都支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际方法）。由于函数没有签名，ECMAScript 中无法实现接口继承，而实现继承主要依靠<strong>原型链</strong>实现。</p>
<p>11.原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法。</p>
<p>12.p182开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function () &#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">function SubType(name, age) &#123;</div><div class="line">	SuperType.call(this, name);  // 借用构造函数</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">SubType.prototype = new SuperType();  // 原型链</div><div class="line">SubType.prototype.constructor = SubType;  // construcotr在上一句中被重写</div><div class="line">SubType.prototype.sayAge = function () &#123;</div><div class="line">	console.log(this.age);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var instance = new SubType(&apos;Kyon&apos;, 20);</div><div class="line">instance.sayName();  // Kyon</div><div class="line">instance.sayAge();  // 20</div></pre></td></tr></table></figure>
<p>说实话，这部分看得我脑壳疼。要不我们直接用ES6引入的class可好？等我哪一天沐浴更衣虔诚焚香再来看…</p>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>1.在严格模式下，不能通过脚本访问<code>arguments.callee</code>来实现递归。可以用命名函数表达式来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var factorial = (function f(num)&#123;</div><div class="line">    if(num &lt;= 1)&#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * f(num-1);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>2.<strong>闭包</strong>是指有权访问另一个函数作用域中的变量的函数（匿名函数的 function 关键字后没有标识符，二者不能混用）。</p>
<p>3.创建闭包的常见方式：在一个函数内部创建另一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outer()&#123;</div><div class="line">    var name = &quot;Kyon&quot;;</div><div class="line">    return function()&#123;</div><div class="line">        console.log(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var inner = outer();</div><div class="line">inner();  // Kyon</div><div class="line">inner = null;  // 解除对outer内部的匿名函数的引用，以释放内存</div></pre></td></tr></table></figure>
<p>在外部函数内部定义的内部函数将外部函数的活动对象（作为变量对象使用）添加到它的作用域链中；外部函数执行完毕后，其活动对象不会被销毁，因为内部函数的作用域链仍在引用这个活动对象；外部函数执行完毕后，内部函数仍然可以访问到其定义的所有变量。</p>
<p>4.由于闭包会携带包含它的函数的作用域，过度使用可能导致内存占用过多，要慎重使用。</p>
<p>5.返回的函数并没有立刻执行，而是等到调用<code>f()</code>才执行。因此返回函数不能引用任何循环变量，或者后续会发生变化的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function count()&#123;</div><div class="line">    var arr = [];</div><div class="line">    for(var i=1; i&lt;=3; i++)&#123;</div><div class="line">        arr[i] = function()&#123;</div><div class="line">             return i * i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var results = count();</div><div class="line">var f1 = results[0];</div><div class="line">var f2 = results[1];</div><div class="line">var f3 = results[2];</div><div class="line"></div><div class="line">// 返回的函数引用了变量i，但并非立即执行。执行时i已变成4</div><div class="line">f1();  // 16</div><div class="line">f2();  // 16</div><div class="line">f3();  // 16</div></pre></td></tr></table></figure>
<p>一定要引用循环变量的方法：再创建一个匿名函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function count()&#123;</div><div class="line">    var arr = [];</div><div class="line">    for(var i=1; i&lt;=3; i++)&#123;</div><div class="line">        arr[i] = function(num)&#123;</div><div class="line">            return function()&#123;</div><div class="line">                return num;</div><div class="line">            &#125;;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">// i的当前值复制给参数num，匿名函数内部又创建并返回一个访问num的闭包，使得result数组中的每个函数都有自己num变量的一个副本</div></pre></td></tr></table></figure>
<p>这里用了一个“创建一个匿名函数并立即执行”的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(x)&#123;</div><div class="line">    return x * x;</div><div class="line">&#125;)(3);  // 9</div></pre></td></tr></table></figure>
<p>6.闭包中使用 this 对象：匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getName: function()&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;; </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(object.getName());  // &quot;The Window&quot;(非严格模式)</div></pre></td></tr></table></figure>
<p>把外部作用域中的 this 对象保存在一个闭包能够访问的变量中，就可以让闭包访问该对象了（想访问作用域中的 arguments对象同理）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getName: function()&#123;</div><div class="line">        var that = this;</div><div class="line">        return function()&#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;; </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(object.getName());  // &quot;My Object&quot;</div></pre></td></tr></table></figure>
<p>7.补充：利用闭包可以实现私有变量的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 用JavaScript创建一个计数器</div><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">function create_counter(initial)&#123;</div><div class="line">    var x = initial || 0;</div><div class="line">    return &#123;</div><div class="line">        inc: function()&#123;</div><div class="line">            x += 1;</div><div class="line">            return x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">var c1 = create_counter();</div><div class="line">c1.inc();  // 1</div><div class="line">c1.inc();  // 2</div><div class="line">var c2 = create_counter(10);</div><div class="line">c2.inc();  // 11</div><div class="line">c2.inc();  // 12</div></pre></td></tr></table></figure>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>8.用匿名函数模仿块级作用域：</p>
<p>JavaScript将 function 关键字当作一个函数声明的开始，而函数声明后不能加圆括号。</p>
<p>将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随的另一对圆括号会立即调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">function()&#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;();  ／／ Error!</div></pre></td></tr></table></figure>
<p>9.这种技术经常用于限制向全局作用域中添加过多的变量和函数；同时可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">    var now = new Date();</div><div class="line">    if(now.getMonth() == 11 &amp;&amp; now.getDate() == 25)&#123;</div><div class="line">        console.log(&quot;Merry Christmas!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>10.任何在函数中定义的变量，都可以认为是私有变量。</p>
<p>11.有权访问私有变量和私有函数的公有方法被称为<strong>特权方法</strong>。两种在对象上创建特权方法的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.构造函数中定义特权方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 私有变量和私有函数</span></div><div class="line">    <span class="keyword">var</span> privateVar = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 特权方法</span></div><div class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        privateVar++;</div><div class="line">        <span class="keyword">return</span> privateFunc();</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2.利用私有和特权成员</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>12.可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;稍微大致翻了一下这本书后续的内容。为了尽快的进入ES6以及框架部分的学习，决定暂时跳过某些章节的学习。后面打算学习的章节有6、7、13、14、20、21、22、24章，剩下的章节等到用到或者时间富余的时候再看。&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的6~7章：面向对象的程序设计，以及函数表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
</feed>
