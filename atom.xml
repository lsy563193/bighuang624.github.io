<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大黄菌的个人博客</title>
  <subtitle>To be a better man</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kyonhuang.top/"/>
  <updated>2017-08-21T04:58:36.000Z</updated>
  <id>http://kyonhuang.top/</id>
  
  <author>
    <name>Kyon Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 Vue 撸一份线上简历有哪些坑</title>
    <link href="http://kyonhuang.top/make-a-resume/"/>
    <id>http://kyonhuang.top/make-a-resume/</id>
    <published>2017-08-21T04:52:16.000Z</published>
    <updated>2017-08-21T04:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。</p>
<ul>
<li>项目地址：<a href="https://github.com/bighuang624/resume" target="_blank" rel="external">bighuang624/resume
</a></li>
<li>在线预览地址：<a href="http://kyonhuang.top/resume/">http://kyonhuang.top/resume/</a></li>
</ul>
<p>目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。</p>
<a id="more"></a>
<h2 id="在-Vue-中使用-sass"><a href="#在-Vue-中使用-sass" class="headerlink" title="在 Vue 中使用 sass"></a>在 Vue 中使用 sass</h2><p>这个步骤之前已经总结过，现在再在博客上记录一次，方便之后查找。</p>
<p>在 Webpack 中，所有的预处理器需要匹配相应的 loader。因此要使用 sass 或 scss，首先下载依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sass-loader node-sass --save-dev</div></pre></td></tr></table></figure>
<p>然后在单文件组件中的<code>&lt;style&gt;</code>标签中加上<code>lang=&quot;sass&quot;</code>。<code>vue-loader</code>会根据<code>lang</code>属性推断出要使用的 loaders，并将内容交给相应的 loaders 处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style lang=&quot;sass&quot;&gt;</div><div class="line">  /* write sass here */</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>与名称相反，sass-loader 默认解析 scss 语法，因此如果想使用 sass 语法，还需要在 build/vue-loader.conf.js 配置 vue-loader 的选项：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-0e5c5d774fa3e00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:vue-loader.conf.png"></p>
<p>这样的修改不会影响 scss 的使用，记得修改<code>&lt;style&gt;</code>标签中为<code>lang=&quot;scss&quot;</code>即可。</p>
<h2 id="项目资源无法加载"><a href="#项目资源无法加载" class="headerlink" title="项目资源无法加载"></a>项目资源无法加载</h2><p>直接<code>npm run build</code>得到的项目，默认引用资源文件的路径为<code>/static/js/app.js</code>。所以程序若不在根目录下，就会出现资源文件引用错误的情况。</p>
<p>最简单的解决方案就是改动 webpack 的配置文件。将<code>/config</code>文件夹中的 index.js 文件中的<code>assetsPublicPath: &#39;/&#39;</code>改为<code>assetsPublicPath: &#39;./&#39;</code>即可，截图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-52590cfcce2b12ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config:index.png"></p>
<p>如果你还使用了 vue-router，你需要在 router 的配置中加上一行<code>base: &#39;/[项目所在文件夹的名字]/&#39;</code>，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e6de7fc323ef16e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router.png"></p>
<p>注意：如果启用了 vue-router 的 history 模式，你需要跟着 <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">vue-router 官方文档的后端配置例子</a> 对服务器进行一定的配置。</p>
<p>这是因为在 history 模式下，router 只是通过 JS 操作 window.history 来改变浏览器地址栏里的路径，并没有发起 http 请求。但是直接在地址栏中输入形如<code>http://www.example.com/example/item/1</code>这样的地址时，就一定先要对服务器发起 http 请求。此目标在服务器上不存在，于是会返回 404。修改服务器的配置，以将所有的请求全部转发到<code>index.html</code>上。</p>
<p>当然，这意味着单纯使用 Github Pages 的在线预览功能没办法进行这样的配置。你也可以关注知乎上的这个问题 <a href="https://www.zhihu.com/question/64173754" target="_blank" rel="external">怎样为Github pages Hack使用了vue-router history模式的vue应用？ - 知乎</a> 来看别人的解决方法。</p>
<h2 id="iconfont-无法加载"><a href="#iconfont-无法加载" class="headerlink" title="iconfont 无法加载"></a>iconfont 无法加载</h2><p>字体图标无法正确加载。参考 <a href="https://github.com/vuejs-templates/webpack/issues/166" target="_blank" rel="external">https://github.com/vuejs-templates/webpack/issues/166</a> ，得到的解决方法是修改 build/utils.js 文件，增加一行<code>publicPath: &#39;../../&#39;</code>，如截图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-4154f0ddd63f0953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:utils.png"></p>
<p>保存后，<code>npm run build</code>打包得到的项目中 iconfont 就可以正常显示了。</p>
<h2 id="实现-Github-Pages-在线预览"><a href="#实现-Github-Pages-在线预览" class="headerlink" title="实现 Github Pages 在线预览"></a>实现 Github Pages 在线预览</h2><p>参考 <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="external">Configuring a publishing source for GitHub Pages - User Documentation</a>，实现 Github Pages 在线预览功能有好几种方法，可以设置从<code>master</code>分支、<code>gh-pages</code>分支或者<code>master</code>分支下的<code>/docs</code>文件夹中读取。我就选择了最简单的一种方法，把<code>npm run build</code>打包下来的<code>/dist</code>文件夹改名为<code>/docs</code>。</p>
<p>之后，在 Github 项目主页的 Settings 下的 Github pages 下进行设置 Source 为<code>master branch /docs folder</code>即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-ec745a361c794183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="githubpage.png"></p>
<p>如果你之前使用过 Github Pages 并绑定了一个域名，那么这个项目的预览地址会像<code>http://kyonhuang.top/resume/</code>这样在这个域名下，看起来很爽。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://vue-loader.vuejs.org/zh-cn/configurations/pre-processors.html" target="_blank" rel="external">预处理器 · vue-loader</a></p>
<p><a href="http://upyang.com/2017/07/25/Vue项目上传github并预览/" target="_blank" rel="external">Vue项目打包上传到github预览</a></p>
<p><a href="https://www.zhihu.com/question/46630687/answer/157166318" target="_blank" rel="external">vuejs怎么在服务器部署？ - 知乎</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>撸这份简历，是一个总结，也是一个激励。</p>
<p>真正撸完简历，才发现自己在技术层面上的项目经历少的可怜，而技术也不敢说有什么掌握。以后看到这份简历，会让我非常想写一些拿得出手的开源项目，然后对项目经历进行修改。</p>
<p>读完《你不知道的JavaScript（中卷）》，就给 JS 的技能条涨 5 个百分点；用 Node 开发一个支持登录注册的后台，就给 Node 的技能条涨 5 个百分点；或者再点亮一个新的技能。</p>
<p>随着我的不断学习，希望这份简历越来越吸引人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;https://github.com/bighuang624/resume&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bighuang624/resume
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线预览地址：&lt;a href=&quot;http://kyonhuang.top/resume/&quot;&gt;http://kyonhuang.top/resume/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿喜欢折腾" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%96%9C%E6%AC%A2%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="简历" scheme="http://kyonhuang.top/tags/%E7%AE%80%E5%8E%86/"/>
    
      <category term="Vue" scheme="http://kyonhuang.top/tags/Vue/"/>
    
      <category term="github 预览" scheme="http://kyonhuang.top/tags/github-%E9%A2%84%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>初探前端自动化测试--以 Vue 为例</title>
    <link href="http://kyonhuang.top/start-front-end-test/"/>
    <id>http://kyonhuang.top/start-front-end-test/</id>
    <published>2017-08-16T01:14:28.000Z</published>
    <updated>2017-08-21T14:13:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高了。因此，对于稳定、多次复用以及需要长期维护的项目，自动化测试显得尤为重要。</p>
<p>现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。</p>
<p>前端的测试类型分为<strong>单元测试（unit testing）</strong>、<strong>集成测试（integration testing）</strong>和<strong>端到端测试（e2e testing）</strong>。</p>
<ul>
<li><strong>单元测试</strong>将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作；</li>
<li><strong>集成测试</strong>是针对产品的某个功能的测试，又称功能测试；</li>
<li><strong>e2e 测试</strong>则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。</li>
</ul>
<a id="more"></a>
<h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>先绕点路，了解一下 TDD、BDD等<strong>以测试为导向的开发模式</strong>，有助于我们更深入地理解自动化测试。</p>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p>TDD（Test Driven Development），即<strong>测试驱动开发</strong>。其先针对每个功能点抽象出接口代码，然后编写单元测试用例代码。之后实现接口，运行单元测试代码进行测试，循环往复直至所有单元测试通过。</p>
<p>TDD 要求测试先于编写功能代码。测试用例不仅是对于代码的验证，更成为对代码的规范与约束，确保在开发以及未来进行修改时能够极大程度地保证该模块行为仍然是正确的。</p>
<h3 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h3><p>BDD（Behavior Driven Development），即<strong>行为驱动开发</strong>。BDD 和 TDD 一样，都要求先写测试，再写代码。可以认为 BDD 是 TDD 的一个子集或分支，是测试驱动开发的扩展。</p>
<p>TDD 基于开发者角度，重点测试函数的输入输出；而 BDD 更侧重于使用者角度，重点测试对用户行为的反应。</p>
<p>BDD 测试中，客户与开发者共同考虑系统该如何运行，然后用通用的语言抽象描述系统的行为，使得双方从技术层面和业务需求都能理解，避免沟通障碍。</p>
<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="测试管理工具"><a href="#测试管理工具" class="headerlink" title="测试管理工具"></a>测试管理工具</h3><p>用来组织和运行整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行被测试代码进行测试。</p>
<p>可选择的有 Karma、Selenium、Mocha（Mocha既是测试工具，也是测试框架）。</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>测试框架是单元测试的核心，提供了单元测试所需的各种API，并对测试用例分组。测试框架会抓取到代码抛出的 AssertionError 并提供附加信息。</p>
<p>选择较多，有名的有 Mocha、Jasmine等。不过 Mocha 既支持 TDD 也支持 BDD 的测试语法，Jasmine 只支持 BDD。</p>
<h3 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h3><p>断言库提供了很多语义化的方法来对值做各种判断。当然也可以不用断言库，Node.js 中也可以直接使用原生 assert 库。</p>
<p>可供选择的断言库也很多，包括 should.js、expect.js、chai.js等。</p>
<h3 id="测试浏览器"><a href="#测试浏览器" class="headerlink" title="测试浏览器"></a>测试浏览器</h3><p>前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持调用和运行本地浏览器来进行测试，但如果测试仅仅是针对函数和模块的单元测试，则完全可以使用一款无界面的 webkit 内核浏览器：PhantomJS。</p>
<h3 id="测试覆盖率统计工具"><a href="#测试覆盖率统计工具" class="headerlink" title="测试覆盖率统计工具"></a>测试覆盖率统计工具</h3><p>测试覆盖率工具为代码在语法级分支上打点，之后运行代码，并在运行结束后根据收集到的信息统计出当前测试用例对源码的覆盖情况。</p>
<p>一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。</p>
<h2 id="vue-cli-的配置"><a href="#vue-cli-的配置" class="headerlink" title="vue-cli 的配置"></a>vue-cli 的配置</h2><p>vue-cli 的 webpack 模版内置了开箱即用的 Karma + Jasmine 单元测试配置，以及 Nightwatch + Selenium E2E 测试配置，<code>npm run test</code>即可测试自带的一个初始测试用例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-50166ab65032fdd5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-unit-test.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-298692df753ab061.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-e2e-test.jpg"></p>
<p>有坑请注意：</p>
<ol>
<li>建议使用 cnpm 对 vue-cli 项目进行依赖安装，否则可能有些东西装不上。</li>
<li>自带的 e2e 测试要求装有 chrome 浏览器，否则报错<code>Error retrieving a new session from the selenium server</code>。我被这个坑折腾了半天…</li>
</ol>
<h2 id="测试代码编写"><a href="#测试代码编写" class="headerlink" title="测试代码编写"></a>测试代码编写</h2><p>to be continued…</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>正在写下一篇：《初探持续集成》</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作资料"><a href="#写作资料" class="headerlink" title="写作资料"></a>写作资料</h3><p><a href="http://www.cnblogs.com/bigdataZJ/p/AutoTesting1.html" target="_blank" rel="external">开发人员看测试之TDD和BDD - JackieZheng - 博客园</a></p>
<p><a href="http://www.jianshu.com/p/6726c0410650" target="_blank" rel="external">前端自动化单元测试初探 - 简书</a></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://www.infoq.com/cn/articles/virtual-panel-tdd-bdd#" target="_blank" rel="external">虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发</a></p>
<p><a href="https://www.qcloud.com/community/article/743451001489391682" target="_blank" rel="external">PhantomJS 基础及示例 - 腾云阁 - 腾讯云</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高了。因此，对于稳定、多次复用以及需要长期维护的项目，自动化测试显得尤为重要。&lt;/p&gt;
&lt;p&gt;现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。&lt;/p&gt;
&lt;p&gt;前端的测试类型分为&lt;strong&gt;单元测试（unit testing）&lt;/strong&gt;、&lt;strong&gt;集成测试（integration testing）&lt;/strong&gt;和&lt;strong&gt;端到端测试（e2e testing）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单元测试&lt;/strong&gt;将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成测试&lt;/strong&gt;是针对产品的某个功能的测试，又称功能测试；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;e2e 测试&lt;/strong&gt;则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端工程" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="测试" scheme="http://kyonhuang.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6 的异步操作 - Generator &amp; async</title>
    <link href="http://kyonhuang.top/Generator-and-async/"/>
    <id>http://kyonhuang.top/Generator-and-async/</id>
    <published>2017-08-03T10:10:53.000Z</published>
    <updated>2017-08-06T00:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：<strong>回调函数、事件监听、发布/订阅和 Promise 对象</strong>。为了使异步操作更加清晰、简洁、方便，ES6 引入了 <strong>Generator 函数</strong>，而 ES2017 标准引入了 <strong>async 函数</strong>作为 Generator 函数的语法糖。</p>
<p>由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。</p>
<p>本博文在 <a href="http://kyonhuang.top/promise/">Promise 对象 | 大黄菌的个人博客</a> 之后食用最佳。</p>
<p><strong>注</strong>：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。</p>
<a id="more"></a>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-92dc7055c94c75cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Generator.png"></p>
<h3 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h3><p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为<strong>协程（coroutine）</strong>。</p>
<p>Generator 函数是 ES6 对协程的不完全实现，因为只有 Generator 函数的调用者才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<h3 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h3><p>Generator 是一个异步操作的容器。想让 Generator <strong>自动执行</strong>，即需要当异步操作有结果时能够自动交回执行权。两种方法：</p>
<ol>
<li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里交回执行权。</li>
<li>Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</li>
</ol>
<p>其中，JavaScript 中的 <strong>Thunk 函数</strong>指将多参数函数替换成的一个只接受回调函数作为参数的单参数函数。任何参数有回调函数的函数，都能写成 Thunk 函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6 版本的简单 Thunk 函数转换器</span></div><div class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前者的实现可用 Thunkify 模块，后者可用 co 模块。了解更多请看 <a href="http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0" target="_blank" rel="external">Generator 函数的异步应用 - ECMAScript 6入门</a>。暂时用不到的工具就不进一步消耗脑细胞了。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="通过-Generator-函数部署-Ajax-操作"><a href="#通过-Generator-函数部署-Ajax-操作" class="headerlink" title="通过 Generator 函数部署 Ajax 操作"></a>通过 Generator 函数部署 Ajax 操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">'http://some.url'</span>);</div><div class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</div><div class="line">  <span class="built_in">console</span>.log(resp.value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">  makeAjaxCall(url, (response) =&gt; &#123;</div><div class="line">    it.next(response);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = main();</div><div class="line">it.next();</div></pre></td></tr></table></figure>
<h4 id="使用-yield-语句遍历完全二叉树"><a href="#使用-yield-语句遍历完全二叉树" class="headerlink" title="使用 yield* 语句遍历完全二叉树"></a>使用 yield* 语句遍历完全二叉树</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.left = left;</div><div class="line">  <span class="keyword">this</span>.label = label;</div><div class="line">  <span class="keyword">this</span>.right = right;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 中序（inorder）遍历函数</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(t) &#123;</div><div class="line">    <span class="keyword">yield</span>* inoreder(t.left);</div><div class="line">    <span class="keyword">yield</span> t.label;</div><div class="line">    <span class="keyword">yield</span>* inorder(t.right);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成二叉树</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="comment">// 判断是否为叶节点</span></div><div class="line">  <span class="keyword">if</span>(array.length === <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</div><div class="line"></div><div class="line"><span class="comment">// 遍历二叉树</span></div><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> inoreder(tree))&#123;</div><div class="line">  result.push(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line">result</div><div class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></div></pre></td></tr></table></figure>
<h4 id="利用-Generator-函数部署-Iterator-接口"><a href="#利用-Generator-函数部署-Iterator-接口" class="headerlink" title="利用 Generator 函数部署 Iterator 接口"></a>利用 Generator 函数部署 Iterator 接口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    <span class="keyword">let</span> key = keys[i];</div><div class="line">    <span class="keyword">yield</span> [key, obj[key]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">bar</span>: <span class="number">7</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// foo 3</span></div><div class="line"><span class="comment">// bar 7</span></div></pre></td></tr></table></figure>
<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-532436b8fe3212f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="async+函数.png"></p>
<p>感觉前面的知识短时间内都消化不了，就没有看处于提案的异步遍历器。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h3 id="异步获取股票报价"><a href="#异步获取股票报价" class="headerlink" title="异步获取股票报价"></a>异步获取股票报价</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockStmbol(name);</div><div class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</div><div class="line">  <span class="keyword">return</span> stockPrice;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="并发发出远程请求"><a href="#并发发出远程请求" class="headerlink" title="并发发出远程请求"></a>并发发出远程请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInorder</span>(<span class="params">urls</span>) </span>&#123;</div><div class="line">  <span class="comment">// 并发读取远程 URL</span></div><div class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</div><div class="line">    <span class="keyword">return</span> response.text();</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="comment">// 按次序输出</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过学习，我感觉 async 函数真的为一组资源依次异步加载等实际开发场景提供了一种非常简便的处理方案。不过想要运用好 async 函数，深究其实现原理，就必须也要对 Generator 函数有清晰的认知。</p>
<p>异步编程不管是在浏览器还是在服务器端的开发都很重要，知识量也很大，一时半会大概消化不过来。在总结完这些知识后，还需要时常复习，并在实际开发过程中探索更好的实践。</p>
<h2 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a>：帮助加深对同步、异步执行机制的认识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：&lt;strong&gt;回调函数、事件监听、发布/订阅和 Promise 对象&lt;/strong&gt;。为了使异步操作更加清晰、简洁、方便，ES6 引入了 &lt;strong&gt;Generator 函数&lt;/strong&gt;，而 ES2017 标准引入了 &lt;strong&gt;async 函数&lt;/strong&gt;作为 Generator 函数的语法糖。&lt;/p&gt;
&lt;p&gt;由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。&lt;/p&gt;
&lt;p&gt;本博文在 &lt;a href=&quot;http://kyonhuang.top/promise/&quot;&gt;Promise 对象 | 大黄菌的个人博客&lt;/a&gt; 之后食用最佳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="异步编程" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 入门笔记</title>
    <link href="http://kyonhuang.top/start-to-learn-NodeJS/"/>
    <id>http://kyonhuang.top/start-to-learn-NodeJS/</id>
    <published>2017-07-30T14:29:41.000Z</published>
    <updated>2017-08-17T13:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 <a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJS</a> 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。</p>
<p>在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。</p>
<p>虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。</p>
<a id="more"></a>
<h2 id="NodeJS-应用领域及特点"><a href="#NodeJS-应用领域及特点" class="headerlink" title="NodeJS 应用领域及特点"></a>NodeJS 应用领域及特点</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-81b14861f2bc2943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Node.js+概念一览.png"></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a1f50c7c0c750605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模块.png"></p>
<h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ol>
<li>大大提高代码的可维护性；</li>
<li>可以随时引用；</li>
<li>避免函数名和变量名冲突；</li>
</ol>
<h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><p>CommonJS 主要是在 <strong>Node 服务器端</strong>的规范。</p>
<p>每个<code>.js</code>文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突。</p>
<p>一个模块要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>。一个模块要引用其他模块暴露的变量，用<code>var foo = require(&#39;module_name&#39;)</code>就拿到了引用模块的变量。</p>
<p><strong>模块加载会有缓存</strong>，且其根据<strong>绝对路径识别</strong>。因此同样的模块名放在不同的路径之中多次 require 不会重新加载。</p>
<p>CommonJS 是<strong>同步加载</strong>的，在服务器端模块文件一般存放在本地，再加上有缓存，加载速度很快。而在浏览器端就可能导致“假死”，因此浏览器端采用另一种异步加载方式 - AMD（Asynchronous Module Definition）。</p>
<p>想要进一步了解，可参考 <a href="www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">Javascript模块化编程（二）：AMD规范 - 阮一峰的网络日志</a>。</p>
<h3 id="深入了解模块原理"><a href="#深入了解模块原理" class="headerlink" title="深入了解模块原理"></a>深入了解模块原理</h3><p>Node.js 的“模块”功能利用了 JavaScript 函数式编程的特性，通过<strong>闭包</strong>实现。</p>
<h2 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-829fee6dc736dbd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码的组织和部署.png"></p>
<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a0e8821626a2e3cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本模块.png"></p>
<p>Node.js 内置的常用模块是为了实现基本的服务器功能，底层代码是用 C/C++ 在 Node.js 运行环境中实现。</p>
<h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>Node.js 环境中唯一的全局变量。</p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>代表当前 Node.js 进程。</p>
<h3 id="判断-JavaScript-执行环境"><a href="#判断-JavaScript-执行环境" class="headerlink" title="判断 JavaScript 执行环境"></a>判断 JavaScript 执行环境</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(<span class="built_in">window</span>) === <span class="string">'undefined'</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'node.js'</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'browser'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-f46374c76abbbe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件操作.png"></p>
<h3 id="不同系统下路径的标准化"><a href="#不同系统下路径的标准化" class="headerlink" title="不同系统下路径的标准化"></a>不同系统下路径的标准化</h3><p>标准化之后的路径里的斜杠在 Windows 系统下是<code>\</code>，而在 Linux 系统下是<code>/</code>。如果想保证任何系统下都使用 / 作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径。</p>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步遍历获取某一文件夹下的所有文件，用 callback 处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>)</span>&#123;</div><div class="line">  fs.readdirSync(dir).forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> pathname = path.join(dir, file);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(fs.statSync(pathname).isDirectory())&#123;</div><div class="line">      travel(pathname, callback)；</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback(pathname);</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 异步遍历</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback, finish</span>)</span>&#123;</div><div class="line">  fs.readdir(dir, (err, files) =&gt; &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(i &lt; files.length) &#123;</div><div class="line">        <span class="keyword">var</span> pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">        fs.stat(pathname, (err, stats) =&gt; &#123;</div><div class="line">          <span class="keyword">if</span>(stats.isDirectory())&#123;</div><div class="line">            travel(pathname, callback, () =&gt; &#123;</div><div class="line">              next(i + <span class="number">1</span>);</div><div class="line">            &#125;);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            callback(pathname, () =&gt; &#123;</div><div class="line">              next(i + <span class="number">1</span>);</div><div class="line">            &#125;)</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        finish &amp;&amp; finish();</div><div class="line">      &#125;</div><div class="line">    &#125;)(<span class="number">0</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-439f836f1c5033bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络操作.png"></p>
<h3 id="监听端口的权限问题"><a href="#监听端口的权限问题" class="headerlink" title="监听端口的权限问题"></a>监听端口的权限问题</h3><p>在 Linux 系统下，监听 1024 以下端口需要 root 权限。因此，如果想监听 80 或 443 端口的话，需要使用 sudo 命令启动程序。</p>
<h3 id="URL-的完整组成"><a href="#URL-的完整组成" class="headerlink" title="URL 的完整组成"></a>URL 的完整组成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                           href</div><div class="line"> -----------------------------------------------------------------</div><div class="line">                            host              path</div><div class="line">                      --------------- ----------------------------</div><div class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</div><div class="line"> -----    ---------   --------   ---- -------- ------------- -----</div><div class="line">protocol     auth     hostname   port pathname     search     hash</div><div class="line">                                                ------------</div><div class="line">                                                   query</div></pre></td></tr></table></figure>
<h3 id="网络操作常见问题"><a href="#网络操作常见问题" class="headerlink" title="网络操作常见问题"></a>网络操作常见问题</h3><ul>
<li><p>问： 为什么通过<code>headers</code>对象访问到的 HTTP 请求头或响应头字段不是驼峰的？</p>
<p>  答： 从规范上讲，HTTP 请求头和响应头字段都应该是驼峰的。但现实中不是每个 HTTP 服务端或客户端程序都严格遵循规范，所以 NodeJS 在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers[&#39;content-length&#39;]</code>。</p>
</li>
<li><p>问： 为什么<code>http</code>模块创建的 HTTP 服务器返回的响应是<code>chunked</code>传输方式的？</p>
<p>  答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用<code>.end</code>方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后 NodeJS 就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>
</li>
<li><p>问： 为什么使用<code>http</code>模块发起 HTTP 客户端请求时，有时候会发生<code>socket hang up</code>错误？</p>
<p>  答： 发起客户端 HTTP 请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许5个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过<code>https.globalAgent.maxSockets</code>属性来处理。</p>
</li>
</ul>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-d48f8689170c4f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程管理.png"></p>
<h3 id="降权"><a href="#降权" class="headerlink" title="降权"></a>降权</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 降权</span></div><div class="line">http.createServer(callback).listen(<span class="number">80</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">var</span> env = process.env,</div><div class="line">      uid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_UID'</span>] || process.getuid(), <span class="number">10</span>);</div><div class="line">      gid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_GID'</span>] || process.getgid(), <span class="number">10</span>);</div><div class="line"></div><div class="line">  process.setgid(gid);</div><div class="line">  process.setuid(uid);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li><p>如果是通过<code>sudo</code>获取 root 权限的，运行程序的用户的 UID 和 GID 保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取 root 权限的，运行程序的用户的 UID 和 GID 可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</p>
</li>
<li><p><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</p>
</li>
<li><p>降权时必须先降 GID 再降 UID，否则顺序反过来的话就没权限更改程序的 GID 了。</p>
</li>
</ol>
<h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><p>如果父子进程都是 NodeJS 进程，就可以通过 IPC（进程间通讯）双向传递数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* parent.js */</span></div><div class="line"><span class="comment">// 在 options.stdio 字段中通过 ipc 开启一条 IPC 通道</span></div><div class="line"><span class="keyword">var</span> child = child_process.spawn(<span class="string">'node'</span>, [<span class="string">'child.js'</span>], &#123;</div><div class="line">  <span class="attr">stdio</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'ipc'</span>]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(<span class="string">'message'</span>, (msg) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(msg);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 给子进程发送消息</span></div><div class="line">child.send(&#123; <span class="attr">hello</span>: <span class="string">'hello'</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">/* child.js */</span></div><div class="line">process.on(<span class="string">'message'</span>, (msg) =&gt; &#123;</div><div class="line">  msg.hello = msg.hello.toUpperCase();</div><div class="line">  process.send(msg);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 守护子进程</span></div><div class="line"><span class="comment">/* daemon.js */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">mainModule</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> worker = child_process.spawn(<span class="string">'node'</span>, [mainModule]);</div><div class="line"></div><div class="line">  worker.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(code !== <span class="number">0</span>)&#123;</div><div class="line">      spawn(mainModule);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(<span class="string">'worker.js'</span>);</div></pre></td></tr></table></figure>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-57c2d4c89e36c4d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步编程.png"></p>
<h3 id="domain-捕获异常"><a href="#domain-捕获异常" class="headerlink" title="domain 捕获异常"></a>domain 捕获异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">request, callback</span>)</span>&#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">  asyncA(request, (data) =&gt; &#123;</div><div class="line">    <span class="comment">// Do something</span></div><div class="line">    asyncB(request, (data) =&gt; &#123;</div><div class="line">      <span class="comment">// Do something</span></div><div class="line">      asyncC(request, (data) =&gt; &#123;</div><div class="line">        <span class="comment">// Do something</span></div><div class="line">        callback(data);</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">var</span> d = domain.create();</div><div class="line"></div><div class="line">  d.on(<span class="string">'error'</span>, () =&gt; &#123;</div><div class="line">    response.writeHead(<span class="number">500</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  d.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">async</span>(request, (data) =&gt; &#123;</div><div class="line">      response.writeHead(<span class="number">200</span>);</div><div class="line">      response.end(data);</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了 C/C++ 部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是 JS 本身的异常，不用担心上述问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJS 的学习其实主要分为三块：</p>
<ol>
<li>JavaScript 语言本身。要学会借助 <a href="https://www.ecma-international.org/publications/standards/Standard.htm" target="_blank" rel="external">ECMAScript 规范</a> 加深自己的理解。</li>
<li>NodeJS 的 API。要熟悉官方 API 文档，主要是熟悉 NodeJS 提供的功能以及知道该查询文档的哪块地方。不推荐死记硬背，因为新版本会更改和弃用部分 API。</li>
<li>生态圈中的各种三方库。要学习检索、过滤、去其糟粕取其精华，利用但不迷信。</li>
</ol>
<p>而在 NodeJS 开发时，首先要有一个全局的设计，再再实现的过程中对之间忽略掉的细节进行设计上的改进，为二次迭代做准备。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>除开文章开头提到的资料，结语部分参考了 <a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=1&amp;sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&amp;chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&amp;mpshare=1&amp;scene=1&amp;srcid=0727qbaSu9gx8oduOdFPTUoU#" target="_blank" rel="external">当我们学习 Node.js 时，我们在学习什么？</a>。</p>
<h3 id="下一步学习"><a href="#下一步学习" class="headerlink" title="下一步学习"></a>下一步学习</h3><p><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="external">《Node.js 包教不包会》 by alsotang</a></p>
<p>《深入浅出Node.js》</p>
<p>自己撸个爬虫</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 &lt;a href=&quot;http://nqdeng.github.io/7-days-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;七天学会NodeJS&lt;/a&gt; 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。&lt;/p&gt;
&lt;p&gt;在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。&lt;/p&gt;
&lt;p&gt;虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS 学习笔记" scheme="http://kyonhuang.top/categories/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="脑图" scheme="http://kyonhuang.top/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>《你不知道的 JavaScript（上卷）》脑图</title>
    <link href="http://kyonhuang.top/You-Dont-Know-JS-notes-1/"/>
    <id>http://kyonhuang.top/You-Dont-Know-JS-notes-1/</id>
    <published>2017-07-27T08:47:12.000Z</published>
    <updated>2017-07-27T12:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。</p>
  <a id="more"></a>
<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作用域和闭包.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">作用域和闭包.png</a></p>
<h2 id="this-和对象原型"><a href="#this-和对象原型" class="headerlink" title="this 和对象原型"></a>this 和对象原型</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="this和对象原型.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">this和对象原型.png</a></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>补一张来自 <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">JavaScript深入之从原型到原型链</a>  的图，来直观地表现原型链。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-d73fdcc0c25efd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链.png"></p>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="脑图" scheme="http://kyonhuang.top/tags/%E8%84%91%E5%9B%BE/"/>
    
      <category term="《你不知道的 JavaScript》" scheme="http://kyonhuang.top/tags/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JavaScript%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>初探人工智能</title>
    <link href="http://kyonhuang.top/start-to-know-AI/"/>
    <id>http://kyonhuang.top/start-to-know-AI/</id>
    <published>2017-07-23T02:17:25.000Z</published>
    <updated>2017-07-30T08:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？</p>
<ol>
<li>发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。</li>
<li>随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。</li>
<li>确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。</li>
</ol>
<p>何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。</p>
<p>这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。</p>
<p>不要拒绝未来的任何可能性。</p>
<a id="more"></a>
<h2 id="相关概念脑图"><a href="#相关概念脑图" class="headerlink" title="相关概念脑图"></a>相关概念脑图</h2><p>一直感觉纯文字的笔记比较难以记忆，导致自己的学习吸收率不高。看到别人的读书笔记是总结了一张脑图，条理比较清晰。这里也试着用 Xmind 总结一张相关概念的脑图（P.S.使用感觉百度脑图比 Xmind 条理清晰+好用）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a64a6eb143122930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="人工智能相关概念.png"></p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>学习算法的输入数据，叫<strong>“训练数据”</strong>。训练数据的每一行称为一个<strong>“训练样本”（Training Sample）</strong>，通常简称“样本”（Sample）。</p>
<p>样本的各种属性称为<strong>“特征”（Feature）</strong>。而希望学得的模型可以用来预判的信息称为样本的<strong>“标注”（Label）</strong>。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>机器学到的模型是一个映射。</p>
<h3 id="映射的输入"><a href="#映射的输入" class="headerlink" title="映射的输入"></a>映射的输入</h3><p>每个样本 xi 的特征组成一个<strong>“特征向量” (Feature Vector)</strong>。所有特征向量的集合就是总的输入集合，称为<strong>“样本空间” (Sample Space)</strong>。</p>
<h3 id="映射的输出"><a href="#映射的输出" class="headerlink" title="映射的输出"></a>映射的输出</h3><p>第 i 个样本的标注记作 yi。同理有<strong>“标注空间”(Label Space)</strong>。</p>
<h3 id="映射的表示"><a href="#映射的表示" class="headerlink" title="映射的表示"></a>映射的表示</h3><p>机器学习模型就是输入空间 X 到输出空间 Y 的一个映射，将映射用符号 g 表示，则模型记作 g: X -&gt; Y。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><strong>学习算法 (Learning Algorithm)</strong> 根据训练数据，从<strong>假设集合 (Hypothesis Set) </strong>中选出最优的那个映射 g 作为最终学得的模型，使得 g 越接近上帝真相 f 越好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>不是所有的机器学习问题都需要标注。根据训练数据是否有标注，机器学习问题大致划分为<strong>监督学习（Supervised Learning）</strong>和<strong>无监督学习（Unsupervised Learning）</strong>两大类（还有半监督学习、增强学习等）。</p>
<ul>
<li>监督学习：每个输入样本都<strong>有标注</strong>。大致分成两类：<ol>
<li><strong>分类（Classification）</strong>问题：标注是<strong>离散值</strong>，比如用户”点击“和”不点击“。如果标注只有两个值，则称为二分类，如果标注有多个值，则称为多分类。</li>
<li><strong>回归（Regression）</strong>问题：标注是<strong>连续值</strong>，比如如果问题是预测北京市房屋的价格，价格作为标注就是一个连续值，属于回归问题。</li>
</ol>
</li>
<li>无监督学习：训练样本<strong>没有标注</strong>，无监督学习解决的典型问题是<strong>聚类（clustering）问题</strong>。比如对一个网站的用户进行聚类，看看这个网站用户的大致构成，分析下每类用户群的特点是什么。</li>
</ul>
<p>以上总结为脑图（感觉百度脑图看起来条理稍微清晰一些）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e14be3cf5133d5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="机器学习.png"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>把听上去最高端的“神经网络”放到最后介绍。</p>
<h3 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h3><p>一组大致模仿人类大脑构造设计的算法，用于识别模式。神经网络通过机器感知系统解释传感器数据，能够对原始输入进行标记或聚类等操作。</p>
<p>神经网络所能识别的模式是数值形式，因此图像、声音、文本、时间序列等一切现实世界的数据必须转换为数值。</p>
<h3 id="感知器、权重与阈值"><a href="#感知器、权重与阈值" class="headerlink" title="感知器、权重与阈值"></a>感知器、权重与阈值</h3><p>大家都在高中的生物课上学过，人类大脑思考的基础是神经元（神经细胞）。如果能够人工制造神经元，就能组成人工神经网络来模拟思考。</p>
<p>上世纪六十年代，科学家们提出了最早的“人造神经元”，并将其称为<strong>“感知器”（perceptron）</strong>。感知器接受一些因素，这些因素根据不同的重要性（决定性因素与次要因素）获得不同的<strong>权重（weight）</strong>。因素的条件成立为 1，不成立为 0，乘以权重的总和大于指定的<strong>阈值（threshold）</strong>，感知器便输出 11，否则输出 0。</p>
<h3 id="决策模型"><a href="#决策模型" class="headerlink" title="决策模型"></a>决策模型</h3><p>单个的感知器构成一个简单的决策模型。而实际的决策模型是由多个感知器组成的多层网络。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png" alt="多层网络"></p>
<p>每一个节点层在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂，因为每一层会整合并重组前一层的特征。</p>
<p>而在“递归神经网络”中，上下层的感知器的输入与输出还可能发生循环传递。</p>
<h3 id="神经网络运作过程"><a href="#神经网络运作过程" class="headerlink" title="神经网络运作过程"></a>神经网络运作过程</h3><p>一个神经网络的搭建，需要满足三个条件：</p>
<ol>
<li>输入和输出</li>
<li>权重（w）和阈值（b）</li>
<li>多层感知器的结构</li>
</ol>
<p>最困难的部分就是确定权重和阈值。我们通过试错法，即保证其他参数不变，对 w 或 b 进行微小变动，然后观察输出的变化。通过不断重复这个过程来得到最精确的那组 w 和 b。这个过程即被称为<strong>模型的训练</strong>。</p>
<p>因此，神经网络的运作过程如下：</p>
<ol>
<li>确定输入和输出</li>
<li>找到一种或多种算法，可以从输入得到输出</li>
<li>找到一组已知答案的数据集，用来训练模型，估算 w 和 b</li>
<li>一旦新的数据产生，输入模型，就可以得到结果，同时对 w 和 b 进行校正</li>
</ol>
<p>整个过程需要海量计算，所以需要使用专门为机器学习定制的 GPU。</p>
<h3 id="输出的连续性"><a href="#输出的连续性" class="headerlink" title="输出的连续性"></a>输出的连续性</h3><p>为了保证模型的敏感，要将 0、1 输出改造为连续性函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">z = wx + b</div><div class="line">σ(z) = 1 / (1 + e^(-z))</div></pre></td></tr></table></figure>
<p>这样，当 z 趋向正无穷（表示感知器强烈匹配）时，σ(z) → 1；如果 z 趋向负无穷（表示感知器强烈不匹配），σ(z) → 0。</p>
<p>同时，Δσ 满足下面的公式：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png" alt="Δσ 公式"></p>
<p>即 Δσ 和 Δw 和 Δb 之间是线性关系，变化率是偏导数。这就有利于精确推算出 w 和 b 的值了。</p>
<h2 id="基于-JavaScript-的机器学习"><a href="#基于-JavaScript-的机器学习" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h2><p>尽管确实是第一选择，机器学习不一定要用 Python。为什么不试试神奇的 JavaScript 呢？</p>
<p>JavaScript 开发者们已经开源了不少基于 Node.js 的机器学习库：</p>
<ol>
<li><a href="https://github.com/harthur-org/brain.js" target="_blank" rel="external">brain.js</a> (神经网络)</li>
<li><a href="https://github.com/cazala/synaptic" target="_blank" rel="external">Synaptic</a> (神经网络)</li>
<li><a href="https://github.com/NaturalNode/natural" target="_blank" rel="external">Natural</a> (自然语言处理)</li>
<li><a href="http://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="external">ConvNetJS</a> (卷积神经网络)</li>
<li><a href="https://github.com/mljs" target="_blank" rel="external">mljs</a> (一系列具有多个函数方法的 AI 库)</li>
<li>Neataptic (神经网络)</li>
<li><a href="https://github.com/mil-tokyo/webdnn" target="_blank" rel="external">Webdnn</a> (深度学习)</li>
</ol>
<p>你可以从 github 的这个项目：<a href="https://github.com/abhisheksoni27/machine-learning-with-js" target="_blank" rel="external">abhisheksoni27/machine-learning-with-js</a> 中获得一些实例的源码，目前作者实现了线性规划和 KNN 算法。你也可以在参考资料的对应章节找到翻译版本进行阅读。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>emmm，如果你看了之后的参考资料中的每一篇，你会发现这篇博文只是一个拙劣的归纳总结。这是因为我确实对相关领域没有什么了解。但我对此兴致勃勃，也已经关注了不少数据挖掘和机器学习的知乎专栏及收藏夹。希望自己将来会有相关方面有价值的产出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="相关概念部分"><a href="#相关概念部分" class="headerlink" title="相关概念部分"></a>相关概念部分</h3><p><a href="http://blog.csdn.net/feichizhongwu888/article/details/52727958" target="_blank" rel="external">简单理解：人工智能、数据挖掘、模式识别、机器学习、深度学习 - feichizhongwu888的博客 - CSDN博客</a></p>
<p><a href="http://36kr.com/p/5052482.html" target="_blank" rel="external">一篇文章讲清楚人工智能、机器学习和深度学习的区别</a></p>
<h3 id="数据、模型部分"><a href="#数据、模型部分" class="headerlink" title="数据、模型部分"></a>数据、模型部分</h3><p><a href="https://zhuanlan.zhihu.com/p/25439997" target="_blank" rel="external">写给大家看的机器学习书（第二篇） - 知乎专栏</a></p>
<h3 id="神经网络部分"><a href="#神经网络部分" class="headerlink" title="神经网络部分"></a>神经网络部分</h3><p><a href="http://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank" rel="external">神经网络入门 - 阮一峰的网络日志</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25358695" target="_blank" rel="external">写给大家看的机器学习书（第三篇）</a></p>
<h3 id="基于-JavaScript-的机器学习-1"><a href="#基于-JavaScript-的机器学习-1" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h3><p><a href="https://blog.fundebug.com/2017/07/03/javascript-machine-learning-regression/" target="_blank" rel="external">JavaScript机器学习之线性回归</a></p>
<p><a href="https://blog.fundebug.com/2017/07/10/javascript-machine-learning-knn/" target="_blank" rel="external">JavaScript机器学习之KNN算法</a></p>
<h3 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h3><p><a href="http://www.cnblogs.com/subconscious/p/5058741.html" target="_blank" rel="external">神经网络浅讲：从神经元到深度学习</a></p>
<p><a href="https://yanqiangmiffy.github.io/2017/07/26/Python28-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BD%BF%E7%94%A8Python%E5%92%8CR%E4%BB%A3%E7%A0%81%EF%BC%89/" target="_blank" rel="external">机器学习算法的基本知识（使用Python和R代码）</a>：带有 Python 和 R 语言代码实例</p>
<p><a href="https://exacity.github.io/deeplearningbook-chinese/" target="_blank" rel="external">Deep Learning 中文翻译</a></p>
<p><a href="http://blog.csdn.net/baihuaxiu123/article/details/69488610" target="_blank" rel="external">[机器学习]机器学习笔记整理全解</a></p>
<p><a href="https://zhuanlan.zhihu.com/dteratech" target="_blank" rel="external">DT新纪元 - 知乎专栏</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。&lt;/p&gt;
&lt;h2 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么&quot;&gt;&lt;/a&gt;为什么&lt;/h2&gt;&lt;p&gt;为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。&lt;/li&gt;
&lt;li&gt;随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。&lt;/li&gt;
&lt;li&gt;确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。&lt;/p&gt;
&lt;p&gt;这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。&lt;/p&gt;
&lt;p&gt;不要拒绝未来的任何可能性。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习笔记" scheme="http://kyonhuang.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人工智能" scheme="http://kyonhuang.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://kyonhuang.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://kyonhuang.top/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>暑假计划进行中</title>
    <link href="http://kyonhuang.top/summer-plan/"/>
    <id>http://kyonhuang.top/summer-plan/</id>
    <published>2017-07-05T13:42:53.000Z</published>
    <updated>2017-08-06T00:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>出征前內心忐忑<br>鋒利的匕首反握<br>準備殺死對手前先讓我來殺死懶惰</p>
<p>— 艾福杰尼 / Killa4nia《酒精》</p>
</blockquote>
<p>简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感兴趣的知识，并且认真做学习笔记和总结。</p>
<p>07.20 更新：暑假已经过去了半个月。对暑期计划进行一些变更使其更加合理。最重要的是提高效率。</p>
<p>08.06 更新：暑假快过了 2/3 了，对计划进行一些修正。</p>
<h4 id="读书计划（脑图整理知识点）"><a href="#读书计划（脑图整理知识点）" class="headerlink" title="读书计划（脑图整理知识点）"></a>读书计划（脑图整理知识点）</h4><p>[Finished] 7月23日为 deadline，看完《你不知道的 JavaScript（上卷）》。</p>
<p>8月8日为deadline， 看完《你不知道的 JavaScript（中卷）》。</p>
<p>8月读《Node.js 深入浅出》。</p>
<p>争取暑假读完《JavaScript 设计模式与开发实践》。</p>
<h4 id="整个暑假："><a href="#整个暑假：" class="headerlink" title="整个暑假："></a>整个暑假：</h4><ul>
<li>每天 12 点前睡觉，8 点前起床。</li>
<li>前端各类练习题。每天 2 - 3 道原生 js 实例题。学累了刷刷 <a href="https://www.nowcoder.com/5257175" target="_blank" rel="external">牛客网</a>。</li>
<li>每天 2 面六级单词。</li>
</ul>
<h4 id="想做的练习："><a href="#想做的练习：" class="headerlink" title="想做的练习："></a>想做的练习：</h4><ul>
<li><a href="http://www.cnblogs.com/coco1s/p/6802374.html" target="_blank" rel="external">谈谈一些有趣的CSS题目</a></li>
<li><a href="http://www.fgm.cc/learn/" target="_blank" rel="external">原生JavaScript学习-实例索引</a></li>
<li><a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a>［可缓］</li>
</ul>
<h4 id="七月："><a href="#七月：" class="headerlink" title="七月："></a>七月：</h4><ul>
<li>写花旗杯项目前端。</li>
<li>Vue 全家桶及相关技术实践。</li>
</ul>
<h4 id="八月："><a href="#八月：" class="headerlink" title="八月："></a>八月：</h4><ul>
<li>Node.js学习。首先是廖雪峰的入门教程，争取一天看完 [08.06：koa 有点难理解…先从 express 学习好了]。接下来选一本书看看（据说朴灵的《Node.js 深入浅出》不错…）</li>
<li>完成一个类似 <a href="https://juejin.im/post/59857c616fb9a03c5c6ffa91" target="_blank" rel="external">带你用 Vue 全家桶和 Node.js 完成一个聚合应用</a> 的 demo。</li>
<li>如果还有时间，试试 Electron 或者 <a href="https://lavas.baidu.com/guide" target="_blank" rel="external">Lavas</a></li>
</ul>
<p>天下武功，唯勤不破！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;出征前內心忐忑&lt;br&gt;鋒利的匕首反握&lt;br&gt;準備殺死對手前先讓我來殺死懶惰&lt;/p&gt;
&lt;p&gt;— 艾福杰尼 / Killa4nia《酒精》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Promise 对象</title>
    <link href="http://kyonhuang.top/promise/"/>
    <id>http://kyonhuang.top/promise/</id>
    <published>2017-06-17T13:38:13.000Z</published>
    <updated>2017-08-08T08:41:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。</p>
<p>特点：</p>
<ol>
<li><strong>对象的状态不受外界影响</strong>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成，又称 Fulfilled）和<code>Rejected</code>（已失败）。只有异步操作的结果可以决定当前是哪一种状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。<code>Promise</code>对象的状态改变只有两种可能：从<code>Pending</code>变为<code>Resovled</code>和从<code>Pending</code>变为<code>Rejected</code>。</li>
</ol>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>缺点：</p>
<ol>
<li>无法取消<code>Promise</code>，一旦新建就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，<code>Promise</code>内部抛出的错误不会反映到外部。</li>
<li>当处于<code>Pending</code>状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。</li>
</ol>
<a id="more"></a>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>一个栗子🌰，用<code>Promise</code>对象实现 Ajax 操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    client.open(<span class="string">"GET"</span>, url);</div><div class="line">    client.onreadystagechange = handler;</div><div class="line">    client.responseType = <span class="string">"json"</span>;</div><div class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.readyState !== <span class="number">4</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="number">200</span>)&#123;</div><div class="line">        resolve(<span class="keyword">this</span>.response);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(<span class="string">"/post.json"</span>).then(</div><div class="line">  <span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json), </div><div class="line">  error =&gt; <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error)</div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>resolve</code>和<code>reject</code>函数由 JavaScript 引擎提供，不用自己部署。两者在改变 <code>Promise</code>对象的状态的同时，将异步操作的结果或报出的错误<strong>作为参数</strong>传递出去。</p>
<p><code>then</code>方法可以接受两个回调函数作为参数（可以说是处理 result 和 err 的回调）。第一个在<code>Promise</code>对象状态变为<code>Resolved</code>时调用，第二个（可省）在<code>Promise</code>对象状态变为<code>Rejected</code>时调用，都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个<code>Promise</code>实例（决定前一个<code>Promise</code>对象的状态），表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>在创建新的 Promise 时，<strong>作为 Promise 参数传入的函数是会被立即执行</strong>的（而不是调用 then 时才执行），只是其中执行的代码可以是异步代码。</p>
<p>虽然 Promise 作为参数接收的函数是同步执行的，但是<strong><code>then</code>方法的回调函数执行</strong>是<strong>异步</strong>的。</p>
<p>🌰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"create a promise"</span></div><div class="line"><span class="string">"after new Promise"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a><code>Promise.prototype.then()</code></h4><p><code>then</code>方法返回一个<strong>新的</strong><code>Promise</code>实例。链式写法调用<code>then</code>方法时，前一个回调函数将<strong>返回结果</strong>作为参数，传入第二个回调函数（前一个回调函数没有用<code>return</code>返回结果时，默认返回 undefined）。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a><code>Promise.prototype.catch()</code></h4><p><code>reject</code>方法的作用，等同于抛出错误。如果<code>Promise</code>状态已经变成<code>Resolved</code>，在<code>resolve</code>语句后再抛出错误是无效的，因为状态不会再改变了。</p>
<p>一般来说，不要在<code>then</code>方法中定义<code>Reject</code>状态的回调函数，<strong>总是使用<code>catch</code>方法</strong>。因为<code>catch</code>可以捕获之前所有<code>then</code>方法执行中的错误，也更接近同步的<code>try/catch</code>写法。</p>
<p><code>catch</code>方法返回的也是一个<code>Promise</code>对象。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h4><p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例（否则调用<code>Promise.resolve</code>方法再处理），包装成一个新的<code>Promise</code>实例。接受一个具有<code>Iterator</code>接口，且返回的每个成员都是<code>Promise</code>实例的参数（一般为数组）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>只有每个成员的状态都为<code>Resolved</code>，p 的状态才为<code>Resolved</code>，所有返回值组成一个参数传递给 p 的回调函数；否则只要有一个成员被<code>rejected</code>，p 的状态为<code>Rejected</code>，第一个被<code>reject</code>的实例的返回值被传递给 p 的回调函数。</p>
<p>如果作为参数的<code>Promise</code>实例自身定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>p 的状态随第一个改变状态的成员而做相同改变，该成员返回值传递给 p 的回调函数。其他与<code>Promise.all</code>方法一致。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a><code>Promise.resolve()</code></h4><p>将现有对象转为<code>Promise</code>对象。根据参数分为四种情况：</p>
<ol>
<li><code>Promise</code>实例：不作任何修改，直接返回该实例；</li>
<li><code>thenable</code>对象（具有<code>then</code>方法的对象）：转为<code>Promise</code>对象，然后在立即调用其<code>then</code>方法的同时状态变为<code>Resolved</code>；</li>
<li>不符合以上情况的任何参数：返回状态为<code>Resolved</code>的<code>Promise</code>对象，参数传给回调函数；</li>
<li>不带有任何参数：返回状态为<code>Resolved</code>的<code>Promise</code>对象。</li>
</ol>
<p><strong>注意</strong>：当<code>Promise.resolve()</code>的<strong>参数是<code>Promise</code>实例</strong>时，<code>resolve</code>会“拆箱”获取这个 Promise 实例的状态和值，但这个过程是<strong>异步</strong>的。</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a><code>Promise.reject()</code></h4><p>返回一个新的<code>Promise</code>实例，状态为<code>Rejected</code>。方法的参数会作为<code>reject</code>的理由，变成后续方法的参数。</p>
<p><code>reject</code>不具备“拆箱”能力。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>加载图片：加载完成时<code>Promise</code>的状态发生变化。</li>
<li>Generator 函数与 Promise 的结合：使用<code>Generator</code>函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>写作：</p>
<p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">Promise 对象 - ECMAScript 6入门</a></p>
<p><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="external">八段代码彻底掌握 Promise</a></p>
<p>进阶（之后阅读）：</p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象的状态不受外界影响&lt;/strong&gt;。&lt;code&gt;Promise&lt;/code&gt;对象代表一个异步操作，有三种状态：&lt;code&gt;Pending&lt;/code&gt;（进行中）、&lt;code&gt;Resolved&lt;/code&gt;（已完成，又称 Fulfilled）和&lt;code&gt;Rejected&lt;/code&gt;（已失败）。只有异步操作的结果可以决定当前是哪一种状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一旦状态改变，就不会再变，任何时候都可以得到这个结果&lt;/strong&gt;。&lt;code&gt;Promise&lt;/code&gt;对象的状态改变只有两种可能：从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Resovled&lt;/code&gt;和从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Rejected&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了&lt;code&gt;Promise&lt;/code&gt;对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，&lt;code&gt;Promise&lt;/code&gt;对象提供统一的接口，使得控制异步操作更加容易。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法取消&lt;code&gt;Promise&lt;/code&gt;，一旦新建就会立即执行，无法中途取消。&lt;/li&gt;
&lt;li&gt;如果不设置回调函数，&lt;code&gt;Promise&lt;/code&gt;内部抛出的错误不会反映到外部。&lt;/li&gt;
&lt;li&gt;当处于&lt;code&gt;Pending&lt;/code&gt;状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="异步编程" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何给终端安上炫酷的皮神黄皮肤？</title>
    <link href="http://kyonhuang.top/pikachu-iterm/"/>
    <id>http://kyonhuang.top/pikachu-iterm/</id>
    <published>2017-06-10T09:11:32.000Z</published>
    <updated>2017-06-17T13:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-17d0934182abb9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pokemon-Terminal，已经有 1200+ star"></p>
<p>给终端安上超几把炫酷的皮神黄皮肤！<br>作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？</p>
<p>一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-bc1f7d006fb2f0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="感觉又能元气满满地查 bug 了呢"></p>
<p>如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。</p>
<a id="more"></a>
<h3 id="从零开始的项目安装"><a href="#从零开始的项目安装" class="headerlink" title="从零开始的项目安装"></a>从零开始的项目安装</h3><p>打开 <a href="https://github.com/LazoCoder/Pokemon-Terminal" target="_blank" rel="external">Pokemon-Terminal 项目的 github 主页</a>，我发现安装前有两个要求：</p>
<ol>
<li>3.5及以上版本的 python；</li>
<li>已安装 iTerm2。</li>
</ol>
<p>巧了，这两个要求我都不符合！</p>
<p>iTerm2 我从来没有接触过，根本不知道是什么。而比较久远的时候，我在试图将 OS X 系统自带的 python 2.+ 升级为 3.+ 时，跟着网上不知道靠不靠谱的教程误操作，以致 2.+ 删掉了 3.+ 却没安好，依赖于 python 的以 Xcode 为首的一系列软件全部罢工（而且过了一周左右才查出来是这个原因），最后灰溜溜地又下了一遍 2.+，从此留下了对 python 的心理阴影（但是我们这篇教程还是很靠谱的）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-cbaa6148775a471f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="吃瘪了"></p>
<p>没关系，作为（准）程序员，要勇于折腾！我们一步一步的搞起。</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p>我是先下载的 iTerm2，<a href="http://www.iterm2.com/" target="_blank" rel="external">官网</a>在此，下载即可。</p>
<p>iTerm2 是 OS X 系统下很好用的一款命令行工具，至于具体怎么好用，敬请百度了解。因为我现在只是为了皮神黄皮肤。当然之后我也会进一步学习使用。</p>
<h3 id="python-3-5"><a href="#python-3-5" class="headerlink" title="python 3.5+"></a>python 3.5+</h3><p>昨晚吃瘪后的我心有不甘，发了一条说说。然后幸得初中同学救驾：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-6bbe74dae5518c8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="向蔡老师低头"></p>
<p>这个允许用户方便地安装不同版本的 python 并可以快速切换的 anaconda 帮助我解决了问题。<a href="https://www.continuum.io/downloads/" target="_blank" rel="external">官网</a>提供了图形化安装和命令行安装两种方式，根据自己的专业程度选择下载即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-7a10e852f127c605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择 3.6 版本，安装后会自动帮你把 python 版本切换为3.6"></p>
<p>这个 anaconda 据说也是 python 开发的利器之一，不过我也不会 python。也许之后机缘巧合会深入学习（想了解可以参照这篇文章<a href="http://www.jianshu.com/p/2f3be7781451#" target="_blank" rel="external">Anaconda使用总结</a>）。说实话为了给终端换个皮肤，让我本不宽裕的存储空间又少了 1G 左右，有些心疼。但是折腾还是给了我很多乐趣，也许之后有用呢。</p>
<p>那么要求都满足了。按照项目 README 要求，在 iTerm 2 中输入以下三条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Pokemon Installation</div><div class="line">git clone https://github.com/LazoCoder/Pokemon-Terminal $HOME/.Pokemon-Terminal</div><div class="line">echo PATH=&quot;$HOME/.Pokemon-Terminal:$&#123;PATH&#125;&quot; &gt;&gt; ~/.bash_profile</div><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>安装完毕，皮神我来了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pokemon pikachu</div></pre></td></tr></table></figure>
<p>然后…出现以下报错提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.Pokemon-Terminal/./Scripts/background.scpt:39:46: script error: Expected end of line but found identifier. (-2741)</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-31f620e842cc120a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错了，就很难受"></p>
<h3 id="翻越最后一座-bug-高山"><a href="#翻越最后一座-bug-高山" class="headerlink" title="翻越最后一座 bug 高山"></a>翻越最后一座 bug 高山</h3><p>想去给作者提一个 issue，就发现作者对于这个 bug 已经给出了<a href="https://github.com/LazoCoder/Pokemon-Terminal/issues/15" target="_blank" rel="external">解决方法</a>。</p>
<p>按照解决方法，我们需要对 .Pokemon-Terminal/scripter.py 文件进行一些修改（当然，不一定每个人都碰上了这个 bug）。其实我也不太会用 vim，所以以下操作参照了这篇文章<a href="http://blog.csdn.net/bruce0532/article/details/7842384" target="_blank" rel="external">修改文件内容 vi命令</a>。</p>
<p>用以下命令在终端打开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi .Pokemon-Terminal/scripter.py</div></pre></td></tr></table></figure>
<p>然后按一下 i，从命令行模式进入插入模式。找到函数<code>__terminal_script</code>（在比较靠上的位置），将：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">content = &quot;tell application \&quot;iTerm\&quot;\n&quot;</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">content = &quot;tell application \&quot;iTerm2\&quot;\n&quot;</div></pre></td></tr></table></figure></p>
<p>按 Esc 键进入命令行模式，再按<code>:wq</code>保存退出。大功告成！</p>
<p>再在 iTerm2 中输入<code>pokemon pikachu</code>，就会发现黑漆漆（或者白晃晃）的背景变成了皮神黄！</p>
<h3 id="深度使用"><a href="#深度使用" class="headerlink" title="深度使用"></a>深度使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">    pokemon [parameter]</div><div class="line"></div><div class="line">Parameters:</div><div class="line">    [name]        -   Change the terminal background to the specified Pokemon.</div><div class="line">    [index]       -   Change the terminal background to a Pokemon by its index.</div><div class="line">    [region]      -   List all the Pokemon of the specified region.</div><div class="line">    [one letter]  -   List all Pokemon who&apos;s names begin with a particular letter.</div><div class="line">    [two letters] -   List all Pokemon who&apos;s names begin with those two letters.</div><div class="line"></div><div class="line">Other Parameters:</div><div class="line">    pokemon all             -   List all the Pokemon supported.</div><div class="line">    pokemon regions         -   List all the available regions.</div><div class="line">    pokemon extra           -   List all the Pokemon from the &apos;Extra&apos; folder.</div><div class="line">    pokemon random          -   Change the terminal background to a random Pokemon.</div><div class="line">    pokemon random-kanto    -   Change the terminal background to a random Pokemon from the specified region.</div><div class="line">    pokemon ?               -   Identify the current Pokemon in the terminal.</div><div class="line">    pokemon _pikachu        -   Change the wallpaper to the specified Pokemon.</div><div class="line">    pokemon _random         -   Change the wallpaper to a random Pokemon.</div><div class="line">    pokemon _random-kanto   -   Change the wallpaper to a random Pokemon from the specified region.</div><div class="line">    pokemon _?              -   Identify the current Pokemon in the wallpaper.</div><div class="line">    pokemon slideshow       -   Iterate through each Pokemon.</div><div class="line">    pokemon slideshow-kanto -   Iterate through each Pokemon in the specified region.</div><div class="line">    pokemon help            -   Display this menu.</div></pre></td></tr></table></figure>
<p>以上是作者提供的用法。可以通过口袋妖怪的英文名或者编号切换皮肤，或者用<code>pokemon random</code>来切换成随机的皮肤。</p>
<p>我们现在还得每次打开 iTerm 后输入命令来切换皮肤。作者同样提供了点开就换的方法，只用在 iTerm 的 Preferences 里做一点配置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e7b439a27bbb15e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可以去掉; clear以使终端界面不自己下滑来隐藏这条命令"></p>
<p>想一想，通过配置为<code>pokemon random</code>，每次打开都是不同皮肤说不定更爽到。</p>
<p>最后作者建议你改变一下透明度之类的，使皮神看起来更酷炫有范：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-f45392ab4550af00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作者的配置"></p>
<p>我的配置是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-1d60fdcb28354450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的配置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-16299e1b9b28d546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再看一次"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实一个皮肤也没有那么重要（还是有那么一点爽的啦），重要的是通过这一番折腾，接触到了很多常规学习中可能不会接触的东西，包括 iTerm 和 anaconda。这也是我第一次有目的性地去看项目的 issue。希望自己以后能多一点这样地非常规学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2702529-17d0934182abb9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Pokemon-Terminal，已经有 1200+ star&quot;&gt;&lt;/p&gt;
&lt;p&gt;给终端安上超几把炫酷的皮神黄皮肤！&lt;br&gt;作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？&lt;/p&gt;
&lt;p&gt;一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2702529-bc1f7d006fb2f0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;感觉又能元气满满地查 bug 了呢&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿喜欢折腾" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%96%9C%E6%AC%A2%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="终端" scheme="http://kyonhuang.top/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端学习之路上的暂歇思考</title>
    <link href="http://kyonhuang.top/relax-and-think/"/>
    <id>http://kyonhuang.top/relax-and-think/</id>
    <published>2017-06-05T07:22:33.000Z</published>
    <updated>2017-06-05T07:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。</p>
  <a id="more"></a>
<p>到现在为止，我的前端学习之路大概插了这些旗帜：</p>
<ol>
<li>对前端生态有了一个大致的了解，对例如 Webpack、Babel 等常用的工具有使用经验或者大概知道是干什么的。</li>
<li>在知乎和微博上关注了前端大佬，养成每天在掘金上看技术文章以及不时逛一些较为优秀的技术博客的习惯。</li>
<li>看了一些前端书籍，大多是 JavaScript 相关。</li>
<li>大致啃完了 Vue.js 的文档，正在学习 Vue-router。同时也对 i-View 等相关项目有一些了解。</li>
</ol>
<p>在之前的前端学习中也有一些问题：</p>
<ol>
<li>最大的问题是不太重视基础。看张鑫旭对前端的要求中，光是“掌握JS中的字符串、函数、对象、数组、字面量等基本概念，熟记所有内置的方法（包括参数和返回值）”这一条就足够我汗颜了。看的书籍虽然有笔记，但也感觉是没有过心。<strong>之后会将博客中的读书笔记再按照知识点，辅以自己的进一步学习成果拆分细化</strong>。虽然这是一个比较大的工程，但我觉得这是一个很有必要的工作。</li>
<li>经典书籍读的不够多。像《你不知道的 JavaScript》、《JavaScript 设计模式与开发实践》等书都没有看。</li>
<li>某些时候还是有些懒惰，没有抽出空余时间来学习。或者是在学习过程中在知乎、贴吧、空间、微博耗费了注意力，导致学习效率不高。</li>
<li>包括博文和项目在内的学习产出还是不多，博文也没有特别有价值的内容。<strong>毕业前要在 github 上有一个 100+ star 的项目，还要部署到 npm 上</strong>。博客考虑备案和 SEO，以激励自己写出更有价值的文章。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>单页面程序及组件化相关笔记</title>
    <link href="http://kyonhuang.top/SPA-learning-notes/"/>
    <id>http://kyonhuang.top/SPA-learning-notes/</id>
    <published>2017-04-29T03:12:53.000Z</published>
    <updated>2017-04-29T03:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 <a href="https://github.com/xufei/blog" target="_blank" rel="external">xufei</a> 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。</p>
<a id="more"></a>
<p>提高开发效率的两个主要途径：</p>
<ul>
<li>加快开发速度：少造轮子。</li>
<li>减少变更代价：清理模块之间的关系，合理分层。</li>
</ul>
<h2 id="单页面程序"><a href="#单页面程序" class="headerlink" title="单页面程序"></a>单页面程序</h2><p>SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。</p>
<h3 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h3><p>高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。</p>
<p>实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。</p>
<h3 id="代码合并与加载策略"><a href="#代码合并与加载策略" class="headerlink" title="代码合并与加载策略"></a>代码合并与加载策略</h3><p>典型特征：部分加载。</p>
<p>一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的<strong>异步加载机制</strong>去运行时加载。</p>
<p>因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。</p>
<h3 id="需要考虑的点"><a href="#需要考虑的点" class="headerlink" title="需要考虑的点"></a>需要考虑的点</h3><h4 id="路由与状态的管理"><a href="#路由与状态的管理" class="headerlink" title="路由与状态的管理"></a>路由与状态的管理</h4><p>界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。</p>
<h4 id="缓存与本地存储"><a href="#缓存与本地存储" class="headerlink" title="缓存与本地存储"></a>缓存与本地存储</h4><p>动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。</p>
<p>在本地存储一些临时数据可以用 localStorage。</p>
<h4 id="服务器通信"><a href="#服务器通信" class="headerlink" title="服务器通信"></a>服务器通信</h4><p>WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。</p>
<p>例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。</p>
<h3 id="困难与缺陷"><a href="#困难与缺陷" class="headerlink" title="困难与缺陷"></a>困难与缺陷</h3><p>SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。</p>
<p>缺陷：不利于 SEO；要注意内存管理。</p>
<h2 id="样式规划"><a href="#样式规划" class="headerlink" title="样式规划"></a>样式规划</h2><h3 id="基准样式的分离"><a href="#基准样式的分离" class="headerlink" title="基准样式的分离"></a>基准样式的分离</h3><p>包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。</p>
<h3 id="组件样式的划分"><a href="#组件样式的划分" class="headerlink" title="组件样式的划分"></a>组件样式的划分</h3><p>组件样式应当尽量减少相互依赖，各组件的样式允许冗余。</p>
<h3 id="堆叠次序的管理"><a href="#堆叠次序的管理" class="headerlink" title="堆叠次序的管理"></a>堆叠次序的管理</h3><p>在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。</p>
<p>职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。</p>
<ul>
<li>HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。</li>
<li>JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。</li>
<li>CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。</li>
</ul>
<h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>jQuery 轻量、灵活，但对代码缺乏约束。</p>
<p>需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。</p>
<p>因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。</p>
<p>AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。</p>
<p>React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。</p>
<p>依赖注入： </p>
<ul>
<li>核心理念：通过配置来实例化所依赖的组件。</li>
<li>缺点：性能以及跟踪调试的便利性上的损失。</li>
<li>优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。</li>
<li>应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。</li>
</ul>
<h3 id="MV-框架的基本原理"><a href="#MV-框架的基本原理" class="headerlink" title="MV*框架的基本原理"></a>MV*框架的基本原理</h3><p>充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在<strong>配置文件</strong>（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动：</p>
<ul>
<li>初始化自身（bootstrap）</li>
<li>异步加载可能尚未引入的 JavaScript 代码（require）</li>
<li>解析定义在 HTML 上的规则（template parser）</li>
<li>实例化模型（scopr）</li>
<li>创建模型和 DOM 的关联关系（binding, injection）</li>
</ul>
<p>这些是主线流程，还有一些支线，比如：</p>
<ul>
<li>解析 url 的 search 字符串，恢复状态（route）</li>
<li>加载 HTML 部件模板（template url）</li>
<li>部件模板和模型的关联（binding）</li>
</ul>
<h2 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h2><p>指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。</p>
<p>Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>博文参考资料：</p>
<p><a href="https://github.com/xufei/blog/issues/6" target="_blank" rel="external">Web应用的组件化（一）——基本思路</a></p>
<p><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a></p>
<p><a href="https://github.com/xufei/blog/issues/33" target="_blank" rel="external">关于新框架的学习</a></p>
<p>延伸阅读资料：</p>
<p><a href="https://github.com/xufei/blog/issues/7" target="_blank" rel="external">Web应用的组件化（二）——管控平台</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 &lt;a href=&quot;https://github.com/xufei/blog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xufei&lt;/a&gt; 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://kyonhuang.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="SPA" scheme="http://kyonhuang.top/tags/SPA/"/>
    
      <category term="单页面程序" scheme="http://kyonhuang.top/tags/%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="组件化" scheme="http://kyonhuang.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>最近在干以及打算干些什么</title>
    <link href="http://kyonhuang.top/recent-and-will/"/>
    <id>http://kyonhuang.top/recent-and-will/</id>
    <published>2017-04-26T10:22:33.000Z</published>
    <updated>2017-06-23T13:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。</p>
<p><img src="/images/QinSir.jpg"></p>
<p>在干什么：</p>
<ul>
<li>写花旗杯项目前端第一版。</li>
<li>开始看 Vue.js 的文档。</li>
<li>看一些关于前端工程化的博文。</li>
</ul>
<p>打算干什么：</p>
<ul>
<li>继续看完 Vue.js 的文档并且找一个 Demo 做一做。</li>
<li>尽早看完 ES 6 新特性。</li>
<li>看一看 Grid。</li>
</ul>
<p>最近看的优秀文章：</p>
<ul>
<li><a href="http://www.alloyteam.com/2017/03/getting-started-with-css-modules-and-react-in-practice/" target="_blank" rel="external">CSS Modules 入门及 React 中实践</a></li>
<li><a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="external">玩转 npm</a>：介绍了常用的 npm 命令。</li>
<li><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a>：理解单页 Web 应用。我想这篇文章我还会再看至少两遍。</li>
<li><a href="https://github.com/lin-xin/blog/issues/11" target="_blank" rel="external">HTML5 高级系列：web Storage</a>：了解如何通过 localStorage 和 sessionStorage 存储一些数据。</li>
<li><a href="https://juejin.im/entry/56e1a95b731956005da35c24?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github" target="_blank" rel="external">[译] 人人须知的 jQuery 技巧</a>：介绍了一些 jQuery 代码片段，包括预加载图片、禁用输入字段、简单的手风琴效果等。建议自己整理一份类似的代码片段库。</li>
<li><a href="https://aotu.io/notes/2016/11/22/figlet/" target="_blank" rel="external">FIGlet初识</a>：了解一下 FIGlet，不实用，但还有点意思。</li>
<li><a href="http://www.w3cplus.com/css3/autoprefixer-css-vender-prefixes.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">如何处理CSS3属性前缀</a>：介绍了 Autoprefixer，用于处理 CSS 3 属性前缀的问题。</li>
<li><a href="https://huangxuan.me/js-module-7day/#/2" target="_blank" rel="external">JavaScript Modularization Journey</a>：JS 模块化发展史。还得再看几遍…等我到了该接触 Webpack 的时候。</li>
</ul>
<p>看到的好玩意：</p>
<ul>
<li><strong><a href="https://www.awesomes.cn/" target="_blank" rel="external">Awesomes - Web前端开发资源库</a></strong>：全是前端的开源项目，遍地的轮子啊。关键是文档很多都翻译成中文了。</li>
<li><a href="https://www.npmjs.com/package/pkg" target="_blank" rel="external">pkg</a>：帮助你将你的 Node.js 程序打包成即使在没有 node 环境的设备上也能运行。</li>
<li><a href="https://www.awesomes.cn/repo/mzabriskie/axios" target="_blank" rel="external">Axios</a>：基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用。这个貌似很常用，看看能不能用在现在的项目中。</li>
<li><a href="https://www.awesomes.cn/css/123" target="_blank" rel="external">一个有趣的 CSS 按钮效果</a></li>
<li><a href="https://www.awesomes.cn/repo/IanLunn/hover" target="_blank" rel="external">Hover.css</a>：Hover.css 是一个 CSS3 的鼠标悬停效果集合，可用于超链接，按钮，logo，SVG，推荐图片等等。能够很简单地运用到我们的元素中。</li>
</ul>
<p>之后想做的练习（时间好少QAQ）：</p>
<ul>
<li><a href="http://www.cnblogs.com/coco1s/p/6802374.html" target="_blank" rel="external">谈谈一些有趣的CSS题目</a></li>
<li><a href="http://www.fgm.cc/learn/" target="_blank" rel="external">原生JavaScript学习-实例索引</a></li>
<li><a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/QinSir.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在干什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写花旗杯项目前端第一版。&lt;/li&gt;
&lt;li&gt;开始看 V
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(二)</title>
    <link href="http://kyonhuang.top/es6-2-notes/"/>
    <id>http://kyonhuang.top/es6-2-notes/</id>
    <published>2017-04-24T10:36:13.000Z</published>
    <updated>2017-04-28T07:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">ECMAScript 6 入门</a>》。希望能早日啃完，想去看 Vue.js 了…</p>
<p>此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。</p>
  <a id="more"></a>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>1.ES 6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>)</span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(<span class="string">'Hello'</span>)  <span class="comment">// Hello World</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">'Kyon'</span>)  <span class="comment">// Hello Kyon</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>)  <span class="comment">// Hello</span></div><div class="line"></div><div class="line"><span class="comment">// 与解构赋值默认值结合使用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)  <span class="comment">// 1, 5</span></div><div class="line">foo()  <span class="comment">// TypeeError: Cannot read property 'x' of undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数没有参数的情况</span></div><div class="line">m1() <span class="comment">// [0, 0]</span></div><div class="line">m2() <span class="comment">// [0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// x有值，y无值的情况</span></div><div class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></div><div class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></div><div class="line"></div><div class="line"><span class="comment">// x和y都无值的情况</span></div><div class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></div><div class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></div></pre></td></tr></table></figure>
<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明；使用参数默认值时，函数不能有同名参数。</p>
<p>定义了默认值的参数通常应该为函数的尾参数。</p>
<p>2.函数的<code>length</code>属性：将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，后面的参数也不会被计入。</p>
<p>3.作用域：一旦<strong>设置了参数的默认值</strong>，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，作用域消失。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数foo内部声明的内部变量与参数不是同一个作用域</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123; x = <span class="number">2</span>; &#125;)&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">    y();</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 3</span></div><div class="line">x  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123; x = <span class="number">2</span>; &#125;)&#123;</div><div class="line">    x = <span class="number">3</span>;</div><div class="line">    y();</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 2</span></div><div class="line">x  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>4.函数参数默认值的应用：可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeprovided = throwIfMissing(</span>))</span>&#123;</div><div class="line">    <span class="keyword">return</span> mustBeProvided;</div><div class="line">&#125;</div><div class="line"><span class="comment">// throwIfMissing函数名之后有一对圆括号</span></div><div class="line"><span class="comment">// 表明参数的默认值不是在定义时执行，而是在运行时执行</span></div><div class="line"><span class="comment">// 即如果参数已经赋值，默认值中的函数就不会运行</span></div><div class="line"></div><div class="line">foo()  <span class="comment">// Error: Missing parameter</span></div></pre></td></tr></table></figure>
<p>可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<p>5.rest 参数：形式为”…变量名”，用于获取函数的多余参数。rest 参数中的变量代表一个数组。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</div></pre></td></tr></table></figure>
<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,...b</span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h3 id="函数参数的默认值-1"><a href="#函数参数的默认值-1" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>6.扩展运算符：<code>...</code>，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">35</span>];</div><div class="line">add(...numbers) <span class="comment">// 39</span></div><div class="line"></div><div class="line"><span class="comment">// 不再需要 apply 方法将数组转为函数参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>)</span>&#123;&#125;</div><div class="line">f(...args);</div></pre></td></tr></table></figure>
<p>7.扩展运算符的应用：</p>
<ul>
<li><p>合并数组：提供了新写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];</div><div class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line"></div><div class="line">arr1.concat(arr2, arr3);  <span class="comment">// ES 5</span></div><div class="line">[...arr1, ...arr2, ...arr3]  <span class="comment">// ES 6</span></div></pre></td></tr></table></figure>
</li>
<li><p>与解构赋值结合：用于生成数组（只能放在参数最后一位）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">first <span class="comment">// 1</span></div><div class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> [first, ...rest] = [];</div><div class="line">first <span class="comment">// undefined</span></div><div class="line">rest  <span class="comment">// []:</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];</div><div class="line">first  <span class="comment">// "foo"</span></div><div class="line">rest   <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>函数的返回值：为函数提供一种返回多个值的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从数据库取出一行数据，通过扩展运算符，直接传入构造函数Date</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> dateFields = readDateFields(database);</div><div class="line"><span class="keyword">var</span> d = newDate(...dateFields);</div></pre></td></tr></table></figure>
</li>
<li><p>字符串：扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</div><div class="line"></div><div class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></div><div class="line"></div><div class="line">[...str].reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现了 Iterator 接口的对象：可以通过扩展运算符转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"><span class="keyword">var</span> array = [...nodeList];</div></pre></td></tr></table></figure>
</li>
<li><p>Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符。Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Map结构</span></div><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</div><div class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</div><div class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// Generator 函数</span></div><div class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[...go()] <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>8.函数内部严格模式：ES 5 时函数内部可以设定为严格模式；ES 6 规定只要函数参数使用了<strong>默认值、解构赋值或者扩展运算符</strong>，则函数内部不能显式设定为严格模式，否则报错。</p>
<p>原因：只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>
<p>两种规避方法：全局性严格模式，将函数包在一个无参数的立即执行函数里。</p>
<p>9.name 属性：返回该函数的函数名。</p>
<p>如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ES 5、ES 6</span></div><div class="line">bar.name <span class="comment">// "baz"</span></div></pre></td></tr></table></figure>
<p><code>Function</code>构造函数返回的函数实例，name 属性的值为 <code>anonymous</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></div></pre></td></tr></table></figure>
<p><code>bind</code>返回的函数，name属性值会加上<code>bound</code>前缀。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></div></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>10.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 箭头函数与变量解构结合使用</span></div><div class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 简化回调函数</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>11.箭头函数使用注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象就是<strong>定义时所在对象</strong>，而不是使用时所在对象。</li>
<li>不可当作构造函数（即不可使用<code>new</code>命令），否则抛出错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
<p><code>this</code>指向的固定化，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。也正因如此，箭头函数不能用作构造函数，也不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>
<p>除了<code>this</code>，<code>arguments</code>、<code>super</code>、<code>new.target</code>在箭头函数中也是不存在的，指向外层函数的对应变量。</p>
<p>12.嵌套的箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES 5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span>(<span class="params">afterValue</span>) </span>&#123;</div><div class="line">      array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</div><div class="line">      <span class="keyword">return</span> array;</div><div class="line">    &#125;&#125;;</div><div class="line">  &#125;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// ES 6</span></div><div class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</div><div class="line">  array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;&#125;)&#125;);</div><div class="line"></div><div class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>13.函数绑定运算符：<code>::</code>，左边为对象，右边为函数。该运算符自动将左边的对象作为上下文环境（即 this 对象），绑定到右边的函数上。用来取代<code>call</code>、<code>apply</code>、<code>bind</code>调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.apply(foo, <span class="built_in">arguments</span>);</div></pre></td></tr></table></figure>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> method = obj::obj.foo;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> method = ::obj.foo;</div><div class="line"></div><div class="line"><span class="keyword">var</span> log = ::<span class="built_in">console</span>.log;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</div></pre></td></tr></table></figure>
<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; find, html &#125; = jake;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">"div.myClass"</span>)</div><div class="line">::find(<span class="string">"p"</span>)</div><div class="line">::html(<span class="string">"hahaha"</span>);</div></pre></td></tr></table></figure>
<p>该语法为已被 Babel 转码器支持的一个 ES 7 提案。</p>
<p>14.尾调用：某个函数的最后一步是调用另一个函数。</p>
<p>To be continued…</p>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>1.属性的简洁表示法：ES 6 允许直接写入变量和函数，作为对象的属性和方法。这时，属性名为变量名，属性值为变量值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line">baz  <span class="comment">// &#123;foo: "bar"&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  method()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  * m()&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>2.属性名表达式：ES 6 允许字面量定义对象时，把表达式放在方括号内。表达式也可用于定义方法名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [propKey]: <span class="literal">true</span>,</div><div class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 表达式用于定义方法名</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.hello()  <span class="comment">// hi</span></div></pre></td></tr></table></figure>
<p>但<strong>属性名</strong>表达式与简洁表达式不能同时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> bar = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123; [foo] &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</div></pre></td></tr></table></figure>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>（即不要这么用）。</p>
<p>3.方法的 name 属性：返回函数名。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<p>4.<code>Object.is()</code>：比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致（不同之处为<code>+0</code>不等于<code>-0</code>，以及<code>NaN</code>等于自身）。</p>
<p>5.<code>Object.assign()</code>：用于对象的合并，将源对象的所有可枚举属性复制到目标对象。第一个参数是目标对象，其他参数是源对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target  <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div></pre></td></tr></table></figure>
<p>如果多个对象有同名属性，后面的属性会覆盖前面的。</p>
<p>如果只有一个参数将直接返回（参数不是对象会先转成对象）。无法转成对象的源对象将被跳过。<code>undefined</code>和<code>null</code>无法转成对象，所以不能作为目标对象（否则报错）。其他相关注意事项见文档。</p>
<p>实行浅拷贝，即源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。对于嵌套对象，一旦遇到同名属性会被替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span>&#125; &#125;;</div><div class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source);  <span class="comment">// &#123;a: &#123; b: 'hello' &#125;&#125;</span></div></pre></td></tr></table></figure>
<p><code>Object.assign()</code>有很多用处，其中包括为对象添加属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加属性</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</div><div class="line">  someMethod(arg1, arg2)&#123; ... &#125;,</div><div class="line">  anotherMethod()&#123; ... &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; ... &#125;;</div><div class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;;</div></pre></td></tr></table></figure>
<h3 id="属性的可枚举性与遍历"><a href="#属性的可枚举性与遍历" class="headerlink" title="属性的可枚举性与遍历"></a>属性的可枚举性与遍历</h3><p>6.<code>Object.getOwnPropertyDescriptor</code>：对象的每个属性都有一个描述对象，用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获得该属性的描述对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   value: 123,</span></div><div class="line"><span class="comment">//   writable: true,</span></div><div class="line"><span class="comment">//   enumerable: true,</span></div><div class="line"><span class="comment">//   configurable: true</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>ES 7 引入<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</div><div class="line">  get bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   foo: &#123;</span></div><div class="line"><span class="comment">//     value: 123,</span></div><div class="line"><span class="comment">//     writable: true,</span></div><div class="line"><span class="comment">//     enumerable: true,</span></div><div class="line"><span class="comment">//     configurable: true</span></div><div class="line"><span class="comment">//   &#125;,</span></div><div class="line"><span class="comment">//   bar: &#123;</span></div><div class="line"><span class="comment">//     get: [Function: bar],</span></div><div class="line"><span class="comment">//     set: undefined,</span></div><div class="line"><span class="comment">//     enumerable: true,</span></div><div class="line"><span class="comment">//     configurable: true</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>7.属性的可枚举性：描述对象的<code>enumerable</code>属性，成为“可枚举性”。ES 5 有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性：</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和<strong>继承的</strong>可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
</ul>
<p>ES 6 新增<code>Object.assign()</code>，会忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</p>
<p><strong>当只关心对象自身的属性时，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</strong></p>
<p>8.<code>Object.keys()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键名</strong>。ES 2017 引入配套的<code>Object.values</code>和<code>Object.entries</code>作为遍历一个对象的补充手段。</p>
<p><code>Object.values()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值</strong>（不含 Symbol 属性）。参数为字符串时返回各个字符组成的一个数组，参数为数值或布尔值时返回空数组（与包装对象有关）。</p>
<p><code>Object.entries()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值对数组</strong>（不含 Symbol 属性）。</p>
<p>9.属性的遍历：ES 6 共有5种遍历对象的方法。</p>
<ol>
<li><code>for...in</code>：循环遍历对象<strong>自身的</strong>和<strong>继承的</strong>可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但<strong>包括不可枚举属性</strong>）。</li>
<li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的<strong>所有 Symbol 属性</strong>。</li>
<li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有属性（无论是否可枚举或者属性名是 Symbol 还是字符串）。</li>
</ol>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则（之前一些遍历的方法也遵循此规则）。</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<h3 id="proto-属性及相关方法"><a href="#proto-属性及相关方法" class="headerlink" title="__proto__属性及相关方法"></a><code>__proto__</code>属性及相关方法</h3><p>10.<code>__proto__</code>属性：用于读取或设置当前对象的<code>prototype</code>对象。内部属性，不是正式对外 API。建议使用<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototype()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>如果一个对象本身部署了<code>__proto__</code>属性，则该属性的值就是对象的原型。</p>
<p>11.<code>Object.setPrototypeOf()</code>：作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</div><div class="line"></div><div class="line"><span class="comment">// 用法</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>如果第一个参数不是对象，会自动转为对象（由于返回的还是第一个参数，故无效果）；是<code>undefined</code>或<code>null</code>则报错（无法转为对象）。</p>
<p>12.<code>Object.getPrototypeOf()</code>：用于读取一个对象的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</div></pre></td></tr></table></figure>
<p>如果参数不是对象，会被自动转为对象；是<code>undefined</code>或<code>null</code>则报错。</p>
<p>13.对象的扩展运算符：ES 2017 将<code>...</code>引入对象。主要用途有：</p>
<ul>
<li>解构赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;x, y, ...z&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line">x  <span class="comment">// 1</span></div><div class="line">y  <span class="comment">// 2</span></div><div class="line">z  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>
<p>注意解构赋值的拷贝是浅拷贝，且不会拷贝继承自原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 扩展某个函数的参数，引入其他操作</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// 使用x和y参数进行操作</span></div><div class="line">  <span class="comment">// 其余参数传给原始函数</span></div><div class="line">  <span class="keyword">return</span> baseFunction(restConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>扩展运算符：取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于<code>Object.assign</code>方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</div><div class="line">n  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> n = <span class="built_in">Object</span>.assign(&#123;&#125;, z);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 用于合并两个对象</span></div><div class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</div></pre></td></tr></table></figure>
<p>如果用户自定义的属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。因此可用于修改现有对象部分的部分属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newVersion = &#123;</div><div class="line">  ...previousVersion,</div><div class="line">  <span class="attr">name</span>: <span class="string">'New Name'</span>  <span class="comment">// Override the name property</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</div></pre></td></tr></table></figure>
<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<p>14.Null 传导运算符：<code>?.</code>，用于判断对象及其内部属性是否存在。仅为提案，详见文档。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>1.概述：ES 6 引入的新的原始数据类型，表示独一无二的值。至此，JS 共有七种数据类型：</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>布尔值（Boolean）</li>
<li>字符串（String）</li>
<li>数值（Number）</li>
<li>对象（Object）</li>
<li>Symbol</li>
</ul>
<p>Symbol 值通过<code>Symbol</code>函数生成。即对象的属性名有两种类型：原来就有的字符串，和新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就是独一无二的，不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> s</div><div class="line"><span class="comment">// "symbol"</span></div></pre></td></tr></table></figure>
<p>生成的 Symbol 是一个原始类型的值，不是对象。因此<code>Symbol</code>函数前不能使用<code>new</code>命令（否则报错），Symbol 值也不能添加属性。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。但相同参数的<code>Symbol</code>函数的返回值是<strong>不相等</strong>的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</div><div class="line"></div><div class="line">s1  <span class="comment">// Symbol(foo)</span></div><div class="line">s2  <span class="comment">// Symbol(bar)</span></div><div class="line"></div><div class="line">s1.toString()  <span class="comment">// "Symbol(foo)"</span></div><div class="line">s2.toString()  <span class="comment">// "Symbol(bar)"</span></div></pre></td></tr></table></figure>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后生成一个 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  toString()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'kyon'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</div><div class="line">sym  <span class="comment">// Symbol(abc)</span></div></pre></td></tr></table></figure>
<p>Symbol 值不能与其他类型的值进行运算（会报错），但可以显式转为字符串和布尔值。</p>
<p>2.作为属性名的Symbol：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="comment">// 第一种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 第二种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  [mySymbol]: <span class="string">'Hello!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 第三种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello'</span>! &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 以上写法都得到同样结果</span></div><div class="line">a[mySymbol]  <span class="comment">// "Hello!"</span></div></pre></td></tr></table></figure>
<p>Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"></div><div class="line">a.mySymbol = <span class="string">'Hello!'</span>;</div><div class="line">a[mySymbol]  <span class="comment">// undefined</span></div><div class="line">a[<span class="string">'mySymbol'</span>]  <span class="comment">// "Hello!"</span></div></pre></td></tr></table></figure>
<p>Symbol 值作为属性名时，该属性是<strong>公开属性</strong>而非私有属性。</p>
<p>3.魔术字符串：在代码中多次出现、与代码形成强耦合的某一个具体的字符串或数值。应尽量消除而改用含义清晰的变量代替。</p>
<p><code>Symbol</code>可用于消除魔术字符串。</p>
<p>4.属性名的遍历：Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。这个特性可被用于为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<p><code>Reflect.ownKeys(obj)</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</div><div class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</div><div class="line"><span class="comment">// ["enum", "nonEnum", Symbol(my_key)]</span></div></pre></td></tr></table></figure>
<p>5.<code>Symbol.for()</code>、<code>Symbol.keyFor()</code>：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2;  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的<code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>Symbol.keyFor</code>方法返回一个<strong>已登记</strong>的 Symbol 类型值的<code>key</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s1);  <span class="comment">// "foo"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>)</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s2);  <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>6.Singleton 模式：指调用一个类，任何时候返回的都是同一个实例。</p>
<p>Node 中，模块文件可以看作一个类。可以使用 Symbol，通过把实例放到顶层对象<code>global</code>来实现 Singleton 模式。</p>
<h3 id="内置的-Symbol-值-暂且略过"><a href="#内置的-Symbol-值-暂且略过" class="headerlink" title="内置的 Symbol 值(暂且略过)"></a>内置的 Symbol 值(暂且略过)</h3><p>7.<code>Symbol.hasInstance</code>属性：指向一个内部方法。</p>
<p>8.<code>Symbol.isConcatSpreadable</code>属性：</p>
<p>9.<code>Symbol.species</code></p>
<p>10.<code>Symbol.match</code></p>
<p>11.<code>Symbol.replace</code></p>
<p>12.<code>Symbol.search</code></p>
<p>13.<code>Symbol.split</code></p>
<p>14.<code>Symbol.iterator</code></p>
<p>15.<code>Symbol.toPrimitive</code></p>
<p>16.<code>Symbol.toStringTag</code></p>
<p>17.<code>Symbol.unscopables</code></p>
<h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>1.基本用法：Set 结构不会添加重复的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 3 5 4</span></div></pre></td></tr></table></figure>
<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。因此有一种去除数组重复成员的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...new <span class="built_in">Set</span>(array)]</div></pre></td></tr></table></figure>
<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，类似精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身（<code>===</code>认为<code>NaN</code>不等于自身）。另外，两个对象总是不相等的。</p>
<p>2.Set 实例的属性和方法：</p>
<p>实例属性：</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>操作方法：</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个表示删除是否成功的布尔值。</li>
<li><code>has(value)</code>：返回一个布尔值。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>遍历方法（Set 结构中，键名和键值是同一个值）：</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>3.含义：与 Set 类似，但成员只能是对象，且都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>ES 6 规定，WeakSet 不可遍历。</p>
<p>4.语法：有<code>add</code>、<code>delete</code>、<code>has</code>方法；没有<code>size</code>属性。</p>
<p>5.用处：是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>6.含义和基本用法：为了解决 Object 的只能用字符串当作键名的问题，ES 6 提供了 Map 数据结构。各种类型的值（包括对象）都可以当作键。</p>
<p>有<code>set(key, value)</code>、<code>get(key)</code>、<code>has(key)</code>、<code>delete(key)</code>、<code>clear()</code>方法。</p>
<p>作为构造函数，Map 可以接受一个数组作为参数，该数组的成员是一个个<strong>表示键值对的数组</strong>。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值；如果读取一个未知的键，则返回<code>undefined</code>。</p>
<p>7.与其他数据结构的互相转换：</p>
<ul>
<li>Map 转为数组：使用扩展运算符（<code>...</code>）。</li>
<li>数组转为 Map：使用 Map 构造函数。</li>
<li>Map 转为对象：如果所有 Map 的键都是字符串，可以转为对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap)&#123;</div><div class="line">    obj[k] = v;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);</div><div class="line">strMapToObj(myMap);</div><div class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>对象转为 Map：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;</div><div class="line">    strMap.set(k, obj[k]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> strMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Map 转为 JSON：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况一：Map 的键名都是字符串</span></div><div class="line"><span class="comment">// 可以转换为对象 JSON</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况二：Map 的键名有非字符串</span></div><div class="line"><span class="comment">// 可以转换为数组 JSON</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJSON</span>(<span class="params">map</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>JSON 转为 Map：逆操作。</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>8.含义：与 Map 类似，用于生成键值对。但只接受对象作为键名（<code>null</code>除外），且键名所指向的对象不计入垃圾回收机制。</p>
<p>专用场合：它的键所对应的对象可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>9.语法：没有遍历操作，无法清空。只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<p>10.用处：DOM 节点作为键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个例子</span></div><div class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</div><div class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</div><div class="line"></div><div class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</div><div class="line">  logoData.timesClicked++;</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险</span></div></pre></td></tr></table></figure>
<p>注册监听事件的<code>listener</code>对象，就很适合用 WeakMap 实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> listener = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line">listener.set(element1, handler1);</div><div class="line">listener.set(element2, handler2);</div><div class="line"></div><div class="line">element1.addEventListener(<span class="string">'click'</span>, listener.get(element1), <span class="literal">false</span>);</div><div class="line">element2.addEventListener(<span class="string">'click'</span>, listener.get(element2), <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一旦DOM对象消失，跟它绑定的监听函数也会自动消失</span></div></pre></td></tr></table></figure>
<p>WeakMap 的另一个用处是部署私有属性。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>暂时跳过。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>暂时跳过。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;》。希望能早日啃完，想去看 Vue.js 了…&lt;/p&gt;
&lt;p&gt;此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《精通jQuery》读书笔记</title>
    <link href="http://kyonhuang.top/jQuery-master-notes/"/>
    <id>http://kyonhuang.top/jQuery-master-notes/</id>
    <published>2017-04-21T06:50:27.000Z</published>
    <updated>2017-04-28T07:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。</p>
<p>感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。</p>
  <a id="more"></a>
<h2 id="了解-jQuery"><a href="#了解-jQuery" class="headerlink" title="了解 jQuery"></a>了解 jQuery</h2><h3 id="jQuery-核心库的工作"><a href="#jQuery-核心库的工作" class="headerlink" title="jQuery 核心库的工作"></a>jQuery 核心库的工作</h3><p>通过处理浏览器加载 HTML 时动态创建的 DOM（文档对象模型），达到动态修改页面内容的目标。</p>
<h2 id="HTML-入门"><a href="#HTML-入门" class="headerlink" title="HTML 入门"></a>HTML 入门</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>一个事件在它的生命周期中要经历 3 个阶段：<strong>捕获</strong>、处理<strong>目标元素</strong>和<strong>冒泡</strong>。</p>
<p>目标元素：触发事件的元素。</p>
<h2 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h2><h3 id="反选择器"><a href="#反选择器" class="headerlink" title="反选择器"></a>反选择器</h3><p><code>:not(&lt;selector&gt;)</code>：选取不匹配指定选择器的元素。</p>
<h3 id="样式层叠"><a href="#样式层叠" class="headerlink" title="样式层叠"></a>样式层叠</h3><p>浏览器查找样式元素值的顺序：</p>
<ol>
<li>行内样式（定义在元素 style 属性中的样式）；</li>
<li>内嵌样式（定义在 style 元素中的样式）；</li>
<li>外部样式（使用 link 元素导入的样式）；</li>
<li>用户样式（用户自己定义的样式）；</li>
<li>浏览器样式（浏览器提供的默认样式）。</li>
</ol>
<p>前三个又合称为作者样式。</p>
<h4 id="important-规则"><a href="#important-规则" class="headerlink" title="important 规则"></a>important 规则</h4><p>在样式声明的末尾追加<code>!important</code>可以把改值标识为<strong>重要样式</strong>。浏览器会给重要样式以优先权，而不再考虑这个样式的定义位置。</p>
<p>唯一能优先于作者样式中重要样式的样式是定义在用户样式表中的重要样式。对于普通样式来说，作者样式优先于用户样式。但对于重要样式，浏览器的做法恰恰相反。</p>
<h4 id="“专一程度”"><a href="#“专一程度”" class="headerlink" title="“专一程度”"></a>“专一程度”</h4><p>浏览器根据以下 3 个特征计算样式的“专一程度”：</p>
<ol>
<li>选择器中出现的 id 值个数；</li>
<li>选择器中出现的其他属性和伪类个数；</li>
<li>选择器中出现的元素名字和伪元素名字个数。</li>
</ol>
<p>以 a-b-c 这种形式评估样式规则的“专一”程度，逐位比较，每一位上数字越大表示越专一。例如，1-0-0 比 0-5-5 更专一。</p>
<p>如果有多条样式规则的专一程度相同，那么浏览器会选择最后定义的那条规则。专一程度规则仅在同一层叠级别有效。</p>
<h3 id="样式单位"><a href="#样式单位" class="headerlink" title="样式单位"></a>样式单位</h3><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><ul>
<li>em：相对于元素字号的高度；</li>
<li>ex：相对于元素字体中小写字母 x 的高度；</li>
<li>rem：相对于根元素的高度；</li>
<li>px：CSS 像素（假定位于一个 96dpi 的显示设备上，实际上是绝对单位，不会改变大小）；</li>
<li>%：另一属性值的百分比。</li>
</ul>
<h2 id="jQuery-基础"><a href="#jQuery-基础" class="headerlink" title="jQuery 基础"></a>jQuery 基础</h2><h3 id="使用-CDN-版的-jQuery"><a href="#使用-CDN-版的-jQuery" class="headerlink" title="使用 CDN 版的 jQuery"></a>使用 CDN 版的 jQuery</h3><p>CDN（Content Delivery Network）：内容分发网络。当用户请求其数据时，CDN 能智能地分配离用户最近的服务器提供服务。</p>
<p>使用 CDN 的两个优点：(1)用户体验更好（速度通常更快）；(2)节省了传输 jQuery 库所需带宽。</p>
<p>CDN 不适合内联网应用程序。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="$ 函数"></a>$ 函数</h3><p><code>jQuery.noConflict</code>方法让 jQuery 放弃使用 $ 符号。也可将该方法的返回值赋给一个变量以自定义 jQuery 简写符号。</p>
<h3 id="延迟-ready-事件的触发时间"><a href="#延迟-ready-事件的触发时间" class="headerlink" title="延迟 ready 事件的触发时间"></a>延迟 ready 事件的触发时间</h3><p><code>$.holdReady(true)</code>必须在 ready 事件触发之前调用，<code>$.holdReady(false)</code>告诉 jQuery 触发 ready 事件。可以多次调用，但在 ready 事件被真正触发之前，使用 true 参数调用次数要等于使用 false 参数调用次数。 </p>
<h3 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h3><p><img src="/images/jQueryMaster/jquery-selector1.jpg"></p>
<p><img src="/images/jQueryMaster/jquery-selector2.jpg"></p>
<h4 id="使用上下文限制搜索范围"><a href="#使用上下文限制搜索范围" class="headerlink" title="使用上下文限制搜索范围"></a>使用上下文限制搜索范围</h4><p>多给 $ 函数提供一个参数以限制搜索的范围。如果提供的上下文选择器匹配多个元素，将会把匹配上下文选择器的元素收集在一起，然后再匹配主选择器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"img:odd"</span>, $(<span class="string">".drow"</span>))</div><div class="line"><span class="comment">// img:odd选择器会应用在.drow选择器的结果上</span></div></pre></td></tr></table></figure>
<h4 id="确定选择结果"><a href="#确定选择结果" class="headerlink" title="确定选择结果"></a>确定选择结果</h4><p><img src="/images/jQueryMaster/jquery-selector3.jpg"></p>
<h2 id="数据模版"><a href="#数据模版" class="headerlink" title="数据模版"></a>数据模版</h2><p>介绍了模板库 Handlebars。</p>
<h3 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h3><p>数据模板库的核心是<strong>数据模板</strong>——包含着占位符的 HTML 元素。</p>
<p>p268</p>
<h2 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h2><p>介绍了 jQuery 插件 Validation，它专门处理表单验证问题。</p>
<p><a href="http://code.ciaoca.com/jquery/validation-engine/" target="_blank" rel="external">jQuery Validation Engine 表单验证</a></p>
<p>p297</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>p331</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。&lt;/p&gt;
&lt;p&gt;感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="jQuery" scheme="http://kyonhuang.top/tags/jQuery/"/>
    
      <category term="《精通jQuery》" scheme="http://kyonhuang.top/tags/%E3%80%8A%E7%B2%BE%E9%80%9AjQuery%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(一)</title>
    <link href="http://kyonhuang.top/es6-1-notes/"/>
    <id>http://kyonhuang.top/es6-1-notes/</id>
    <published>2017-04-06T08:21:52.000Z</published>
    <updated>2017-05-12T02:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">ECMAScript 6 入门</a>。将知识点简便地总结一下，以供后续使用时参考或复习。</p>
<p>此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。</p>
  <a id="more"></a>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><p>1.<code>let</code>：<code>let</code>声明的变量仅在块级作用域内有效。不存在变量提升；存在暂时性死区，只能在声明的位置后面获取和使用；相同作用域内不可重复声明。</p>
<p>2.块级作用域：外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。</p>
<p>3.根据ES 6附录B的规定，在浏览器的ES 6环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。应避免在块级作用域内声明函数，或用函数表达式代替函数声明语句。</p>
<p>4.do 表达式：在块级作用域之前加上<code>do</code>，使其变为表达式（可以返回值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量x得到整个块级作用域的返回值</span></div><div class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> t = f();</div><div class="line">    t * t + <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>5.<code>const</code>：声明一个只读常量。一旦声明，就必须立即初始化。和<code>let</code>一样，只在声明所在的块级作用域内有效；声明的常量不提升；存在暂时性死区；不可重复声明。</p>
<p><code>const</code>保证变量指向的内存地址不可改动。因此将对象声明为常量时，不可变的只是地址，对象本身可变，可以为其添加新属性。</p>
<p>如果真想将对象冻结，应用<code>Object.freeze()</code>方法（对象本身和 其属性都应冻结）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">Object</span>.freeze(obj);</div><div class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            constantize(obj[key]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>6.顶层对象的属性：<code>let</code>、<code>const</code>、<code>class</code>声明的全局变量不属于顶层对象的属性。</p>
<p>补充资料：<a href="https://blog.fundebug.com/2017/05/04/why-you-should-not-use-var/" target="_blank" rel="external">ES6之”let”能替代”var”吗?</a></p>
<h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>1.解构：按照一定模式，从数组和对象中提取值，对变量进行赋值。解构不成功，变量的值就等于<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line">third <span class="comment">// "baz"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</div><div class="line">foo <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>2.不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<p>3.解构赋值允许指定默认值。ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值不会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></div></pre></td></tr></table></figure>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的（用到时才会求值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x能取到值，所以函数f根本不会执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>4.要将一个已经声明的变量用于解构赋值时，将大括号写在行首会导致JavaScript引擎将其解释为代码块，从而发生语法错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"><span class="comment">// 错误写法</span></div><div class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;  <span class="comment">// SyntaxError: syntax error</span></div><div class="line"><span class="comment">// 正确写法</span></div><div class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h3><p>5.对象的解构：属性没有次序，变量取值由名称决定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; bar, foo&#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo  <span class="comment">// "aaa"</span></div><div class="line">bar  <span class="comment">// "bbb"</span></div></pre></td></tr></table></figure>
<p>如果变量名与属性名不一致，须写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz&#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</div><div class="line">baz  <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</div><div class="line">f  <span class="comment">// 'hello'</span></div><div class="line">l  <span class="comment">// 'world'</span></div></pre></td></tr></table></figure>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p>6.解构也可用于嵌套结构的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">p</span>: [</div><div class="line">        <span class="string">'Hello'</span>,</div><div class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;]&#125; = obj;</div><div class="line">x  <span class="comment">// "Hello"</span></div><div class="line">y  <span class="comment">// "World"</span></div><div class="line"><span class="comment">// 这时p是模式，不是变量，因此不会被赋值。</span></div><div class="line">p  <span class="comment">// error: p is undefined</span></div></pre></td></tr></table></figure>
<h3 id="字符串的结构赋值"><a href="#字符串的结构赋值" class="headerlink" title="字符串的结构赋值"></a>字符串的结构赋值</h3><p>7.此时字符串被转化成一个类似数组的对象，且具有<code>length</code>属性（可以针对此属性解构赋值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a  <span class="comment">// "h"</span></div><div class="line">e  <span class="comment">// "o"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len  <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h3 id="数值、布尔值的结构赋值"><a href="#数值、布尔值的结构赋值" class="headerlink" title="数值、布尔值的结构赋值"></a>数值、布尔值的结构赋值</h3><p>8.解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。<code>undefined</code>和<code>null</code>无法转为对象，所以对它们解构赋值都会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure>
<h3 id="函数参数的结构赋值"><a href="#函数参数的结构赋值" class="headerlink" title="函数参数的结构赋值"></a>函数参数的结构赋值</h3><p>9.为函数<code>move</code>的参数指定默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, 0]</span></div><div class="line">move(&#123;&#125;);  <span class="comment">// [0, 0]</span></div><div class="line">move();  <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure>
<p>为变量<code>x</code>和<code>y</code>指定默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y:<span class="number">0</span>&#125;</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, undefined]</span></div><div class="line">move(&#123;&#125;);  <span class="comment">// [undefined, undefined]</span></div><div class="line">move();  <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure>
<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>10.ES6规定，只要可能导致解构歧义，就不得使用圆括号。由于这条规则不易辨别，因此建议尽量不要在模式中放置圆括号。</p>
<p>11.以下三种解构赋值不得使用圆括号。</p>
<ul>
<li>变量声明语句中，不能带有圆括号。</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</li>
</ul>
<p>12.可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。</p>
<p><strong>用途</strong></p>
<ul>
<li>交换变量的值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<ul>
<li>从函数中返回多个值：将返回的数组或对象中的值取出</li>
<li>函数参数的定义：方便地将无序的参数与变量名对应</li>
<li>提取JSON数据：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">24</span>,</div><div class="line">  <span class="attr">status</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="attr">data</span>: [<span class="number">424</span>, <span class="number">5920</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 24, "OK", [424, 5920]</span></div></pre></td></tr></table></figure>
<ul>
<li>函数参数的默认值</li>
<li>遍历Map结构：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div></pre></td></tr></table></figure>
<ul>
<li>输入模块的指定方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>1.字符的Unicode表示法：将码点放入大括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\u&#123;20BB7&#125;"</span>  <span class="comment">// "𠮷"</span></div><div class="line"></div><div class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span>  <span class="comment">// "ABC"</span></div></pre></td></tr></table></figure>
<p>2.新增一些方法：</p>
<ul>
<li><code>codePointAt()</code>：能够正确处理4个字节储存的字符，返回一个字符的码点。是测试一个字符由两个字节还是由四个字节组成的最简单方法。</li>
<li><code>String.fromCodePoint()</code>：用于从码点返回对应字符，可识别Unicode编号大于0xFFFF的码点（32位的UTF-16字符）。</li>
<li><code>at()</code>（提案）：返回字符串给定位置的字符，可识别Unicode编号大于0xFFFF的码点。</li>
<li><code>repeat(n)</code>：返回一个新字符串，表示将原字符串重复n次。</li>
<li><code>normalize()</code>：将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
<li><code>padStart()</code>：如果某个字符串不够指定长度，会在头部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串（默认为空格）。</li>
<li><code>padEnd()</code>：同上，用于尾部补全。</li>
</ul>
<p>3.模版字符串：常用于定义多行字符串，或者在字符串中嵌入变量。用反引号（`）标识。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Kyon"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure>
<p>模板字符串中嵌入变量，要将变量名卸载<code>${}</code>中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，也可以调用函数。</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串（例如对象调用<code>toString</code>方法）。</p>
<p>4.标签模板（功能）：函数调用的一种特殊形式。模板字符串作为参数紧跟在一个函数名后，该函数被调用以处理该模板字符串。常用于转义特殊字符和多语言转换（国际化处理）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log<span class="string">`Kyon`</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Kyon'</span>)</div></pre></td></tr></table></figure>
<p>模板字符有变量时，先把模板字符串处理成多个参数。处理得到的第一个参数是一个数组，包含那些没有变量替换的部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">tag([<span class="string">'Hello'</span>, <span class="string">' world'</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性，保存转义后的原字符串。</p>
<p>5.<code>String.raw()</code>：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串；如果原字符串的斜杠已经转义，则不会做任何处理。常用于处理模板字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">3</span>+<span class="number">4</span>&#125;</span>!`</span>;</div><div class="line"><span class="comment">// "Hi\\n7!"</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</div><div class="line"><span class="comment">// 'Hi\\u000A!'</span></div></pre></td></tr></table></figure>
<p>也可作为正常函数使用，第一个参数应是具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应是一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// 't0e1s2t'</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>6.模板字符串的限制（提案）：放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>
<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><p>1.<code>u</code>修饰符：Unicode 模式，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。对于码点大于<code>\uFFFF</code>的 Unicode 字符，点字符(<code>.</code>，除了换行符外的任意单个字符)、Unicode 字符表示法（使用大括号表示 Unicode 字符）、量词、预定义模式（<code>\S</code>，匹配所有不是空格的字符）必须加上<code>u</code>修饰符才能识别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>)</div><div class="line"><span class="comment">// false</span></div><div class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>2.<code>y</code>修饰符：“粘连”修饰符，全局匹配，但须确保匹配必须从剩余的第一个位置开始。一个应用是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</div><div class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</div><div class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</div><div class="line"></div><div class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></div><div class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></div><div class="line"></div><div class="line">r1.exec(s) <span class="comment">// ["aa"]</span></div><div class="line">r2.exec(s) <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>3.ES 6 的正则对象新增了<code>sticky</code>属性和<code>flags</code>属性，分别表示是否设置了<code>y</code>修饰符以及返回正则表达式的修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</div><div class="line">r.sticky  <span class="comment">// true</span></div><div class="line">r.flags  <span class="comment">// 'y'</span></div></pre></td></tr></table></figure>
<p>4.有一些提案。因为我暂时对正则不太熟悉，所以略过。</p>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>1.二进制、八进制表示法：分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。用<code>Number()</code>方法将其转化为十进制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>)  <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>2.新增 Number 对象上的一些方法：</p>
<ul>
<li><code>Number.isFinite()</code>：用于检查一个数值是否为有限的。</li>
<li><code>Number.isNaN()</code>：用于检查一个值是否为<code>NaN</code>。</li>
</ul>
<p>与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>
<ul>
<li>将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到 Number 对象上，行为完全保持不变，目的是逐步减少全局性方法，使得语言逐步模块化。</li>
<li><code>Number.isInteger()</code>：用于判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是同样的储存方法，这个方法都会返回 true。</li>
</ul>
<p>3.<code>Number.EPSILON</code>：极小的常量，表示一个可以接受的误差范围。浮点数计算误差小于<code>Number.EPSILON</code>时可以认为得到正确结果。</p>
<p>4.<code>Number.isSafeInteger()</code>：JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围的值无法精确表示。<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量用来表示这个范围的上下限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<p>5.Math 对象的扩展：所有新增方法都是静态方法，只能在 Math 对象上调用。</p>
<ul>
<li><code>Math.trunc()</code>：用于去除一个数的小数部分，返回整数部分。对于非数值内部使用<code>Number</code>方法将其先转为数值；对于空值和无法截取整数的值，返回 NaN。</li>
<li><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。它会返回五种值：参数为正数，返回+1；负数返回-1；0返回0；-0返回-0；其他值返回NaN。</li>
<li><code>Math.cbrt</code>：用于计算一个数的立方根。</li>
</ul>
<p>此外，还有一些对数方法和三角函数方法。</p>
<p>6.指数运算符（<code>**</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span> ** <span class="number">2</span>  <span class="comment">// 4</span></div><div class="line"><span class="number">2</span> ** <span class="number">3</span>  <span class="comment">// 8</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</div><div class="line">a **= <span class="number">3</span>;</div><div class="line"><span class="comment">// 等同于 a = a * a * a;</span></div></pre></td></tr></table></figure>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>1.<code>Array.from()</code>：将类数组对象（本质特征是有<code>length</code>属性）和可遍历对象（部署了 Iterator 接口的数据结构，包括 ES 6新增的 Set 和 Map）转化为真正的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123;</div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr1 = <span class="built_in">Array</span>.from(arrayLike);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>);</div><div class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></div></pre></td></tr></table></figure></p>
<p>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组；如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from()</code>的第三个参数，用来绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</div><div class="line"><span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure>
<p>2.<code>Array.of()</code>：返回参数值组成的数组（没有参数则返回空数组）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>)  <span class="comment">// [3]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></div></pre></td></tr></table></figure>
<p>3.数组实例的<code>copyWithin()</code>：在当前数组内部，将指定位置的成员复制到其他位置（覆盖原有成员），然后返回当前数组。</p>
<p>接受三个参数（都为数值，否则自动转换）：</p>
<ul>
<li>target（必需）：从该位置开始替换数据；</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>4.数组实例的<code>find()</code>和<code>findIndex()</code>：</p>
<p><code>find()</code>用于找出第一个符合条件的数组成员。其参数为一个回调函数（可以接收三个参数：当前的值，当前的位置和原数组），所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员，否则返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</div><div class="line"><span class="comment">// -5</span></div></pre></td></tr></table></figure>
<p><code>findIndex()</code>类似，返回第一个符合条件的数组成员的位置，否则返回<code>-1</code>。</p>
<p>5.数组实例的<code>fill()</code>：用给定值填充一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组中原有的元素将被覆盖</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line"><span class="comment">// 还可以接受两个参数，用于指定填充的起始位置和结束位置</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// ['a', 7, 'c']</span></div></pre></td></tr></table></figure>
<p>6.数组实例的<code>keys()</code>、<code>values()</code>和<code>entries()</code>：用于遍历数组。都返回一个遍历器对象，可以用<code>for..of</code>循环进行遍历；区别为分别对键名、键值、键值对遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys())&#123;</div><div class="line">    <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values())&#123;</div><div class="line">    <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries())&#123;</div><div class="line">    <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure>
<p>7.数组实例的<code>includes()</code>（属于ES 7 但 Babel 转码器已经支持）：返回一个布尔值，表示某个数组是否包含给定的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);  <span class="comment">// true</span></div><div class="line">[<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);  <span class="comment">// false</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>8.数组的空位：和<code>undefined</code>不同，数组的空位没有任何值。ES 5 对空位的处理规则很不一致（大多数情况会忽略）；而 ES 6 明确将空位转为<code>undefined</code>。尽管如此，建议避免出现空位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;。将知识点简便地总结一下，以供后续使用时参考或复习。&lt;/p&gt;
&lt;p&gt;此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>探究伪元素及其用途</title>
    <link href="http://kyonhuang.top/pseudo_elements/"/>
    <id>http://kyonhuang.top/pseudo_elements/</id>
    <published>2017-04-05T10:43:45.000Z</published>
    <updated>2017-06-18T03:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。</p>
  <a id="more"></a>
<h2 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h2><p>伪元素(Pseudo-elements)容易与伪类(Pseudo-classes)混淆。在 w3c 定义中，伪类用于向某些选择器添加特殊的效果，而伪元素用于将特殊的效果添加到某些选择器。可以看到从定义上来说，二者确实不好分辨。不过在种类上可以看出二者的一些不同。</p>
<p>伪类包括：</p>
<ul>
<li><code>:link</code>：向未被访问的链接添加样式。</li>
<li><code>:visited</code>：向已被访问的链接添加样式。</li>
<li><code>:hover</code>：当鼠标悬浮在元素上方时，向元素添加样式。</li>
<li><code>:active</code>：向被激活的元素添加样式。</li>
<li><code>:focus</code>：向拥有键盘输入焦点的元素添加样式。</li>
<li><code>:first-child</code>：向元素的第一个子元素添加样式。</li>
<li><code>:lang</code>：向带有指定 lang 属性的元素添加样式。</li>
</ul>
<p>其中前四个因为用不同的方式显示链接的不同状态，被称为“锚伪类”。在 CSS 定义中，<code>a:hover</code>必须被置于 <code>a:link</code>和<code>a:visited</code>之后，而<code>a:active</code>必须被置于<code>a:hover</code>之后才是有效的。</p>
<p>伪元素包括：</p>
<ul>
<li><code>:before</code>：在元素之前添加内容。</li>
<li><code>:after</code>：在元素之后添加内容。</li>
<li><code>:first-letter</code>：向文本的第一个字母添加特殊样式。</li>
<li><code>:first-line</code>：向文本的首行添加特殊样式。</li>
</ul>
<p>其中前两个无疑是用的最多的。后两个也可以用于实现一些特殊效果，例如通过<code>:first-letter</code>实现段落首字母加粗或变色。</p>
<p>两者的<strong>根本区别</strong>是：伪类可以通过<strong>直接添加一个实际的类样式</strong>达到同等效果；而伪元素的效果则需要<strong>先添加一个实际的元素，再在元素上添加样式</strong>才能达到。</p>
<p>在 CSS 3 中修订后的伪元素使用两个冒号（<code>::</code>）以与伪类进行区分。但无论使用单冒号还是双冒号，浏览器都能识别。并且 IE 8 只支持单冒号的写法。因此为了更广泛的浏览器兼容性，还是推荐使用单冒号的写法。</p>
<h2 id="伪元素的优点"><a href="#伪元素的优点" class="headerlink" title="伪元素的优点"></a>伪元素的优点</h2><p>最常使用的两种伪元素——<code>:before</code>和<code>:after</code>可以在内容元素的前后插入额外的元素。通过伪元素，在实现很多炫酷的视觉效果时，我们不必修改现有的 HTML 文档结构。因为 HTML 文档本身仅仅应该包含内容，而不应该包含样式，所以伪元素更应该被提倡。</p>
<h2 id="伪元素的应用"><a href="#伪元素的应用" class="headerlink" title="伪元素的应用"></a>伪元素的应用</h2><p>鉴于伪元素应用很多时候代码相对专一，建议配合 Sass，通过设置 mixin 来使用以提高复用性（你可以通过我的上一篇博文 <a href="http://kyonhuang.top/1478/">初见Sass－便捷的CSS预处理器</a> 来了解Sass）。</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>这大概是伪元素最为常见的应用了。比起插入额外的非语义标记来清除内联元素的浮动，这种俗称“clearfix”的方式更语义化。</p>
<p><strong>CSS</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.group:before,</div><div class="line">.group:after &#123;</div><div class="line">  content:&quot;&quot;;</div><div class="line">  display:table;</div><div class="line">&#125;</div><div class="line">.group:after &#123;</div><div class="line">  clear:both;</div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div><div class="line">.group &#123;</div><div class="line">  zoom:1; /* For IE 6/7 (trigger hasLayout) */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Sass</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@mixin clearfix &#123; </div><div class="line">  @if $legacy-support-for-ie &#123; </div><div class="line">    *zoom: 1; </div><div class="line">  &#125; </div><div class="line">  &amp;:before, </div><div class="line">  &amp;:after &#123; </div><div class="line">    content: &quot;&quot;; </div><div class="line">    display: table; </div><div class="line">  &#125; </div><div class="line">  &amp;:after &#123; </div><div class="line">    clear: both; </div><div class="line">    overflow: hidden; </div><div class="line">  &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过 @include 方法调用</div></pre></td></tr></table></figure>
<h3 id="实现样式效果"><a href="#实现样式效果" class="headerlink" title="实现样式效果"></a>实现样式效果</h3><p>能够借助伪元素实现的样式效果数不胜数。这里举一个简单而常用的例子。</p>
<p>很多时候我们会在每一节的标题下做一个类似下划线效果，用来强调。使用伪元素可以让我们不必添加额外的元素来实现这个效果。</p>
<p><img src="/images/section-title.png" width="264px" height="88px"></p>
<p>Sass 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@mixin section-title() &#123;</div><div class="line">  font-size: 2em;</div><div class="line">  padding: 2em 0;</div><div class="line">  text-transform: uppercase;</div><div class="line">  color: #55a2dd;</div><div class="line"></div><div class="line">  &amp;:after &#123;</div><div class="line">    display: block;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    background-color: #cccccc;</div><div class="line">    width: 2em;</div><div class="line">    height: .2em;</div><div class="line">    margin: .4em auto;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h3><p>有时我们想给一张大图设置透明度，却发现其子元素都会被继承这个透明度。以往想要消除这个属性总让我头大。现在通过伪元素，我们就可以分别为文字和图片设置不同的透明度。</p>
<p>Sass 代码如下（来自<a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/design_your_own_site/index.html" target="_blank" rel="external">第3周：设计你自己的页面</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">.hero &#123;</div><div class="line">  width: 100%;</div><div class="line">  min-height: 50em;</div><div class="line">  position: relative;</div><div class="line">  background-color: $mask-color;</div><div class="line">  z-index: 1;</div><div class="line"></div><div class="line">  &amp;:after &#123;</div><div class="line">    background: url(&apos;../images/hero-1-resized.jpg&apos;);</div><div class="line">    background-size: cover;</div><div class="line">    position: absolute;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    z-index: -1;</div><div class="line">    opacity: .2;</div><div class="line">    width: 100%;</div><div class="line">    height: 100%;</div><div class="line">    top: 0;</div><div class="line">    left: 0;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  h2 &#123;</div><div class="line">    font-size: 6em;</div><div class="line">    font-weight: bold;</div><div class="line">    padding: 3em 0 1em 0;</div><div class="line">    text-transform: uppercase;</div><div class="line">    color: white;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  p &#123;</div><div class="line">    max-width: 70%;</div><div class="line">    font-size: 1.5em;</div><div class="line">    font-weight: lighter;</div><div class="line">    color: #cecece;</div><div class="line">    line-height: 1.4;</div><div class="line">    margin: 0 auto;</div><div class="line">    padding: 1em 0 8em 0;</div><div class="line">    span &#123;</div><div class="line">      color: $heading-color;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 .hero 这个 section，我们将其背景设置为灰色，并将 position 设置为 relative。然后为其添加了一个伪元素，这个伪元素上包含了实际的图片，并为图片设置了透明度 .2。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.w3school.com.cn/css/css_pseudo_elements.asp" target="_blank" rel="external">CSS 伪元素 - W3School</a></p>
<p>你可以从这篇文章中了解更多伪元素的应用：<a href="http://www.w3cplus.com/css3/pseudo-element-roundup.html" target="_blank" rel="external">大放异彩的伪元素——可以做什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="HTML" scheme="http://kyonhuang.top/tags/HTML/"/>
    
      <category term="CSS" scheme="http://kyonhuang.top/tags/CSS/"/>
    
      <category term="伪元素" scheme="http://kyonhuang.top/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>初见Sass－便捷的CSS预处理器</title>
    <link href="http://kyonhuang.top/sass-begin/"/>
    <id>http://kyonhuang.top/sass-begin/</id>
    <published>2017-04-03T11:21:22.000Z</published>
    <updated>2017-08-03T03:32:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现自己又找到一本关于前端实践的优质开源书<a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/index.html" target="_blank" rel="external">《3周3页面》</a>。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。”</p>
<a id="more"></a>
<h2 id="什么是Sass"><a href="#什么是Sass" class="headerlink" title="什么是Sass"></a>什么是Sass</h2><p>为了给 CSS 加入编程元素，人们发明了Sass。Sass 是一个 CSS3 的扩展语言，它提供了嵌套样式，变量定义，扩展，mixin等丰富的特性，使得编写样式更加容易，节省了开发者的时间。</p>
<h2 id="Sass基础语法"><a href="#Sass基础语法" class="headerlink" title="Sass基础语法"></a>Sass基础语法</h2><p>这里只记录我觉得比较关键的语法作为备忘。可以查看 <a href="http://www.w3cplus.com/sassguide/" target="_blank" rel="external">sass十分钟入门</a> 或者 <a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="external">SASS用法指南</a> 以较为全面地入门。</p>
<ul>
<li>变量：以<code>$</code>开头。如果变量需要镶嵌在字符串之外，需要写在<code>#{}</code>中。</li>
<li>嵌套：用<code>&amp;</code>引用父元素。</li>
<li>继承：使用<code>@extend</code>命令。</li>
<li>Mixin：使用<code>@mixin</code>命令定义一个代码块，使用<code>@include</code>命令调用。可以指定参数和缺省值。</li>
<li>插入文件：使用<code>@import</code>命令。</li>
<li>自定义函数：使用<code>@function</code>和<code>@return</code>。</li>
<li>此外支持条件语句和循环语句。</li>
</ul>
<h2 id="WebStorm中使用Sass"><a href="#WebStorm中使用Sass" class="headerlink" title="WebStorm中使用Sass"></a>WebStorm中使用Sass</h2><p>注意，本节内容针对 OS X 环境。可能部分内容也兼容其他平台，但我没试过。</p>
<p>WebStorm 支持 Sass 的自动编译。在 WebStorm 的 Preferences 中，Tools 下选择 File Watchers。配置 Sass 和 SCSS（最新版的 Sass 后缀）需要有相应的 Program。</p>
<p><img src="/images/webstorm_sass.jpg"></p>
<p>因为 Sass 依赖 ruby，所以要先安装 ruby。不过 OS X 好像自带 ruby（至少我没有什么时候安装过的印象…）。之后建议安装 Compass：<code>sudo gem install compass</code>，Sass 和 SCSS 的 Program 会被一并安装，WebStorm 也会检测到，之后点击 OK 即可。</p>
<p>之后，WebStorm 会自动监测 Sass 文件的改动，并时刻编译为同名 CSS 文件，保存在同一文件夹下，非常方便。</p>
<h2 id="Sass实现媒体查询"><a href="#Sass实现媒体查询" class="headerlink" title="Sass实现媒体查询"></a>Sass实现媒体查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 定义两个 break-point</div><div class="line">$break-small: 320px;</div><div class="line">$break-large: 1024px;</div><div class="line"></div><div class="line">// 定义一个 mixin，接收三个可能的参数</div><div class="line">// 分别代表不同的设备——手机、平板和桌面显示器</div><div class="line">@mixin respond-to($media) &#123;</div><div class="line">  @if $media == handhelds &#123;</div><div class="line">    @media only screen and (max-width: $break-small) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">  @else if $media == medium-screens &#123;</div><div class="line">    @media only screen and (min-width: $break-small + 1) and (max-width: $break-large) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">  @else if $media == wide-screens &#123;</div><div class="line">    @media only screen and (min-width: $break-large) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">  @include respond-to(medium-screens) &#123;</div><div class="line">    //...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式使用起来更方便，也便于后期统一修改变量的具体数值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《3周3页面》的作者同样推荐了 Compass。这是一个使用了 Sass 的库，将很多常用样式打包成了一些模块以供使用。因为安装时出现了一些我还没解决的 error，我还没有使用过。可以查看 <a href="http://www.ruanyifeng.com/blog/2012/11/compass.html" target="_blank" rel="external">Compass用法指南</a> 以获得更多了解。</p>
<p>此外，推荐 <a href="http://www.w3cplus.com/preprocessor/ten-best-common-mixins.html" target="_blank" rel="external">SASS基础——十个常见的Mixins</a>。这篇文章总结了一些常用的 Mixin，更重要的是，通过这些Mixin，对 CSS 可以获得更深入的理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现自己又找到一本关于前端实践的优质开源书&lt;a href=&quot;https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《3周3页面》&lt;/a&gt;。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。”&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="学习笔记" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="SASS" scheme="http://kyonhuang.top/tags/SASS/"/>
    
      <category term="WebStorm" scheme="http://kyonhuang.top/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title>神奇的CSS动画</title>
    <link href="http://kyonhuang.top/css-animation/"/>
    <id>http://kyonhuang.top/css-animation/</id>
    <published>2017-03-25T07:58:01.000Z</published>
    <updated>2017-08-21T07:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。</p>
<p>通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。</p>
<p>17.04.03更新：补充打字机动效。</p>
<a id="more"></a>
<h2 id="transition-属性"><a href="#transition-属性" class="headerlink" title="transition 属性"></a>transition 属性</h2><p>transition 是一个速记属性，有以下四个属性：</p>
<ol>
<li>transition-property：指定 CSS 属性的 name, transition 效果；</li>
<li>transition-duration：transition 效果需要指定多少秒（或毫秒）才能完成；</li>
<li>transition-timing-function：指定 transition 效果的转速曲线，包括五个模式：ease（渐慢，默认）、linear（匀速）、ease-in（加速）、ease-out（减速）、cubic-bezier 函数（自定义速度模式，可使用<a href="http://cubic-bezier.com/" target="_blank" rel="external">工具网站</a>定制）；</li>
<li>transition-delay：定义 transition 效果开始的时候。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 简写</div><div class="line">img&#123;</div><div class="line">    transition: 1s 1s height ease;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 单独定义</div><div class="line">img&#123;</div><div class="line">    transition-property: height;</div><div class="line">    transition-duration: 1s;</div><div class="line">    transition-delay: 1s;</div><div class="line">    transition-timing-function: ease;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中必须指定 transition-duration 属性，否则持续时间默认为 0 ，没有任何效果。</p>
<p>transition 的局限：</p>
<ul>
<li>需要事件触发，没法在网页加载时自动发生；</li>
<li>一次性，除非一再触发，否则不能重复发生；</li>
<li>只能定义开始状态和结束状态（即只有两个状态），不能定义中间状态；</li>
<li>需要明确知道开始状态和结束状态的具体<strong>数值</strong>，才能计算中间状态；</li>
<li>一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ul>
<h2 id="keyframes（关键帧）"><a href="#keyframes（关键帧）" class="headerlink" title="keyframes（关键帧）"></a>keyframes（关键帧）</h2><p>animation 属性可以利用 keyframes 关键字定义动画的各个状态，将指定时间段内的动画划分的更为精细。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</div><div class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0% 可以用 from 表示，100% 可以用 to 表示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</div><div class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果省略某个状态，浏览器会自动推算中间状态。也可将多个状态写在一行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 以下都为合法的写法</div><div class="line"></div><div class="line">@keyframes rainbow &#123;</div><div class="line">  50% &#123; background: orange &#125;</div><div class="line">  to &#123; background: yellowgreen &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@keyframes rainbow &#123;</div><div class="line">  to &#123; background: yellowgreen &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@keyframes pound &#123;</div><div class="line">  from，to &#123; transform: none; &#125;</div><div class="line">  50% &#123; transform: scale(1.2); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从一个状态向另一个状态过渡，浏览器默认为平滑过渡。steps 函数可以实现分布过渡。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite <span class="built_in">steps</span>(10);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="animation-常用属性"><a href="#animation-常用属性" class="headerlink" title="animation 常用属性"></a>animation 常用属性</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 简写</div><div class="line">div:hover &#123;</div><div class="line">    animation: 1s 1s rainbow linear 3 forwards normal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 单独定义</div><div class="line">div:hover&#123;</div><div class="line">    animation-name: rainbow;</div><div class="line">    animation-duration: 1s;</div><div class="line">    ainmation-timing-function: linear;</div><div class="line">    animation-delay: 1s;</div><div class="line">    animation-fill-mode: forwards;</div><div class="line">    animation-direction: normal;</div><div class="line">    animation-iteration-count: 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>animation 有以下常用属性（其余和 transition 大致相似）：</p>
<p><strong>animation-iteration-count</strong>：指定动画播放次数，可指定为数值或 infinite（无限次）。</p>
<p><strong>animation-direction</strong>：指定动画播放方向，默认为 normal。其他可选值有 reverse，alternate 和 alternate-reverse（后两种浏览器支持情况不佳）。</p>
<p><strong>animation-fill-mode</strong>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。有四个可选值：</p>
<ol>
<li>forwards：让动画停留在结束状态；</li>
<li>none：回到动画没开始的状态；</li>
<li>backwards：让动画回到第一帧的状态；</li>
<li>both：根据 animation-direction 轮流应用 forwards 和 backwards 规则。</li>
</ol>
<p><strong>animation-play-state</strong>：指定动画播放突然终止时的状态，默认行为是跳回动画的开始状态。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 让动画保持突然终止时的状态</div><div class="line"></div><div class="line">div &#123;</div><div class="line">    animation: spin 1s linear infinite;</div><div class="line">    animation-play-state: paused;</div><div class="line">&#125;</div><div class="line"></div><div class="line">div:hover &#123;</div><div class="line">    animation-play-state: running;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>IE 10、Firefox 16.0、Chrome 43.0、Safari 9.0、Opera 30.0 以上支持没有前缀的 animation。详见 <a href="http://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="external">CSS3 animation（动画） 属性
</a> “浏览器支持”部分。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="打字机动效"><a href="#打字机动效" class="headerlink" title="打字机动效"></a>打字机动效</h3><p>依照 <a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/animate_your_page/index.html" target="_blank" rel="external">让页面动起来</a> 实现的打字机动效。图片素材为自制，因此部分数据与参照有出入。素材及代码见 <a href="https://github.com/bighuang624/Front-end_Learning/tree/master/%E6%89%93%E5%AD%97%E6%9C%BA%E5%8A%A8%E6%95%88" target="_blank" rel="external">bighuang624/Front-end_Learning/打字机动效</a>。</p>
<p><img src="/images/type-writer.jpg"></p>
<p>（gif图没搞好…）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="external">CSS动画简介 - 阮一峰的网络日志</a></p>
<p><a href="http://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="external">CSS3 animation（动画） 属性
</a></p>
<p><a href="https://github.com/junruchen/junruchen.github.io/wiki/CSS-%E5%8F%98%E6%8D%A2-%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" target="_blank" rel="external">CSS 变换 过渡 动画使用案例</a></p>
<p>补充：</p>
<p><a href="https://aotu.io/notes/2016/11/28/css3-animation-properties/" target="_blank" rel="external">css3 animation 属性众妙</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。&lt;/p&gt;
&lt;p&gt;通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。&lt;/p&gt;
&lt;p&gt;17.04.03更新：补充打字机动效。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="CSS动画" scheme="http://kyonhuang.top/tags/CSS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>探究JS中的词法作用域</title>
    <link href="http://kyonhuang.top/js-lexical-scope/"/>
    <id>http://kyonhuang.top/js-lexical-scope/</id>
    <published>2017-03-22T13:58:50.000Z</published>
    <updated>2017-07-26T06:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 <a href="https://github.com/qibaoguang/Study-Step-by-Step/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/javascript_the_good_parts.md" target="_blank" rel="external">JavaScript 语言精粹</a> 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 <a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="external">箭头函数</a> 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。”</p>
<p>这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。</p>
<a id="more"></a>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>《JavaScript 权威指南》第5章“8.8.1 词法作用域”中对“词法作用域”的解释如下：</p>
<p>“JavaScript 中的函数是通过词法来划分作用域的，而不是动态地划分作用域的。这意味着它们在定义它们的作用域里运行，而不是在执行它们的作用域里运行。当定义了一个函数，当前的作用域链就保存起来，并且成为函数的内部状态的一部分。”</p>
<p>当然，这几句话还是玄之又玄，摸不着头脑。它还是没有具体解释“词法作用域”中的“词法”二字代表什么。不过我这学期的《编译原理》课程上经常见到这个词：编译过程被划分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成 6 个阶段（清华大学出版社《编译原理》）。在查阅资料后，我确信这个概念确实与编译有关。</p>
<p>JavaScript 引擎在代码执行前会对其进行编译，而所谓的词法作用域指作用域是由书写代码时<strong>函数声明的位置</strong>决定，在词法解析阶段就已经确定，之后不会改变。也就是说，JS 中的“词法作用域”等同于静态作用域，即与动态作用域（运行时确定）相对。</p>
<p>词法作用域关注函数在<strong>何处声明</strong>；而动态作用域关注函数从<strong>何处调用</strong>，其作用域链是基于运行时的调用栈的。换言之，在遇到既不是形参也不是函数内部定义的局部变量的变量时，词法作用域的函数会去函数<strong>定义</strong>时的环境中查询；而动态作用域的函数会到函数调用时的环境中查询。</p>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    print a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar()&#123;</div><div class="line">    var a = 1;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line">bar();</div></pre></td></tr></table></figure>
<p>采用词法作用域的语言会从函数定义位置开始向上层查找，最后输出 2。</p>
<p>而采用动态作用域的语言会输出 1。</p>
<p>顺便一提，在 JS 中<code>eval</code>和<code>with</code>可以产生动态作用域的效果。但《JavaScript 高级程序设计》不推荐使用此二者。</p>
<h2 id="强调与补充"><a href="#强调与补充" class="headerlink" title="强调与补充"></a>强调与补充</h2><p>函数的作用域基于函数<strong>定义</strong>的位置。</p>
<p>为了去实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数逻辑的代码，除此之外还包含当前作用域链的引用。函数对象可以通过这个作用域链相互关联起来。</p>
<p>如此，函数体内部的变量都可以保存在函数的作用域内，在程序语言范畴内这被称为<strong>闭包</strong>。而我们常说的闭包是指<strong>让外部函数访问到内部的变量</strong>，也就是说，按照一般的做法，是<strong>使内部函数返回一个函数，然后操作其中的变量</strong>。这样做的话一是可以读取函数内部的变量，二是可以让这些变量的值始终保存在内存中。</p>
<p>这时，调用函数的时候闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.zhihu.com/question/20032419" target="_blank" rel="external">动态作用域和词法域的区别是什么？- 知乎</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="external">JavaScript深入之词法作用域和动态作用域 · Issue #3 · mqyqingfeng/Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 &lt;a href=&quot;https://github.com/qibaoguang/Study-Step-by-Step/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/javascript_the_good_parts.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript 语言精粹&lt;/a&gt; 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 &lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;箭头函数&lt;/a&gt; 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。”&lt;/p&gt;
&lt;p&gt;这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="概念理解" scheme="http://kyonhuang.top/tags/%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    
      <category term="JavaScript" scheme="http://kyonhuang.top/tags/JavaScript/"/>
    
      <category term="词法作用域" scheme="http://kyonhuang.top/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>在把玩中学习——typewriter.js</title>
    <link href="http://kyonhuang.top/typewriter/"/>
    <id>http://kyonhuang.top/typewriter/</id>
    <published>2017-03-17T03:28:32.000Z</published>
    <updated>2017-04-25T10:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。</p>
<p>好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。</p>
<p><img src="/images/typewriter.jpg"></p>
<a id="more"></a>
<p>这个有打字和仿光标闪烁效果的 <a href="http://www.jq22.com/jquery-info6035" target="_blank" rel="external">typewriter.js</a> 好像是我在看什么“程序员表白利器”时加到收藏夹里的。现在学习了 js，敢看看源码了，发现 js 代码只有20行不到。作者说：“原生JavaScript就是这么牛。”确实是这样的。虽然效果也很简单，但也能从里面学到一些东西。</p>
<p>HTML 源代码（大致结构）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;mainDiv&quot;&gt;</div><div class="line">        &lt;div id=&quot;content&quot;&gt;</div><div class="line">            &lt;div id=&quot;code&quot;&gt;</div><div class="line">                &lt;span class=&quot;comments&quot;&gt;/**&lt;/span&gt;&lt;br /&gt;</div><div class="line">                &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* We are both XXX Unversity  business administration and programmers,&lt;/span&gt;&lt;br /&gt;</div><div class="line">                &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* so I write some code to show my love to you.&lt;/span&gt;&lt;br /&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"> document.getElementById(&quot;code&quot;).typewriter();</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>JavaScript 源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Element.prototype.typewriter=function(a)&#123;</div><div class="line">			var d = this,</div><div class="line">				c = d.innerHTML,</div><div class="line">				b = 0;</div><div class="line">			d.innerHTML=&quot;&quot;;</div><div class="line">			var e = setInterval(function() &#123;</div><div class="line">				var f = c.substr(b, 1);</div><div class="line">				if (f == &quot;&lt;&quot;) &#123;</div><div class="line">					b = c.indexOf(&quot;&gt;&quot;, b) + 1</div><div class="line">				&#125; else &#123;</div><div class="line">					b++</div><div class="line">				&#125;</div><div class="line">				d.innerHTML=c.substring(0, b) + (b &amp; 1 ? &quot;_&quot; : &quot;&quot;);</div><div class="line">				if (b &gt;= c.length) &#123;</div><div class="line">					clearInterval(e)</div><div class="line">				&#125;</div><div class="line">			&#125;, 75)</div><div class="line">		return this</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在这份 js 代码中可以学习的点：</p>
<ol>
<li><strong>原型模式定义方法</strong>：给 Element 添加实例方法<code>typewriter()</code>（在 html 文件中调用），这里有一个参数 a，实际上没什么用。顺便一说，源码在 head 处引入了 js 文件，这是为了先加载 js 文件。如果按照代码规范将引入放在 body 部分的最后，则有一瞬间所有字先出现再消失，不符合效果要求。可见代码规范也要根据实际来遵守。</li>
<li>声明三个变量，d 保存当前对象（”code”）。这个操作是必要的，因为后面要给 “code” 的 innerHTML 赋值的时候有时在函数作用域中，this 取不到 “code”。</li>
<li>代码逻辑很清晰，包括对标签的处理、光标效果的实现和定时器的清除等。要对自己想要实现的效果有一个全面的认知和大致的构思再开始写代码。</li>
<li>末尾<code>return this</code>以<strong>支持链式操作</strong>。</li>
</ol>
<p>想要用功能强大的JavaScript实现一些小效果不难，但是怎样一步步规划、修改到实现对现在的我来说还是比较有挑战性的。希望自己能在欣赏、借鉴、吸收的过程中去实现一些有趣的 demo，重拾对代码的兴趣和创造力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。&lt;/p&gt;
&lt;p&gt;好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/typewriter.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="学习笔记" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
