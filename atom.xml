<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大黄菌的个人博客</title>
  <subtitle>天下武功，无勤不破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kyonhuang.top/"/>
  <updated>2017-09-23T02:25:42.000Z</updated>
  <id>http://kyonhuang.top/</id>
  
  <author>
    <name>Kyon Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ANTLR v4 学习笔记（二）－实现变种计算器</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-2/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-2/</id>
    <published>2017-09-21T11:25:56.000Z</published>
    <updated>2017-09-23T02:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习解释器构造和 ANTLR。在系列博文的上一篇 <a href="http://kyonhuang.top/ANTLR-learning-notes-1/">ANTLR v4 学习笔记（一）－ANTLR 初体验</a>，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。</p>
<p>我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。</p>
<p>这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。</p>
<a id="more"></a>
<h2 id="计算器描述"><a href="#计算器描述" class="headerlink" title="计算器描述"></a>计算器描述</h2><p>计算器接受四则运算表达式为输入（如下所示）。如果表达式语法正确，则输出计算结果，否则报错，指出错误位置及原因。</p>
<p>例子1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input <span class="number">1</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-a/<span class="number">2</span>;    print(b);    print(a);Output <span class="number">1</span>:    <span class="number">5246.04</span>    <span class="number">3497.36</span></div></pre></td></tr></table></figure>
<p>例子2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input <span class="number">2</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-c/<span class="number">2</span>;    print(b);Output <span class="number">2</span>:    Error(line <span class="number">2</span>,position <span class="number">6</span>): undefined identifier.</div></pre></td></tr></table></figure>
<p>以上两个示例包含了这个计算器的全部特性：</p>
<ol>
<li>每个语句需要以“<code>;</code>”结束；</li>
<li>涉及的操作符只要求加减乘除；支持括号；</li>
<li>操作数为整数或浮点数；</li>
<li>变量不需要先声明，可直接赋值，它的类型由右边表达式的类型决定；每个变量在使用之前必须要已经有赋值；</li>
<li>变量名可以是由数字和字母组成，但首字符必须是字母； </li>
<li>输出语句使用<code>print()</code>函数，输出并换行；</li>
<li><code>print()</code>函数不仅可以输出变量，还可以直接输出表达式的值，例如<code>print(1+2)</code>；</li>
<li>尽量考虑周全，顾及corner cases。例如除零；</li>
<li>程序不需要 GUI，接受一个源文件路径为命令行参数。</li>
</ol>
<h2 id="匹配运算表达式的语法"><a href="#匹配运算表达式的语法" class="headerlink" title="匹配运算表达式的语法"></a>匹配运算表达式的语法</h2><p>在经过之前的学习后，我们可以比较轻松地写出一份匹配运算表达式的 ANTLR 语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a grammar called Calculator</div><div class="line"> */</div><div class="line">grammar Calculator;</div><div class="line">// 程序起始规则，语法分析的起点</div><div class="line">program : stat+;</div><div class="line"></div><div class="line">stat: define NEWLINE?            # defineStat</div><div class="line">    | print NEWLINE?             # printStat</div><div class="line">    | NEWLINE                    # blank</div><div class="line">    ;</div><div class="line">// 声明</div><div class="line">define: VAR '=' expr ';';</div><div class="line">// 计算表达式</div><div class="line">expr: expr op=('*'|'/') expr     # MulDiv </div><div class="line">     | expr op=('+'|'-') expr    # AddSub</div><div class="line">     | '('expr')'                # parens</div><div class="line">     | NUMBER                    # number</div><div class="line">     | VAR                       # var</div><div class="line">     ;</div><div class="line"></div><div class="line">// 输出</div><div class="line">print: 'print''('VAR')'';'       # printVAR</div><div class="line">      | 'print''('expr')'';'     # printExpr </div><div class="line">      ;</div><div class="line">// 操作数类别</div><div class="line">NUMBER: INT|FLOAT;</div><div class="line">VAR : [a-zA-Z][a-zA-Z0-9]*;</div><div class="line">INT : [0-9]+;</div><div class="line">FLOAT : [0-9]+'.'[0-9]+;</div><div class="line">NEWLINE: '\r'? '\n'? ;</div><div class="line">WS : [ \t]+ -&gt; skip;</div><div class="line">MUL : '*' ;  </div><div class="line">DIV : '/' ;  </div><div class="line">ADD : '+' ;  </div><div class="line">SUB : '-' ;</div></pre></td></tr></table></figure>
<p>这份语法有一些值得注意的地方：</p>
<ul>
<li>语法分析器的规则以小写字母开头；</li>
<li>词法分析器的规则以大写字母开头；</li>
<li>我们使用<code>|</code>来分隔同一个语言规则的若干备选分支，并使用圆括号把一些符号组合成子规则；</li>
<li>WS 词法规则中，<code>-&gt; skip</code>是一条指令，告诉词法分析器匹配并丢弃空白字符；</li>
<li>你也许会注意到一些<code>#</code>开头的标签。如果备选分支上没有标签，ANTLR 就只为每条规则生成一个方法；</li>
<li>我们为运算符等词法符号定义了一些名字，这样，在之后访问器的编写中，我们可以将这些词法符号的名字当作常量使用，使代码更加清晰。</li>
</ul>
<p>现在我们已经可以通过 ANTLR 内置的测试组件来进行测试。由于 Eclipse 的最新版本 ANTLR 插件里的 ANTLR 版本仍然是 4.4（官网的 ANTLR 包已到 4.7 版本），所以我们还是自己通过命令行生成 java 文件并编译：</p>
<p><img src="/images/antlr/note2/cal1.jpg"></p>
<p>添加的<code>-gui</code>参数使我们可以看到关于输入的语法分析树：</p>
<p><img src="/images/antlr/note2/caltree.jpg"></p>
<p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复。例如，我们的输入少一个<code>;</code>，语法分析器会自动输出错误信息：</p>
<p><img src="/images/antlr/note2/cal1-error.jpg"></p>
<p>添加<code>-gui</code>参数生成的可视化语法分析树会将错误节点自动标红：</p>
<p><img src="/images/antlr/note2/caltree-error.jpg"></p>
<h3 id="语法优化"><a href="#语法优化" class="headerlink" title="语法优化"></a>语法优化</h3><p>这里的“优化”不是指对语法本身，而是对 ANTLR 语法文件，即<code>.g4</code>作为扩展名的文件。ANTLR 允许我们将非常大的语法拆分为多个部分，根据习惯，我们将其分为语法分析器的语法和词法分析器的语法两部分。</p>
<p>这样做的好处是对于两种词法规则或者语法规则相同的语言，我们可以复用这些“模块”来构建语法分析器。</p>
<p>词法规则文件 CalculatorLexerRules.g4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意开头是 "lexer grammer"</span></div><div class="line">lexer grammar CalculatorLexerRules;</div><div class="line"></div><div class="line"><span class="comment">// 操作数类别</span></div><div class="line">NUMBER: INT|FLOAT;</div><div class="line">VAR : [a-zA-Z][a-zA-Z0-<span class="number">9</span>]*;</div><div class="line">INT : [<span class="number">0</span>-<span class="number">9</span>]+;</div><div class="line">FLOAT : [<span class="number">0</span>-<span class="number">9</span>]+<span class="string">'.'</span>[<span class="number">0</span>-<span class="number">9</span>]+;</div><div class="line">NEWLINE: <span class="string">'\r'</span>? <span class="string">'\n'</span>? ;</div><div class="line">WS : [ \t]+ -&gt; skip;</div><div class="line">MUL : <span class="string">'*'</span> ;  </div><div class="line">DIV : <span class="string">'/'</span> ;  </div><div class="line">ADD : <span class="string">'+'</span> ;  </div><div class="line">SUB : <span class="string">'-'</span> ;</div></pre></td></tr></table></figure>
<p>语法规则文件 CalculatorExpr.g4，之前语法中的词法规则全部通过 import 语句导入：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a grammar called CalculatorExpr</div><div class="line"> */</div><div class="line">// 注意 grammer 要和文件名相同</div><div class="line">grammar CalculatorExpr;</div><div class="line">// 引入词法规则</div><div class="line">import CalculatorLexerRules;</div><div class="line">// 程序起始规则，语法分析的起点</div><div class="line">program : stat+;</div><div class="line"></div><div class="line">stat: define NEWLINE?            # defineStat</div><div class="line">    | print NEWLINE?             # printStat</div><div class="line">    | NEWLINE                    # blank</div><div class="line">    ;</div><div class="line">// 声明</div><div class="line">define: VAR '=' expr ';';</div><div class="line">// 计算表达式</div><div class="line">expr: expr op=('*'|'/') expr     # MulDiv </div><div class="line">     | expr op=('+'|'-') expr    # AddSub</div><div class="line">     | '('expr')'                # parens</div><div class="line">     | NUMBER                    # number</div><div class="line">     | VAR                       # var</div><div class="line">     ;</div><div class="line"></div><div class="line">// 输出</div><div class="line">print: 'print''('VAR')'';'       # printVAR</div><div class="line">      | 'print''('expr')'';'     # printExpr </div><div class="line">      ;</div></pre></td></tr></table></figure>
<p>要生成 java 文件，我们只需要对语法文件使用<code>antlr4</code>命令即可。这样我们就得到了和之前一样的 java 文件（测试就不贴图了）：</p>
<p><img src="/images/antlr/note2/import-java.jpg"></p>
<p>import 语句赋予我们编写模块化语法的能力，这使得 ANTLR 语法文件的耦合度降低，复用性提高。</p>
<h2 id="使用-Visitor-构建计算器"><a href="#使用-Visitor-构建计算器" class="headerlink" title="使用 Visitor 构建计算器"></a>使用 Visitor 构建计算器</h2><p>我们最终的目的是将生成的语法分析器集成到程序中，因此我们需要写一些 Java 代码。我们会用 Visitor（访问者模式）来实现我们的变种计算器。</p>
<p>由于我的实现代码基于 Calculator.g4 生成的 java 文件，而非拆分后的 CalculatorExpr.g4，所以之后的文件名、类名和方法名还是会以 Calculator 开头。当然，所有功能都是相同的，使用哪份语法文件生成的 java 文件都不会有影响。</p>
<p>我们通过以下命令来让 ANTLR 生成 Visitor 而非 Listener：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antlr4 -no-listener -visitor -encoding UTF-8 Calculator.g4</div></pre></td></tr></table></figure>
<p>这样，ANTLR 会自动生成一个访问器接口文件 CalculatorVisitor.java，以及该访问器的一个默认实现类 CalculatorBaseVisitor。实现时，我们需要自己写一个 Visitor 的子类，继承<br>CalculatorBaseVisitor<float>（这样表达式的计算结果都是浮点数），并重写其中的方法，以实现变量键值对存储、计算、打印等需求。</float></p>
<p>以下是我们实现的 Visitor 子类 MainVisitor 的完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainVisitor</span> <span class="keyword">extends</span> <span class="title">CalculatorBaseVisitor</span>&lt;<span class="title">Float</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 声明一个 map，存放变量与值的键值对</span></div><div class="line">    Map&lt;String, Float&gt; memory = <span class="keyword">new</span> HashMap&lt;String, Float&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * define: VAR '=' expr ';';</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitDefine</span><span class="params">(CalculatorParser.DefineContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">float</span> value = visit(ctx.expr());</div><div class="line">        memory.put(var, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * expr op=('*'|'/') expr</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitMulDiv</span><span class="params">(CalculatorParser.MulDivContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</div><div class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.MUL)</div><div class="line">            <span class="keyword">return</span> left * right;</div><div class="line">        <span class="keyword">return</span> left / right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * expr op=('+'|'-') expr</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitAddSub</span><span class="params">(CalculatorParser.AddSubContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</div><div class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.ADD)</div><div class="line">            <span class="keyword">return</span> left + right;</div><div class="line">        <span class="keyword">return</span> left - right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * NUMBER</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitNumber</span><span class="params">(CalculatorParser.NumberContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Float.valueOf(ctx.NUMBER().getText());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * VAR</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitVar</span><span class="params">(CalculatorParser.VarContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">if</span> (memory.containsKey(var))</div><div class="line">            <span class="keyword">return</span> memory.get(var);</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>) <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * '('expr')'</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitParens</span><span class="params">(CalculatorParser.ParensContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> visit(ctx.expr());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * print: ('print''('VAR')'';');</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintVAR</span><span class="params">(CalculatorParser.PrintVARContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">if</span> (memory.containsKey(var))</div><div class="line">            System.out.println(memory.get(var));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            System.err.println(<span class="string">"undefined identifier"</span>);</div><div class="line">        <span class="keyword">return</span> visitChildren(ctx);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * print: ('print''('expr')'';');</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> </span>&#123;</div><div class="line">        System.out.println(visit(ctx.expr()));</div><div class="line">        <span class="keyword">return</span> visitChildren(ctx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我们需要写一个 Calculator.java 来新建所需要的所有对象，并针对 program 规则启动语法分析器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        </div><div class="line">        String inputFile = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Usage:\n\tjava -jar Calculator.jar [sourceFile]"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</div><div class="line">            inputFile = args[<span class="number">0</span>];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.err.println(<span class="string">"The file path cannot be recognized"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        InputStream instream = System.in;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(inputFile != <span class="keyword">null</span>)</div><div class="line">            instream = <span class="keyword">new</span> FileInputStream(inputFile);</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(instream);</div><div class="line">        <span class="comment">// 新建词法分析器对象</span></div><div class="line">        CalculatorLexer lexer = <span class="keyword">new</span> CalculatorLexer(input);</div><div class="line">        <span class="comment">// 新建词法符号流管道</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        <span class="comment">// 新建语法分析器对象</span></div><div class="line">        CalculatorParser parser = <span class="keyword">new</span> CalculatorParser(tokens);</div><div class="line">        <span class="comment">// 启动语法分析器，从 program 规则开始进行语法分析</span></div><div class="line">        ParseTree tree = parser.program();</div><div class="line">        </div><div class="line">        MainVisitor cal = <span class="keyword">new</span> MainVisitor();</div><div class="line">        </div><div class="line">        cal.visit(tree);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，现在我们的变种计算器就有了一个初步版本。打包成 jar 包后，我们可以看一下效果：</p>
<p><img src="/images/antlr/note2/Calculator-effect.jpg"></p>
<p>我觉得可以。</p>
<h2 id="继续完善"><a href="#继续完善" class="headerlink" title="继续完善"></a>继续完善</h2><p>那么这时候，一般就会有人跳出来说：“我觉得不行。我觉得很普通。”</p>
<p>其实我也是这么认为的（阿黄真的很严格！）。</p>
<p>实际上，我们这个计算器还有一些需要继续完善的地方。比如下面这种情况：</p>
<p><img src="/images/antlr/note2/exception.jpg"></p>
<p>可以看到并未赋值的变量 c 被当作 0。然而在我们的要求中，这样的变量应该当作未初始化，使用时要报错。另外，当被除数为 0 时，输出的结果会是 “Infinity”，而我们还是希望这种情况发生时会报错。以上情况说明<strong>我们定义的语法没有覆盖到所有设想中的错误</strong>。</p>
<p>另外，ANTLR 自带的错误报告采用以下的语句，基本算是直接输出了行号、错误信息等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.err.println(<span class="string">"line "</span> + line + <span class="string">":"</span> + charPositionInLine + <span class="string">" "</span> + msg);</div></pre></td></tr></table></figure>
<p>说实话，不是很显眼。我还是喜欢错误报告开头有一些比较明显的标示，比如<code>Error(line 2,position 6): undefined identifier</code>感觉就要好一些。</p>
<p>不幸的是，Chapter 4 尚未涉及到 ANTLR 的错误处理机制。这部分内容在 Chapter 9 Error Reporting and Recovery 中。为了不用麻烦糖糖先记着，我们不妨先对这部分内容进行一些学习。</p>
<h3 id="错误报告格式优化"><a href="#错误报告格式优化" class="headerlink" title="错误报告格式优化"></a>错误报告格式优化</h3><p>先从错误报告格式优化开始。ANTLR 的错误报告通过 ANTLRErrorListener 接口，由 ConsoleErrorListener 实现，输出信息比较简单。</p>
<p>ANTLRErrorListener 包含四个方法：<strong>syntaxError</strong>、reportAmbiguity、reportAttemptingFullContext、reportContextSensitivity。其中 syntaxError 顾名思义用于处理语法错误，而后三个用于二义性处理。</p>
<p>ANTLR 也内置了一些 ANTLRErrorListener 的实现。除开默认采用的 ConsoleErrorListener，还有一个空实现 <strong>BaseErrorListener</strong>。我们可以 new 一个 BaseErrorListener 来自定义一些错误的处理方法，然后通过 addErrorListener 把它添加到语法分析器上。</p>
<p>根据以上思路，我们可以在 Calculator.java 中新建语法分析器对象的语句后加上几行代码，用于移除 ANTLR 默认的错误处理，以及添加一个我们自定义的错误监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除默认的错误处理</span></div><div class="line">parser.removeErrorListeners();</div><div class="line"><span class="comment">// 添加自定义错误监听器</span></div><div class="line">parser.addErrorListener(<span class="keyword">new</span> BaseErrorListener() &#123;</div><div class="line">    <span class="comment">//出现语法错误</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syntaxError</span><span class="params">(Recognizer&lt;?, ?&gt; recognizer, Object offendingSymbol, <span class="keyword">int</span> line, <span class="keyword">int</span> charPositionInLine, String msg, RecognitionException e)</span> </span>&#123;</div><div class="line">        System.err.println(<span class="string">"Error(line "</span> + line + <span class="string">", position "</span> + charPositionInLine + <span class="string">"): "</span> + msg);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在的错误报告看起来就更加有条理了：</p>
<p><img src="/images/antlr/note2/newErrorReport.jpg"></p>
<h3 id="部分错误特例的处理方式"><a href="#部分错误特例的处理方式" class="headerlink" title="部分错误特例的处理方式"></a>部分错误特例的处理方式</h3><p>不幸的是，读完了 Chapter 9，我仍然没有找到关于调用未初始化变量、被除数为 0 时报错应该怎么写。<br>现在我的权宜之计是直接<code>System.err.println</code>，也就是跳过错误机制。由于上下文对象会记录根据规则识别词组时产生的所有信息，可以通过<code>ctx.start.getLine()</code>获得<code>ctx.start.getCharPositionInLine()</code>错误出现的行数和行内具体位置。</p>
<p><img src="/images/antlr/note2/undefined-error.jpg"></p>
<p>可以看到所显示的位置好像并不是特别准确，个人认为是 ctx 给出的位置会追溯到所在规则开始的地方。也许随着学习更加深入，我会找到比较优雅的实现方法。</p>
<h2 id="计算器运行截图"><a href="#计算器运行截图" class="headerlink" title="计算器运行截图"></a>计算器运行截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-952930bcab492aee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-891de540a356c539.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result2.jpg"></p>
<h2 id="计算器实现中遇到的问题"><a href="#计算器实现中遇到的问题" class="headerlink" title="计算器实现中遇到的问题"></a>计算器实现中遇到的问题</h2><p>实现这个变种计算器的过程当然也不是一帆风顺的，尤其我是先动手摸索再看的 Chapter 4。以下几个小坑可能还会有新司机踩上，特此写明：</p>
<ul>
<li>开始的语法写输出语句为<code>print: (&#39;print&#39;&#39;(&#39;VAR|expr&#39;)&#39;&#39;;&#39;);</code>没有在<code>VAR|expr</code>外加一层括号，导致后续开发匹配错误。当然，我认为现在开两个备选分支的写法应该更好。</li>
<li>第一次实现时，没有给备选分支加上标签，之后实现 Visitor 时很多方法就需要自己写 if 判断，十分麻烦。通过标签来对每种输入都获得一个不同的事件是坠吼的。</li>
<li>开始的语法写的是<code>WS : [ \t\r\n]+ -&gt; skip;</code>。后来测试时感觉直接跳过换行符好像有时对错误定位会有影响，于是改成现在的样子。</li>
</ul>
<h2 id="我对-ANTLR-的理解"><a href="#我对-ANTLR-的理解" class="headerlink" title="我对 ANTLR 的理解"></a>我对 ANTLR 的理解</h2><p>那么到现在为止，我已经使用 ANTLR 写了几个示例，并完成了一个小项目。经过实际体验，ANTLR 真的可以使我们开发语言类应用程序时，少做很多繁琐的工作。</p>
<p>只要输入一份合法的语法（当然用户需要自行保证语法的准确性），无论多复杂，ANTLR 的语法分析器都能够自动识别，并在运行时以<strong>动态方式</strong>对语法执行分析。相比静态分析必须考虑所有可行的输入序列，动态分析使得我们不必为了适应底层的语法分析策略而扭曲我们语法，从而省略了很多不必要的工作。这是 ANTLR 4 相比其他语法分析器的一个很大的优势。</p>
<p>举个例子，选择使用 ANTLR 进行编译相关的开发工作有一个重要的原因，是它能够自动处理直接左递归（间接左递归暂时不能够）。</p>
<p>我们知道，左递归指某个语言规则在某个备选分支的起始位置调用了自身。由于含有左递归的文法必然不是 LL(1) 文法，也就不可能使用确定的自顶向下分析法。然而，允许使用左递归的文法来表示语言规则又要简洁的多。ANTLR 可以将直接左递归规则自动重写为等价的非左递归形式，省却了不少麻烦。</p>
<p>此外，ANLTR 语法文件独立于程序。在生成的所需的语法分析器之后，我们只需要用熟悉的 Java 来实现我们所需要的语法分析树遍历器（重写部分方法），以符合我们的要求即可。不需要自己去写词法分析器、语法分析器，ANLTR 大大降低了语言类应用程序开发的门槛。</p>
<p>当然，无论工具有多方便，终究只能帮助人完成事务、减少工作量，而非完全替代。想要使用好 ANTLR，还是得对编译原理有透彻的理解。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ANTLR 学习的第二篇笔记到这里就结束了。在这之后我会继续学习解释器构造，阅读《The Definitive ANTLR 4 Reference》，并博客上持续记录学习过程中的一点心得。敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/yuexiang321/article/details/52770283" target="_blank" rel="external">antlr入门实例——计算器 - Yue Xiang - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习解释器构造和 ANTLR。在系列博文的上一篇 &lt;a href=&quot;http://kyonhuang.top/ANTLR-learning-notes-1/&quot;&gt;ANTLR v4 学习笔记（一）－ANTLR 初体验&lt;/a&gt;，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。&lt;/p&gt;
&lt;p&gt;我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。&lt;/p&gt;
&lt;p&gt;这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。&lt;/p&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>yuki-目录文档生成工具</title>
    <link href="http://kyonhuang.top/yuki-intro/"/>
    <id>http://kyonhuang.top/yuki-intro/</id>
    <published>2017-09-14T13:56:35.000Z</published>
    <updated>2017-09-14T15:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。<br>——沃兹基硕德</p>
</blockquote>
<p>受到掘金上看到的 <a href="https://github.com/kenshinji/yddict" target="_blank" rel="external">yddict：一个命令行查单词的工具</a> 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。</p>
<p>看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 <a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a>，蕴含了我个人满满的宅趣味。</p>
<p><img src="/images/yuki/Yuki.jpg"></p>
<p>幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。</p>
<p>这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。</p>
<a id="more"></a>
<h2 id="关于-yuki"><a href="#关于-yuki" class="headerlink" title="关于 yuki"></a>关于 yuki</h2><p>使用 Node.js 开发的项目目录管理工具，能够将项目内文件结构自动映射并生成为 README.md</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/yuki/master/example.gif"></p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">bighuang624/yuki</a></p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>当一份 README.md 的主体内容是项目目录，而你又厌倦了每次增加、修改、删除项目中文件时都要对 README 进行维护，那么不妨试试 yuki！</p>
<p>它可以在极短时间内帮你生成符合要求的 README.md 文档。你更可以通过配置一份 yuki.config.json 来满足你的以下需求：</p>
<ul>
<li>固定文档标题</li>
<li>目录前后增加固定内容</li>
<li>映射时忽略指定文件夹、文件、扩展名</li>
<li>根据指定扩展名选择是否去掉文件名的扩展名或加上书名号</li>
<li>让每个文件都带上 Github 的链接以方便在线跳转查看</li>
</ul>
<p>你可以用 yuki 帮助你轻松维护 github 上类似博客、笔记、代码汇总等项目！</p>
<h3 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h3><p>我的<a href="https://github.com/bighuang624/Algorithms-notes" target="_blank" rel="external">《算法》笔记及代码</a>项目的 README.md 完全通过 yuki 生成。你可以点击以查看效果。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>请确认你使用的电脑有 Node 环境，越新越好。</p>
<h4 id="安装-yuki"><a href="#安装-yuki" class="headerlink" title="安装 yuki"></a>安装 yuki</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g yuki</div></pre></td></tr></table></figure>
<h4 id="进入需要生成-README-md-的文件夹"><a href="#进入需要生成-README-md-的文件夹" class="headerlink" title="进入需要生成 README.md 的文件夹"></a>进入需要生成 README.md 的文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 请将 &lt;dirname&gt; 换为文件夹路径</span></div><div class="line"><span class="built_in">cd</span> &lt;dirname&gt;</div></pre></td></tr></table></figure>
<h4 id="创建-yuki-config-json（可选）"><a href="#创建-yuki-config-json（可选）" class="headerlink" title="创建 yuki.config.json（可选）"></a>创建 yuki.config.json（可选）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch yuki.config.json</div></pre></td></tr></table></figure>
<h4 id="配置-yuki-config-json（可选）"><a href="#配置-yuki-config-json（可选）" class="headerlink" title="配置 yuki.config.json（可选）"></a>配置 yuki.config.json（可选）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  // README.md的大标题（h1），默认为所在文件夹名</div><div class="line">  &quot;title&quot;: &quot;《算法（第4版）》笔记及代码&quot;,</div><div class="line">  // github库地址，如果配置了这项会给每个文件加上超链接</div><div class="line">  // 如果配置，请保证index填写无误，且所有文件名不含空格（否则链接无法正确表示）</div><div class="line">  // branch默认为master</div><div class="line">  &quot;repository&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;https://github.com/bighuang624/Algorithms-notes&quot;,</div><div class="line">    &quot;branch&quot;: &quot;master&quot;</div><div class="line">  &#125;,</div><div class="line">  // 目录开始的标题等级</div><div class="line">  // 默认为2，即该目录下的文件夹名等级从3开始，随层级深入递减</div><div class="line">  &quot;startLevel&quot;: 2,</div><div class="line">  // 需要忽略的目录、扩展名和文件，都以数组表示</div><div class="line">  &quot;ignore&quot;: &#123;</div><div class="line">    &quot;dir&quot;: [&quot;.git&quot;],</div><div class="line">    &quot;extname&quot;: [&quot;.json&quot;],</div><div class="line">    &quot;file&quot;: [</div><div class="line">      &quot;yuki.config.json&quot;,</div><div class="line">      &quot;.gitignore&quot;,</div><div class="line">      &quot;README.md&quot;,</div><div class="line">      &quot;.DS_Store&quot;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  // 根据扩展名选择对展示的文件名做一些处理</div><div class="line">  // 每个扩展名的配置需要单独一个对象</div><div class="line">  // 目前支持省略扩展名&quot;withoutExt&quot;: true</div><div class="line">  // 和加上书名号&quot;withBookmark&quot;: true</div><div class="line">  &quot;format&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;extname&quot;: &quot;.md&quot;,</div><div class="line">      &quot;withoutExt&quot;: true,</div><div class="line">      &quot;withBookmark&quot;: true</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  // 在大标题之后，目录之前添加的内容</div><div class="line">  // 每个对象可选择包含标题、标题等级和内容</div><div class="line">  // 其中，标题和标题等级需在一个对象中一同填写</div><div class="line">  &quot;prefix&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;content&quot;: &quot;[![作者](https:\//img.shields.io\/badge/%E4%BD%9C%E8%80%85-KyonHuang-7AD6FD.svg)](http:\//kyonhuang.top)&quot;</div><div class="line">    &#125;, &#123;</div><div class="line">      &quot;title&quot;: &quot;目录&quot;,</div><div class="line">      &quot;level&quot;: &quot;2&quot;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  // 在README.md末尾添加的内容</div><div class="line">  // 和prefix相同，每个对象可选择包含标题、标题等级和内容</div><div class="line">  &quot;append&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;title&quot;: &quot;维护&quot;,</div><div class="line">      &quot;level&quot;: &quot;2&quot;,</div><div class="line">      &quot;content&quot;: &quot;本文档由 [yuki](https://github.com/bighuang624/yuki) 维护&quot;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 JSON 标准中不含注释，请在使用时将注释去掉。项目中也提供一份不带注释、可供修改使用的 yuki.config.json 模版。</p>
<p>不需要的配置选项请全部删除。</p>
<h4 id="创建-README-md"><a href="#创建-README-md" class="headerlink" title="创建 README.md"></a>创建 README.md</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yuki</div></pre></td></tr></table></figure>
<h3 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h3><p><a href="https://github.com/bighuang624/yuki/blob/master/LICENSE" target="_blank" rel="external">Apache License 2.0</a></p>
<h2 id="开发中的那些事"><a href="#开发中的那些事" class="headerlink" title="开发中的那些事"></a>开发中的那些事</h2><h3 id="Cli-命令工具开发的准备工作"><a href="#Cli-命令工具开发的准备工作" class="headerlink" title="Cli 命令工具开发的准备工作"></a>Cli 命令工具开发的准备工作</h3><p>我们来了解一下围绕 NPM 开发的准备工作。第一步自然是在文件夹下使用命令<code>npm init</code>生成 package.json 文件。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>可以通过以下命令在 NPM 资源库中注册用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm adduser</div></pre></td></tr></table></figure>
<p>之后跟着要求填写 Username、Password、Email 就 ok 了。项目发布前可能需要<code>npm login</code>一下。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>NPM 使用语义版本号来管理代码。语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：</p>
<ul>
<li>如果只是修复 bug，需要更新 Z 位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新 Y 位。</li>
<li>如果有大变动，向下不兼容，需要更新 X 位。</li>
</ul>
<p>当然我这个小项目比较随便，bug 修的多了次版本号看心情也往上升一次。</p>
<p>你可以用<code>npm view &lt;pkg&gt; version</code>来查看你发布到 NPM 项目的现在版本号。</p>
<h4 id="测试小窍门"><a href="#测试小窍门" class="headerlink" title="测试小窍门"></a>测试小窍门</h4><p>这两个小窍门可以节省你在一边开发一边测试的时间（没发现之前，3 天的开发时间花在这上面的不少…）。</p>
<ul>
<li><p>在 package.json 所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;pkg&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
</ul>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><p>想要在全局使用你编写的 cli 工具，你需要在 package.json 加一个 bin 属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"bin": &#123;</div><div class="line">  "yuki": "./index.js"</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>yuki 换做你启动这个程序所要在命令行输入的命令。属性的值是项目的入口文件。添加这个属性后，在命令行执行<code>yuki</code>就等同于执行<code>node ./index.js</code>。</p>
<h4 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h4><p>项目写了一个版本准备发布，先在 package.json 所在目录下用<code>npm version</code>看一下版本号，然后就可以 publish 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> yuki</div><div class="line">npm version</div><div class="line">npm publish</div></pre></td></tr></table></figure>
<p>之后就可以通过全局安装来使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g yuki</div></pre></td></tr></table></figure>
<h3 id="获得程序运行的路径"><a href="#获得程序运行的路径" class="headerlink" title="获得程序运行的路径"></a>获得程序运行的路径</h3><p>说实话，一个我很不擅长的东西就是 API，哪怕是那些非常常用的。这次我一开始就遇到了麻烦：如何获得程序开始遍历的“根目录”路径？</p>
<p>在查找的同时顺便了解了一下获得各种路径的方法，有以下几种：</p>
<ul>
<li><p><code>process.cwd()</code>获得 Node.js 进程当前工作的路径（即执行命令行时候的路径，而非代码路径。例如在根目录下执行<code>node ./xxx/xxx/example.js</code>，则<code>process.cwd()</code>返回的是根目录地址）；</p>
</li>
<li><p><code>__dirname</code>: 获得代码存放的位置（例如运行位于<code>/usr/a</code>目录下的<code>example.js</code>文件：<code>node example.js</code>，则<code>__dirname</code>返回<code>/usr/a</code>）；</p>
</li>
<li><p><code>process.execPath</code>: 返回返回启动 Node.js 进程的可执行文件所在的绝对路径（也就是当前执行的 Node 自身的路径，例如：<code>/usr/local/bin/node</code>）。</p>
</li>
</ul>
<p>根据查询结果和实际需求，应该使用<code>process.cwd()</code>（我们要求在 package.json 所在目录下使用 yuki）。不过实际上使用的是<code>path.resolve()</code>。<code>path.resolve()</code>不含参数时，返回返回当前工作目录的绝对路径，也符合要求。</p>
<p>yuki 的编写也帮助我熟悉了 Node 里的很多 API，尤其是和 path 和 fs 相关的。</p>
<h3 id="先遍历文件再深度遍历文件夹"><a href="#先遍历文件再深度遍历文件夹" class="headerlink" title="先遍历文件再深度遍历文件夹"></a>先遍历文件再深度遍历文件夹</h3><p>开发的过程中发现一个问题：遍历文件夹 a 下的所有文件时，经常先深度遍历了其中的文件夹，导致文件排在这些文件夹深度遍历的结果之后，在生成的 README 中无法看出其准确位置。</p>
<p>解决方法还比较简单，就是在每一次递归的遍历方法中都建立一个队列，遍历到文件夹先推入队列，遍历到文件则展示。所有文件遍历结束后，将队列中的文件夹依次取出并遍历。这样既满足了要求，也没有对深度优先遍历造成影响。</p>
<p>更好的是，JS 的数组原生支持了<code>push</code>方法，使得我不用再写一个队列的实现。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管只是一个微不足道的小工具，我还是很开心能够根据自己的实际需求开发了 yuki，更开心有机会开发一个能在名字中夹私货的项目（早在看到 vue 的版本名时我就一直心心念念了）。</p>
<p>如果你觉得这个小工具还不错，或者使用时觉得很方便、减轻了重复的工作负担，那么不妨为 <a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a> 点一个 star，因为我憧憬着能在毕业前拥有一个自己的 100+ star 项目。</p>
<p><img src="/images/yuki/give-him-first.jpg"></p>
<p>当然，我更希望这些 star 是凭借我自己的开发创意和技术所得到的认可的。而我的开发经验确实不太足，所以如果你觉得这个工具不太好使、代码糟糕、发现了 bug，或是有可以增加的功能，也欢迎你开 issue 或者提交 PR 来告知我。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。&lt;br&gt;——沃兹基硕德&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;受到掘金上看到的 &lt;a href=&quot;https://github.com/kenshinji/yddict&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yddict：一个命令行查单词的工具&lt;/a&gt; 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。&lt;/p&gt;
&lt;p&gt;看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 &lt;a href=&quot;https://github.com/bighuang624/yuki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yuki&lt;/a&gt;，蕴含了我个人满满的宅趣味。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/yuki/Yuki.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。&lt;/p&gt;
&lt;p&gt;这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="开源小项目" scheme="http://kyonhuang.top/categories/%E5%BC%80%E6%BA%90%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="yuki" scheme="http://kyonhuang.top/tags/yuki/"/>
    
      <category term="NPM" scheme="http://kyonhuang.top/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s start Python!</title>
    <link href="http://kyonhuang.top/lets-start-Python/"/>
    <id>http://kyonhuang.top/lets-start-Python/</id>
    <published>2017-09-11T15:03:19.000Z</published>
    <updated>2017-09-20T11:20:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！</p>
<p>今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，Python 这方面的生态环境还是要比 Node 强大不少。当然我也希望不丢掉之前的 JS 和 Node 基础，要时常写点东西或者看看书保持状态。</p>
<p>顺便谈一下，朱老师让我学 Python 2.7，大概是有一些历史遗留问题。但是我在知乎上查了一下，还是决定先看廖雪峰 3.x 版本的 Python 教程。我觉得知乎里一个回答给的建议不错，摘抄一下：</p>
<ul>
<li>学习 Python 前，先了解在 Python 3 里面已经弃用的 Python 2 语法，对这些部分简单带过不要花太多时间；</li>
<li>使用 Python 2，不要使用 Python 2.7 以前的版本；</li>
<li>使用 Python 3，不要使用 Python 3.4 以前的版本；</li>
<li>多了解 Python 2 的<code>__future__</code>库；</li>
<li>对同一份代码，不要为 Python 2 和 Python 3 分别维护分支，努力在一套代码中兼容 Python 2 和 Python 3。</li>
</ul>
<p>根据以上建议，我在 Anaconda 配置了 2.7.13 和 3.6.0 的两种版本。当然这份回答里最重要的还有一句话：</p>
<p><strong>stop talking, just do it！</strong></p>
<p>这一篇大概就讲这么些废话。人生苦短，我用 Python，常听到这句话，现在我就来体验啦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！&lt;/p&gt;
&lt;p&gt;今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，P
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="http://kyonhuang.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR v4 学习笔记（一）－ANTLR 初体验</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-1/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-1/</id>
    <published>2017-09-06T07:34:19.000Z</published>
    <updated>2017-09-21T07:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。</p>
<p>课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。</p>
<p>ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。</p>
<p>更新记录：</p>
<ul>
<li>17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布</li>
<li>17.09.11 Chapter 3 阅读完毕，增加动手上路章节。</li>
<li>17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译</li>
</ul>
<a id="more"></a>
<h2 id="我对编译技术的认识"><a href="#我对编译技术的认识" class="headerlink" title="我对编译技术的认识"></a>我对编译技术的认识</h2><p>在正式进行 ANTLR 的学习前，先让我们聊一聊在经过上学期《编译技术及应用》的学习，以及查阅了有关资料后，我对编译技术和编译工具的一点认识。</p>
<p>说实话，如果单单是谈在《编译技术及应用》这门课上的认识的话，我可能只能像孔乙己一样，接连便是难懂的话，什么“上下文无关文法”，什么“LL(1)”，引得各位都哄笑起来，屏幕内外充满了快活的空气…  </p>
<p>尽管经过了计算器和 JSONCompiler 两次实验，但我们可能对编译技术的应用还没有什么认识，觉得编译器的唯一用处就是写一个能把 xx 语言翻译成 xx 然后再运行成功…</p>
<p>基于写这篇博文的契机，我查了一下编译技术的各种应用，才发现其实“编译”这个概念应用还是很广泛的。</p>
<p>比如我的博客是用 hexo 这个博客框架搭建的，而你现在看到的这篇博文是 hexo 将我写的 markdown 文件解析成 html 生成的，这其中自然有编译模块的功劳（感兴趣可见 <a href="http://www.jianshu.com/p/ef88b5bbb914" target="_blank" rel="external">大前端-5分钟带你读懂Hexo源码设计模式 - 简书</a>）。</p>
<p>再比如作为一个前端，有不少我使用过或日常接触的工具、框架其实都是编译相关知识的应用：Babel 作为 ES 6 的所有新特性还没有在主流浏览器全面推广的一个暂时的解决方法，将 ES 6 编译成 ES 5 等浏览器能够运行的 JavaScript 代码；在 Vue 中频繁出现的模版引擎、<code>v-for=&quot;item in list&quot;</code>等也有编译的身影。如果真正对编译原理理解透彻，大概可以去摸摸 v8 ，帮助提高一下 Node.js 的运行效率。</p>
<p>编程，本质上是程序员通过语言来控制计算机按照人的意志去进行各种运算和操作。自 20 世纪 50 年代早期，第一个只能进行单目运算的编译程序诞生起，编译技术一直作为人与计算机之间的传声筒，支撑着计算机语言的发展，使其更加系统化、合理化。</p>
<p>在知乎上“编译原理学了有什么用？”这个提问下，有答主贴了一幅《C 编译器解剖》序的照片，其中有一段话：</p>
<blockquote>
<p>操作系统和编译器就如武侠小说中的“九阴真经”，没看过“九阴真经”的侠客也可以行走江湖，但看过并练成九阴真经的人最终才更有机会登上华山之巅。</p>
</blockquote>
<p>怀着对程序员之巅的心向往之，我也对编译原理更生敬畏。</p>
<p>当然，如何让这门古老的屠龙术落地，而不至于成为学生心中虚无缥缈的空中楼阁。我个人认为可以再开设一些相关的新课题，让学生能够充分了解编译技术的实用性，从而能够自主学习、实践。我也希望《解释器构造实践》能成为一个不错的起点。</p>
<h2 id="初识-ANTLR"><a href="#初识-ANTLR" class="headerlink" title="初识 ANTLR"></a>初识 ANTLR</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 1 Meet ANTLR。书里的这一章主要是介绍 ANTLR 的下载安装方法，并运行了一个简单的 demo。</p>
</blockquote>
<h3 id="安装-ANTLR"><a href="#安装-ANTLR" class="headerlink" title="安装 ANTLR"></a>安装 ANTLR</h3><p>ANTLR 是用 Java 编写的，所以就算你想使用 C# 或者 C++ 来配合 ANTLR 生成解释器，安装 ANTLR 前也需要有 Java 环境。</p>
<p>之后需要下载 antlr-4.x-complete.jar（越新越好，4.x 指最新版本的版本号）并把它放在你记得住的地方。这个 jar 包包含了运行 ANTLR 工具所需要的所有依赖，还包含两个支持库：一个树状排版库，以及 StringTemplate，一个用于生成代码以及其他结构化文本的模版引擎。</p>
<p>安装的具体步骤请直接看<a href="http://www.antlr.org/" target="_blank" rel="external">官网</a>的 Quick Start，在此不作展示。</p>
<h2 id="ANTLR-全貌"><a href="#ANTLR-全貌" class="headerlink" title="ANTLR 全貌"></a>ANTLR 全貌</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 2 The Big Picture，书中这一章介绍了从字符流到语法分析树的过程、ANTLR 运行流程中的一些重要术语，以及ANTLR 自带的 Listener、Visitor 这两种遍历树的机制。</p>
</blockquote>
<p>想要实现一种语言，我们就需要构建读取句子的应用，并对输入的元素做出正确的反应。</p>
<p>如果一个应用可以计算或执行句子，我们就叫它<strong>解释器（interpreter）</strong>。包括计算器、配置文件读取器、Python 解释器都属于解释器。</p>
<p>而如果一个应用将句子转换成另一种语言，我们就叫它<strong>翻译器（translator）</strong>。例如 Java 到 C# 的翻译器和<strong>编译器</strong>都属于翻译器。</p>
<p>不管是解释器还是翻译器，想要正确运行，应用首先都要识别出所有有效的句子、词组、字词组等，识别语言的程序就叫<strong>解析器（parser）</strong>或<strong>语法分析器（syntax analyzer）</strong>。</p>
<p>完全 DIY 一个解析器非常麻烦，所以我们需要 ANTLR 的帮助。ANTLR 是一种能写出程序的程序，只需编写 ANTLR 的语法（grammars）文件，描述我们要解析的语言的语法，ANTLR 就能够自动生成用来解析这种语言的解析器。而用来声明我们语言的ANTLR语言的语法，就是<strong>元语言（meta-language）</strong>。</p>
<h3 id="最基本的解析过程"><a href="#最基本的解析过程" class="headerlink" title="最基本的解析过程"></a>最基本的解析过程</h3><p>为了简单起见，我们将解析分为两个阶段，第一阶段是<strong>词法分析（lexical analysis）</strong>，对应的分析程序叫做<strong>词法分析器（lexer）</strong>，负责将符号（token）分组成<strong>符号类（token class or token type）</strong>。而第二阶段就是真正的<em>语法分析</em>，默认 ANTLR 会构建出一棵<strong>语法分析树（parse tree / syntax tree）</strong>。下图展示了一个简单的赋值表达式的解析过程：</p>
<p><img src="/images/antlr/note1/antlr1.jpg"></p>
<p>语法树的叶子是输入的 token，而上级结点是包含其孩子结点的词组名（phase），线性的句子其实是语法树的序列化。最终生成语法树的好处是：</p>
<ol>
<li>树形结构易于遍历和处理，并且容易被程序员理解，方便了应用代码做进一步处理。</li>
<li>多种解释或翻译的应用代码都可以重用一个解析器。但 ANTLR 也支持像传统解析器生成器那样，将应用处理代码直接嵌入到语法中。</li>
<li>对于因为计算依赖而需要多趟处理的翻译器来说，比起多次调用解析器去解析，遍历语法树多次更加高效。</li>
</ol>
<h3 id="深入-ANTLR-的解析过程"><a href="#深入-ANTLR-的解析过程" class="headerlink" title="深入 ANTLR 的解析过程"></a>深入 ANTLR 的解析过程</h3><p>ANTLR 生成的解析器叫做<strong>递归下降语法分析器（recursive-descent parser）</strong>，属于自顶向下语法分析器（top-down parser）的一种。</p>
<p>顾名思义，递归下降指的就是解析过程是从语法树的根开始，向叶子（token）递归。还是以前面的赋值表达式解析为例，其递归下降语法分析器的代码大概是下面这个样子：</p>
<p><img src="/images/antlr/note1/antlr2.jpg"></p>
<p>很酷的一点是<code>stat()</code>、<code>assign()</code>、<code>expr()</code>等方法调用所形成的调用栈能与语法分析树的内部节点一一对应。<code>match()</code>的调用对应树的叶子，而<code>assign()</code>方法直接顺序读取输入字符，而不用做任何选择。相比之下，<code>stat()</code>方法要复杂一些，因为在解析时，它需要<strong>向前看（lookahead）</strong>一些字符才能确认走哪个代码分支，有时甚至要读取完所有输入才能得出预测结果。</p>
<p>虽然 ANTLR 默默地为我们处理了这整个过程，但对这个选择过程有一个基本的了解会使得对生成的解析器进行 debug 变得更加容易。</p>
<h3 id="用语法分析树构建语言应用"><a href="#用语法分析树构建语言应用" class="headerlink" title="用语法分析树构建语言应用"></a>用语法分析树构建语言应用</h3><p>在内部，ANTLR 的数据结构会尽可能地共享数据来节约内存。如下图所示，语法分析树的叶子节点指向 token 流中的 token，而 token 中的起止字符索引指向字符流，并不拷贝子字符串。而像空格这种不与任何 token 相关的字符会直接被 Lexer 丢弃掉。</p>
<p><img src="/images/antlr/note1/antlr3.jpg"></p>
<p>ANTLR 为每条规则都会生成一个 RuleNode，叫做<strong>上下文（Context）对象</strong>，它会记录根据规则识别词组时产生的所有上下文信息。每一个上下文对象都知道已经识别的短语的起始 token 和结束 token，并且提供了对这些短语的访问。例如，<code>AssignContext</code>提供<code>ID()</code>和<code>expr()</code>方法来访问标识符节点和表达式子树。</p>
<h3 id="语法分析树的-Listener-和-Visitor-机制"><a href="#语法分析树的-Listener-和-Visitor-机制" class="headerlink" title="语法分析树的 Listener 和 Visitor 机制"></a>语法分析树的 Listener 和 Visitor 机制</h3><p>ANTLR 在其运行库提供了 Listener 和 Visitor 两种语法分析树遍历机制。</p>
<h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>Listener 的特点是全自动化，我们不必写一个语法分析树的遍历器，ANTLR 会生成一个 ParseTreeWalker 的子类来主导深度优先遍历过程，我们只需处理各种事件就可以了。例如当遍历器遍历到<code>assign</code>规则的节点时，会触发<code>enterAssign()</code>并向其传递<code>AssignContext</code>参数；而当遍历器遍历完<code>assign</code>节点的所有子节点时，触发<code>exitAssign()</code>。下图展示了 ParseTreeWalker 如何进行深度优先遍历：</p>
<p><img src="/images/antlr/note1/antlr4.jpg"></p>
<p>而下图展示了 ParseTreeWalker 的完整监听器方法调用队列：</p>
<p><img src="/images/antlr/note1/antlr5.jpg"></p>
<h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h4><p>而 Visitor 则提供了可控的遍历方式，我们可以自行决定是否将子结点作为参数调用<code>visit()</code>方法。</p>
<p>在使用 ANTLR 生成时加上参数<code>-visitor</code>，会生成带有默认实现的 Visitor 实现类。我们不必实现接口中的每一个方法，只需要覆盖我们感兴趣的方法。</p>
<p><img src="/images/antlr/note1/antlr6.jpg"></p>
<h2 id="动手上路"><a href="#动手上路" class="headerlink" title="动手上路"></a>动手上路</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 3 A Starter ANTLR Project。</p>
</blockquote>
<h3 id="ANTLR-工具，运行时类库和生成代码"><a href="#ANTLR-工具，运行时类库和生成代码" class="headerlink" title="ANTLR 工具，运行时类库和生成代码"></a>ANTLR 工具，运行时类库和生成代码</h3><p>ANTLR 分为两个重要的部分：ANLTR 工具自身和 ANTLR 运行时（runtime） API。运行 ALTLR 工具会生成能够辨认语法所描述语言的句子的代码（词法分析程序和语法分析程序）；而运行时类库提供了生成代码所需的一系列类与方法，例如 Parser, Lexer 和 token。</p>
<p>我们先对一份语法运行 ANTLR，然后借助 jar 包中的运行时类库（runtime classes in the jar）对生成的代码进行编译。最后，编译得到的应用与运行库结合着运行。</p>
<p>《The Definitive ANTLR 4 Reference》（后文可能简写为《Reference》）给出了一份简单的示例，让我们可以快速了解 ANTLR 所需语法的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Grammers always start with a grammer header. This grammer */</span></div><div class="line"><span class="comment">/** is called ArrayInit and must match the filename: ArrayInit.g4 */</span></div><div class="line">grammar ArrayInit;</div><div class="line"></div><div class="line"><span class="comment">/** A rule called init that that matches comma-separated values between &#123;...&#125; */</span></div><div class="line">init : <span class="string">'&#123;'</span> value (<span class="string">','</span> value)* <span class="string">'&#125;'</span> ;  <span class="comment">// must match at least one value</span></div><div class="line"></div><div class="line"><span class="comment">/** A value can be either a nested array/struct or a simple integer (INT) */</span></div><div class="line">value : init</div><div class="line">      | INT</div><div class="line">      ;</div><div class="line">      </div><div class="line"><span class="comment">// parser rules start with lowercase letters, lexer rules with uppercase</span></div><div class="line">INT :  [<span class="number">0</span>-<span class="number">9</span>]+ ;              <span class="comment">// Define Token INT as one or more digits</span></div><div class="line">WS  :  [ \t\r\n]+ -&gt; skip ;  <span class="comment">// Define whitespace rule, toss it out</span></div></pre></td></tr></table></figure>
<p>之后通过命令行运行<code>antlr4 ArrayInit.g4</code>，ANTLR 为我们生成很多一般需要我们自己手写的文件：</p>
<p><img src="/images/antlr/note1/antlr-generation.jpg"></p>
<p>这些文件的功能如下：</p>
<ul>
<li>ArrayInitParser.java：包含了专用于 ArrayInit 语法的解析器（parser）类的定义。</li>
<li>ArrayInitLexer.java：包含专用的词法分析程序（lexer）类的定义。</li>
<li>ArrayInit.Tokens：对于我们定义的每个 token，ANTLR 分配了一个 token 类型码（token type number）并将这些值保存在 ArrayInit.tokens。因为这个文件的存在，当我们将较大规模的语法分割为各种小型的语法表达时，ANTLR 能够使同种 token 的类型码保持一致。</li>
<li>ArrayInitListener.java, ArrayInitBaseListener.java：ANTLR 生成的解释器会默认根据输入构建一棵树。通过遍历这棵树，一个遍历器可以将事件（回调函数）传递给我们提供的监听者对象（listener object）。ArrayInitListener 是描述我们可以实现的回调函数的接口，而ArrayInitBaseListener 是默认空实现的集合，使我们可以方便的重写（override）那些我们感兴趣的回调函数。通过<code>-visitor</code>命令行参数，ANTLR 也可以为我们生成树的 visitors。</li>
</ul>
<h3 id="测试生成的解析器"><a href="#测试生成的解析器" class="headerlink" title="测试生成的解析器"></a>测试生成的解析器</h3><p>之后，我们通过<code>javac *.java</code>来编译 ANTLR 生成的所有代码。UNIX 系统用户可以将以下代码写入<code>.bash_profile</code>或其他启动脚本，以免每次都要在命令行输入一遍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> CLASSPATH=<span class="string">".:/usr/local/lib/antlr-4.7-complete.jar:<span class="variable">$CLASSPATH</span>"</span></div><div class="line"><span class="built_in">alias</span> antlr4=<span class="string">'java -jar /usr/local/lib/antlr-4.7-complete.jar'</span></div><div class="line"><span class="built_in">alias</span> grun=<span class="string">'java org.antlr.v4.gui.TestRig'</span></div></pre></td></tr></table></figure>
<p>之后就可以通过<code>grun</code>命令来测试生成的解析器了。注意输入要以 EOF（Unix 系统 Ctrl + D，Windows 系统 Ctrl + Z）作为结束。加上<code>-tokens</code>命令行参数，输出的每一行会展示一个单独的 token 及其所有信息：</p>
<p><img src="/images/antlr/note1/grun-the-example1.jpg"></p>
<p><code>-tree</code>会生成一个 Lisp 风格的简单语法分析树：</p>
<p><img src="/images/antlr/note1/grun-the-example2.jpg"></p>
<p>而<code>-gui</code>会生成一个展示语法分析树的 GUI 界面：</p>
<p><img src="/images/antlr/note1/grun-the-example3.jpg"></p>
<p><img src="/images/antlr/note1/grun-the-example4.jpg"></p>
<p>根据我们定义的语法规则，ANTLR 自动生成了这棵语法分析树。之后我们会利用 ANTLR 内置的遍历器触发<code>enterInit()</code>和<code>enterValue()</code>等各种回调函数。</p>
<h3 id="将生成的解析器集成进-Java-程序"><a href="#将生成的解析器集成进-Java-程序" class="headerlink" title="将生成的解析器集成进 Java 程序"></a>将生成的解析器集成进 Java 程序</h3><p>我们来写一个简单的 Java <code>main()</code>方法来集成生成的解析器，并打印出和使用<code>-tree</code>参数一样的语法分析树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import ANTLR's runtime libraries</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// create a CharStream that reads from standard input</span></div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</div><div class="line">        </div><div class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></div><div class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</div><div class="line">        </div><div class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        </div><div class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></div><div class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</div><div class="line">        </div><div class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></div><div class="line">        System.out.println(tree.toStringTree(parser));  <span class="comment">// print LISP-style tree</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果如下。语法错误也可以被报告：</p>
<p><img src="/images/antlr/note1/integrating-test.jpg"></p>
<h3 id="构建语言应用"><a href="#构建语言应用" class="headerlink" title="构建语言应用"></a>构建语言应用</h3><p>我们的目标不仅仅是识别，还想做一些翻译工作。最简单的方法是利用 ANTLR 内置的语法分析树遍历器，这样我们不需要自己去进行树遍历，大大减少了工作量。</p>
<p>我们给 ArrayInit 加一个新需求：将 short 数组<code>{99, 3, 451}</code>翻译为字符串<code>\u0063\u0003\u01c3</code>。实现这个需求，我们只需要继承<code>ArrayInitBaseListener</code>，来实现其中的一些监听器方法。</p>
<p>我们在 ShortToUnicodeString.java 中实现我们的监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Convert short array inits like &#123;1, 2, 3&#125; to "\u0001\u0002\u0003" */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToUnicodeString</span> <span class="keyword">extends</span> <span class="title">ArrayInitBaseListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">'"'</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">'"'</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterValue</span><span class="params">(ArrayInitParser.ValueContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> value = Integer.valueOf(ctx.INT().getText());</div><div class="line">        System.out.printf(<span class="string">"\\u%04x"</span>, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们不需要覆盖每一个<code>enter/exit</code>方法，只需要实现我们需要的那些。代码里<code>ctx.INT()</code>代表上下文对象请求已经匹配的整数 INT 的值。记住我们之前提到的，上下文对象会记录根据规则识别词组时产生的所有信息。</p>
<p>接下来，我们要创建一个主程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import ANTLR's runtime libraries</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// create a CharStream that reads from standard input</span></div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</div><div class="line">        </div><div class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></div><div class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</div><div class="line">        </div><div class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        </div><div class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></div><div class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</div><div class="line">        </div><div class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></div><div class="line">        </div><div class="line">        <span class="comment">// Create a generic parse tree walker that can trigger callbacks</span></div><div class="line">        ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</div><div class="line">        </div><div class="line">        <span class="comment">// Walk the tree created during the parse, trigger callbacks</span></div><div class="line">        walker.walk(<span class="keyword">new</span> ShortToUnicodeString(), tree);</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比起上一节的主程序，我们多创建了一个树遍历器（<code>ParseTreeWalker walker</code>），并用它来遍历语法分析器返回的语法分析树，它会触发<code>ShortToUnicodeString</code>中的回调方法。</p>
<p>javac 进行编译后就可以使用了：</p>
<p><img src="/images/antlr/note1/translate-test.jpg"></p>
<p>我们可以通过传入不同的监听器来产生完全不同的输出。监听器将语法和我们的语言应用很大程度上解耦了，使语法具有了更大的重用性。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>第一篇笔记到这里就结束了。我们聊了一下我对编译技术的一点看法，并阅读了《The Definitive ANTLR 4 Reference》的前三章。而书的 Part I: Introducing ANTLR and Computer Languages 还剩第四章 A Quick Tour，根据实验课的要求，这一章我会单独写一篇学习笔记，示例与内容也会和书上有一些区别。在这之后我会继续学习解释器构造，并继续写这本书的阅读笔记，敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/dc_726/article/details/45399371" target="_blank" rel="external">Antlr v4入门教程和实例 - 西代零零发 - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。&lt;/p&gt;
&lt;p&gt;课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。&lt;/p&gt;
&lt;p&gt;ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。&lt;/p&gt;
&lt;p&gt;更新记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布&lt;/li&gt;
&lt;li&gt;17.09.11 Chapter 3 阅读完毕，增加动手上路章节。&lt;/li&gt;
&lt;li&gt;17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Node 学习中遇到的 repo 和 ideas（持续更新）</title>
    <link href="http://kyonhuang.top/Node-repo-and-ideas/"/>
    <id>http://kyonhuang.top/Node-repo-and-ideas/</id>
    <published>2017-09-03T11:03:16.000Z</published>
    <updated>2017-09-19T12:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>对 Node 有所学习后，有时感觉无所不能，真正想做一些 demo 时又自觉无能；有时突发奇想一些 ideas，有时间想敲 demo 时又有点无所事事；有时看到一些有用或者有趣的库，事后又忘的干干净净。所以专门开一篇博文，一是记录一些常用的或者没用过有机会想体验的库，二是记录一些 ideas，等着有时间、有能力、有兴趣时来实现。</p>
<h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ul>
<li><a href="https://github.com/mikeal/r2" target="_blank" rel="external">r2</a>：request 模块的作者新写的 HTTP 请求模块，基于 Promise 及 async/await 实现，让 Ajax 写法更轻松（不过功能应该和 superagent 基本一致，API 不同而已，不强迫使用）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> r2 = <span class="built_in">require</span>(<span class="string">'r2'</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> html = <span class="keyword">await</span> r2(<span class="string">'https://www.google.com'</span>).text</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://visionmedia.github.io/superagent" target="_blank" rel="external">superagent</a> + <a href="https://github.com/jpodwys/superagent-cache" target="_blank" rel="external">superagent-cache</a></li>
</ul>
<h3 id="html-文本分析"><a href="#html-文本分析" class="headerlink" title="html 文本分析"></a>html 文本分析</h3><ul>
<li><a href="https://github.com/cheeriojs/cheerio/blob/master/Readme.md" target="_blank" rel="external">cheerio</a>：Node 中的 jQuery</li>
</ul>
<h2 id="ideas"><a href="#ideas" class="headerlink" title="ideas"></a>ideas</h2><ul>
<li>大黄说：个人短日志记录的小程序</li>
<li>知乎爬虫：可以参考<a href="https://juejin.im/post/5943526fac502e006c71c242" target="_blank" rel="external">基于node的微小爬虫——扒了一下知乎 - 掘金</a>，需要考虑一下具体需求</li>
<li>markdown 按格式解析成 html：这个具体结合把我的歌词变成 html</li>
<li>与机器人实时聊天：可以参考 <a href="https://github.com/hua1995116/webchat" target="_blank" rel="external">基于vue2.0的实时聊天项目</a>，可以了解一下机器人和 Socket.io</li>
<li>带后台和 SSR 的博客</li>
<li>yuki：一个小工具，可以将算法的文件和笔记维护到大的 README.md 中，用一个 config.js 加以配置［已开发：<a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a>］</li>
<li>一个带前端、后台、数据库的，管理什么书单、这个 ideas，或者个人每天想法什么的 micro website。这个应该作为 node 和云服务器练手不错，然后留出接口应该还可以给第一个 idea 用。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 Node 有所学习后，有时感觉无所不能，真正想做一些 demo 时又自觉无能；有时突发奇想一些 ideas，有时间想敲 demo 时又有点无所事事；有时看到一些有用或者有趣的库，事后又忘的干干净净。所以专门开一篇博文，一是记录一些常用的或者没用过有机会想体验的库，二是记
    
    </summary>
    
      <category term="NodeJS 学习笔记" scheme="http://kyonhuang.top/categories/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Node 异步 I/O</title>
    <link href="http://kyonhuang.top/async-IO-in-Node/"/>
    <id>http://kyonhuang.top/async-IO-in-Node/</id>
    <published>2017-09-02T12:43:16.000Z</published>
    <updated>2017-09-20T07:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。</p>
<p>Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。</p>
<p>因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。</p>
<p>这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。</p>
<a id="more"></a>
<h2 id="选择异步的原因"><a href="#选择异步的原因" class="headerlink" title="选择异步的原因"></a>选择异步的原因</h2><p>选择异步的原因包括用户体验和资源分配两个方面。</p>
<p>从用户体验的角度分析，浏览器中 JavaScript 在单线程上执行，并且与 UI 渲染共用一个线程。因此采用异步请求将使下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为。</p>
<p>而从资源分配角度来看，当遇到一组互不相关的任务需要完成的场景时，主流选择有以下两种：</p>
<ul>
<li>单线程串行依次执行：容易导致阻塞，硬件资源难以有效利用；</li>
<li>多线程并行：创建线程和执行期线程上下文切换的开销较大，且经常面临锁、状态同步等问题（但多线程在多核 CPU 上能够有效提升 CPU 的利用率）；</li>
</ul>
<p>而 Node 给出的解决方案是：利用<strong>单线程</strong>，远离多线程死锁、状态同步等问题；利用<strong>异步 I/O</strong>，让单线程远离阻塞以更好地利用 CPU。</p>
<p>而为了弥补单线程无法有效利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效利用 CPU 和 I/O。</p>
<h2 id="从操作系统看异步-I-O"><a href="#从操作系统看异步-I-O" class="headerlink" title="从操作系统看异步 I/O"></a>从操作系统看异步 I/O</h2><p>Node 的异步 I/O 不可否认地受到操作系统中异步 I/O 实现的启发。</p>
<p>要强调的是，从计算机内核 I/O 而言，<strong>异步/同步和阻塞/非阻塞实际上是两回事</strong>。</p>
<h3 id="阻塞-非阻塞-I-O"><a href="#阻塞-非阻塞-I-O" class="headerlink" title="阻塞/非阻塞 I/O"></a>阻塞/非阻塞 I/O</h3><p>在调用<strong>阻塞 I/O</strong> 时，应用程序需要等待 I/O 完成时才返回结果。特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束，因此造成 <strong>CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用</strong>。</p>
<p>与阻塞 I/O 完成整个获取数据的过程相比，<strong>非阻塞 I/O</strong> 则<strong>不带数据直接返回</strong>，要获取数据还需要通过<strong>文件描述符</strong>再次读取。非阻塞 I/O 返回之后，CPU 的时间片可以用来处理其他事务。</p>
<p>但由于完整的 I/O 并没有完成，非阻塞 I/O 立即返回的仅仅是当前调用的状态。为了获取完整数据，需要<strong>轮询</strong>这种重复调用以判断操作是否完成的技术。</p>
<p>现存的轮询技术包括 <strong>read</strong>（通过重复调用检查 I/O 状态，性能最低，CPU 一直等待）、<strong>select</strong>（通过对文件描述符上的事件状态进行判断）、<strong>poll</strong>（比 select 有所改进，但性能仍较低）、<strong>epoll</strong>（Linux 下<strong>效率最高</strong>的 I/O 事件通知机制，进入轮询时休眠，直到事件发生将其唤醒）和<strong>kqueue</strong>（与 epoll 类似，仅在 FreeBSD 系统存在）。</p>
<p>虽然轮询技术能够满足了非阻塞 I/O 确保获取完整数据的需求，但应用程序依旧花费了很多时间来等待 I/O 完全返回。等待期间，CPU 要么用于<strong>遍历文件描述符的状态</strong>，要么用于<strong>休眠等待事件发生</strong>。因此，<strong>它仍然只能算是一种同步</strong>。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>在看廖雪峰的 Python 教程的异步 IO 这一章时，在评论区看到一个对于阻塞/非阻塞和同步/异步非常精妙的解释，十分容易理解和记忆，特摘录如下：</p>
<blockquote>
<p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p>
<p>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻</p>
<p>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</p>
<p>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大</p>
<p>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p>
<p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p>
<p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</blockquote>
<h3 id="异步-I-O-的实现"><a href="#异步-I-O-的实现" class="headerlink" title="异步 I/O 的实现"></a>异步 I/O 的实现</h3><p>我们期望的完美异步 I/O 应该是：应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序即可。</p>
<p>Linux 原生提供 AIO 这种符合要求的异步 I/O 方式，但只有 Linux 下有，且其无法利用系统缓存。因此现实情况下，想在单线程场景完美实现异步 I/O 有些难度。</p>
<p>而在<strong>多线程</strong>，通过<strong>让部分线程进行阻塞 I/O 或者非阻塞 I/O 加载轮询技术来完成数据获取，让一个线程进行计算处理，再通过线程间的通信将 I/O 得到的数据进行传递</strong>，可以模拟异步 I/O。</p>
<p>*nix 平台，Node 自行实现了线程池来完成异步 I/O；Windows 平台则采用 IOCP 实现。Node 提供了 libuv 作为抽象封装层，平台兼容性由这一层完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。</p>
<p>Node 在<strong>编译期间判断平台条件</strong>，选择性编译 unix 目录或 win 目录下的源文件到目标程序中。</p>
<ul>
<li>我们常说的“Node 是单线程的”里的“单线程”仅指 <strong>JavaScript 执行在单线程</strong>。而内部完成 I/O 任务的另有线程池，只是 I/O 线程使用的 CPU 较少。</li>
<li>除了用户代码无法并行执行外，所有的 I/O （磁盘 I/O 和网络 I/O 等）可以并行。</li>
</ul>
<h2 id="Node-的异步-I-O"><a href="#Node-的异步-I-O" class="headerlink" title="Node 的异步 I/O"></a>Node 的异步 I/O</h2><p><strong>事件循环</strong>、<strong>观察者</strong>、<strong>请求对象</strong>、<strong>I/O 线程池</strong>一同构成了 Node 异步 I/O 模型的基本要素。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>每执行一次循环体的过程被称为 <strong>Tick</strong>，查看是否有事件待处理，若有则取出事件及相关回调函数。如果存在关联的回调函数，就执行它们。直到没有事件，进入下个循环。</p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>每个事件循环中有一个或者多个观察者，<strong>判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</strong>。</p>
<p>事件循环是一个典型的<strong>生产者/消费者模型</strong>。<em>异步 I/O、网络请求</em>是事件的<em>生产者</em>，事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。<strong>观察者相当于事件池</strong>。</p>
<p>在 Windows 下，这个循环基于 IOCP 创建，而在 *unix 下基于多线程创建。</p>
<h3 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h3><p>请求对象是从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中的重要<strong>中间产物</strong>。所有的状态都保存在这个对象中，包括<strong>送入 I/O 线程池等待执行</strong>以及 I/O 操作完毕后的回调处理。</p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><p>组装好请求对象、送入 I/O 线程池等待执行，构成了异步 I/O 的第一部分。而回调通知是第二部分。</p>
<p>线程池中的 I/O 操作调用完毕后，会调用方法向 IOCP 提交执行状态，并将线程归还线程池。</p>
<p>在每次 Tick 的执行中，I/O 观察者会调用方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。</p>
<p>整个异步 I/O 流程图如下：</p>
<p><img src="/images/async IO model.jpg"></p>
<h2 id="非-I-O-的异步-API"><a href="#非-I-O-的异步-API" class="headerlink" title="非 I/O 的异步 API"></a>非 I/O 的异步 API</h2><p>Node 中还存在一些与 I/O 无关的异步 API：<code>setTimeout()</code>、<code>setInterval()</code>、<code>setImmediate()</code>、<code>process.nextTick()</code>。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><code>setTimeout()</code>和<code>setInterval()</code>与浏览器 API 一致，创建的定时器会被插入到<strong>定时器观察者内部的一个红黑树</strong>中。每次 Tick 执行时，会从该红黑树中<strong>迭代</strong>取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件并执行其回调函数。注意：由于事件循环自身特点，定时器并非精确的。</p>
<h3 id="process-nextTick-amp-setImmediate"><a href="#process-nextTick-amp-setImmediate" class="headerlink" title="process.nextTick() &amp; setImmediate()"></a>process.nextTick() &amp; setImmediate()</h3><p>两者都可用于将回调函数延迟执行，以异步执行一个任务。两者的区别如下：</p>
<ul>
<li><p>优先级：<code>process.nextTick()</code>中回调函数执行优先级要高于<code>setImmediate()</code>，原因在于<strong>事件循环对观察者的检查是有先后顺序的</strong>，idle 观察者（<code>process.nextTick()</code>） &gt; I/O 观察者 &gt; check 观察者（<code>setImmediate()</code>）。</p>
</li>
<li><p>具体实现：<code>process.nextTick()</code>的回调函数保存在一个<em>数组</em>中，<code>setImmediate()</code>保存在<em>链表</em>中。</p>
</li>
<li><p>行为：<code>process.nextTick()</code>在每轮循环中会将数组中的回调函数<em>全部执行</em>完，而<code>setImmediate()</code>在每轮循环中执行链表中的<em>一个</em>回调函数。这样的设计是为了保证每轮循环能够较快地执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。</p>
</li>
</ul>
<h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p>事件驱动的实质：通过<strong>主循环加事件触发</strong>的方式来运行程序。</p>
<p>几种经典的服务器模型各有其优缺点：</p>
<ul>
<li><strong>同步式</strong>：对于同步式的服务，一次只能处理一个请求，并且其他请求都处于等待状态。</li>
<li><strong>每进程/每请求</strong>：为每个请求启动一个进程，这样可以处理多个请求，但因为系统资源有限而不具备扩展性。</li>
<li><strong>每线程/每请求</strong>：为每个请求启动一个线程来处理。扩展性强于每进程/每请求，但由于每个线程都占用一定内存，大并发到来时内存还是会很快用光。</li>
</ul>
<p>Apache 目前还采用每线程/每请求，而 Nginx 采用事件驱动。</p>
<p>Nginx 与 Node 比较：</p>
<ul>
<li>Nginx 采用纯 C 写成，性能较高，但仅适合做 Web 服务器，用于反向代理或负载均衡等服务，在处理具体业务方面欠缺；</li>
<li>Node 是一套高性能平台，没有 Nginx 在 Web 服务器方面那么专业，但场景更大，可以处理各种具体业务。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入浅出Node.js》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。&lt;/p&gt;
&lt;p&gt;Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。&lt;/p&gt;
&lt;p&gt;因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。&lt;/p&gt;
&lt;p&gt;这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS 学习笔记" scheme="http://kyonhuang.top/categories/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="异步 I/O" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5-I-O/"/>
    
  </entry>
  
  <entry>
    <title>夏天就要过去</title>
    <link href="http://kyonhuang.top/summer-time-gone/"/>
    <id>http://kyonhuang.top/summer-time-gone/</id>
    <published>2017-08-29T10:22:33.000Z</published>
    <updated>2017-09-02T12:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=587963&auto=0&height=66"></iframe>

<p>现在是 2017 年的 8 月 29 号，离 9 月还有 2 天。大三近在咫尺，而夏天就要过去。</p>
<p>前几天的 ASL 舞台上，平野绫、茅原实里、后藤邑子三人毫无征兆地重新聚首，演唱了《凉宫春日的忧郁》的 ED《ハレ晴レユカイ（晴天好心情）》。06 年的最强动画，我最爱的动画，11 年后再看到这些人，恍如隔世。</p>
<p><img src="/images/forever-SOS.jpg"></p>
<p>过去是体育场旁的石板路，现在是教学楼到二食堂的小道，低头时摇曳的叶影把光束割出形状，抬头看到的是一成不变的蓝天白云。闻着空气里隐约弥漫着躁动的气息，你会产生错觉，真的以为八月是漫无止境的，度过的每一天会被慷慨归还。</p>
<p>只是在那个古老的不再回来的夏日，所有的结局都已写好，所有的泪水也都已启程。</p>
<p>“夏天就要过去”这句话念来，总有淡淡的感伤。也许正因如此，我才喜欢上夏天。</p>
<a id="more"></a>
<h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><h3 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h3><p>好了，矫情完毕。暑假还是老毛病，后期学习效率不高。目前成果和暑假计划写的还是有些差距。</p>
<p>《深入浅出 Node.js》读了几章，感觉确实有些深，很多章节涉及到操作系统的知识，而且没有大量实践经验可能很难领会其精髓。所以将前四章（主要是异步 I/O 和异步编程）总结成一个笔记，然后根据需要看一下第八章-构建 Web 应用后，就先暂停这本书的阅读。</p>
<p>之后看《你不知道的 JavaScript（中卷）》。这本因为前两章讲繁琐的强制转换的知识，看的我晕头转向（JS 里的各种显隐式转换至少从表面上看毫无规律，为人诟病），所以当时停下来了。现在还是要啃完，之后还有下卷。这一系列书还是将 JS 的细节讲的比较全面的。</p>
<p>看完以上之后可以考虑啃《JavaScript 设计模式与开发实践》。不过可能下学期时间不太够，量力而行。还要啃一下《计算机网络－自顶向下方法》的前几章，虽然是课本，也做笔记和脑图。</p>
<h3 id="项目练习"><a href="#项目练习" class="headerlink" title="项目练习"></a>项目练习</h3><ul>
<li>做了一个简单的<a href="http://kyonhuang.top/resume/">在线个人简历</a>，只用到了 vue 和 axios；</li>
<li>上手了 electron，将上述的个人简历包装成桌面程序扔到了 Github 上：<a href="https://github.com/bighuang624/electron-demo" target="_blank" rel="external">bighuang624/electron-demo
</a>。十分粗糙，而且在 mac 上的程序大小达到 122 MB。如果有时间和兴趣可以深入研究，最好是再拿一个前后端项目来做小白鼠；</li>
<li>今天想用 Node.js 重写之前的基于 Java 的 BiliBili 视频爬虫。不过折腾半天，感觉 B 站有了更严的反爬机制，还没有研究出怎么爬（估计之前的那个爬虫现在也不能用了）…</li>
<li>跟着教程摸了摸 express 和 koa。准备写一个有后台的项目，成功了就买一个服务器折腾折腾挂上去。</li>
</ul>
<p>可以看到项目练习这一块也不算特别满意。要求自己在夏令营之前有两到三个还（neng）不（hu）错（ren）的项目。</p>
<h3 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h3><p>要开始准备保研了。</p>
<ul>
<li>这学期要准备一下六级，争取考到 600 分以上，才不至于掉底子；</li>
<li>找一个实验室干点活，找不到靠谱的就算了；</li>
<li>想办法看科研和竞赛能不能有些东西；</li>
<li>保持绩点。这学期一定不能翘课，全部争取满分。而且要稍微多选一点课，尽量不留选修课。</li>
<li>慢慢读《算法》，一天 5 面吧。天杨说笔试蛮关键的，什么数据结构与算法、操作系统、机组等知识大三下学期都要重新捡起来。</li>
</ul>
<p>虽然没有企望过，但也许我可以走的稍微远一点。那就开始努力吧，因为夏天就要过去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=587963&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;现在是 2017 年的 8 月 29 号，离 9 月还有 2 天。大三近在咫尺，而夏天就要过去。&lt;/p&gt;
&lt;p&gt;前几天的 ASL 舞台上，平野绫、茅原实里、后藤邑子三人毫无征兆地重新聚首，演唱了《凉宫春日的忧郁》的 ED《ハレ晴レユカイ（晴天好心情）》。06 年的最强动画，我最爱的动画，11 年后再看到这些人，恍如隔世。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/forever-SOS.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;过去是体育场旁的石板路，现在是教学楼到二食堂的小道，低头时摇曳的叶影把光束割出形状，抬头看到的是一成不变的蓝天白云。闻着空气里隐约弥漫着躁动的气息，你会产生错觉，真的以为八月是漫无止境的，度过的每一天会被慷慨归还。&lt;/p&gt;
&lt;p&gt;只是在那个古老的不再回来的夏日，所有的结局都已写好，所有的泪水也都已启程。&lt;/p&gt;
&lt;p&gt;“夏天就要过去”这句话念来，总有淡淡的感伤。也许正因如此，我才喜欢上夏天。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>再探前端自动化－持续集成</title>
    <link href="http://kyonhuang.top/start-CI/"/>
    <id>http://kyonhuang.top/start-CI/</id>
    <published>2017-08-23T00:47:28.000Z</published>
    <updated>2017-08-24T08:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文承接前端工程自动化入门系列的第一篇：<a href="http://kyonhuang.top/start-front-end-test/">《初探前端自动化测试–以 Vue 为例》</a>。</p>
<p>传统开发模式中，项目经理等待所有模块都开发完成后再进行集成，出现 bug 则记录并分配责任人进行修改，之后再进行集成，直到通过测试为止持续循环。这个过程可能会出现如下问题：</p>
<ol>
<li>bug 总在最后才被发现（尤其是模块之间的依赖导致的 bug），并且越到项目后期，随着项目规模的膨胀，bug 变得愈发难以修复；</li>
<li>各个环节无效的等待时间较长，加上程序需要经常变更，导致软件交付时机无法保障；</li>
<li>用户无法随时看到项目演示原型，满意度低。</li>
</ol>
<p>为了解决这些问题，<strong>“持续集成”（Continuous Integration）</strong>的概念被提出。</p>
<a id="more"></a>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>持续集成</strong>（CI）是指将所有开发者工作副本频繁地（每天多次）合并到主干，始终保持可发布状态的做法。而<strong>持续集成服务器</strong>就是能够采用自动化的手段，实现项目持续集成的工具。</p>
<p>持续集成的具体工作流程：</p>
<ol>
<li><strong>本地开发（developing）</strong></li>
<li><strong>静态代码检查（linting）</strong></li>
<li><strong>单元测试（testing）</strong>：代码仓库对 commit 操作配置钩子（hook），只要提交代码或者合并进入主干，就会跑自动化测试。这一轮可以先只跑单元测试。</li>
<li><strong>合并进入主干（merging）</strong></li>
<li><strong>自动构建（building）</strong>：将源码经过安装依赖、配置各种资源（CSS、JS、images），转换为可以运行的实际代码。之后会跑全面的测试。</li>
<li><strong>自动发布（publishing）</strong>：将可以直接部署的版本打包，发到生产服务器以启动应用。</li>
</ol>
<p>持续集成之后还有<strong>持续交付</strong>和<strong>持续部署</strong>，分别强调代码在任何时候都是可交付和可部署的。</p>
<h2 id="持续集成的优点"><a href="#持续集成的优点" class="headerlink" title="持续集成的优点"></a>持续集成的优点</h2><ol>
<li>自动化部署工作解放了重复性劳动，并减少手工集成的错误；</li>
<li>防止分支大幅偏离主干，而导致以后的集成难度变大，甚至难以集成；</li>
<li>持续集成缩短了开发、集成、测试、部署等各个环节的时间，从而减少等待时间，同时可以更快地发现、定位、修复问题并交付成果，使得产品可以快速迭代；</li>
<li>集成服务器一般都提供 Code review、代码质量检测等功能，帮助开发人员提高产品质量。</li>
</ol>
<h2 id="持续集成服务平台-Travis"><a href="#持续集成服务平台-Travis" class="headerlink" title="持续集成服务平台 - Travis"></a>持续集成服务平台 - Travis</h2><p>很多 PaaS 平台都提供了持续集成服务。Travis CI 是其中最著名的一个，对于开源项目可以免费使用。</p>
<p>每次跑测试时，Travis 提供的都是一个空白的环境。这个环境只有  Linux 基本的<code>build-essential</code>和<code>wget</code>、<code>git</code>那些依赖。连 Node.js 的运行时都是现跑现安装的。因为 Travis 默认带有的依赖都是每个用户的机器上都会有的，所以一旦应用能在 Travis 上跑通，别的用户就都能安装上。</p>
<p>Travis 的使用方法如下：</p>
<p>首先，在官网 <a href="https://travis-ci.org/" target="_blank" rel="external">https://travis-ci.org/</a> 注册后选择需要开启集成测试的仓库。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-046bd7b6765f890e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="travis.png"></p>
<p>然后，需要在项目的根目录放一份配置文件<code>.travis.yml</code>来告诉 Travis 需要用什么版本的 Node 跑，以及跑测试的命令等信息。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">//</span> <span class="string">一份简单的</span> <span class="string">.travis.yml</span></div><div class="line"></div><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet"> -</span> <span class="string">'4.2.5'</span></div><div class="line"><span class="bullet"> -</span> <span class="string">'7.5.0'</span></div><div class="line"></div><div class="line"><span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></div></pre></td></tr></table></figure>
<p>如果有用到数据库，则<code>.travis.yml</code>还需要添加一些内容。详细内容参考 <a href="https://docs.travis-ci.com/user/database-setup/" target="_blank" rel="external">Setting up Databases - Travis CI</a>。</p>
<p>之后将这份配置文件 push 上 github，Travis 就会被自动触发。下图是正在进行集成测试的 <a href="https://github.com/bighuang624/resume" target="_blank" rel="external">我的简历项目</a>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-b96ac611cef2c347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CItesting.png"></p>
<p>P.S. e2e 测试需要装 chrome 浏览器这个坑又出现了…简直阴魂不散。是不是要用 PhantomJS 才行啊…</p>
<p>我们先只跑单元测试好了。把<code>.travis.yml</code>更改一下：<code>script: npm run unit</code>，再 push 到 github 上。过一会就看到测试通过了。可以把 BlingBling 的 build 徽章加进项目的 README.md 中，来显示项目的构建状态了（徽章添加方案可见参考资料）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-c8621de29eb8b3c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="badage-sample.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作资料"><a href="#写作资料" class="headerlink" title="写作资料"></a>写作资料</h3><p><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成是什么？ - 阮一峰的网络日志</a></p>
<p><a href="https://juejin.im/post/599a3366518825241e221138" target="_blank" rel="external">为什么我们迫切需要持续集成？</a></p>
<p><a href="https://github.com/alsotang/node-lessons/tree/master/lesson13" target="_blank" rel="external">《持续集成平台：travis》</a></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://efe.baidu.com/blog/front-end-continuous-integration-tools/" target="_blank" rel="external">前端开源项目持续集成三剑客 | EFE Tech</a>：添加徽章步骤，可以说是非常具体了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文承接前端工程自动化入门系列的第一篇：&lt;a href=&quot;http://kyonhuang.top/start-front-end-test/&quot;&gt;《初探前端自动化测试–以 Vue 为例》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;传统开发模式中，项目经理等待所有模块都开发完成后再进行集成，出现 bug 则记录并分配责任人进行修改，之后再进行集成，直到通过测试为止持续循环。这个过程可能会出现如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bug 总在最后才被发现（尤其是模块之间的依赖导致的 bug），并且越到项目后期，随着项目规模的膨胀，bug 变得愈发难以修复；&lt;/li&gt;
&lt;li&gt;各个环节无效的等待时间较长，加上程序需要经常变更，导致软件交付时机无法保障；&lt;/li&gt;
&lt;li&gt;用户无法随时看到项目演示原型，满意度低。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决这些问题，&lt;strong&gt;“持续集成”（Continuous Integration）&lt;/strong&gt;的概念被提出。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端工程" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="持续集成" scheme="http://kyonhuang.top/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>用 Vue 撸一份线上简历有哪些坑</title>
    <link href="http://kyonhuang.top/make-a-resume/"/>
    <id>http://kyonhuang.top/make-a-resume/</id>
    <published>2017-08-21T04:52:16.000Z</published>
    <updated>2017-09-09T08:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。</p>
<ul>
<li>项目地址：<a href="https://github.com/bighuang624/resume" target="_blank" rel="external">bighuang624/resume
</a></li>
<li>在线预览地址：<a href="http://kyonhuang.top/resume/">http://kyonhuang.top/resume/</a></li>
</ul>
<p>目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。</p>
<a id="more"></a>
<h2 id="在-Vue-中使用-sass"><a href="#在-Vue-中使用-sass" class="headerlink" title="在 Vue 中使用 sass"></a>在 Vue 中使用 sass</h2><p>这个步骤之前已经总结过，现在再在博客上记录一次，方便之后查找。</p>
<p>在 Webpack 中，所有的预处理器需要匹配相应的 loader。因此要使用 sass 或 scss，首先下载依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sass-loader node-sass --save-dev</div></pre></td></tr></table></figure>
<p>然后在单文件组件中的<code>&lt;style&gt;</code>标签中加上<code>lang=&quot;sass&quot;</code>。<code>vue-loader</code>会根据<code>lang</code>属性推断出要使用的 loaders，并将内容交给相应的 loaders 处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style lang=&quot;sass&quot;&gt;</div><div class="line">  /* write sass here */</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>与名称相反，sass-loader 默认解析 scss 语法，因此如果想使用 sass 语法，还需要在 build/vue-loader.conf.js 配置 vue-loader 的选项：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-0e5c5d774fa3e00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:vue-loader.conf.png"></p>
<p>这样的修改不会影响 scss 的使用，记得修改<code>&lt;style&gt;</code>标签中为<code>lang=&quot;scss&quot;</code>即可。</p>
<h2 id="项目资源无法加载"><a href="#项目资源无法加载" class="headerlink" title="项目资源无法加载"></a>项目资源无法加载</h2><p>直接<code>npm run build</code>得到的项目，默认引用资源文件的路径为<code>/static/js/app.js</code>。所以程序若不在根目录下，就会出现资源文件引用错误的情况。</p>
<p>最简单的解决方案就是改动 webpack 的配置文件。将<code>/config</code>文件夹中的 index.js 文件中的<code>assetsPublicPath: &#39;/&#39;</code>改为<code>assetsPublicPath: &#39;./&#39;</code>即可，截图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-52590cfcce2b12ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config:index.png"></p>
<p>如果你还使用了 vue-router，你需要在 router 的配置中加上一行<code>base: &#39;/[项目所在文件夹的名字]/&#39;</code>，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e6de7fc323ef16e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router.png"></p>
<p>注意：如果启用了 vue-router 的 history 模式，你需要跟着 <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">vue-router 官方文档的后端配置例子</a> 对服务器进行一定的配置。</p>
<p>这是因为在 history 模式下，router 只是通过 JS 操作 window.history 来改变浏览器地址栏里的路径，并没有发起 http 请求。但是直接在地址栏中输入形如<code>http://www.example.com/example/item/1</code>这样的地址时，就一定先要对服务器发起 http 请求。此目标在服务器上不存在，于是会返回 404。修改服务器的配置，以将所有的请求全部转发到<code>index.html</code>上。</p>
<p>当然，这意味着单纯使用 Github Pages 的在线预览功能没办法进行这样的配置。你也可以关注知乎上的这个问题 <a href="https://www.zhihu.com/question/64173754" target="_blank" rel="external">怎样为Github pages Hack使用了vue-router history模式的vue应用？ - 知乎</a> 来看别人的解决方法。</p>
<h2 id="iconfont-无法加载"><a href="#iconfont-无法加载" class="headerlink" title="iconfont 无法加载"></a>iconfont 无法加载</h2><p>字体图标无法正确加载。参考 <a href="https://github.com/vuejs-templates/webpack/issues/166" target="_blank" rel="external">https://github.com/vuejs-templates/webpack/issues/166</a> ，得到的解决方法是修改 build/utils.js 文件，增加一行<code>publicPath: &#39;../../&#39;</code>，如截图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-4154f0ddd63f0953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:utils.png"></p>
<p>保存后，<code>npm run build</code>打包得到的项目中 iconfont 就可以正常显示了。</p>
<h2 id="实现-Github-Pages-在线预览"><a href="#实现-Github-Pages-在线预览" class="headerlink" title="实现 Github Pages 在线预览"></a>实现 Github Pages 在线预览</h2><p>参考 <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="external">Configuring a publishing source for GitHub Pages - User Documentation</a>，实现 Github Pages 在线预览功能有好几种方法，可以设置从<code>master</code>分支、<code>gh-pages</code>分支或者<code>master</code>分支下的<code>/docs</code>文件夹中读取。我就选择了最简单的一种方法，把<code>npm run build</code>打包下来的<code>/dist</code>文件夹改名为<code>/docs</code>。</p>
<p>之后，在 Github 项目主页的 Settings 下的 Github pages 下进行设置 Source 为<code>master branch /docs folder</code>即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-ec745a361c794183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="githubpage.png"></p>
<p>如果你之前使用过 Github Pages 并绑定了一个域名，那么这个项目的预览地址会像<code>http://kyonhuang.top/resume/</code>这样在这个域名下，看起来很爽。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://vue-loader.vuejs.org/zh-cn/configurations/pre-processors.html" target="_blank" rel="external">预处理器 · vue-loader</a></p>
<p><a href="http://upyang.com/2017/07/25/Vue项目上传github并预览/" target="_blank" rel="external">Vue项目打包上传到github预览</a></p>
<p><a href="https://www.zhihu.com/question/46630687/answer/157166318" target="_blank" rel="external">vuejs怎么在服务器部署？ - 知乎</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>撸这份简历，是一个总结，也是一个激励。</p>
<p>真正撸完简历，才发现自己在技术层面上的项目经历少的可怜，而技术也不敢说有什么掌握。以后看到这份简历，会让我非常想写一些拿得出手的开源项目，然后对项目经历进行修改。</p>
<p>读完《你不知道的JavaScript（中卷）》，就给 JS 的技能条涨 5 个百分点；用 Node 开发一个支持登录注册的后台，就给 Node 的技能条涨 5 个百分点；或者再点亮一个新的技能。</p>
<p>随着我的不断学习，希望这份简历越来越吸引人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;https://github.com/bighuang624/resume&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bighuang624/resume
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线预览地址：&lt;a href=&quot;http://kyonhuang.top/resume/&quot;&gt;http://kyonhuang.top/resume/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="开源小项目" scheme="http://kyonhuang.top/categories/%E5%BC%80%E6%BA%90%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="简历" scheme="http://kyonhuang.top/tags/%E7%AE%80%E5%8E%86/"/>
    
      <category term="Vue" scheme="http://kyonhuang.top/tags/Vue/"/>
    
      <category term="github 预览" scheme="http://kyonhuang.top/tags/github-%E9%A2%84%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>初探前端自动化测试--以 Vue 为例</title>
    <link href="http://kyonhuang.top/start-front-end-test/"/>
    <id>http://kyonhuang.top/start-front-end-test/</id>
    <published>2017-08-16T01:14:28.000Z</published>
    <updated>2017-08-24T08:49:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高；但对于稳定、多次复用以及需要长期维护的项目，自动化测试就尤为重要。</p>
<p>现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。</p>
<p>前端的测试类型分为<strong>单元测试（unit testing）</strong>、<strong>集成测试（integration testing）</strong>和<strong>端到端测试（e2e testing）</strong>。</p>
<ul>
<li><strong>单元测试</strong>将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作；</li>
<li><strong>集成测试</strong>是针对产品的某个功能的测试，又称功能测试；</li>
<li><strong>e2e 测试</strong>则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。</li>
</ul>
<a id="more"></a>
<h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>先绕点路，了解一下 TDD、BDD等<strong>以测试为导向的开发模式</strong>，有助于我们更深入地理解自动化测试。</p>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p>TDD（Test Driven Development），即<strong>测试驱动开发</strong>。其先针对每个功能点抽象出接口代码，然后编写单元测试用例代码。之后实现接口，运行单元测试代码进行测试，循环往复直至所有单元测试通过。</p>
<p>TDD 要求测试先于编写功能代码。测试用例不仅是对于代码的验证，更成为对代码的规范与约束，确保在开发以及未来进行修改时能够极大程度地保证该模块行为仍然是正确的。</p>
<h3 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h3><p>BDD（Behavior Driven Development），即<strong>行为驱动开发</strong>。BDD 和 TDD 一样，都要求先写测试，再写代码。可以认为 BDD 是 TDD 的一个子集或分支，是测试驱动开发的扩展。</p>
<p>TDD 基于开发者角度，重点测试函数的输入输出；而 BDD 更侧重于使用者角度，重点测试对用户行为的反应。</p>
<p>BDD 测试中，客户与开发者共同考虑系统该如何运行，然后用通用的语言抽象描述系统的行为，使得双方从技术层面和业务需求都能理解，避免沟通障碍。</p>
<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="测试管理工具"><a href="#测试管理工具" class="headerlink" title="测试管理工具"></a>测试管理工具</h3><p>用来组织和运行整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行被测试代码进行测试。</p>
<p>可选择的有 Karma、Selenium、Mocha（Mocha既是测试工具，也是测试框架）。</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>测试框架是单元测试的核心，提供了单元测试所需的各种API，并对测试用例分组。测试框架会抓取到代码抛出的 AssertionError 并提供附加信息。</p>
<p>选择较多，有名的有 Mocha、Jasmine等。不过 Mocha 既支持 TDD 也支持 BDD 的测试语法，Jasmine 只支持 BDD。</p>
<h3 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h3><p>断言库提供了很多语义化的方法来对值做各种判断。当然也可以不用断言库，Node.js 中也可以直接使用原生 assert 库。</p>
<p>可供选择的断言库也很多，包括 should.js、expect.js、chai.js等。</p>
<h3 id="测试浏览器"><a href="#测试浏览器" class="headerlink" title="测试浏览器"></a>测试浏览器</h3><p>前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持调用和运行本地浏览器来进行测试，但如果测试仅仅是针对函数和模块的单元测试，则完全可以使用一款无界面的 webkit 内核浏览器：PhantomJS。</p>
<h3 id="测试覆盖率统计工具"><a href="#测试覆盖率统计工具" class="headerlink" title="测试覆盖率统计工具"></a>测试覆盖率统计工具</h3><p>测试覆盖率工具为代码在语法级分支上打点，之后运行代码，并在运行结束后根据收集到的信息统计出当前测试用例对源码的覆盖情况。</p>
<p>一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。</p>
<h2 id="vue-cli-的配置"><a href="#vue-cli-的配置" class="headerlink" title="vue-cli 的配置"></a>vue-cli 的配置</h2><p>vue-cli 的 webpack 模版内置了开箱即用的 Karma + Jasmine 单元测试配置，以及 Nightwatch + Selenium E2E 测试配置，<code>npm run test</code>即可测试自带的一个初始测试用例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-50166ab65032fdd5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-unit-test.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-298692df753ab061.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-e2e-test.jpg"></p>
<p>有坑请注意：</p>
<ol>
<li>建议使用 cnpm 对 vue-cli 项目进行依赖安装，否则可能有些东西装不上。</li>
<li>自带的 e2e 测试要求装有 chrome 浏览器，否则报错<code>Error retrieving a new session from the selenium server</code>。我被这个坑折腾了半天…</li>
</ol>
<h2 id="开始编写测试代码"><a href="#开始编写测试代码" class="headerlink" title="开始编写测试代码"></a>开始编写测试代码</h2><p><a href="https://github.com/bighuang624/resume" target="_blank" rel="external">我的简历项目</a> 是我花了一天时间写的一个 vue-cli 初始化、只用了 Vue 的一个小项目，我们拿这个简单的小项目来入门测试代码的编写。我们直接利用 vue-cli 的初始配置，即用 Karma + Jasmine 进行单元测试，Nightwatch + Selenium 进行 E2E 测试。</p>
<p>你可以将我的项目 clone 下来进行测试代码的编写练习，不过项目里的测试代码可能已经因为更新而何下面的示例不一样了。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><code>/test/unit/index.js</code>中可以看到，单元测试的测试代码是<code>/specs</code>文件夹下以<code>.spec.js</code>结尾的文件。将自带的<code>Hello.spec.js</code>改写为<code>LeftNav.spec.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</div><div class="line"><span class="keyword">import</span> LeftNav <span class="keyword">from</span> <span class="string">'@/components/LeftNav'</span>;</div><div class="line"></div><div class="line">describe(<span class="string">'LeftNav.vue'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> Constructor = Vue.extend(LeftNav);</div><div class="line">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Constructor().$mount();</div><div class="line"></div><div class="line">  it(<span class="string">'should render correct name'</span>, () =&gt; &#123;</div><div class="line">    expect(vm.$el.querySelector(<span class="string">'.leftNav h1'</span>).textContent)</div><div class="line">      .to.equal(<span class="string">'Kyon Huang'</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'should render correct title'</span>, () =&gt; &#123;</div><div class="line">    expect(vm.$el.querySelector(<span class="string">'.leftNav h3'</span>).textContent)</div><div class="line">      .to.equal(<span class="string">'Web 开发工程师'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="E2E-测试"><a href="#E2E-测试" class="headerlink" title="E2E 测试"></a>E2E 测试</h3><p>同理，将<code>/test/e2e/specs/test.js</code>改写为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// For authoring Nightwatch tests, see</span></div><div class="line"><span class="comment">// http://nightwatchjs.org/guide#usage</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="string">'default e2e tests'</span>: <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">browser</span>) </span>&#123;</div><div class="line">    <span class="comment">// automatically uses dev Server port from /config.index.js</span></div><div class="line">    <span class="comment">// default: http://localhost:8080</span></div><div class="line">    <span class="comment">// see nightwatch.conf.js</span></div><div class="line">    <span class="keyword">const</span> devServer = browser.globals.devServerURL;</div><div class="line"></div><div class="line">    browser</div><div class="line">      .url(devServer)</div><div class="line">      .waitForElementVisible(<span class="string">'#app'</span>, <span class="number">5000</span>)</div><div class="line">      .assert.elementPresent(<span class="string">'.leftNav'</span>)</div><div class="line">      .assert.containsText(<span class="string">'h1'</span>, <span class="string">'Kyon Huang'</span>)</div><div class="line">      .assert.elementCount(<span class="string">'img'</span>, <span class="number">1</span>)</div><div class="line">      .end();</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-bd0c6382e613c281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unit-test-result.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-dbd1bfcc046e28fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e2e-test-result.png"></p>
<p>可以看到，我们的单元测试和 e2e 测试都通过了。不过单元测试的覆盖率有点低，只有 25%。如何写好测试代码，需要进一步的学习。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端工程自动化入门系列下一篇：<a href="http://kyonhuang.top/start-CI/">《再探前端自动化－持续集成》</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作资料"><a href="#写作资料" class="headerlink" title="写作资料"></a>写作资料</h3><p><a href="http://www.cnblogs.com/bigdataZJ/p/AutoTesting1.html" target="_blank" rel="external">开发人员看测试之TDD和BDD - JackieZheng - 博客园</a></p>
<p><a href="http://www.jianshu.com/p/6726c0410650" target="_blank" rel="external">前端自动化单元测试初探 - 简书</a></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://www.infoq.com/cn/articles/virtual-panel-tdd-bdd#" target="_blank" rel="external">虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发</a></p>
<p><a href="https://www.qcloud.com/community/article/743451001489391682" target="_blank" rel="external">PhantomJS 基础及示例 - 腾云阁 - 腾讯云</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高；但对于稳定、多次复用以及需要长期维护的项目，自动化测试就尤为重要。&lt;/p&gt;
&lt;p&gt;现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。&lt;/p&gt;
&lt;p&gt;前端的测试类型分为&lt;strong&gt;单元测试（unit testing）&lt;/strong&gt;、&lt;strong&gt;集成测试（integration testing）&lt;/strong&gt;和&lt;strong&gt;端到端测试（e2e testing）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单元测试&lt;/strong&gt;将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成测试&lt;/strong&gt;是针对产品的某个功能的测试，又称功能测试；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;e2e 测试&lt;/strong&gt;则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端工程" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="测试" scheme="http://kyonhuang.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6 的异步操作 - Generator 和 async</title>
    <link href="http://kyonhuang.top/Generator-and-async/"/>
    <id>http://kyonhuang.top/Generator-and-async/</id>
    <published>2017-08-03T10:10:53.000Z</published>
    <updated>2017-09-20T06:59:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：<strong>回调函数、事件监听器模式（发布/订阅模式）、流程控制库和 Promise/Deferred 模式</strong>。为了使异步操作更加清晰、简洁、方便，ES6 引入了 <strong>Generator 函数</strong>，而 ES2017 标准引入了 <strong>async 函数</strong>作为 Generator 函数的语法糖。</p>
<p>由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。</p>
<p>本博文在 <a href="http://kyonhuang.top/promise/">Promise 对象 | 大黄菌的个人博客</a> 之后食用最佳。</p>
<p><strong>注</strong>：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。</p>
<a id="more"></a>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-92dc7055c94c75cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Generator.png"></p>
<h3 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h3><p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为<strong>协程（coroutine）</strong>。</p>
<p>Generator 函数是 ES6 对协程的不完全实现，因为只有 Generator 函数的调用者才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<h3 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h3><p>Generator 是一个异步操作的容器。想让 Generator <strong>自动执行</strong>，即需要当异步操作有结果时能够自动交回执行权。两种方法：</p>
<ol>
<li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里交回执行权。</li>
<li>Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</li>
</ol>
<p>其中，JavaScript 中的 <strong>Thunk 函数</strong>指将多参数函数替换成的一个只接受回调函数作为参数的单参数函数。任何参数有回调函数的函数，都能写成 Thunk 函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6 版本的简单 Thunk 函数转换器</span></div><div class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前者的实现可用 Thunkify 模块，后者可用 co 模块。了解更多请看 <a href="http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0" target="_blank" rel="external">Generator 函数的异步应用 - ECMAScript 6入门</a>。暂时用不到的工具就不进一步消耗脑细胞了。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="通过-Generator-函数部署-Ajax-操作"><a href="#通过-Generator-函数部署-Ajax-操作" class="headerlink" title="通过 Generator 函数部署 Ajax 操作"></a>通过 Generator 函数部署 Ajax 操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">'http://some.url'</span>);</div><div class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</div><div class="line">  <span class="built_in">console</span>.log(resp.value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">  makeAjaxCall(url, (response) =&gt; &#123;</div><div class="line">    it.next(response);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = main();</div><div class="line">it.next();</div></pre></td></tr></table></figure>
<h4 id="使用-yield-语句遍历完全二叉树"><a href="#使用-yield-语句遍历完全二叉树" class="headerlink" title="使用 yield* 语句遍历完全二叉树"></a>使用 yield* 语句遍历完全二叉树</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.left = left;</div><div class="line">  <span class="keyword">this</span>.label = label;</div><div class="line">  <span class="keyword">this</span>.right = right;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 中序（inorder）遍历函数</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(t) &#123;</div><div class="line">    <span class="keyword">yield</span>* inoreder(t.left);</div><div class="line">    <span class="keyword">yield</span> t.label;</div><div class="line">    <span class="keyword">yield</span>* inorder(t.right);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成二叉树</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="comment">// 判断是否为叶节点</span></div><div class="line">  <span class="keyword">if</span>(array.length === <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</div><div class="line"></div><div class="line"><span class="comment">// 遍历二叉树</span></div><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> inoreder(tree))&#123;</div><div class="line">  result.push(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line">result</div><div class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></div></pre></td></tr></table></figure>
<h4 id="利用-Generator-函数部署-Iterator-接口"><a href="#利用-Generator-函数部署-Iterator-接口" class="headerlink" title="利用 Generator 函数部署 Iterator 接口"></a>利用 Generator 函数部署 Iterator 接口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    <span class="keyword">let</span> key = keys[i];</div><div class="line">    <span class="keyword">yield</span> [key, obj[key]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">bar</span>: <span class="number">7</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// foo 3</span></div><div class="line"><span class="comment">// bar 7</span></div></pre></td></tr></table></figure>
<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-532436b8fe3212f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="async+函数.png"></p>
<p>感觉前面的知识短时间内都消化不了，就没有看处于提案的异步遍历器。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h3 id="异步获取股票报价"><a href="#异步获取股票报价" class="headerlink" title="异步获取股票报价"></a>异步获取股票报价</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockStmbol(name);</div><div class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</div><div class="line">  <span class="keyword">return</span> stockPrice;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="并发发出远程请求"><a href="#并发发出远程请求" class="headerlink" title="并发发出远程请求"></a>并发发出远程请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInorder</span>(<span class="params">urls</span>) </span>&#123;</div><div class="line">  <span class="comment">// 并发读取远程 URL</span></div><div class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</div><div class="line">    <span class="keyword">return</span> response.text();</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="comment">// 按次序输出</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过学习，我感觉 async 函数真的为一组资源依次异步加载等实际开发场景提供了一种非常简便的处理方案。不过想要运用好 async 函数，深究其实现原理，就必须也要对 Generator 函数有清晰的认知。</p>
<p>异步编程不管是在浏览器还是在服务器端的开发都很重要，知识量也很大，一时半会大概消化不过来。在总结完这些知识后，还需要时常复习，并在实际开发过程中探索更好的实践。</p>
<h2 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a>：帮助加深对同步、异步执行机制的认识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：&lt;strong&gt;回调函数、事件监听器模式（发布/订阅模式）、流程控制库和 Promise/Deferred 模式&lt;/strong&gt;。为了使异步操作更加清晰、简洁、方便，ES6 引入了 &lt;strong&gt;Generator 函数&lt;/strong&gt;，而 ES2017 标准引入了 &lt;strong&gt;async 函数&lt;/strong&gt;作为 Generator 函数的语法糖。&lt;/p&gt;
&lt;p&gt;由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。&lt;/p&gt;
&lt;p&gt;本博文在 &lt;a href=&quot;http://kyonhuang.top/promise/&quot;&gt;Promise 对象 | 大黄菌的个人博客&lt;/a&gt; 之后食用最佳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="异步编程" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 入门笔记</title>
    <link href="http://kyonhuang.top/start-to-learn-NodeJS/"/>
    <id>http://kyonhuang.top/start-to-learn-NodeJS/</id>
    <published>2017-07-30T14:29:41.000Z</published>
    <updated>2017-09-02T01:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 <a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJS</a> 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。</p>
<p>在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。</p>
<p>虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。</p>
<p>更新记录：</p>
<ul>
<li>17.08.30 根据《深入浅出 Node.js》的笔记，对”NodeJS 应用领域及特点”部分进行文字补充。</li>
<li>17.09.02 根据《深入浅出 Node.js》的笔记，对”模块”部分进行文字补充。</li>
</ul>
<a id="more"></a>
<h2 id="NodeJS-应用领域及特点"><a href="#NodeJS-应用领域及特点" class="headerlink" title="NodeJS 应用领域及特点"></a>NodeJS 应用领域及特点</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-81b14861f2bc2943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Node.js+概念一览.png"></p>
<p>设计高性能 Web 服务器的要点：<strong>事件驱动、非阻塞 I/O</strong>。</p>
<p>Node 从 Ryan Dahl 一开始设想的 Web 服务器，发展成一个<strong>强制不共享任何资源的单线程、单进程系统</strong>，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施的<strong>网络应用平台</strong>。</p>
<h3 id="Node-与浏览器的异同"><a href="#Node-与浏览器的异同" class="headerlink" title="Node 与浏览器的异同"></a>Node 与浏览器的异同</h3><p>Chrome 浏览器除了 V8 作为 JavaScript 引擎外，还有一个 WebKit 布局引擎。</p>
<p>Node 的结构和 Chrome 十分相似，都是<strong>基于事件驱动的异步架构</strong>。浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。</p>
<h3 id="Node-的特点"><a href="#Node-的特点" class="headerlink" title="Node 的特点"></a>Node 的特点</h3><h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><h4 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h4><p>事件的编程方式具有<strong>轻量级</strong>、<strong>松耦合</strong>、<strong>只关注事务点</strong>等优势，但是在多个异步任务的场景下，各事件之间各自独立，如何协作是一个问题。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>保持了 JS 在浏览器中单线程的特点。在 Node 中，JS 与其余线程无法共享状态。</p>
<p>好处：</p>
<ol>
<li>不用在意状态同步问题；</li>
<li>没有死锁；</li>
<li>没有线程上下文交换带来的性能开销；</li>
</ol>
<p>弱点：</p>
<ol>
<li>无法利用多核 CPU；</li>
<li>错误会引起整个应用退出，应用的健壮性值得考验；</li>
<li>大量计算占用 COU 导致无法继续调用异步 I/O。</li>
</ol>
<p>浏览器端，Web Workers 能够创建工作线程进行计算。为了不阻塞主线程，工作线程采用<strong>消息传递</strong>的方式来传递运行结果，使得工作线程不能访问主线程的 UI。</p>
<p>Node 采用同样的思路解决单线程中大计算量的问题：<strong>child_process</strong>。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息传递结果。</p>
<p>子进程的出现，意味着 Node 可以从容应对单线程在健壮性和无法利用多核 CPU 方面的问题。</p>
<h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p>操作系统与 Node 上层模块之间构建了一层平台层架构，即<strong>libuv</strong>。</p>
<h3 id="Node-的应用场景"><a href="#Node-的应用场景" class="headerlink" title="Node 的应用场景"></a>Node 的应用场景</h3><h4 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h4><p>Node 面向网络且擅长并行 I/O，能够有效组织更多的硬件资源。</p>
<p>I/O 密集的优势在于<strong>Node 利用事件循环的处理能力</strong>（而非为每一个服务启动一个线程），资源占用极少。</p>
<h4 id="不擅长-CPU-密集型业务？"><a href="#不擅长-CPU-密集型业务？" class="headerlink" title="不擅长 CPU 密集型业务？"></a>不擅长 CPU 密集型业务？</h4><p>由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将导致 CPU 时间片不能释放，使得后续 I/O 无法发起。<strong>适当调整和分解大型运算任务</strong>能使运算适时释放，不阻塞 I/O 调用的发起。</p>
<h4 id="与遗留系统和平共处"><a href="#与遗留系统和平共处" class="headerlink" title="与遗留系统和平共处"></a>与遗留系统和平共处</h4><p>可以将稳定的旧有系统作为后端接口与中间件，而让 Node 将该数据源作为数据接口，发挥异步并行的优势。</p>
<h4 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h4><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a1f50c7c0c750605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模块.png"></p>
<h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ol>
<li>大大提高代码的可维护性；</li>
<li>可以随时引用；</li>
<li>避免函数名和变量名冲突；</li>
</ol>
<h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><p>CommonJS 主要是在 <strong>Node 服务器端</strong>的规范。意义在于将类聚的方法与变量限定在私有的作用域中，使得用户完全不必考虑变量污染。</p>
<p>CommonJS 对模块的定义主要分为模块引用、模块定义、模块标识三个部分：</p>
<h4 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h4><p>一个模块要引用其他模块暴露的变量，用<code>var foo = require(&#39;module_name&#39;)</code>就拿到了引用模块的变量。</p>
<h4 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h4><p>上下文提供了 <strong>exports 对象</strong>用于导出当前模块的方法或者变量，并且它是唯一的出口。</p>
<p>在模块中，还存在一个 <strong>module 对象</strong>，代表<strong>模块自身</strong>，而 exports 是 module 的<strong>属性</strong>。</p>
<p>一个模块要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>。</p>
<h4 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h4><p>即传递给<code>require()</code>方法的参数。</p>
<h3 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h3><p>在 Node 中引入模块，需要经历如下三个步骤：</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<p>在 Node 中，模块分为 Node 提供的<strong>核心模块</strong>和用户编写的<strong>文件模块</strong>。</p>
<p><strong>核心模块</strong>部分在 Node 源代码的编译过程中，编译进了<strong>二进制执行文件</strong>。在 Node 进程启动时，部分核心模块就直接加载进内存中。因此可以省略文件定位和编译执行两个步骤，且在路径分析中优先判断，<strong>加载速度最快</strong>。</p>
<p><strong>文件模块</strong>在<strong>运动时动态加载</strong>，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</p>
<h4 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h4><p><strong>模块加载会有缓存</strong>，且其根据<strong>绝对路径识别</strong>。因此同样的模块名放在不同的路径之中多次 require 不会重新加载。</p>
<p>Node 对引入过的模块都会以<strong>编译和执行后的对象</strong>的形式进行缓存。核心模块和文件模块都采用缓存优先进行二次加载，核心模块的缓存检查先于文件模块。</p>
<h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h4><p><strong>模块路径</strong>是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。</p>
<p>其生成规则为从当前文件目录下的 node_modules 目录开始，沿路径向上逐级递归，直到根目录下的 node_modules 目录。</p>
<p>Node 在当前目录下查找 package.json，通过<code>JSON.parse()</code>解析出包描述对象，从中取出<code>main</code>属性制定的文件名进行定位。</p>
<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><ul>
<li>.js 文件。通过 fs 模块同步读取文件后编译执行。</li>
<li>.node 文件。这是用 C/C++ 编写的扩展文件，通过<code>dlopen()</code>方法加载最后编译生成的文件。</li>
<li>.json 文件。通过 fs 模块同步读取文件后，用<code>JSON.parse()</code>解析返回结果。</li>
<li>其余扩展名。它们都被当作 .js 文件载入。</li>
</ul>
<p>每一个编译成功的模块都会将其<strong>文件路径作为索引</strong>缓存在 <strong>Module._cache 对象</strong>上，以提高二次引入的性能。</p>
<p><strong>如果要达成 require 引入一个类的效果，请赋值给 module.exports 对象。</strong></p>
<h3 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h3><p>浏览器端的 JavaScript 需要经历从同一个服务器端分发到多个客户端执行，瓶颈在于<strong>带宽</strong>；而服务器端 JavaScript 则是相同的代码需要多次执行，瓶颈在于 <strong>CPU 和内存等资源</strong>。</p>
<p>CommonJS 是<strong>同步加载</strong>的，在服务器端模块文件一般存放在本地，再加上有缓存，加载速度很快。而在浏览器端就可能导致“假死”，因此浏览器端采用另一种异步加载方式 - AMD（Asynchronous Module Definition，异步模块定义）规范。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> exports = &#123;&#125;</div><div class="line">  exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Hello from module: '</span> + <span class="built_in">module</span>.id)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> exports</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到 AMD 的模块定义与 Node 模块相似，不同之处在于 <strong>AMD 模块需要用</strong><code>define</code><strong>来明确定义一个模块</strong>，而在 Node 实现中是隐式包装的；以及内容需要通过<strong>返回</strong>的方式实现导出。</p>
<p>想要进一步了解，可参考 <a href="www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">Javascript模块化编程（二）：AMD规范 - 阮一峰的网络日志</a>。</p>
<h3 id="深入了解模块原理"><a href="#深入了解模块原理" class="headerlink" title="深入了解模块原理"></a>深入了解模块原理</h3><p>Node.js 的“模块”功能利用了 JavaScript 函数式编程的特性，通过<strong>闭包</strong>实现。</p>
<h2 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-829fee6dc736dbd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码的组织和部署.png"></p>
<h3 id="包描述文件中的部分属性"><a href="#包描述文件中的部分属性" class="headerlink" title="包描述文件中的部分属性"></a>包描述文件中的部分属性</h3><ul>
<li>maintainers。包维护者列表，npm 通过该属性进行权限认证。</li>
<li>bin。将包作为命令行工具使用，需配置好 bin 字段，通过<code>npm install package_name -g</code>命令将脚本添加到执行路径中。之后可以在命令行中直接执行。例如：<code>&quot;bin&quot;: { &quot;express&quot;: &quot;./bin/express&quot; }</code></li>
</ul>
<h3 id="全局模式安装"><a href="#全局模式安装" class="headerlink" title="全局模式安装"></a>全局模式安装</h3><p><code>-g</code>将一个包安装为全局可用的可执行命令。通过全局模式安装的所有模块包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.resolve(process.execPath, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'lib'</span>, <span class="string">'node_modules'</span>);</div></pre></td></tr></table></figure>
<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a0e8821626a2e3cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本模块.png"></p>
<p>Node.js 内置的常用模块是为了实现基本的服务器功能，底层代码是用 C/C++ 在 Node.js 运行环境中实现。</p>
<h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>Node.js 环境中唯一的全局变量。</p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>代表当前 Node.js 进程。</p>
<h3 id="判断-JavaScript-执行环境"><a href="#判断-JavaScript-执行环境" class="headerlink" title="判断 JavaScript 执行环境"></a>判断 JavaScript 执行环境</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(<span class="built_in">window</span>) === <span class="string">'undefined'</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'node.js'</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'browser'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-f46374c76abbbe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件操作.png"></p>
<h3 id="不同系统下路径的标准化"><a href="#不同系统下路径的标准化" class="headerlink" title="不同系统下路径的标准化"></a>不同系统下路径的标准化</h3><p>标准化之后的路径里的斜杠在 Windows 系统下是<code>\</code>，而在 Linux 系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径。</p>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步遍历获取某一文件夹下的所有文件，用 callback 处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>)</span>&#123;</div><div class="line">  fs.readdirSync(dir).forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> pathname = path.join(dir, file);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(fs.statSync(pathname).isDirectory())&#123;</div><div class="line">      travel(pathname, callback)；</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback(pathname);</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 异步遍历</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback, finish</span>)</span>&#123;</div><div class="line">  fs.readdir(dir, (err, files) =&gt; &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(i &lt; files.length) &#123;</div><div class="line">        <span class="keyword">var</span> pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">        fs.stat(pathname, (err, stats) =&gt; &#123;</div><div class="line">          <span class="keyword">if</span>(stats.isDirectory())&#123;</div><div class="line">            travel(pathname, callback, () =&gt; &#123;</div><div class="line">              next(i + <span class="number">1</span>);</div><div class="line">            &#125;);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            callback(pathname, () =&gt; &#123;</div><div class="line">              next(i + <span class="number">1</span>);</div><div class="line">            &#125;)</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        finish &amp;&amp; finish();</div><div class="line">      &#125;</div><div class="line">    &#125;)(<span class="number">0</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-439f836f1c5033bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络操作.png"></p>
<h3 id="监听端口的权限问题"><a href="#监听端口的权限问题" class="headerlink" title="监听端口的权限问题"></a>监听端口的权限问题</h3><p>在 Linux 系统下，监听 1024 以下端口需要 root 权限。因此，如果想监听 80 或 443 端口的话，需要使用 sudo 命令启动程序。</p>
<h3 id="URL-的完整组成"><a href="#URL-的完整组成" class="headerlink" title="URL 的完整组成"></a>URL 的完整组成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                           href</div><div class="line"> -----------------------------------------------------------------</div><div class="line">                            host              path</div><div class="line">                      --------------- ----------------------------</div><div class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</div><div class="line"> -----    ---------   --------   ---- -------- ------------- -----</div><div class="line">protocol     auth     hostname   port pathname     search     hash</div><div class="line">                                                ------------</div><div class="line">                                                   query</div></pre></td></tr></table></figure>
<h3 id="网络操作常见问题"><a href="#网络操作常见问题" class="headerlink" title="网络操作常见问题"></a>网络操作常见问题</h3><ul>
<li><p>问： 为什么通过<code>headers</code>对象访问到的 HTTP 请求头或响应头字段不是驼峰的？</p>
<p>  答： 从规范上讲，HTTP 请求头和响应头字段都应该是驼峰的。但现实中不是每个 HTTP 服务端或客户端程序都严格遵循规范，所以 NodeJS 在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers[&#39;content-length&#39;]</code>。</p>
</li>
<li><p>问： 为什么<code>http</code>模块创建的 HTTP 服务器返回的响应是<code>chunked</code>传输方式的？</p>
<p>  答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用<code>.end</code>方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后 NodeJS 就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>
</li>
<li><p>问： 为什么使用<code>http</code>模块发起 HTTP 客户端请求时，有时候会发生<code>socket hang up</code>错误？</p>
<p>  答： 发起客户端 HTTP 请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许5个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过<code>https.globalAgent.maxSockets</code>属性来处理。</p>
</li>
</ul>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-d48f8689170c4f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程管理.png"></p>
<h3 id="降权"><a href="#降权" class="headerlink" title="降权"></a>降权</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 降权</span></div><div class="line">http.createServer(callback).listen(<span class="number">80</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">var</span> env = process.env,</div><div class="line">      uid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_UID'</span>] || process.getuid(), <span class="number">10</span>);</div><div class="line">      gid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_GID'</span>] || process.getgid(), <span class="number">10</span>);</div><div class="line"></div><div class="line">  process.setgid(gid);</div><div class="line">  process.setuid(uid);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li><p>如果是通过<code>sudo</code>获取 root 权限的，运行程序的用户的 UID 和 GID 保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取 root 权限的，运行程序的用户的 UID 和 GID 可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</p>
</li>
<li><p><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</p>
</li>
<li><p>降权时必须先降 GID 再降 UID，否则顺序反过来的话就没权限更改程序的 GID 了。</p>
</li>
</ol>
<h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><p>如果父子进程都是 NodeJS 进程，就可以通过 IPC（进程间通讯）双向传递数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* parent.js */</span></div><div class="line"><span class="comment">// 在 options.stdio 字段中通过 ipc 开启一条 IPC 通道</span></div><div class="line"><span class="keyword">var</span> child = child_process.spawn(<span class="string">'node'</span>, [<span class="string">'child.js'</span>], &#123;</div><div class="line">  <span class="attr">stdio</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'ipc'</span>]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(<span class="string">'message'</span>, (msg) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(msg);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 给子进程发送消息</span></div><div class="line">child.send(&#123; <span class="attr">hello</span>: <span class="string">'hello'</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">/* child.js */</span></div><div class="line">process.on(<span class="string">'message'</span>, (msg) =&gt; &#123;</div><div class="line">  msg.hello = msg.hello.toUpperCase();</div><div class="line">  process.send(msg);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 守护子进程</span></div><div class="line"><span class="comment">/* daemon.js */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">mainModule</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> worker = child_process.spawn(<span class="string">'node'</span>, [mainModule]);</div><div class="line"></div><div class="line">  worker.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(code !== <span class="number">0</span>)&#123;</div><div class="line">      spawn(mainModule);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(<span class="string">'worker.js'</span>);</div></pre></td></tr></table></figure>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-57c2d4c89e36c4d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步编程.png"></p>
<h3 id="domain-捕获异常"><a href="#domain-捕获异常" class="headerlink" title="domain 捕获异常"></a>domain 捕获异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">request, callback</span>)</span>&#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">  asyncA(request, (data) =&gt; &#123;</div><div class="line">    <span class="comment">// Do something</span></div><div class="line">    asyncB(request, (data) =&gt; &#123;</div><div class="line">      <span class="comment">// Do something</span></div><div class="line">      asyncC(request, (data) =&gt; &#123;</div><div class="line">        <span class="comment">// Do something</span></div><div class="line">        callback(data);</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">var</span> d = domain.create();</div><div class="line"></div><div class="line">  d.on(<span class="string">'error'</span>, () =&gt; &#123;</div><div class="line">    response.writeHead(<span class="number">500</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  d.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">async</span>(request, (data) =&gt; &#123;</div><div class="line">      response.writeHead(<span class="number">200</span>);</div><div class="line">      response.end(data);</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了 C/C++ 部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是 JS 本身的异常，不用担心上述问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJS 的学习其实主要分为三块：</p>
<ol>
<li>JavaScript 语言本身。要学会借助 <a href="https://www.ecma-international.org/publications/standards/Standard.htm" target="_blank" rel="external">ECMAScript 规范</a> 加深自己的理解。</li>
<li>NodeJS 的 API。要熟悉官方 API 文档，主要是熟悉 NodeJS 提供的功能以及知道该查询文档的哪块地方。不推荐死记硬背，因为新版本会更改和弃用部分 API。</li>
<li>生态圈中的各种三方库。要学习检索、过滤、去其糟粕取其精华，利用但不迷信。</li>
</ol>
<p>而在 NodeJS 开发时，首先要有一个全局的设计，再再实现的过程中对之间忽略掉的细节进行设计上的改进，为二次迭代做准备。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>除开文章开头提到的资料，结语部分参考了 <a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=1&amp;sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&amp;chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&amp;mpshare=1&amp;scene=1&amp;srcid=0727qbaSu9gx8oduOdFPTUoU#" target="_blank" rel="external">当我们学习 Node.js 时，我们在学习什么？</a>。</p>
<h3 id="下一步学习"><a href="#下一步学习" class="headerlink" title="下一步学习"></a>下一步学习</h3><p><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="external">《Node.js 包教不包会》 by alsotang</a></p>
<p>《深入浅出Node.js》</p>
<p>自己撸个爬虫</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 &lt;a href=&quot;http://nqdeng.github.io/7-days-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;七天学会NodeJS&lt;/a&gt; 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。&lt;/p&gt;
&lt;p&gt;在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。&lt;/p&gt;
&lt;p&gt;虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。&lt;/p&gt;
&lt;p&gt;更新记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;17.08.30 根据《深入浅出 Node.js》的笔记，对”NodeJS 应用领域及特点”部分进行文字补充。&lt;/li&gt;
&lt;li&gt;17.09.02 根据《深入浅出 Node.js》的笔记，对”模块”部分进行文字补充。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NodeJS 学习笔记" scheme="http://kyonhuang.top/categories/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="脑图" scheme="http://kyonhuang.top/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>《你不知道的 JavaScript（上卷）》脑图</title>
    <link href="http://kyonhuang.top/You-Dont-Know-JS-notes-1/"/>
    <id>http://kyonhuang.top/You-Dont-Know-JS-notes-1/</id>
    <published>2017-07-27T08:47:12.000Z</published>
    <updated>2017-07-27T12:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。</p>
  <a id="more"></a>
<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作用域和闭包.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-2804c3c63580ec6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">作用域和闭包.png</a></p>
<h2 id="this-和对象原型"><a href="#this-和对象原型" class="headerlink" title="this 和对象原型"></a>this 和对象原型</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="this和对象原型.png"></p>
<p>大图：<a href="http://upload-images.jianshu.io/upload_images/2702529-e0b5c9e70a40628d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">this和对象原型.png</a></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>补一张来自 <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">JavaScript深入之从原型到原型链</a>  的图，来直观地表现原型链。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-d73fdcc0c25efd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链.png"></p>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文展示了我读《你不知道的 JavaScript（上卷）》所总结的脑图。以后读的书争取都用脑图做总结，以建立清晰的知识体系。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="脑图" scheme="http://kyonhuang.top/tags/%E8%84%91%E5%9B%BE/"/>
    
      <category term="《你不知道的 JavaScript》" scheme="http://kyonhuang.top/tags/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JavaScript%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>初探人工智能</title>
    <link href="http://kyonhuang.top/start-to-know-AI/"/>
    <id>http://kyonhuang.top/start-to-know-AI/</id>
    <published>2017-07-23T02:17:25.000Z</published>
    <updated>2017-09-24T03:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？</p>
<ol>
<li>发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。</li>
<li>随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。</li>
<li>确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。</li>
</ol>
<p>何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。</p>
<p>这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。</p>
<p>不要拒绝未来的任何可能性。</p>
<a id="more"></a>
<h2 id="相关概念脑图"><a href="#相关概念脑图" class="headerlink" title="相关概念脑图"></a>相关概念脑图</h2><p>一直感觉纯文字的笔记比较难以记忆，导致自己的学习吸收率不高。看到别人的读书笔记是总结了一张脑图，条理比较清晰。这里也试着用 Xmind 总结一张相关概念的脑图（P.S.使用感觉百度脑图比 Xmind 条理清晰+好用）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a64a6eb143122930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="人工智能相关概念.png"></p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>学习算法的输入数据，叫<strong>“训练数据”</strong>。训练数据的每一行称为一个<strong>“训练样本”（Training Sample）</strong>，通常简称“样本”（Sample）。</p>
<p>样本的各种属性称为<strong>“特征”（Feature）</strong>。而希望学得的模型可以用来预判的信息称为样本的<strong>“标注”（Label）</strong>。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>机器学到的模型是一个映射。</p>
<h3 id="映射的输入"><a href="#映射的输入" class="headerlink" title="映射的输入"></a>映射的输入</h3><p>每个样本 xi 的特征组成一个<strong>“特征向量” (Feature Vector)</strong>。所有特征向量的集合就是总的输入集合，称为<strong>“样本空间” (Sample Space)</strong>。</p>
<h3 id="映射的输出"><a href="#映射的输出" class="headerlink" title="映射的输出"></a>映射的输出</h3><p>第 i 个样本的标注记作 yi。同理有<strong>“标注空间”(Label Space)</strong>。</p>
<h3 id="映射的表示"><a href="#映射的表示" class="headerlink" title="映射的表示"></a>映射的表示</h3><p>机器学习模型就是输入空间 X 到输出空间 Y 的一个映射，将映射用符号 g 表示，则模型记作 g: X -&gt; Y。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><strong>学习算法 (Learning Algorithm)</strong> 根据训练数据，从<strong>假设集合 (Hypothesis Set) </strong>中选出最优的那个映射 g 作为最终学得的模型，使得 g 越接近上帝真相 f 越好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>不是所有的机器学习问题都需要标注。根据训练数据是否有标注，机器学习问题大致划分为<strong>监督学习（Supervised Learning）</strong>和<strong>无监督学习（Unsupervised Learning）</strong>两大类（还有半监督学习、增强学习等）。</p>
<ul>
<li>监督学习：每个输入样本都<strong>有标注</strong>。大致分成两类：<ol>
<li><strong>分类（Classification）</strong>问题：标注是<strong>离散值</strong>，比如用户”点击“和”不点击“。如果标注只有两个值，则称为二分类，如果标注有多个值，则称为多分类。</li>
<li><strong>回归（Regression）</strong>问题：标注是<strong>连续值</strong>，比如如果问题是预测北京市房屋的价格，价格作为标注就是一个连续值，属于回归问题。</li>
</ol>
</li>
<li>无监督学习：训练样本<strong>不需要标注</strong>。这类模型试图学习或是提取数据背后的结构，或从中抽取最为重要的特征。无监督学习解决的典型问题是<strong>聚类（clustering）问题</strong>，比如对一个网站的用户进行聚类，根据用户特征进行分组，看看这个网站用户的大致构成，分析下每类用户群的特点是什么。</li>
</ul>
<p>以上总结为脑图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e14be3cf5133d5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="机器学习.png"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>把听上去最高端的“神经网络”放到最后介绍。</p>
<h3 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h3><p>一组大致模仿人类大脑构造设计的算法，用于识别模式。神经网络通过机器感知系统解释传感器数据，能够对原始输入进行标记或聚类等操作。</p>
<p>神经网络所能识别的模式是数值形式，因此图像、声音、文本、时间序列等一切现实世界的数据必须转换为数值。</p>
<h3 id="感知器、权重与阈值"><a href="#感知器、权重与阈值" class="headerlink" title="感知器、权重与阈值"></a>感知器、权重与阈值</h3><p>大家都在高中的生物课上学过，人类大脑思考的基础是神经元（神经细胞）。如果能够人工制造神经元，就能组成人工神经网络来模拟思考。</p>
<p>上世纪六十年代，科学家们提出了最早的“人造神经元”，并将其称为<strong>“感知器”（perceptron）</strong>。感知器接受一些因素，这些因素根据不同的重要性（决定性因素与次要因素）获得不同的<strong>权重（weight）</strong>。因素的条件成立为 1，不成立为 0，乘以权重的总和大于指定的<strong>阈值（threshold）</strong>，感知器便输出 11，否则输出 0。</p>
<h3 id="决策模型"><a href="#决策模型" class="headerlink" title="决策模型"></a>决策模型</h3><p>单个的感知器构成一个简单的决策模型。而实际的决策模型是由多个感知器组成的多层网络。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png" alt="多层网络"></p>
<p>每一个节点层在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂，因为每一层会整合并重组前一层的特征。</p>
<p>而在“递归神经网络”中，上下层的感知器的输入与输出还可能发生循环传递。</p>
<h3 id="神经网络运作过程"><a href="#神经网络运作过程" class="headerlink" title="神经网络运作过程"></a>神经网络运作过程</h3><p>一个神经网络的搭建，需要满足三个条件：</p>
<ol>
<li>输入和输出</li>
<li>权重（w）和阈值（b）</li>
<li>多层感知器的结构</li>
</ol>
<p>最困难的部分就是确定权重和阈值。我们通过试错法，即保证其他参数不变，对 w 或 b 进行微小变动，然后观察输出的变化。通过不断重复这个过程来得到最精确的那组 w 和 b。这个过程即被称为<strong>模型的训练</strong>。</p>
<p>因此，神经网络的运作过程如下：</p>
<ol>
<li>确定输入和输出</li>
<li>找到一种或多种算法，可以从输入得到输出</li>
<li>找到一组已知答案的数据集，用来训练模型，估算 w 和 b</li>
<li>一旦新的数据产生，输入模型，就可以得到结果，同时对 w 和 b 进行校正</li>
</ol>
<p>整个过程需要海量计算，所以需要使用专门为机器学习定制的 GPU。</p>
<h3 id="输出的连续性"><a href="#输出的连续性" class="headerlink" title="输出的连续性"></a>输出的连续性</h3><p>为了保证模型的敏感，要将 0、1 输出改造为连续性函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">z = wx + b</div><div class="line">σ(z) = 1 / (1 + e^(-z))</div></pre></td></tr></table></figure>
<p>这样，当 z 趋向正无穷（表示感知器强烈匹配）时，σ(z) → 1；如果 z 趋向负无穷（表示感知器强烈不匹配），σ(z) → 0。</p>
<p>同时，Δσ 满足下面的公式：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png" alt="Δσ 公式"></p>
<p>即 Δσ 和 Δw 和 Δb 之间是线性关系，变化率是偏导数。这就有利于精确推算出 w 和 b 的值了。</p>
<h2 id="基于-JavaScript-的机器学习"><a href="#基于-JavaScript-的机器学习" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h2><p>尽管确实是第一选择，机器学习不一定要用 Python。为什么不试试神奇的 JavaScript 呢？</p>
<p>JavaScript 开发者们已经开源了不少基于 Node.js 的机器学习库：</p>
<ol>
<li><a href="https://github.com/harthur-org/brain.js" target="_blank" rel="external">brain.js</a> (神经网络)</li>
<li><a href="https://github.com/cazala/synaptic" target="_blank" rel="external">Synaptic</a> (神经网络)</li>
<li><a href="https://github.com/NaturalNode/natural" target="_blank" rel="external">Natural</a> (自然语言处理)</li>
<li><a href="http://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="external">ConvNetJS</a> (卷积神经网络)</li>
<li><a href="https://github.com/mljs" target="_blank" rel="external">mljs</a> (一系列具有多个函数方法的 AI 库)</li>
<li>Neataptic (神经网络)</li>
<li><a href="https://github.com/mil-tokyo/webdnn" target="_blank" rel="external">Webdnn</a> (深度学习)</li>
</ol>
<p>你可以从 github 的这个项目：<a href="https://github.com/abhisheksoni27/machine-learning-with-js" target="_blank" rel="external">abhisheksoni27/machine-learning-with-js</a> 中获得一些实例的源码，目前作者实现了线性规划和 KNN 算法。你也可以在参考资料的对应章节找到翻译版本进行阅读。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>emmm，如果你看了之后的参考资料中的每一篇，你会发现这篇博文只是一个拙劣的归纳总结。这是因为我确实对相关领域没有什么了解。但我对此兴致勃勃，也已经关注了不少数据挖掘和机器学习的知乎专栏及收藏夹。希望自己将来会有相关方面有价值的产出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="相关概念部分"><a href="#相关概念部分" class="headerlink" title="相关概念部分"></a>相关概念部分</h3><ul>
<li><a href="http://blog.csdn.net/feichizhongwu888/article/details/52727958" target="_blank" rel="external">简单理解：人工智能、数据挖掘、模式识别、机器学习、深度学习 - feichizhongwu888的博客 - CSDN博客</a></li>
<li><a href="http://36kr.com/p/5052482.html" target="_blank" rel="external">一篇文章讲清楚人工智能、机器学习和深度学习的区别</a></li>
</ul>
<h3 id="数据、模型部分"><a href="#数据、模型部分" class="headerlink" title="数据、模型部分"></a>数据、模型部分</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25439997" target="_blank" rel="external">写给大家看的机器学习书（第二篇） - 知乎专栏</a></li>
</ul>
<h3 id="神经网络部分"><a href="#神经网络部分" class="headerlink" title="神经网络部分"></a>神经网络部分</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank" rel="external">神经网络入门 - 阮一峰的网络日志</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25358695" target="_blank" rel="external">写给大家看的机器学习书（第三篇）</a></li>
</ul>
<h3 id="基于-JavaScript-的机器学习-1"><a href="#基于-JavaScript-的机器学习-1" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h3><ul>
<li><a href="https://blog.fundebug.com/2017/07/03/javascript-machine-learning-regression/" target="_blank" rel="external">JavaScript机器学习之线性回归</a></li>
<li><a href="https://blog.fundebug.com/2017/07/10/javascript-machine-learning-knn/" target="_blank" rel="external">JavaScript机器学习之KNN算法</a></li>
</ul>
<h3 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h3><ul>
<li><a href="http://www.cnblogs.com/subconscious/p/5058741.html" target="_blank" rel="external">神经网络浅讲：从神经元到深度学习</a></li>
<li><a href="https://yanqiangmiffy.github.io/2017/07/26/Python28-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BD%BF%E7%94%A8Python%E5%92%8CR%E4%BB%A3%E7%A0%81%EF%BC%89/" target="_blank" rel="external">机器学习算法的基本知识（使用Python和R代码）</a>：带有 Python 和 R 语言代码实例</li>
<li><a href="https://exacity.github.io/deeplearningbook-chinese/" target="_blank" rel="external">Deep Learning 中文翻译</a></li>
<li><a href="http://blog.csdn.net/baihuaxiu123/article/details/69488610" target="_blank" rel="external">[机器学习]机器学习笔记整理全解</a></li>
<li><a href="https://zhuanlan.zhihu.com/dteratech" target="_blank" rel="external">DT新纪元 - 知乎专栏</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。&lt;/p&gt;
&lt;h2 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么&quot;&gt;&lt;/a&gt;为什么&lt;/h2&gt;&lt;p&gt;为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。&lt;/li&gt;
&lt;li&gt;随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。&lt;/li&gt;
&lt;li&gt;确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。&lt;/p&gt;
&lt;p&gt;这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。&lt;/p&gt;
&lt;p&gt;不要拒绝未来的任何可能性。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习笔记" scheme="http://kyonhuang.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人工智能" scheme="http://kyonhuang.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://kyonhuang.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://kyonhuang.top/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>暑假计划进行中</title>
    <link href="http://kyonhuang.top/summer-plan/"/>
    <id>http://kyonhuang.top/summer-plan/</id>
    <published>2017-07-05T13:42:53.000Z</published>
    <updated>2017-08-06T00:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>出征前內心忐忑<br>鋒利的匕首反握<br>準備殺死對手前先讓我來殺死懶惰</p>
<p>— 艾福杰尼 / Killa4nia《酒精》</p>
</blockquote>
<p>简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感兴趣的知识，并且认真做学习笔记和总结。</p>
<p>07.20 更新：暑假已经过去了半个月。对暑期计划进行一些变更使其更加合理。最重要的是提高效率。</p>
<p>08.06 更新：暑假快过了 2/3 了，对计划进行一些修正。</p>
<h4 id="读书计划（脑图整理知识点）"><a href="#读书计划（脑图整理知识点）" class="headerlink" title="读书计划（脑图整理知识点）"></a>读书计划（脑图整理知识点）</h4><p>[Finished] 7月23日为 deadline，看完《你不知道的 JavaScript（上卷）》。</p>
<p>8月8日为deadline， 看完《你不知道的 JavaScript（中卷）》。</p>
<p>8月读《Node.js 深入浅出》。</p>
<p>争取暑假读完《JavaScript 设计模式与开发实践》。</p>
<h4 id="整个暑假："><a href="#整个暑假：" class="headerlink" title="整个暑假："></a>整个暑假：</h4><ul>
<li>每天 12 点前睡觉，8 点前起床。</li>
<li>前端各类练习题。每天 2 - 3 道原生 js 实例题。学累了刷刷 <a href="https://www.nowcoder.com/5257175" target="_blank" rel="external">牛客网</a>。</li>
<li>每天 2 面六级单词。</li>
</ul>
<h4 id="想做的练习："><a href="#想做的练习：" class="headerlink" title="想做的练习："></a>想做的练习：</h4><ul>
<li><a href="http://www.cnblogs.com/coco1s/p/6802374.html" target="_blank" rel="external">谈谈一些有趣的CSS题目</a></li>
<li><a href="http://www.fgm.cc/learn/" target="_blank" rel="external">原生JavaScript学习-实例索引</a></li>
<li><a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a>［可缓］</li>
</ul>
<h4 id="七月："><a href="#七月：" class="headerlink" title="七月："></a>七月：</h4><ul>
<li>写花旗杯项目前端。</li>
<li>Vue 全家桶及相关技术实践。</li>
</ul>
<h4 id="八月："><a href="#八月：" class="headerlink" title="八月："></a>八月：</h4><ul>
<li>Node.js学习。首先是廖雪峰的入门教程，争取一天看完 [08.06：koa 有点难理解…先从 express 学习好了]。接下来选一本书看看（据说朴灵的《Node.js 深入浅出》不错…）</li>
<li>完成一个类似 <a href="https://juejin.im/post/59857c616fb9a03c5c6ffa91" target="_blank" rel="external">带你用 Vue 全家桶和 Node.js 完成一个聚合应用</a> 的 demo。</li>
<li>如果还有时间，试试 Electron 或者 <a href="https://lavas.baidu.com/guide" target="_blank" rel="external">Lavas</a></li>
</ul>
<p>天下武功，唯勤不破！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;出征前內心忐忑&lt;br&gt;鋒利的匕首反握&lt;br&gt;準備殺死對手前先讓我來殺死懶惰&lt;/p&gt;
&lt;p&gt;— 艾福杰尼 / Killa4nia《酒精》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地规划一下暑假。期望自己能利用好两个月的宝贵时间，学习和实践自己感
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Promise 对象</title>
    <link href="http://kyonhuang.top/promise/"/>
    <id>http://kyonhuang.top/promise/</id>
    <published>2017-06-17T13:38:13.000Z</published>
    <updated>2017-08-23T01:58:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。</p>
<p>特点：</p>
<ol>
<li><strong>对象的状态不受外界影响</strong>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Fulfilled</code>（已完成，又称 Resolved）和<code>Rejected</code>（已失败）。只有异步操作的结果可以决定当前是哪一种状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。<code>Promise</code>对象的状态改变只有两种可能：从<code>Pending</code>变为<code>Fulfilled</code>和从<code>Pending</code>变为<code>Rejected</code>。</li>
</ol>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>缺点：</p>
<ol>
<li>无法取消<code>Promise</code>，一旦新建就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，<code>Promise</code>内部抛出的错误不会反映到外部。</li>
<li>当处于<code>Pending</code>状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。</li>
</ol>
<a id="more"></a>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>一个栗子🌰，用<code>Promise</code>对象实现 Ajax 操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    client.open(<span class="string">"GET"</span>, url);</div><div class="line">    client.onreadystagechange = handler;</div><div class="line">    client.responseType = <span class="string">"json"</span>;</div><div class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.readyState !== <span class="number">4</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="number">200</span>)&#123;</div><div class="line">        resolve(<span class="keyword">this</span>.response);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(<span class="string">"/post.json"</span>).then(</div><div class="line">  <span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json), </div><div class="line">  error =&gt; <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error)</div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>resolve</code>和<code>reject</code>函数由 JavaScript 引擎提供，不用自己部署。两者在改变 <code>Promise</code>对象的状态的同时，将异步操作的结果或报出的错误<strong>作为参数</strong>传递出去。</p>
<p><code>then</code>方法可以接受两个回调函数作为参数（可以说是处理 result 和 err 的回调）。第一个在<code>Promise</code>对象状态变为<code>Fulfilled</code>时调用，第二个（可省）在<code>Promise</code>对象状态变为<code>Rejected</code>时调用，都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个<code>Promise</code>实例（决定前一个<code>Promise</code>对象的状态），表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><code>then</code>方法会返回一个 Promise 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> outputPromise = promise.then(</div><div class="line">  <span class="function">(<span class="params">fulfilled</span>) =&gt;</span> &#123;...&#125;,</div><div class="line">  (rejected) =&gt; &#123;...&#125;,</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这时，<code>outputPromise</code>变成了受<code>function(fulfilled)</code>或者 <code>function(rejected)</code>控制状态的 Promise 实例了：</p>
<ul>
<li>若<code>function(fulfilled)</code>或者 <code>function(rejected)</code>返回一个值（字符串、数组、对象等），那么<code>outputPromise</code>的状态变为<code>Resolved</code>；</li>
<li>若<code>function(fulfilled)</code>或者 <code>function(rejected)</code>抛出异常（<code>throw new Error(...)</code>），那么<code>outputPromise</code>的状态变为<code>Rejected</code>；</li>
<li>若<code>function(fulfilled)</code>或者 <code>function(rejected)</code>返回一个 Promise 实例，那么<code>outputPromise</code>就成为这个新的 Promise 实例。</li>
</ul>
<p>可以看 <a href="https://github.com/alsotang/node-lessons/tree/master/lesson17#promise%E7%9A%84%E4%BC%A0%E9%80%92" target="_blank" rel="external">promise的传递</a> 的例子（使用了 q）加深理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过defer获得promise</div><div class="line"> * @private</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> defer.promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 当inputPromise状态由未完成变成fulfilled时，调用function(fulfilled)</div><div class="line"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</div><div class="line"> * 将then返回的promise赋给outputPromise</div><div class="line"> * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由</div><div class="line"> * 未完成改变为fulfilled</div><div class="line"> * @private</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'fulfilled'</span>;</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'rejected'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">defer.reject(); <span class="comment">// 输出 fulfilled: rejected</span></div><div class="line"></div><div class="line"><span class="comment">// defer.resolve(); // 输出 fulfilled: fulfilled</span></div></pre></td></tr></table></figure>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>在创建新的 Promise 时，<strong>作为 Promise 参数传入的函数是会被立即执行</strong>的（而不是调用 then 时才执行），只是其中执行的代码可以是异步代码。</p>
<p>虽然 Promise 作为参数接收的函数是同步执行的，但是<strong><code>then</code>方法的回调函数执行</strong>是<strong>异步</strong>的。</p>
<p>🌰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"create a promise"</span></div><div class="line"><span class="string">"after new Promise"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a><code>Promise.prototype.then()</code></h4><p><code>then</code>方法返回一个<strong>新的</strong><code>Promise</code>实例。链式写法调用<code>then</code>方法时，前一个回调函数将<strong>返回结果</strong>作为参数，传入第二个回调函数（前一个回调函数没有用<code>return</code>返回结果时，默认返回 undefined）。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a><code>Promise.prototype.catch()</code></h4><p><code>reject</code>方法的作用，等同于抛出错误。如果<code>Promise</code>状态已经变成<code>Fulfilled</code>，在<code>resolve</code>语句后再抛出错误是无效的，因为状态不会再改变了。</p>
<p>一般来说，不要在<code>then</code>方法中定义<code>Reject</code>状态的回调函数，<strong>总是使用<code>catch</code>方法</strong>。因为<code>catch</code>可以捕获之前所有<code>then</code>方法执行中的错误，也更接近同步的<code>try/catch</code>写法。</p>
<p><code>catch</code>方法返回的也是一个<code>Promise</code>对象。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h4><p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例（否则调用<code>Promise.resolve</code>方法再处理），包装成一个新的<code>Promise</code>实例。接受一个具有<code>Iterator</code>接口，且返回的每个成员都是<code>Promise</code>实例的参数（一般为数组）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>只有每个成员的状态都为<code>Fulfilled</code>，p 的状态才为<code>Fulfilled</code>，所有返回值组成一个参数传递给 p 的回调函数；否则只要有一个成员被<code>rejected</code>，p 的状态为<code>Rejected</code>，第一个被<code>reject</code>的实例的返回值被传递给 p 的回调函数。</p>
<p>如果作为参数的<code>Promise</code>实例自身定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>p 的状态随第一个改变状态的成员而做相同改变，该成员返回值传递给 p 的回调函数。其他与<code>Promise.all</code>方法一致。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a><code>Promise.resolve()</code></h4><p>将现有对象转为<code>Promise</code>对象。根据参数分为四种情况：</p>
<ol>
<li><code>Promise</code>实例：不作任何修改，直接返回该实例；</li>
<li><code>thenable</code>对象（具有<code>then</code>方法的对象）：转为<code>Promise</code>对象，然后在立即调用其<code>then</code>方法的同时状态变为<code>Resolved</code>；</li>
<li>不符合以上情况的任何参数：返回状态为<code>Fulfilled</code>的<code>Promise</code>对象，参数传给回调函数；</li>
<li>不带有任何参数：返回状态为<code>Fulfilled</code>的<code>Promise</code>对象。</li>
</ol>
<p><strong>注意</strong>：当<code>Promise.resolve()</code>的<strong>参数是<code>Promise</code>实例</strong>时，<code>resolve</code>会“拆箱”获取这个 Promise 实例的状态和值，但这个过程是<strong>异步</strong>的。</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a><code>Promise.reject()</code></h4><p>返回一个新的<code>Promise</code>实例，状态为<code>Rejected</code>。方法的参数会作为<code>reject</code>的理由，变成后续方法的参数。</p>
<p><code>reject</code>不具备“拆箱”能力。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>加载图片：加载完成时<code>Promise</code>的状态发生变化。</li>
<li>Generator 函数与 Promise 的结合：使用<code>Generator</code>函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>写作：</p>
<p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">Promise 对象 - ECMAScript 6入门</a></p>
<p><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="external">八段代码彻底掌握 Promise</a></p>
<p>进阶（之后阅读）：</p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象的状态不受外界影响&lt;/strong&gt;。&lt;code&gt;Promise&lt;/code&gt;对象代表一个异步操作，有三种状态：&lt;code&gt;Pending&lt;/code&gt;（进行中）、&lt;code&gt;Fulfilled&lt;/code&gt;（已完成，又称 Resolved）和&lt;code&gt;Rejected&lt;/code&gt;（已失败）。只有异步操作的结果可以决定当前是哪一种状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一旦状态改变，就不会再变，任何时候都可以得到这个结果&lt;/strong&gt;。&lt;code&gt;Promise&lt;/code&gt;对象的状态改变只有两种可能：从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Fulfilled&lt;/code&gt;和从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Rejected&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了&lt;code&gt;Promise&lt;/code&gt;对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，&lt;code&gt;Promise&lt;/code&gt;对象提供统一的接口，使得控制异步操作更加容易。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法取消&lt;code&gt;Promise&lt;/code&gt;，一旦新建就会立即执行，无法中途取消。&lt;/li&gt;
&lt;li&gt;如果不设置回调函数，&lt;code&gt;Promise&lt;/code&gt;内部抛出的错误不会反映到外部。&lt;/li&gt;
&lt;li&gt;当处于&lt;code&gt;Pending&lt;/code&gt;状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="异步编程" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何给终端安上炫酷的皮神黄皮肤？</title>
    <link href="http://kyonhuang.top/pikachu-iterm/"/>
    <id>http://kyonhuang.top/pikachu-iterm/</id>
    <published>2017-06-10T09:11:32.000Z</published>
    <updated>2017-06-17T13:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-17d0934182abb9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pokemon-Terminal，已经有 1200+ star"></p>
<p>给终端安上超几把炫酷的皮神黄皮肤！<br>作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？</p>
<p>一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-bc1f7d006fb2f0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="感觉又能元气满满地查 bug 了呢"></p>
<p>如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。</p>
<a id="more"></a>
<h3 id="从零开始的项目安装"><a href="#从零开始的项目安装" class="headerlink" title="从零开始的项目安装"></a>从零开始的项目安装</h3><p>打开 <a href="https://github.com/LazoCoder/Pokemon-Terminal" target="_blank" rel="external">Pokemon-Terminal 项目的 github 主页</a>，我发现安装前有两个要求：</p>
<ol>
<li>3.5及以上版本的 python；</li>
<li>已安装 iTerm2。</li>
</ol>
<p>巧了，这两个要求我都不符合！</p>
<p>iTerm2 我从来没有接触过，根本不知道是什么。而比较久远的时候，我在试图将 OS X 系统自带的 python 2.+ 升级为 3.+ 时，跟着网上不知道靠不靠谱的教程误操作，以致 2.+ 删掉了 3.+ 却没安好，依赖于 python 的以 Xcode 为首的一系列软件全部罢工（而且过了一周左右才查出来是这个原因），最后灰溜溜地又下了一遍 2.+，从此留下了对 python 的心理阴影（但是我们这篇教程还是很靠谱的）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-cbaa6148775a471f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="吃瘪了"></p>
<p>没关系，作为（准）程序员，要勇于折腾！我们一步一步的搞起。</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p>我是先下载的 iTerm2，<a href="http://www.iterm2.com/" target="_blank" rel="external">官网</a>在此，下载即可。</p>
<p>iTerm2 是 OS X 系统下很好用的一款命令行工具，至于具体怎么好用，敬请百度了解。因为我现在只是为了皮神黄皮肤。当然之后我也会进一步学习使用。</p>
<h3 id="python-3-5"><a href="#python-3-5" class="headerlink" title="python 3.5+"></a>python 3.5+</h3><p>昨晚吃瘪后的我心有不甘，发了一条说说。然后幸得初中同学救驾：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-6bbe74dae5518c8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="向蔡老师低头"></p>
<p>这个允许用户方便地安装不同版本的 python 并可以快速切换的 anaconda 帮助我解决了问题。<a href="https://www.continuum.io/downloads/" target="_blank" rel="external">官网</a>提供了图形化安装和命令行安装两种方式，根据自己的专业程度选择下载即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-7a10e852f127c605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择 3.6 版本，安装后会自动帮你把 python 版本切换为3.6"></p>
<p>这个 anaconda 据说也是 python 开发的利器之一，不过我也不会 python。也许之后机缘巧合会深入学习（想了解可以参照这篇文章<a href="http://www.jianshu.com/p/2f3be7781451#" target="_blank" rel="external">Anaconda使用总结</a>）。说实话为了给终端换个皮肤，让我本不宽裕的存储空间又少了 1G 左右，有些心疼。但是折腾还是给了我很多乐趣，也许之后有用呢。</p>
<p>那么要求都满足了。按照项目 README 要求，在 iTerm 2 中输入以下三条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Pokemon Installation</div><div class="line">git clone https://github.com/LazoCoder/Pokemon-Terminal $HOME/.Pokemon-Terminal</div><div class="line">echo PATH=&quot;$HOME/.Pokemon-Terminal:$&#123;PATH&#125;&quot; &gt;&gt; ~/.bash_profile</div><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>安装完毕，皮神我来了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pokemon pikachu</div></pre></td></tr></table></figure>
<p>然后…出现以下报错提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.Pokemon-Terminal/./Scripts/background.scpt:39:46: script error: Expected end of line but found identifier. (-2741)</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-31f620e842cc120a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错了，就很难受"></p>
<h3 id="翻越最后一座-bug-高山"><a href="#翻越最后一座-bug-高山" class="headerlink" title="翻越最后一座 bug 高山"></a>翻越最后一座 bug 高山</h3><p>想去给作者提一个 issue，就发现作者对于这个 bug 已经给出了<a href="https://github.com/LazoCoder/Pokemon-Terminal/issues/15" target="_blank" rel="external">解决方法</a>。</p>
<p>按照解决方法，我们需要对 .Pokemon-Terminal/scripter.py 文件进行一些修改（当然，不一定每个人都碰上了这个 bug）。其实我也不太会用 vim，所以以下操作参照了这篇文章<a href="http://blog.csdn.net/bruce0532/article/details/7842384" target="_blank" rel="external">修改文件内容 vi命令</a>。</p>
<p>用以下命令在终端打开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi .Pokemon-Terminal/scripter.py</div></pre></td></tr></table></figure>
<p>然后按一下 i，从命令行模式进入插入模式。找到函数<code>__terminal_script</code>（在比较靠上的位置），将：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">content = &quot;tell application \&quot;iTerm\&quot;\n&quot;</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">content = &quot;tell application \&quot;iTerm2\&quot;\n&quot;</div></pre></td></tr></table></figure></p>
<p>按 Esc 键进入命令行模式，再按<code>:wq</code>保存退出。大功告成！</p>
<p>再在 iTerm2 中输入<code>pokemon pikachu</code>，就会发现黑漆漆（或者白晃晃）的背景变成了皮神黄！</p>
<h3 id="深度使用"><a href="#深度使用" class="headerlink" title="深度使用"></a>深度使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">    pokemon [parameter]</div><div class="line"></div><div class="line">Parameters:</div><div class="line">    [name]        -   Change the terminal background to the specified Pokemon.</div><div class="line">    [index]       -   Change the terminal background to a Pokemon by its index.</div><div class="line">    [region]      -   List all the Pokemon of the specified region.</div><div class="line">    [one letter]  -   List all Pokemon who&apos;s names begin with a particular letter.</div><div class="line">    [two letters] -   List all Pokemon who&apos;s names begin with those two letters.</div><div class="line"></div><div class="line">Other Parameters:</div><div class="line">    pokemon all             -   List all the Pokemon supported.</div><div class="line">    pokemon regions         -   List all the available regions.</div><div class="line">    pokemon extra           -   List all the Pokemon from the &apos;Extra&apos; folder.</div><div class="line">    pokemon random          -   Change the terminal background to a random Pokemon.</div><div class="line">    pokemon random-kanto    -   Change the terminal background to a random Pokemon from the specified region.</div><div class="line">    pokemon ?               -   Identify the current Pokemon in the terminal.</div><div class="line">    pokemon _pikachu        -   Change the wallpaper to the specified Pokemon.</div><div class="line">    pokemon _random         -   Change the wallpaper to a random Pokemon.</div><div class="line">    pokemon _random-kanto   -   Change the wallpaper to a random Pokemon from the specified region.</div><div class="line">    pokemon _?              -   Identify the current Pokemon in the wallpaper.</div><div class="line">    pokemon slideshow       -   Iterate through each Pokemon.</div><div class="line">    pokemon slideshow-kanto -   Iterate through each Pokemon in the specified region.</div><div class="line">    pokemon help            -   Display this menu.</div></pre></td></tr></table></figure>
<p>以上是作者提供的用法。可以通过口袋妖怪的英文名或者编号切换皮肤，或者用<code>pokemon random</code>来切换成随机的皮肤。</p>
<p>我们现在还得每次打开 iTerm 后输入命令来切换皮肤。作者同样提供了点开就换的方法，只用在 iTerm 的 Preferences 里做一点配置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e7b439a27bbb15e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可以去掉; clear以使终端界面不自己下滑来隐藏这条命令"></p>
<p>想一想，通过配置为<code>pokemon random</code>，每次打开都是不同皮肤说不定更爽到。</p>
<p>最后作者建议你改变一下透明度之类的，使皮神看起来更酷炫有范：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-f45392ab4550af00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作者的配置"></p>
<p>我的配置是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-1d60fdcb28354450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的配置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-16299e1b9b28d546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再看一次"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实一个皮肤也没有那么重要（还是有那么一点爽的啦），重要的是通过这一番折腾，接触到了很多常规学习中可能不会接触的东西，包括 iTerm 和 anaconda。这也是我第一次有目的性地去看项目的 issue。希望自己以后能多一点这样地非常规学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2702529-17d0934182abb9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Pokemon-Terminal，已经有 1200+ star&quot;&gt;&lt;/p&gt;
&lt;p&gt;给终端安上超几把炫酷的皮神黄皮肤！&lt;br&gt;作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？&lt;/p&gt;
&lt;p&gt;一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2702529-bc1f7d006fb2f0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;感觉又能元气满满地查 bug 了呢&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿喜欢折腾" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%96%9C%E6%AC%A2%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="终端" scheme="http://kyonhuang.top/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端学习之路上的暂歇思考</title>
    <link href="http://kyonhuang.top/relax-and-think/"/>
    <id>http://kyonhuang.top/relax-and-think/</id>
    <published>2017-06-05T07:22:33.000Z</published>
    <updated>2017-08-29T11:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。</p>
  <a id="more"></a>
<p>到现在为止，我的前端学习之路大概插了这些旗帜：</p>
<ol>
<li>对前端生态有了一个大致的了解，对例如 Webpack、Babel 等常用的工具有使用经验或者大概知道是干什么的。</li>
<li>在知乎和微博上关注了前端大佬，养成每天在掘金上看技术文章以及不时逛一些较为优秀的技术博客的习惯。</li>
<li>看了一些前端书籍，大多是 JavaScript 相关。</li>
<li>大致啃完了 Vue.js 的文档，正在学习 Vue-router。同时也对 i-View 等相关项目有一些了解。</li>
</ol>
<p>在之前的前端学习中也有一些问题：</p>
<ol>
<li>最大的问题是不太重视基础。看张鑫旭对前端的要求中，光是“掌握 JS 中的字符串、函数、对象、数组、字面量等基本概念，熟记所有内置的方法（包括参数和返回值）”这一条就足够我汗颜了。看的书籍虽然有笔记，但也感觉是没有过心。<strong>之后会将博客中的读书笔记再按照知识点，辅以自己的进一步学习成果拆分细化</strong>。虽然这是一个比较大的工程，但我觉得这是一个很有必要的工作。</li>
<li>经典书籍读的不够多。像《你不知道的 JavaScript》、《JavaScript 设计模式与开发实践》等书都没有看。</li>
<li>某些时候还是有些懒惰，没有抽出空余时间来学习。或者是在学习过程中在知乎、贴吧、空间、微博耗费了注意力，导致学习效率不高。</li>
<li>包括博文和项目在内的学习产出还是不多，博文也没有特别有价值的内容。<strong>毕业前要在 github 上有一个 100+ star 的项目，还要部署到 npm 上</strong>。博客考虑备案和 SEO，以激励自己写出更有价值的文章。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又快到考试周了，大二的下学期马上要过完了。这个学期可以说是我编程学习中进步最大的一个学期，自己明确了要学习的方向并为之奔赴。不过这几周可能因为事务繁忙加上有些疲倦，学习效率比较低，也有好久没写博客了。不如暂歇一下，对自己的前端学习做一个阶段性的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>单页面程序及组件化相关笔记</title>
    <link href="http://kyonhuang.top/SPA-learning-notes/"/>
    <id>http://kyonhuang.top/SPA-learning-notes/</id>
    <published>2017-04-29T03:12:53.000Z</published>
    <updated>2017-09-08T07:16:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 <a href="https://github.com/xufei/blog" target="_blank" rel="external">xufei</a> 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。</p>
<a id="more"></a>
<p>提高开发效率的两个主要途径：</p>
<ul>
<li>加快开发速度：少造轮子。</li>
<li>减少变更代价：清理模块之间的关系，合理分层。</li>
</ul>
<h2 id="单页面程序"><a href="#单页面程序" class="headerlink" title="单页面程序"></a>单页面程序</h2><p>SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。</p>
<h3 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h3><p>高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。</p>
<p>实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。</p>
<h3 id="代码合并与加载策略"><a href="#代码合并与加载策略" class="headerlink" title="代码合并与加载策略"></a>代码合并与加载策略</h3><p>典型特征：部分加载。</p>
<p>一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的<strong>异步加载机制</strong>去运行时加载。</p>
<p>因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。</p>
<h3 id="需要考虑的点"><a href="#需要考虑的点" class="headerlink" title="需要考虑的点"></a>需要考虑的点</h3><h4 id="路由与状态的管理"><a href="#路由与状态的管理" class="headerlink" title="路由与状态的管理"></a>路由与状态的管理</h4><p>界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。</p>
<h4 id="缓存与本地存储"><a href="#缓存与本地存储" class="headerlink" title="缓存与本地存储"></a>缓存与本地存储</h4><p>动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。</p>
<p>在本地存储一些临时数据可以用 localStorage。</p>
<h4 id="服务器通信"><a href="#服务器通信" class="headerlink" title="服务器通信"></a>服务器通信</h4><p>WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。</p>
<p>例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。</p>
<h3 id="困难与缺陷"><a href="#困难与缺陷" class="headerlink" title="困难与缺陷"></a>困难与缺陷</h3><p>SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。</p>
<p>缺陷：不利于 SEO；要注意内存管理。</p>
<h2 id="样式规划"><a href="#样式规划" class="headerlink" title="样式规划"></a>样式规划</h2><h3 id="基准样式的分离"><a href="#基准样式的分离" class="headerlink" title="基准样式的分离"></a>基准样式的分离</h3><p>包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。</p>
<h3 id="组件样式的划分"><a href="#组件样式的划分" class="headerlink" title="组件样式的划分"></a>组件样式的划分</h3><p>组件样式应当尽量减少相互依赖，各组件的样式允许冗余。</p>
<h3 id="堆叠次序的管理"><a href="#堆叠次序的管理" class="headerlink" title="堆叠次序的管理"></a>堆叠次序的管理</h3><p>在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。</p>
<p>职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。</p>
<ul>
<li>HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。</li>
<li>JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。</li>
<li>CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。</li>
</ul>
<h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>jQuery 轻量、灵活，但对代码缺乏约束。</p>
<p>需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。</p>
<p>因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。</p>
<p>AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。</p>
<p>React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。</p>
<p>依赖注入： </p>
<ul>
<li>核心理念：通过配置来实例化所依赖的组件。</li>
<li>缺点：性能以及跟踪调试的便利性上的损失。</li>
<li>优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。</li>
<li>应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。</li>
</ul>
<h3 id="MV-框架的基本原理"><a href="#MV-框架的基本原理" class="headerlink" title="MV*框架的基本原理"></a>MV*框架的基本原理</h3><p>充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在<strong>配置文件</strong>（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动：</p>
<ul>
<li>初始化自身（bootstrap）</li>
<li>异步加载可能尚未引入的 JavaScript 代码（require）</li>
<li>解析定义在 HTML 上的规则（template parser）</li>
<li>实例化模型（scopr）</li>
<li>创建模型和 DOM 的关联关系（binding, injection）</li>
</ul>
<p>这些是主线流程，还有一些支线，比如：</p>
<ul>
<li>解析 url 的 search 字符串，恢复状态（route）</li>
<li>加载 HTML 部件模板（template url）</li>
<li>部件模板和模型的关联（binding）</li>
</ul>
<h2 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h2><p>指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。</p>
<p>Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>博文参考资料：</p>
<p><a href="https://github.com/xufei/blog/issues/6" target="_blank" rel="external">Web应用的组件化（一）——基本思路</a></p>
<p><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a></p>
<p><a href="https://github.com/xufei/blog/issues/33" target="_blank" rel="external">关于新框架的学习</a></p>
<p>延伸阅读资料：</p>
<p><a href="https://github.com/xufei/blog/issues/7" target="_blank" rel="external">Web应用的组件化（二）——管控平台</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 &lt;a href=&quot;https://github.com/xufei/blog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xufei&lt;/a&gt; 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://kyonhuang.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="SPA" scheme="http://kyonhuang.top/tags/SPA/"/>
    
      <category term="单页面程序" scheme="http://kyonhuang.top/tags/%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="组件化" scheme="http://kyonhuang.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>最近在干以及打算干些什么</title>
    <link href="http://kyonhuang.top/recent-and-will/"/>
    <id>http://kyonhuang.top/recent-and-will/</id>
    <published>2017-04-26T10:22:33.000Z</published>
    <updated>2017-06-23T13:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。</p>
<p><img src="/images/QinSir.jpg"></p>
<p>在干什么：</p>
<ul>
<li>写花旗杯项目前端第一版。</li>
<li>开始看 Vue.js 的文档。</li>
<li>看一些关于前端工程化的博文。</li>
</ul>
<p>打算干什么：</p>
<ul>
<li>继续看完 Vue.js 的文档并且找一个 Demo 做一做。</li>
<li>尽早看完 ES 6 新特性。</li>
<li>看一看 Grid。</li>
</ul>
<p>最近看的优秀文章：</p>
<ul>
<li><a href="http://www.alloyteam.com/2017/03/getting-started-with-css-modules-and-react-in-practice/" target="_blank" rel="external">CSS Modules 入门及 React 中实践</a></li>
<li><a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="external">玩转 npm</a>：介绍了常用的 npm 命令。</li>
<li><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a>：理解单页 Web 应用。我想这篇文章我还会再看至少两遍。</li>
<li><a href="https://github.com/lin-xin/blog/issues/11" target="_blank" rel="external">HTML5 高级系列：web Storage</a>：了解如何通过 localStorage 和 sessionStorage 存储一些数据。</li>
<li><a href="https://juejin.im/entry/56e1a95b731956005da35c24?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github" target="_blank" rel="external">[译] 人人须知的 jQuery 技巧</a>：介绍了一些 jQuery 代码片段，包括预加载图片、禁用输入字段、简单的手风琴效果等。建议自己整理一份类似的代码片段库。</li>
<li><a href="https://aotu.io/notes/2016/11/22/figlet/" target="_blank" rel="external">FIGlet初识</a>：了解一下 FIGlet，不实用，但还有点意思。</li>
<li><a href="http://www.w3cplus.com/css3/autoprefixer-css-vender-prefixes.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">如何处理CSS3属性前缀</a>：介绍了 Autoprefixer，用于处理 CSS 3 属性前缀的问题。</li>
<li><a href="https://huangxuan.me/js-module-7day/#/2" target="_blank" rel="external">JavaScript Modularization Journey</a>：JS 模块化发展史。还得再看几遍…等我到了该接触 Webpack 的时候。</li>
</ul>
<p>看到的好玩意：</p>
<ul>
<li><strong><a href="https://www.awesomes.cn/" target="_blank" rel="external">Awesomes - Web前端开发资源库</a></strong>：全是前端的开源项目，遍地的轮子啊。关键是文档很多都翻译成中文了。</li>
<li><a href="https://www.npmjs.com/package/pkg" target="_blank" rel="external">pkg</a>：帮助你将你的 Node.js 程序打包成即使在没有 node 环境的设备上也能运行。</li>
<li><a href="https://www.awesomes.cn/repo/mzabriskie/axios" target="_blank" rel="external">Axios</a>：基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用。这个貌似很常用，看看能不能用在现在的项目中。</li>
<li><a href="https://www.awesomes.cn/css/123" target="_blank" rel="external">一个有趣的 CSS 按钮效果</a></li>
<li><a href="https://www.awesomes.cn/repo/IanLunn/hover" target="_blank" rel="external">Hover.css</a>：Hover.css 是一个 CSS3 的鼠标悬停效果集合，可用于超链接，按钮，logo，SVG，推荐图片等等。能够很简单地运用到我们的元素中。</li>
</ul>
<p>之后想做的练习（时间好少QAQ）：</p>
<ul>
<li><a href="http://www.cnblogs.com/coco1s/p/6802374.html" target="_blank" rel="external">谈谈一些有趣的CSS题目</a></li>
<li><a href="http://www.fgm.cc/learn/" target="_blank" rel="external">原生JavaScript学习-实例索引</a></li>
<li><a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/QinSir.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在干什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写花旗杯项目前端第一版。&lt;/li&gt;
&lt;li&gt;开始看 V
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
</feed>
