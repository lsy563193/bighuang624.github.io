<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大黄菌的个人博客</title>
  <subtitle>To be a better man</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kyonhuang.top/"/>
  <updated>2017-04-29T03:13:45.000Z</updated>
  <id>http://kyonhuang.top/</id>
  
  <author>
    <name>Kyon Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单页面程序及组件化相关笔记</title>
    <link href="http://kyonhuang.top/SPA-learning-notes/"/>
    <id>http://kyonhuang.top/SPA-learning-notes/</id>
    <published>2017-04-29T03:12:53.000Z</published>
    <updated>2017-04-29T03:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 <a href="https://github.com/xufei/blog" target="_blank" rel="external">xufei</a> 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。</p>
<a id="more"></a>
<p>提高开发效率的两个主要途径：</p>
<ul>
<li>加快开发速度：少造轮子。</li>
<li>减少变更代价：清理模块之间的关系，合理分层。</li>
</ul>
<h2 id="单页面程序"><a href="#单页面程序" class="headerlink" title="单页面程序"></a>单页面程序</h2><p>SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。</p>
<h3 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h3><p>高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。</p>
<p>实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。</p>
<h3 id="代码合并与加载策略"><a href="#代码合并与加载策略" class="headerlink" title="代码合并与加载策略"></a>代码合并与加载策略</h3><p>典型特征：部分加载。</p>
<p>一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的<strong>异步加载机制</strong>去运行时加载。</p>
<p>因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。</p>
<h3 id="需要考虑的点"><a href="#需要考虑的点" class="headerlink" title="需要考虑的点"></a>需要考虑的点</h3><h4 id="路由与状态的管理"><a href="#路由与状态的管理" class="headerlink" title="路由与状态的管理"></a>路由与状态的管理</h4><p>界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。</p>
<h4 id="缓存与本地存储"><a href="#缓存与本地存储" class="headerlink" title="缓存与本地存储"></a>缓存与本地存储</h4><p>动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。</p>
<p>在本地存储一些临时数据可以用 localStorage。</p>
<h4 id="服务器通信"><a href="#服务器通信" class="headerlink" title="服务器通信"></a>服务器通信</h4><p>WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。</p>
<p>例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。</p>
<h3 id="困难与缺陷"><a href="#困难与缺陷" class="headerlink" title="困难与缺陷"></a>困难与缺陷</h3><p>SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。</p>
<p>缺陷：不利于 SEO；要注意内存管理。</p>
<h2 id="样式规划"><a href="#样式规划" class="headerlink" title="样式规划"></a>样式规划</h2><h3 id="基准样式的分离"><a href="#基准样式的分离" class="headerlink" title="基准样式的分离"></a>基准样式的分离</h3><p>包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。</p>
<h3 id="组件样式的划分"><a href="#组件样式的划分" class="headerlink" title="组件样式的划分"></a>组件样式的划分</h3><p>组件样式应当尽量减少相互依赖，各组件的样式允许冗余。</p>
<h3 id="堆叠次序的管理"><a href="#堆叠次序的管理" class="headerlink" title="堆叠次序的管理"></a>堆叠次序的管理</h3><p>在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。</p>
<p>职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。</p>
<ul>
<li>HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。</li>
<li>JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。</li>
<li>CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。</li>
</ul>
<h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>jQuery 轻量、灵活，但对代码缺乏约束。</p>
<p>需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。</p>
<p>因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。</p>
<p>AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。</p>
<p>React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。</p>
<p>依赖注入： </p>
<ul>
<li>核心理念：通过配置来实例化所依赖的组件。</li>
<li>缺点：性能以及跟踪调试的便利性上的损失。</li>
<li>优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。</li>
<li>应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。</li>
</ul>
<h3 id="MV-框架的基本原理"><a href="#MV-框架的基本原理" class="headerlink" title="MV*框架的基本原理"></a>MV*框架的基本原理</h3><p>充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在<strong>配置文件</strong>（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动：</p>
<ul>
<li>初始化自身（bootstrap）</li>
<li>异步加载可能尚未引入的 JavaScript 代码（require）</li>
<li>解析定义在 HTML 上的规则（template parser）</li>
<li>实例化模型（scopr）</li>
<li>创建模型和 DOM 的关联关系（binding, injection）</li>
</ul>
<p>这些是主线流程，还有一些支线，比如：</p>
<ul>
<li>解析 url 的 search 字符串，恢复状态（route）</li>
<li>加载 HTML 部件模板（template url）</li>
<li>部件模板和模型的关联（binding）</li>
</ul>
<h2 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h2><p>指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。</p>
<p>Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>博文参考资料：</p>
<p><a href="https://github.com/xufei/blog/issues/6" target="_blank" rel="external">Web应用的组件化（一）——基本思路</a></p>
<p><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a></p>
<p><a href="https://github.com/xufei/blog/issues/33" target="_blank" rel="external">关于新框架的学习</a></p>
<p>延伸阅读资料：</p>
<p><a href="https://github.com/xufei/blog/issues/7" target="_blank" rel="external">Web应用的组件化（二）——管控平台</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 &lt;a href=&quot;https://github.com/xufei/blog&quot;&gt;xufei&lt;/a&gt; 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://kyonhuang.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="SPA" scheme="http://kyonhuang.top/tags/SPA/"/>
    
      <category term="单页面程序" scheme="http://kyonhuang.top/tags/%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="组件化" scheme="http://kyonhuang.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>最近在干以及打算干些什么</title>
    <link href="http://kyonhuang.top/recent-and-will/"/>
    <id>http://kyonhuang.top/recent-and-will/</id>
    <published>2017-04-26T10:22:33.000Z</published>
    <updated>2017-04-29T12:23:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。</p>
<p><img src="/images/QinSir.jpg"></p>
<p>在干什么：</p>
<ul>
<li>写花旗杯项目前端第一版。</li>
<li>开始看 Vue.js 的文档。</li>
<li>看一些关于前端工程化的博文。</li>
</ul>
<p>打算干什么：</p>
<ul>
<li>对花旗项目设计效果不是很满意，想抽时间自己设计一版并实现。</li>
<li>继续看完 Vue.js 的文档并且找一个 Demo 做一做。</li>
<li>尽早看完 ES 6 新特性。</li>
<li>看一看 Grid。</li>
</ul>
<p>最近看的优秀文章：</p>
<ul>
<li><a href="http://www.alloyteam.com/2017/03/getting-started-with-css-modules-and-react-in-practice/" target="_blank" rel="external">CSS Modules 入门及 React 中实践</a></li>
<li><a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="external">玩转 npm</a>：介绍了常用的 npm 命令。</li>
<li><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="external">构建单页Web应用</a>：理解单页 Web 应用。我想这篇文章我还会再看至少两遍。</li>
<li><a href="https://github.com/lin-xin/blog/issues/11" target="_blank" rel="external">HTML5 高级系列：web Storage</a>：了解如何通过 localStorage 和 sessionStorage 存储一些数据。</li>
<li><a href="https://juejin.im/entry/56e1a95b731956005da35c24?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github" target="_blank" rel="external">[译] 人人须知的 jQuery 技巧</a>：介绍了一些 jQuery 代码片段，包括预加载图片、禁用输入字段、简单的手风琴效果等。建议自己整理一份类似的代码片段库。</li>
<li><a href="https://aotu.io/notes/2016/11/22/figlet/" target="_blank" rel="external">FIGlet初识</a>：了解一下 FIGlet，不实用，但还有点意思。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几周很忙，有种没头没脑的感觉。简单地总结一下最近干了些什么以及打算干些什么。可能很快删。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/QinSir.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在干什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写花旗杯项目前端第一版。&lt;/li&gt;
&lt;li&gt;开始看 V
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(二)</title>
    <link href="http://kyonhuang.top/es6-2-notes/"/>
    <id>http://kyonhuang.top/es6-2-notes/</id>
    <published>2017-04-24T10:36:13.000Z</published>
    <updated>2017-04-28T07:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">ECMAScript 6 入门</a>》。希望能早日啃完，想去看 Vue.js 了…</p>
<p>此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。</p>
  <a id="more"></a>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>1.ES 6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>)</span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(<span class="string">'Hello'</span>)  <span class="comment">// Hello World</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">'Kyon'</span>)  <span class="comment">// Hello Kyon</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>)  <span class="comment">// Hello</span></div><div class="line"></div><div class="line"><span class="comment">// 与解构赋值默认值结合使用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)  <span class="comment">// 1, 5</span></div><div class="line">foo()  <span class="comment">// TypeeError: Cannot read property 'x' of undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数没有参数的情况</span></div><div class="line">m1() <span class="comment">// [0, 0]</span></div><div class="line">m2() <span class="comment">// [0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// x有值，y无值的情况</span></div><div class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></div><div class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></div><div class="line"></div><div class="line"><span class="comment">// x和y都无值的情况</span></div><div class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></div><div class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></div></pre></td></tr></table></figure>
<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明；使用参数默认值时，函数不能有同名参数。</p>
<p>定义了默认值的参数通常应该为函数的尾参数。</p>
<p>2.函数的<code>length</code>属性：将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，后面的参数也不会被计入。</p>
<p>3.作用域：一旦<strong>设置了参数的默认值</strong>，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，作用域消失。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数foo内部声明的内部变量与参数不是同一个作用域</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123; x = <span class="number">2</span>; &#125;)&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">    y();</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 3</span></div><div class="line">x  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123; x = <span class="number">2</span>; &#125;)&#123;</div><div class="line">    x = <span class="number">3</span>;</div><div class="line">    y();</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 2</span></div><div class="line">x  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>4.函数参数默认值的应用：可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeprovided = throwIfMissing(</span>))</span>&#123;</div><div class="line">    <span class="keyword">return</span> mustBeProvided;</div><div class="line">&#125;</div><div class="line"><span class="comment">// throwIfMissing函数名之后有一对圆括号</span></div><div class="line"><span class="comment">// 表明参数的默认值不是在定义时执行，而是在运行时执行</span></div><div class="line"><span class="comment">// 即如果参数已经赋值，默认值中的函数就不会运行</span></div><div class="line"></div><div class="line">foo()  <span class="comment">// Error: Missing parameter</span></div></pre></td></tr></table></figure>
<p>可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<p>5.rest 参数：形式为”…变量名”，用于获取函数的多余参数。rest 参数中的变量代表一个数组。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</div></pre></td></tr></table></figure>
<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,...b</span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h3 id="函数参数的默认值-1"><a href="#函数参数的默认值-1" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>6.扩展运算符：<code>...</code>，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">35</span>];</div><div class="line">add(...numbers) <span class="comment">// 39</span></div><div class="line"></div><div class="line"><span class="comment">// 不再需要 apply 方法将数组转为函数参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>)</span>&#123;&#125;</div><div class="line">f(...args);</div></pre></td></tr></table></figure>
<p>7.扩展运算符的应用：</p>
<ul>
<li><p>合并数组：提供了新写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];</div><div class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line"></div><div class="line">arr1.concat(arr2, arr3);  <span class="comment">// ES 5</span></div><div class="line">[...arr1, ...arr2, ...arr3]  <span class="comment">// ES 6</span></div></pre></td></tr></table></figure>
</li>
<li><p>与解构赋值结合：用于生成数组（只能放在参数最后一位）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">first <span class="comment">// 1</span></div><div class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> [first, ...rest] = [];</div><div class="line">first <span class="comment">// undefined</span></div><div class="line">rest  <span class="comment">// []:</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];</div><div class="line">first  <span class="comment">// "foo"</span></div><div class="line">rest   <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>函数的返回值：为函数提供一种返回多个值的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从数据库取出一行数据，通过扩展运算符，直接传入构造函数Date</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> dateFields = readDateFields(database);</div><div class="line"><span class="keyword">var</span> d = newDate(...dateFields);</div></pre></td></tr></table></figure>
</li>
<li><p>字符串：扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</div><div class="line"></div><div class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></div><div class="line"></div><div class="line">[...str].reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现了 Iterator 接口的对象：可以通过扩展运算符转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"><span class="keyword">var</span> array = [...nodeList];</div></pre></td></tr></table></figure>
</li>
<li><p>Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符。Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Map结构</span></div><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</div><div class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</div><div class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// Generator 函数</span></div><div class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[...go()] <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>8.函数内部严格模式：ES 5 时函数内部可以设定为严格模式；ES 6 规定只要函数参数使用了<strong>默认值、解构赋值或者扩展运算符</strong>，则函数内部不能显式设定为严格模式，否则报错。</p>
<p>原因：只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>
<p>两种规避方法：全局性严格模式，将函数包在一个无参数的立即执行函数里。</p>
<p>9.name 属性：返回该函数的函数名。</p>
<p>如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ES 5、ES 6</span></div><div class="line">bar.name <span class="comment">// "baz"</span></div></pre></td></tr></table></figure>
<p><code>Function</code>构造函数返回的函数实例，name 属性的值为 <code>anonymous</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></div></pre></td></tr></table></figure>
<p><code>bind</code>返回的函数，name属性值会加上<code>bound</code>前缀。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></div></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>10.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 箭头函数与变量解构结合使用</span></div><div class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 简化回调函数</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>11.箭头函数使用注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象就是<strong>定义时所在对象</strong>，而不是使用时所在对象。</li>
<li>不可当作构造函数（即不可使用<code>new</code>命令），否则抛出错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
<p><code>this</code>指向的固定化，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。也正因如此，箭头函数不能用作构造函数，也不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>
<p>除了<code>this</code>，<code>arguments</code>、<code>super</code>、<code>new.target</code>在箭头函数中也是不存在的，指向外层函数的对应变量。</p>
<p>12.嵌套的箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES 5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span>(<span class="params">afterValue</span>) </span>&#123;</div><div class="line">      array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</div><div class="line">      <span class="keyword">return</span> array;</div><div class="line">    &#125;&#125;;</div><div class="line">  &#125;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// ES 6</span></div><div class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</div><div class="line">  array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;&#125;)&#125;);</div><div class="line"></div><div class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>13.函数绑定运算符：<code>::</code>，左边为对象，右边为函数。该运算符自动将左边的对象作为上下文环境（即 this 对象），绑定到右边的函数上。用来取代<code>call</code>、<code>apply</code>、<code>bind</code>调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.apply(foo, <span class="built_in">arguments</span>);</div></pre></td></tr></table></figure>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> method = obj::obj.foo;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> method = ::obj.foo;</div><div class="line"></div><div class="line"><span class="keyword">var</span> log = ::<span class="built_in">console</span>.log;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</div></pre></td></tr></table></figure>
<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; find, html &#125; = jake;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">"div.myClass"</span>)</div><div class="line">::find(<span class="string">"p"</span>)</div><div class="line">::html(<span class="string">"hahaha"</span>);</div></pre></td></tr></table></figure>
<p>该语法为已被 Babel 转码器支持的一个 ES 7 提案。</p>
<p>14.尾调用：某个函数的最后一步是调用另一个函数。</p>
<p>To be continued…</p>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>1.属性的简洁表示法：ES 6 允许直接写入变量和函数，作为对象的属性和方法。这时，属性名为变量名，属性值为变量值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line">baz  <span class="comment">// &#123;foo: "bar"&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  method()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  * m()&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>2.属性名表达式：ES 6 允许字面量定义对象时，把表达式放在方括号内。表达式也可用于定义方法名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [propKey]: <span class="literal">true</span>,</div><div class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 表达式用于定义方法名</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.hello()  <span class="comment">// hi</span></div></pre></td></tr></table></figure>
<p>但<strong>属性名</strong>表达式与简洁表达式不能同时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> bar = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123; [foo] &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</div></pre></td></tr></table></figure>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>（即不要这么用）。</p>
<p>3.方法的 name 属性：返回函数名。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<p>4.<code>Object.is()</code>：比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致（不同之处为<code>+0</code>不等于<code>-0</code>，以及<code>NaN</code>等于自身）。</p>
<p>5.<code>Object.assign()</code>：用于对象的合并，将源对象的所有可枚举属性复制到目标对象。第一个参数是目标对象，其他参数是源对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target  <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div></pre></td></tr></table></figure>
<p>如果多个对象有同名属性，后面的属性会覆盖前面的。</p>
<p>如果只有一个参数将直接返回（参数不是对象会先转成对象）。无法转成对象的源对象将被跳过。<code>undefined</code>和<code>null</code>无法转成对象，所以不能作为目标对象（否则报错）。其他相关注意事项见文档。</p>
<p>实行浅拷贝，即源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。对于嵌套对象，一旦遇到同名属性会被替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span>&#125; &#125;;</div><div class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source);  <span class="comment">// &#123;a: &#123; b: 'hello' &#125;&#125;</span></div></pre></td></tr></table></figure>
<p><code>Object.assign()</code>有很多用处，其中包括为对象添加属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加属性</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</div><div class="line">  someMethod(arg1, arg2)&#123; ... &#125;,</div><div class="line">  anotherMethod()&#123; ... &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; ... &#125;;</div><div class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;;</div></pre></td></tr></table></figure>
<h3 id="属性的可枚举性与遍历"><a href="#属性的可枚举性与遍历" class="headerlink" title="属性的可枚举性与遍历"></a>属性的可枚举性与遍历</h3><p>6.<code>Object.getOwnPropertyDescriptor</code>：对象的每个属性都有一个描述对象，用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获得该属性的描述对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   value: 123,</span></div><div class="line"><span class="comment">//   writable: true,</span></div><div class="line"><span class="comment">//   enumerable: true,</span></div><div class="line"><span class="comment">//   configurable: true</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>ES 7 引入<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</div><div class="line">  get bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   foo: &#123;</span></div><div class="line"><span class="comment">//     value: 123,</span></div><div class="line"><span class="comment">//     writable: true,</span></div><div class="line"><span class="comment">//     enumerable: true,</span></div><div class="line"><span class="comment">//     configurable: true</span></div><div class="line"><span class="comment">//   &#125;,</span></div><div class="line"><span class="comment">//   bar: &#123;</span></div><div class="line"><span class="comment">//     get: [Function: bar],</span></div><div class="line"><span class="comment">//     set: undefined,</span></div><div class="line"><span class="comment">//     enumerable: true,</span></div><div class="line"><span class="comment">//     configurable: true</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>7.属性的可枚举性：描述对象的<code>enumerable</code>属性，成为“可枚举性”。ES 5 有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性：</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和<strong>继承的</strong>可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
</ul>
<p>ES 6 新增<code>Object.assign()</code>，会忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</p>
<p><strong>当只关心对象自身的属性时，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</strong></p>
<p>8.<code>Object.keys()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键名</strong>。ES 2017 引入配套的<code>Object.values</code>和<code>Object.entries</code>作为遍历一个对象的补充手段。</p>
<p><code>Object.values()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值</strong>（不含 Symbol 属性）。参数为字符串时返回各个字符组成的一个数组，参数为数值或布尔值时返回空数组（与包装对象有关）。</p>
<p><code>Object.entries()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值对数组</strong>（不含 Symbol 属性）。</p>
<p>9.属性的遍历：ES 6 共有5种遍历对象的方法。</p>
<ol>
<li><code>for...in</code>：循环遍历对象<strong>自身的</strong>和<strong>继承的</strong>可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但<strong>包括不可枚举属性</strong>）。</li>
<li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的<strong>所有 Symbol 属性</strong>。</li>
<li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有属性（无论是否可枚举或者属性名是 Symbol 还是字符串）。</li>
</ol>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则（之前一些遍历的方法也遵循此规则）。</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<h3 id="proto-属性及相关方法"><a href="#proto-属性及相关方法" class="headerlink" title="__proto__属性及相关方法"></a><code>__proto__</code>属性及相关方法</h3><p>10.<code>__proto__</code>属性：用于读取或设置当前对象的<code>prototype</code>对象。内部属性，不是正式对外 API。建议使用<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototype()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>如果一个对象本身部署了<code>__proto__</code>属性，则该属性的值就是对象的原型。</p>
<p>11.<code>Object.setPrototypeOf()</code>：作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</div><div class="line"></div><div class="line"><span class="comment">// 用法</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>如果第一个参数不是对象，会自动转为对象（由于返回的还是第一个参数，故无效果）；是<code>undefined</code>或<code>null</code>则报错（无法转为对象）。</p>
<p>12.<code>Object.getPrototypeOf()</code>：用于读取一个对象的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</div></pre></td></tr></table></figure>
<p>如果参数不是对象，会被自动转为对象；是<code>undefined</code>或<code>null</code>则报错。</p>
<p>13.对象的扩展运算符：ES 2017 将<code>...</code>引入对象。主要用途有：</p>
<ul>
<li>解构赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;x, y, ...z&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line">x  <span class="comment">// 1</span></div><div class="line">y  <span class="comment">// 2</span></div><div class="line">z  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>
<p>注意解构赋值的拷贝是浅拷贝，且不会拷贝继承自原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 扩展某个函数的参数，引入其他操作</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// 使用x和y参数进行操作</span></div><div class="line">  <span class="comment">// 其余参数传给原始函数</span></div><div class="line">  <span class="keyword">return</span> baseFunction(restConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>扩展运算符：取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于<code>Object.assign</code>方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</div><div class="line">n  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> n = <span class="built_in">Object</span>.assign(&#123;&#125;, z);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 用于合并两个对象</span></div><div class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</div></pre></td></tr></table></figure>
<p>如果用户自定义的属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。因此可用于修改现有对象部分的部分属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newVersion = &#123;</div><div class="line">  ...previousVersion,</div><div class="line">  <span class="attr">name</span>: <span class="string">'New Name'</span>  <span class="comment">// Override the name property</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</div></pre></td></tr></table></figure>
<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<p>14.Null 传导运算符：<code>?.</code>，用于判断对象及其内部属性是否存在。仅为提案，详见文档。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>1.概述：ES 6 引入的新的原始数据类型，表示独一无二的值。至此，JS 共有七种数据类型：</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>布尔值（Boolean）</li>
<li>字符串（String）</li>
<li>数值（Number）</li>
<li>对象（Object）</li>
<li>Symbol</li>
</ul>
<p>Symbol 值通过<code>Symbol</code>函数生成。即对象的属性名有两种类型：原来就有的字符串，和新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就是独一无二的，不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> s</div><div class="line"><span class="comment">// "symbol"</span></div></pre></td></tr></table></figure>
<p>生成的 Symbol 是一个原始类型的值，不是对象。因此<code>Symbol</code>函数前不能使用<code>new</code>命令（否则报错），Symbol 值也不能添加属性。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。但相同参数的<code>Symbol</code>函数的返回值是<strong>不相等</strong>的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</div><div class="line"></div><div class="line">s1  <span class="comment">// Symbol(foo)</span></div><div class="line">s2  <span class="comment">// Symbol(bar)</span></div><div class="line"></div><div class="line">s1.toString()  <span class="comment">// "Symbol(foo)"</span></div><div class="line">s2.toString()  <span class="comment">// "Symbol(bar)"</span></div></pre></td></tr></table></figure>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后生成一个 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  toString()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'kyon'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</div><div class="line">sym  <span class="comment">// Symbol(abc)</span></div></pre></td></tr></table></figure>
<p>Symbol 值不能与其他类型的值进行运算（会报错），但可以显式转为字符串和布尔值。</p>
<p>2.作为属性名的Symbol：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="comment">// 第一种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 第二种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  [mySymbol]: <span class="string">'Hello!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 第三种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello'</span>! &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 以上写法都得到同样结果</span></div><div class="line">a[mySymbol]  <span class="comment">// "Hello!"</span></div></pre></td></tr></table></figure>
<p>Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"></div><div class="line">a.mySymbol = <span class="string">'Hello!'</span>;</div><div class="line">a[mySymbol]  <span class="comment">// undefined</span></div><div class="line">a[<span class="string">'mySymbol'</span>]  <span class="comment">// "Hello!"</span></div></pre></td></tr></table></figure>
<p>Symbol 值作为属性名时，该属性是<strong>公开属性</strong>而非私有属性。</p>
<p>3.魔术字符串：在代码中多次出现、与代码形成强耦合的某一个具体的字符串或数值。应尽量消除而改用含义清晰的变量代替。</p>
<p><code>Symbol</code>可用于消除魔术字符串。</p>
<p>4.属性名的遍历：Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。这个特性可被用于为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<p><code>Reflect.ownKeys(obj)</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</div><div class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</div><div class="line"><span class="comment">// ["enum", "nonEnum", Symbol(my_key)]</span></div></pre></td></tr></table></figure>
<p>5.<code>Symbol.for()</code>、<code>Symbol.keyFor()</code>：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2;  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的<code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>Symbol.keyFor</code>方法返回一个<strong>已登记</strong>的 Symbol 类型值的<code>key</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s1);  <span class="comment">// "foo"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>)</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s2);  <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>6.Singleton 模式：指调用一个类，任何时候返回的都是同一个实例。</p>
<p>Node 中，模块文件可以看作一个类。可以使用 Symbol，通过把实例放到顶层对象<code>global</code>来实现 Singleton 模式。</p>
<h3 id="内置的-Symbol-值-暂且略过"><a href="#内置的-Symbol-值-暂且略过" class="headerlink" title="内置的 Symbol 值(暂且略过)"></a>内置的 Symbol 值(暂且略过)</h3><p>7.<code>Symbol.hasInstance</code>属性：指向一个内部方法。</p>
<p>8.<code>Symbol.isConcatSpreadable</code>属性：</p>
<p>9.<code>Symbol.species</code></p>
<p>10.<code>Symbol.match</code></p>
<p>11.<code>Symbol.replace</code></p>
<p>12.<code>Symbol.search</code></p>
<p>13.<code>Symbol.split</code></p>
<p>14.<code>Symbol.iterator</code></p>
<p>15.<code>Symbol.toPrimitive</code></p>
<p>16.<code>Symbol.toStringTag</code></p>
<p>17.<code>Symbol.unscopables</code></p>
<h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>1.基本用法：Set 结构不会添加重复的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 3 5 4</span></div></pre></td></tr></table></figure>
<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。因此有一种去除数组重复成员的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...new <span class="built_in">Set</span>(array)]</div></pre></td></tr></table></figure>
<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，类似精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身（<code>===</code>认为<code>NaN</code>不等于自身）。另外，两个对象总是不相等的。</p>
<p>2.Set 实例的属性和方法：</p>
<p>实例属性：</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>操作方法：</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个表示删除是否成功的布尔值。</li>
<li><code>has(value)</code>：返回一个布尔值。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>遍历方法（Set 结构中，键名和键值是同一个值）：</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>3.含义：与 Set 类似，但成员只能是对象，且都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>ES 6 规定，WeakSet 不可遍历。</p>
<p>4.语法：有<code>add</code>、<code>delete</code>、<code>has</code>方法；没有<code>size</code>属性。</p>
<p>5.用处：是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>6.含义和基本用法：为了解决 Object 的只能用字符串当作键名的问题，ES 6 提供了 Map 数据结构。各种类型的值（包括对象）都可以当作键。</p>
<p>有<code>set(key, value)</code>、<code>get(key)</code>、<code>has(key)</code>、<code>delete(key)</code>、<code>clear()</code>方法。</p>
<p>作为构造函数，Map 可以接受一个数组作为参数，该数组的成员是一个个<strong>表示键值对的数组</strong>。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值；如果读取一个未知的键，则返回<code>undefined</code>。</p>
<p>7.与其他数据结构的互相转换：</p>
<ul>
<li>Map 转为数组：使用扩展运算符（<code>...</code>）。</li>
<li>数组转为 Map：使用 Map 构造函数。</li>
<li>Map 转为对象：如果所有 Map 的键都是字符串，可以转为对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap)&#123;</div><div class="line">    obj[k] = v;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);</div><div class="line">strMapToObj(myMap);</div><div class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>对象转为 Map：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;</div><div class="line">    strMap.set(k, obj[k]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> strMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Map 转为 JSON：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况一：Map 的键名都是字符串</span></div><div class="line"><span class="comment">// 可以转换为对象 JSON</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况二：Map 的键名有非字符串</span></div><div class="line"><span class="comment">// 可以转换为数组 JSON</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJSON</span>(<span class="params">map</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>JSON 转为 Map：逆操作。</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>8.含义：与 Map 类似，用于生成键值对。但只接受对象作为键名（<code>null</code>除外），且键名所指向的对象不计入垃圾回收机制。</p>
<p>专用场合：它的键所对应的对象可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>9.语法：没有遍历操作，无法清空。只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<p>10.用处：DOM 节点作为键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个例子</span></div><div class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</div><div class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</div><div class="line"></div><div class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</div><div class="line">  logoData.timesClicked++;</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险</span></div></pre></td></tr></table></figure>
<p>注册监听事件的<code>listener</code>对象，就很适合用 WeakMap 实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> listener = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line">listener.set(element1, handler1);</div><div class="line">listener.set(element2, handler2);</div><div class="line"></div><div class="line">element1.addEventListener(<span class="string">'click'</span>, listener.get(element1), <span class="literal">false</span>);</div><div class="line">element2.addEventListener(<span class="string">'click'</span>, listener.get(element2), <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一旦DOM对象消失，跟它绑定的监听函数也会自动消失</span></div></pre></td></tr></table></figure>
<p>WeakMap 的另一个用处是部署私有属性。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>暂时跳过。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>暂时跳过。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot;&gt;ECMAScript 6 入门&lt;/a&gt;》。希望能早日啃完，想去看 Vue.js 了…&lt;/p&gt;
&lt;p&gt;此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《精通jQuery》读书笔记</title>
    <link href="http://kyonhuang.top/jQuery-master-notes/"/>
    <id>http://kyonhuang.top/jQuery-master-notes/</id>
    <published>2017-04-21T06:50:27.000Z</published>
    <updated>2017-04-28T07:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。</p>
<p>感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。</p>
  <a id="more"></a>
<h2 id="了解-jQuery"><a href="#了解-jQuery" class="headerlink" title="了解 jQuery"></a>了解 jQuery</h2><h3 id="jQuery-核心库的工作"><a href="#jQuery-核心库的工作" class="headerlink" title="jQuery 核心库的工作"></a>jQuery 核心库的工作</h3><p>通过处理浏览器加载 HTML 时动态创建的 DOM（文档对象模型），达到动态修改页面内容的目标。</p>
<h2 id="HTML-入门"><a href="#HTML-入门" class="headerlink" title="HTML 入门"></a>HTML 入门</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>一个事件在它的生命周期中要经历 3 个阶段：<strong>捕获</strong>、处理<strong>目标元素</strong>和<strong>冒泡</strong>。</p>
<p>目标元素：触发事件的元素。</p>
<h2 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h2><h3 id="反选择器"><a href="#反选择器" class="headerlink" title="反选择器"></a>反选择器</h3><p><code>:not(&lt;selector&gt;)</code>：选取不匹配指定选择器的元素。</p>
<h3 id="样式层叠"><a href="#样式层叠" class="headerlink" title="样式层叠"></a>样式层叠</h3><p>浏览器查找样式元素值的顺序：</p>
<ol>
<li>行内样式（定义在元素 style 属性中的样式）；</li>
<li>内嵌样式（定义在 style 元素中的样式）；</li>
<li>外部样式（使用 link 元素导入的样式）；</li>
<li>用户样式（用户自己定义的样式）；</li>
<li>浏览器样式（浏览器提供的默认样式）。</li>
</ol>
<p>前三个又合称为作者样式。</p>
<h4 id="important-规则"><a href="#important-规则" class="headerlink" title="important 规则"></a>important 规则</h4><p>在样式声明的末尾追加<code>!important</code>可以把改值标识为<strong>重要样式</strong>。浏览器会给重要样式以优先权，而不再考虑这个样式的定义位置。</p>
<p>唯一能优先于作者样式中重要样式的样式是定义在用户样式表中的重要样式。对于普通样式来说，作者样式优先于用户样式。但对于重要样式，浏览器的做法恰恰相反。</p>
<h4 id="“专一程度”"><a href="#“专一程度”" class="headerlink" title="“专一程度”"></a>“专一程度”</h4><p>浏览器根据以下 3 个特征计算样式的“专一程度”：</p>
<ol>
<li>选择器中出现的 id 值个数；</li>
<li>选择器中出现的其他属性和伪类个数；</li>
<li>选择器中出现的元素名字和伪元素名字个数。</li>
</ol>
<p>以 a-b-c 这种形式评估样式规则的“专一”程度，逐位比较，每一位上数字越大表示越专一。例如，1-0-0 比 0-5-5 更专一。</p>
<p>如果有多条样式规则的专一程度相同，那么浏览器会选择最后定义的那条规则。专一程度规则仅在同一层叠级别有效。</p>
<h3 id="样式单位"><a href="#样式单位" class="headerlink" title="样式单位"></a>样式单位</h3><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><ul>
<li>em：相对于元素字号的高度；</li>
<li>ex：相对于元素字体中小写字母 x 的高度；</li>
<li>rem：相对于根元素的高度；</li>
<li>px：CSS 像素（假定位于一个 96dpi 的显示设备上，实际上是绝对单位，不会改变大小）；</li>
<li>%：另一属性值的百分比。</li>
</ul>
<h2 id="jQuery-基础"><a href="#jQuery-基础" class="headerlink" title="jQuery 基础"></a>jQuery 基础</h2><h3 id="使用-CDN-版的-jQuery"><a href="#使用-CDN-版的-jQuery" class="headerlink" title="使用 CDN 版的 jQuery"></a>使用 CDN 版的 jQuery</h3><p>CDN（Content Delivery Network）：内容分发网络。当用户请求其数据时，CDN 能智能地分配离用户最近的服务器提供服务。</p>
<p>使用 CDN 的两个优点：(1)用户体验更好（速度通常更快）；(2)节省了传输 jQuery 库所需带宽。</p>
<p>CDN 不适合内联网应用程序。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="$ 函数"></a>$ 函数</h3><p><code>jQuery.noConflict</code>方法让 jQuery 放弃使用 $ 符号。也可将该方法的返回值赋给一个变量以自定义 jQuery 简写符号。</p>
<h3 id="延迟-ready-事件的触发时间"><a href="#延迟-ready-事件的触发时间" class="headerlink" title="延迟 ready 事件的触发时间"></a>延迟 ready 事件的触发时间</h3><p><code>$.holdReady(true)</code>必须在 ready 事件触发之前调用，<code>$.holdReady(false)</code>告诉 jQuery 触发 ready 事件。可以多次调用，但在 ready 事件被真正触发之前，使用 true 参数调用次数要等于使用 false 参数调用次数。 </p>
<h3 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h3><p><img src="/images/jQueryMaster/jquery-selector1.jpg"></p>
<p><img src="/images/jQueryMaster/jquery-selector2.jpg"></p>
<h4 id="使用上下文限制搜索范围"><a href="#使用上下文限制搜索范围" class="headerlink" title="使用上下文限制搜索范围"></a>使用上下文限制搜索范围</h4><p>多给 $ 函数提供一个参数以限制搜索的范围。如果提供的上下文选择器匹配多个元素，将会把匹配上下文选择器的元素收集在一起，然后再匹配主选择器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"img:odd"</span>, $(<span class="string">".drow"</span>))</div><div class="line"><span class="comment">// img:odd选择器会应用在.drow选择器的结果上</span></div></pre></td></tr></table></figure>
<h4 id="确定选择结果"><a href="#确定选择结果" class="headerlink" title="确定选择结果"></a>确定选择结果</h4><p><img src="/images/jQueryMaster/jquery-selector3.jpg"></p>
<h2 id="数据模版"><a href="#数据模版" class="headerlink" title="数据模版"></a>数据模版</h2><p>介绍了模板库 Handlebars。</p>
<h3 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h3><p>数据模板库的核心是<strong>数据模板</strong>——包含着占位符的 HTML 元素。</p>
<p>p268</p>
<h2 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h2><p>介绍了 jQuery 插件 Validation，它专门处理表单验证问题。</p>
<p><a href="http://code.ciaoca.com/jquery/validation-engine/" target="_blank" rel="external">jQuery Validation Engine 表单验证</a></p>
<p>p297</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>p331</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天看到很多前端大牛对学习中的一个共同认知：不要啃别人的二手资料。确实别人咀嚼后的产物质量参差不齐，还是要多读文档，然后是优秀的书籍。&lt;/p&gt;
&lt;p&gt;感觉自己对 jQuery 了解不够，看见别人有推荐《精通jQuery》，先读一读。前面几章的基础知识也可起查漏补缺的作用。这里只记录一些我不清楚或者感觉要背的那种知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jQuery" scheme="http://kyonhuang.top/tags/jQuery/"/>
    
      <category term="《精通jQuery》" scheme="http://kyonhuang.top/tags/%E3%80%8A%E7%B2%BE%E9%80%9AjQuery%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(一)</title>
    <link href="http://kyonhuang.top/es6-1-notes/"/>
    <id>http://kyonhuang.top/es6-1-notes/</id>
    <published>2017-04-06T08:21:52.000Z</published>
    <updated>2017-04-28T07:49:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">ECMAScript 6 入门</a>。将知识点简便地总结一下，以供后续使用时参考或复习。</p>
<p>此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。</p>
  <a id="more"></a>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><p>1.<code>let</code>：<code>let</code>声明的变量仅在块级作用域内有效。不存在变量提升；存在暂时性死区，只能在声明的位置后面获取和使用；相同作用域内不可重复声明。</p>
<p>2.块级作用域：外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。</p>
<p>3.根据ES 6附录B的规定，在浏览器的ES 6环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。应避免在块级作用域内声明函数，或用函数表达式代替函数声明语句。</p>
<p>4.do 表达式：在块级作用域之前加上<code>do</code>，使其变为表达式（可以返回值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量x得到整个块级作用域的返回值</span></div><div class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> t = f();</div><div class="line">    t * t + <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>5.<code>const</code>：声明一个只读常量。一旦声明，就必须立即初始化。和<code>let</code>一样，只在声明所在的块级作用域内有效；声明的常量不提升；存在暂时性死区；不可重复声明。</p>
<p><code>const</code>保证变量指向的内存地址不可改动。因此将对象声明为常量时，不可变的只是地址，对象本身可变，可以为其添加新属性。</p>
<p>如果真想将对象冻结，应用<code>Object.freeze()</code>方法（对象本身和 其属性都应冻结）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">Object</span>.freeze(obj);</div><div class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            constantize(obj[key]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>6.顶层对象的属性：<code>let</code>、<code>const</code>、<code>class</code>声明的全局变量不属于顶层对象的属性。</p>
<h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>1.解构：按照一定模式，从数组和对象中提取值，对变量进行赋值。解构不成功，变量的值就等于<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line">third <span class="comment">// "baz"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</div><div class="line">foo <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>2.不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<p>3.解构赋值允许指定默认值。ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值不会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></div></pre></td></tr></table></figure>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的（用到时才会求值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x能取到值，所以函数f根本不会执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>4.要将一个已经声明的变量用于解构赋值时，将大括号写在行首会导致JavaScript引擎将其解释为代码块，从而发生语法错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"><span class="comment">// 错误写法</span></div><div class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;  <span class="comment">// SyntaxError: syntax error</span></div><div class="line"><span class="comment">// 正确写法</span></div><div class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h3><p>5.对象的解构：属性没有次序，变量取值由名称决定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; bar, foo&#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo  <span class="comment">// "aaa"</span></div><div class="line">bar  <span class="comment">// "bbb"</span></div></pre></td></tr></table></figure>
<p>如果变量名与属性名不一致，须写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz&#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</div><div class="line">baz  <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</div><div class="line">f  <span class="comment">// 'hello'</span></div><div class="line">l  <span class="comment">// 'world'</span></div></pre></td></tr></table></figure>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p>6.解构也可用于嵌套结构的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">p</span>: [</div><div class="line">        <span class="string">'Hello'</span>,</div><div class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;]&#125; = obj;</div><div class="line">x  <span class="comment">// "Hello"</span></div><div class="line">y  <span class="comment">// "World"</span></div><div class="line"><span class="comment">// 这时p是模式，不是变量，因此不会被赋值。</span></div><div class="line">p  <span class="comment">// error: p is undefined</span></div></pre></td></tr></table></figure>
<h3 id="字符串的结构赋值"><a href="#字符串的结构赋值" class="headerlink" title="字符串的结构赋值"></a>字符串的结构赋值</h3><p>7.此时字符串被转化成一个类似数组的对象，且具有<code>length</code>属性（可以针对此属性解构赋值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a  <span class="comment">// "h"</span></div><div class="line">e  <span class="comment">// "o"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len  <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h3 id="数值、布尔值的结构赋值"><a href="#数值、布尔值的结构赋值" class="headerlink" title="数值、布尔值的结构赋值"></a>数值、布尔值的结构赋值</h3><p>8.解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。<code>undefined</code>和<code>null</code>无法转为对象，所以对它们解构赋值都会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure>
<h3 id="函数参数的结构赋值"><a href="#函数参数的结构赋值" class="headerlink" title="函数参数的结构赋值"></a>函数参数的结构赋值</h3><p>9.为函数<code>move</code>的参数指定默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, 0]</span></div><div class="line">move(&#123;&#125;);  <span class="comment">// [0, 0]</span></div><div class="line">move();  <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure>
<p>为变量<code>x</code>和<code>y</code>指定默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y:<span class="number">0</span>&#125;</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, undefined]</span></div><div class="line">move(&#123;&#125;);  <span class="comment">// [undefined, undefined]</span></div><div class="line">move();  <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure>
<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>10.ES6规定，只要可能导致解构歧义，就不得使用圆括号。由于这条规则不易辨别，因此建议尽量不要在模式中放置圆括号。</p>
<p>11.以下三种解构赋值不得使用圆括号。</p>
<ul>
<li>变量声明语句中，不能带有圆括号。</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</li>
</ul>
<p>12.可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。</p>
<p><strong>用途</strong></p>
<ul>
<li>交换变量的值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<ul>
<li>从函数中返回多个值：将返回的数组或对象中的值取出</li>
<li>函数参数的定义：方便地将无序的参数与变量名对应</li>
<li>提取JSON数据：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">24</span>,</div><div class="line">  <span class="attr">status</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="attr">data</span>: [<span class="number">424</span>, <span class="number">5920</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 24, "OK", [424, 5920]</span></div></pre></td></tr></table></figure>
<ul>
<li>函数参数的默认值</li>
<li>遍历Map结构：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div></pre></td></tr></table></figure>
<ul>
<li>输入模块的指定方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>1.字符的Unicode表示法：将码点放入大括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\u&#123;20BB7&#125;"</span>  <span class="comment">// "𠮷"</span></div><div class="line"></div><div class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span>  <span class="comment">// "ABC"</span></div></pre></td></tr></table></figure>
<p>2.新增一些方法：</p>
<ul>
<li><code>codePointAt()</code>：能够正确处理4个字节储存的字符，返回一个字符的码点。是测试一个字符由两个字节还是由四个字节组成的最简单方法。</li>
<li><code>String.fromCodePoint()</code>：用于从码点返回对应字符，可识别Unicode编号大于0xFFFF的码点（32位的UTF-16字符）。</li>
<li><code>at()</code>（提案）：返回字符串给定位置的字符，可识别Unicode编号大于0xFFFF的码点。</li>
<li><code>repeat(n)</code>：返回一个新字符串，表示将原字符串重复n次。</li>
<li><code>normalize()</code>：将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
<li><code>padStart()</code>：如果某个字符串不够指定长度，会在头部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串（默认为空格）。</li>
<li><code>padEnd()</code>：同上，用于尾部补全。</li>
</ul>
<p>3.模版字符串：常用于定义多行字符串，或者在字符串中嵌入变量。用反引号（`）标识。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Kyon"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure>
<p>模板字符串中嵌入变量，要将变量名卸载<code>${}</code>中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，也可以调用函数。</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串（例如对象调用<code>toString</code>方法）。</p>
<p>4.标签模板（功能）：函数调用的一种特殊形式。模板字符串作为参数紧跟在一个函数名后，该函数被调用以处理该模板字符串。常用于转义特殊字符和多语言转换（国际化处理）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log<span class="string">`Kyon`</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Kyon'</span>)</div></pre></td></tr></table></figure>
<p>模板字符有变量时，先把模板字符串处理成多个参数。处理得到的第一个参数是一个数组，包含那些没有变量替换的部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">tag([<span class="string">'Hello'</span>, <span class="string">' world'</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性，保存转义后的原字符串。</p>
<p>5.<code>String.raw()</code>：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串；如果原字符串的斜杠已经转义，则不会做任何处理。常用于处理模板字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">3</span>+<span class="number">4</span>&#125;</span>!`</span>;</div><div class="line"><span class="comment">// "Hi\\n7!"</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</div><div class="line"><span class="comment">// 'Hi\\u000A!'</span></div></pre></td></tr></table></figure>
<p>也可作为正常函数使用，第一个参数应是具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应是一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// 't0e1s2t'</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>6.模板字符串的限制（提案）：放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>
<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><p>1.<code>u</code>修饰符：Unicode 模式，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。对于码点大于<code>\uFFFF</code>的 Unicode 字符，点字符(<code>.</code>，除了换行符外的任意单个字符)、Unicode 字符表示法（使用大括号表示 Unicode 字符）、量词、预定义模式（<code>\S</code>，匹配所有不是空格的字符）必须加上<code>u</code>修饰符才能识别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>)</div><div class="line"><span class="comment">// false</span></div><div class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>2.<code>y</code>修饰符：“粘连”修饰符，全局匹配，但须确保匹配必须从剩余的第一个位置开始。一个应用是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</div><div class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</div><div class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</div><div class="line"></div><div class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></div><div class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></div><div class="line"></div><div class="line">r1.exec(s) <span class="comment">// ["aa"]</span></div><div class="line">r2.exec(s) <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>3.ES 6 的正则对象新增了<code>sticky</code>属性和<code>flags</code>属性，分别表示是否设置了<code>y</code>修饰符以及返回正则表达式的修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</div><div class="line">r.sticky  <span class="comment">// true</span></div><div class="line">r.flags  <span class="comment">// 'y'</span></div></pre></td></tr></table></figure>
<p>4.有一些提案。因为我暂时对正则不太熟悉，所以略过。</p>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>1.二进制、八进制表示法：分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。用<code>Number()</code>方法将其转化为十进制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>)  <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>2.新增 Number 对象上的一些方法：</p>
<ul>
<li><code>Number.isFinite()</code>：用于检查一个数值是否为有限的。</li>
<li><code>Number.isNaN()</code>：用于检查一个值是否为<code>NaN</code>。</li>
</ul>
<p>与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>
<ul>
<li>将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到 Number 对象上，行为完全保持不变，目的是逐步减少全局性方法，使得语言逐步模块化。</li>
<li><code>Number.isInteger()</code>：用于判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是同样的储存方法，这个方法都会返回 true。</li>
</ul>
<p>3.<code>Number.EPSILON</code>：极小的常量，表示一个可以接受的误差范围。浮点数计算误差小于<code>Number.EPSILON</code>时可以认为得到正确结果。</p>
<p>4.<code>Number.isSafeInteger()</code>：JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围的值无法精确表示。<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量用来表示这个范围的上下限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<p>5.Math 对象的扩展：所有新增方法都是静态方法，只能在 Math 对象上调用。</p>
<ul>
<li><code>Math.trunc()</code>：用于去除一个数的小数部分，返回整数部分。对于非数值内部使用<code>Number</code>方法将其先转为数值；对于空值和无法截取整数的值，返回 NaN。</li>
<li><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。它会返回五种值：参数为正数，返回+1；负数返回-1；0返回0；-0返回-0；其他值返回NaN。</li>
<li><code>Math.cbrt</code>：用于计算一个数的立方根。</li>
</ul>
<p>此外，还有一些对数方法和三角函数方法。</p>
<p>6.指数运算符（<code>**</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span> ** <span class="number">2</span>  <span class="comment">// 4</span></div><div class="line"><span class="number">2</span> ** <span class="number">3</span>  <span class="comment">// 8</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</div><div class="line">a **= <span class="number">3</span>;</div><div class="line"><span class="comment">// 等同于 a = a * a * a;</span></div></pre></td></tr></table></figure>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>1.<code>Array.from()</code>：将类数组对象（本质特征是有<code>length</code>属性）和可遍历对象（部署了 Iterator 接口的数据结构，包括 ES 6新增的 Set 和 Map）转化为真正的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123;</div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr1 = <span class="built_in">Array</span>.from(arrayLike);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>);</div><div class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></div></pre></td></tr></table></figure></p>
<p>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组；如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from()</code>的第三个参数，用来绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</div><div class="line"><span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure>
<p>2.<code>Array.of()</code>：返回参数值组成的数组（没有参数则返回空数组）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>)  <span class="comment">// [3]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></div></pre></td></tr></table></figure>
<p>3.数组实例的<code>copyWithin()</code>：在当前数组内部，将指定位置的成员复制到其他位置（覆盖原有成员），然后返回当前数组。</p>
<p>接受三个参数（都为数值，否则自动转换）：</p>
<ul>
<li>target（必需）：从该位置开始替换数据；</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>4.数组实例的<code>find()</code>和<code>findIndex()</code>：</p>
<p><code>find()</code>用于找出第一个符合条件的数组成员。其参数为一个回调函数（可以接收三个参数：当前的值，当前的位置和原数组），所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员，否则返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</div><div class="line"><span class="comment">// -5</span></div></pre></td></tr></table></figure>
<p><code>findIndex()</code>类似，返回第一个符合条件的数组成员的位置，否则返回<code>-1</code>。</p>
<p>5.数组实例的<code>fill()</code>：用给定值填充一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组中原有的元素将被覆盖</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line"><span class="comment">// 还可以接受两个参数，用于指定填充的起始位置和结束位置</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// ['a', 7, 'c']</span></div></pre></td></tr></table></figure>
<p>6.数组实例的<code>keys()</code>、<code>values()</code>和<code>entries()</code>：用于遍历数组。都返回一个遍历器对象，可以用<code>for..of</code>循环进行遍历；区别为分别对键名、键值、键值对遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys())&#123;</div><div class="line">    <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values())&#123;</div><div class="line">    <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries())&#123;</div><div class="line">    <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure>
<p>7.数组实例的<code>includes()</code>（属于ES 7 但 Babel 转码器已经支持）：返回一个布尔值，表示某个数组是否包含给定的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);  <span class="comment">// true</span></div><div class="line">[<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);  <span class="comment">// false</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>8.数组的空位：和<code>undefined</code>不同，数组的空位没有任何值。ES 5 对空位的处理规则很不一致（大多数情况会忽略）；而 ES 6 明确将空位转为<code>undefined</code>。尽管如此，建议避免出现空位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot;&gt;ECMAScript 6 入门&lt;/a&gt;。将知识点简便地总结一下，以供后续使用时参考或复习。&lt;/p&gt;
&lt;p&gt;此博文包括：let 和 const命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ES 6" scheme="http://kyonhuang.top/tags/ES-6/"/>
    
      <category term="《ECMAScript 6 入门》" scheme="http://kyonhuang.top/tags/%E3%80%8AECMAScript-6-%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>探究伪元素及其用途</title>
    <link href="http://kyonhuang.top/5171/"/>
    <id>http://kyonhuang.top/5171/</id>
    <published>2017-04-05T10:43:45.000Z</published>
    <updated>2017-04-05T10:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。</p>
  <a id="more"></a>
<h2 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h2><p>伪元素(Pseudo-elements)容易与伪类(Pseudo-classes)混淆。在 w3c 定义中，伪类用于向某些选择器添加特殊的效果，而伪元素用于将特殊的效果添加到某些选择器。可以看到从定义上来说，二者确实不好分辨。不过在种类上可以看出二者的一些不同。</p>
<p>伪类包括：</p>
<ul>
<li><code>:link</code>：向未被访问的链接添加样式。</li>
<li><code>:visited</code>：向已被访问的链接添加样式。</li>
<li><code>:hover</code>：当鼠标悬浮在元素上方时，向元素添加样式。</li>
<li><code>:active</code>：向被激活的元素添加样式。</li>
<li><code>:focus</code>：向拥有键盘输入焦点的元素添加样式。</li>
<li><code>:first-child</code>：向元素的第一个子元素添加样式。</li>
<li><code>:lang</code>：向带有指定 lang 属性的元素添加样式。</li>
</ul>
<p>其中前四个因为用不同的方式显示链接的不同状态，被称为“锚伪类”。在 CSS 定义中，<code>a:hover</code>必须被置于 <code>a:link</code>和<code>a:visited</code>之后，而<code>a:active</code>必须被置于<code>a:hover</code>之后才是有效的。</p>
<p>伪元素包括：</p>
<ul>
<li><code>:before</code>：在元素之前添加内容。</li>
<li><code>:after</code>：在元素之后添加内容。</li>
<li><code>:first-letter</code>：向文本的第一个字母添加特殊样式。</li>
<li><code>:first-line</code>：向文本的首行添加特殊样式。</li>
</ul>
<p>其中前两个无疑是用的最多的。后两个也可以用于实现一些特殊效果，例如通过<code>:first-letter</code>实现段落首字母加粗或变色。</p>
<p>两者的<strong>根本区别</strong>是：伪类可以通过<strong>直接添加一个实际的类样式</strong>达到同等效果；而伪元素的效果则需要<strong>先添加一个实际的元素，再在元素上添加样式</strong>才能达到。</p>
<p>在 CSS 3 中修订后的伪元素使用两个冒号（<code>::</code>）以与伪类进行区分。但无论使用单冒号还是双冒号，浏览器都能识别。并且 IE 8 只支持单冒号的写法。因此为了更广泛的浏览器兼容性，还是推荐使用单冒号的写法。</p>
<h2 id="伪元素的优点"><a href="#伪元素的优点" class="headerlink" title="伪元素的优点"></a>伪元素的优点</h2><p>最常使用的两种伪元素——<code>:before</code>和<code>:after</code>可以在内容元素的前后插入额外的元素。通过伪元素，在实现很多炫酷的视觉效果时，我们不必修改现有的 HTML 文档结构。因为 HTML 文档本身仅仅应该包含内容，而不应该包含样式，所以伪元素更应该被提倡。</p>
<h2 id="伪元素的应用"><a href="#伪元素的应用" class="headerlink" title="伪元素的应用"></a>伪元素的应用</h2><p>鉴于伪元素应用很多时候代码相对专一，建议配合 Sass，通过设置 mixin 来使用以提高复用性（你可以通过我的上一篇博文 <a href="http://kyonhuang.top/1478/">初见Sass－便捷的CSS预处理器</a> 来了解Sass）。</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>这大概是伪元素最为常见的应用了。比起插入额外的非语义标记来清除内联元素的浮动，这种俗称“clearfix”的方式更语义化。</p>
<p><strong>CSS</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.group:before,</div><div class="line">.group:after &#123;</div><div class="line">  content:&quot;&quot;;</div><div class="line">  display:table;</div><div class="line">&#125;</div><div class="line">.group:after &#123;</div><div class="line">  clear:both;</div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div><div class="line">.group &#123;</div><div class="line">  zoom:1; /* For IE 6/7 (trigger hasLayout) */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Sass</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@mixin clearfix &#123; </div><div class="line">  @if $legacy-support-for-ie &#123; </div><div class="line">    *zoom: 1; </div><div class="line">  &#125; </div><div class="line">  &amp;:before, </div><div class="line">  &amp;:after &#123; </div><div class="line">    content: &quot;&quot;; </div><div class="line">    display: table; </div><div class="line">  &#125; </div><div class="line">  &amp;:after &#123; </div><div class="line">    clear: both; </div><div class="line">    overflow: hidden; </div><div class="line">  &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过 @include 方法调用</div></pre></td></tr></table></figure>
<h3 id="实现样式效果"><a href="#实现样式效果" class="headerlink" title="实现样式效果"></a>实现样式效果</h3><p>能够借助伪元素实现的样式效果数不胜数。这里举一个简单而常用的例子。</p>
<p>很多时候我们会在每一节的标题下做一个类似下划线效果，用来强调。使用伪元素可以让我们不必添加额外的元素来实现这个效果。</p>
<p><img src="/images/section-title.png" width="264px" height="88px"></p>
<p>Sass 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@mixin section-title() &#123;</div><div class="line">  font-size: 2em;</div><div class="line">  padding: 2em 0;</div><div class="line">  text-transform: uppercase;</div><div class="line">  color: #55a2dd;</div><div class="line"></div><div class="line">  &amp;:after &#123;</div><div class="line">    display: block;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    background-color: #cccccc;</div><div class="line">    width: 2em;</div><div class="line">    height: .2em;</div><div class="line">    margin: .4em auto;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h3><p>有时我们想给一张大图设置透明度，却发现其子元素都会被继承这个透明度。以往想要消除这个属性总让我头大。现在通过伪元素，我们就可以分别为文字和图片设置不同的透明度。</p>
<p>Sass 代码如下（来自<a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/design_your_own_site/index.html" target="_blank" rel="external">第3周：设计你自己的页面</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">.hero &#123;</div><div class="line">  width: 100%;</div><div class="line">  min-height: 50em;</div><div class="line">  position: relative;</div><div class="line">  background-color: $mask-color;</div><div class="line">  z-index: 1;</div><div class="line"></div><div class="line">  &amp;:after &#123;</div><div class="line">    background: url(&apos;../images/hero-1-resized.jpg&apos;);</div><div class="line">    background-size: cover;</div><div class="line">    position: absolute;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    z-index: -1;</div><div class="line">    opacity: .2;</div><div class="line">    width: 100%;</div><div class="line">    height: 100%;</div><div class="line">    top: 0;</div><div class="line">    left: 0;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  h2 &#123;</div><div class="line">    font-size: 6em;</div><div class="line">    font-weight: bold;</div><div class="line">    padding: 3em 0 1em 0;</div><div class="line">    text-transform: uppercase;</div><div class="line">    color: white;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  p &#123;</div><div class="line">    max-width: 70%;</div><div class="line">    font-size: 1.5em;</div><div class="line">    font-weight: lighter;</div><div class="line">    color: #cecece;</div><div class="line">    line-height: 1.4;</div><div class="line">    margin: 0 auto;</div><div class="line">    padding: 1em 0 8em 0;</div><div class="line">    span &#123;</div><div class="line">      color: $heading-color;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 .hero 这个 section，我们将其背景设置为灰色，并将 position 设置为 relative。然后为其添加了一个伪元素，这个伪元素上包含了实际的图片，并为图片设置了透明度 .2。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.w3school.com.cn/css/css_pseudo_elements.asp" target="_blank" rel="external">CSS 伪元素 - W3School</a></p>
<p>你可以从这篇文章中了解更多伪元素的应用：<a href="http://www.w3cplus.com/css3/pseudo-element-roundup.html" target="_blank" rel="external">大放异彩的伪元素——可以做什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前也或多或少看过一些关于伪元素的资料，有些许了解。这两天练手时遇到相关的实现较多，特再查找一些资料，看过后进行总结。内容包括伪类与伪元素的区别、伪元素的优点和一些伪元素的实际应用，目标是一篇文章基本讲通。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://kyonhuang.top/tags/HTML/"/>
    
      <category term="CSS" scheme="http://kyonhuang.top/tags/CSS/"/>
    
      <category term="伪元素" scheme="http://kyonhuang.top/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>初见Sass－便捷的CSS预处理器</title>
    <link href="http://kyonhuang.top/sass-begin/"/>
    <id>http://kyonhuang.top/sass-begin/</id>
    <published>2017-04-03T11:21:22.000Z</published>
    <updated>2017-04-25T10:47:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现自己又找到一本关于前端实践的优质开源书<a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/index.html" target="_blank" rel="external">《3周3页面》</a>。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。”</p>
<a id="more"></a>
<h2 id="什么是Sass"><a href="#什么是Sass" class="headerlink" title="什么是Sass"></a>什么是Sass</h2><p>为了给 CSS 加入编程元素，人们发明了Sass。Sass 是一个 CSS3 的扩展语言，它提供了嵌套样式，变量定义，扩展，mixin等丰富的特性，使得编写样式更加容易，节省了开发者的时间。</p>
<h2 id="Sass基础语法"><a href="#Sass基础语法" class="headerlink" title="Sass基础语法"></a>Sass基础语法</h2><p>这里只记录我觉得比较关键的语法作为备忘。可以查看 <a href="http://www.w3cplus.com/sassguide/" target="_blank" rel="external">sass十分钟入门</a> 或者 <a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="external">SASS用法指南</a> 以较为全面地入门。</p>
<ul>
<li>变量：以<code>$</code>开头。如果变量需要镶嵌在字符串之外，需要写在<code>#{}</code>中。</li>
<li>嵌套：用<code>&amp;</code>引用父元素。</li>
<li>继承：使用<code>@extend</code>命令。</li>
<li>Mixin：使用<code>@mixin</code>命令定义一个代码块，使用<code>@include</code>命令调用。可以指定参数和缺省值。</li>
<li>插入文件：使用<code>@import</code>命令。</li>
<li>自定义函数：使用<code>@function</code>和<code>@return</code>。</li>
<li>此外支持条件语句和循环语句。</li>
</ul>
<h2 id="WebStorm中使用Sass"><a href="#WebStorm中使用Sass" class="headerlink" title="WebStorm中使用Sass"></a>WebStorm中使用Sass</h2><p>注意，本节内容针对 OS X 环境。可能部分内容也兼容其他平台，但我没试过。</p>
<p>WebStorm 支持 Sass 的自动编译。在 WebStorm 的 Preferences 中，Tools 下选择 File Watchers。配置 Sass 和 SCSS（最新版的 Sass 后缀）需要有相应的 Program。</p>
<p><img src="/images/webstorm_sass.jpg"></p>
<p>因为 Sass 依赖 ruby，所以要先安装 ruby。不过 OS X 好像自带 ruby（至少我没有什么时候安装过的印象…）。之后建议安装 Compass：<code>sudo gem install compass</code>，Sass 和 SCSS 的 Program 会被一并安装，WebStorm 也会检测到，之后点击 OK 即可。</p>
<p>之后，WebStorm 会自动监测 Sass 文件的改动，并时刻编译为同名 CSS 文件，保存在同一文件夹下，非常方便。</p>
<h2 id="Sass实现媒体查询"><a href="#Sass实现媒体查询" class="headerlink" title="Sass实现媒体查询"></a>Sass实现媒体查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 定义两个 break-point</div><div class="line">$break-small: 320px;</div><div class="line">$break-large: 1024px;</div><div class="line"></div><div class="line">// 定义一个 mixin，接收三个可能的参数</div><div class="line">// 分别代表不同的设备——手机、平板和桌面显示器</div><div class="line">@mixin respond-to($media) &#123;</div><div class="line">  @if $media == handhelds &#123;</div><div class="line">    @media only screen and (max-width: $break-small) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">  @else if $media == medium-screens &#123;</div><div class="line">    @media only screen and (min-width: $break-small + 1) and (max-width: $break-large) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">  @else if $media == wide-screens &#123;</div><div class="line">    @media only screen and (min-width: $break-large) &#123; @content; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">  @include respond-to(medium-screens) &#123;</div><div class="line">    //...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式使用起来更方便，也便于后期统一修改变量的具体数值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《3周3页面》的作者同样推荐了 Compass。这是一个使用了 Sass 的库，将很多常用样式打包成了一些模块以供使用。因为安装时出现了一些我还没解决的 error，我还没有使用过。可以查看 <a href="http://www.ruanyifeng.com/blog/2012/11/compass.html" target="_blank" rel="external">Compass用法指南</a> 以获得更多了解。</p>
<p>此外，推荐 <a href="http://www.w3cplus.com/preprocessor/ten-best-common-mixins.html" target="_blank" rel="external">SASS基础——十个常见的Mixins</a>。这篇文章总结了一些常用的 Mixin，更重要的是，通过这些Mixin，对 CSS 可以获得更深入的理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现自己又找到一本关于前端实践的优质开源书&lt;a href=&quot;https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/index.html&quot;&gt;《3周3页面》&lt;/a&gt;。作者通过实际项目介绍了前端必备的一些工具，教读者一步一步实现设计，而且步骤非常详细。写下这篇博文为止，我已经完成了第一个项目。在第一个项目中，作者向读者推荐了Sass，并且号称“一旦你开始使用它，你就再也回不去了。”&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SASS" scheme="http://kyonhuang.top/tags/SASS/"/>
    
      <category term="WebStorm" scheme="http://kyonhuang.top/tags/WebStorm/"/>
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>神奇的CSS动画</title>
    <link href="http://kyonhuang.top/css-animation/"/>
    <id>http://kyonhuang.top/css-animation/</id>
    <published>2017-03-25T07:58:01.000Z</published>
    <updated>2017-04-29T07:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。</p>
<p>通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。</p>
<p>17.04.03更新：补充打字机动效。</p>
<a id="more"></a>
<h2 id="transition-属性"><a href="#transition-属性" class="headerlink" title="transition 属性"></a>transition 属性</h2><p>transition 是一个速记属性，有以下四个属性：</p>
<ol>
<li>transition-property：指定 CSS 属性的 name, transition 效果；</li>
<li>transition-duration：transition 效果需要指定多少秒（或毫秒）才能完成；</li>
<li>transition-timing-function：指定 transition 效果的转速曲线，包括五个模式：ease（渐慢，默认）、linear（匀速）、ease-in（加速）、ease-out（减速）、cubic-bezier 函数（自定义速度模式，可使用<a href="http://cubic-bezier.com/" target="_blank" rel="external">工具网站</a>定制）；</li>
<li>transition-delay：定义 transition 效果开始的时候。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 简写</div><div class="line">img&#123;</div><div class="line">    transition: 1s 1s height ease;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 单独定义</div><div class="line">img&#123;</div><div class="line">    transition-property: height;</div><div class="line">    transition-duration: 1s;</div><div class="line">    transition-delay: 1s;</div><div class="line">    transition-timing-function: ease;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中必须指定 transition-duration 属性，否则持续时间默认为 0 ，没有任何效果。</p>
<p>transition 的局限：</p>
<ul>
<li>需要事件触发，没法在网页加载时自动发生；</li>
<li>一次性，除非一再触发，否则不能重复发生；</li>
<li>只能定义开始状态和结束状态（即只有两个状态），不能定义中间状态；</li>
<li>需要明确知道开始状态和结束状态的具体<strong>数值</strong>，才能计算中间状态；</li>
<li>一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ul>
<h2 id="keyframes（关键帧）"><a href="#keyframes（关键帧）" class="headerlink" title="keyframes（关键帧）"></a>keyframes（关键帧）</h2><p>animation 属性可以利用 keyframes 关键字定义动画的各个状态，将指定时间段内的动画划分的更为精细。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@keyframes rainbow &#123;</div><div class="line">  0% &#123; background: #c00; &#125;</div><div class="line">  50% &#123; background: orange; &#125;</div><div class="line">  100% &#123; background: yellowgreen; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">div:hover &#123;</div><div class="line">    animation: 1s rainbow infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0% 可以用 from 表示，100% 可以用 to 表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@keyframes rainbow &#123;</div><div class="line">  from &#123; background: #c00; &#125;</div><div class="line">  50% &#123; background: orange; &#125;</div><div class="line">  to &#123; background: yellowgreen; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果省略某个状态，浏览器会自动推算中间状态。也可将多个状态写在一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 以下都为合法的写法</div><div class="line"></div><div class="line">@keyframes rainbow &#123;</div><div class="line">  50% &#123; background: orange &#125;</div><div class="line">  to &#123; background: yellowgreen &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@keyframes rainbow &#123;</div><div class="line">  to &#123; background: yellowgreen &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@keyframes pound &#123;</div><div class="line">  from，to &#123; transform: none; &#125;</div><div class="line">  50% &#123; transform: scale(1.2); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从一个状态向另一个状态过渡，浏览器默认为平滑过渡。steps 函数可以实现分布过渡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div:hover &#123;</div><div class="line">  animation: 1s rainbow infinite steps(10);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="animation-常用属性"><a href="#animation-常用属性" class="headerlink" title="animation 常用属性"></a>animation 常用属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 简写</div><div class="line">div:hover &#123;</div><div class="line">    animation: 1s 1s rainbow linear 3 forwards normal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 单独定义</div><div class="line">div:hover&#123;</div><div class="line">    animation-name: rainbow;</div><div class="line">    animation-duration: 1s;</div><div class="line">    ainmation-timing-function: linear;</div><div class="line">    animation-delay: 1s;</div><div class="line">    animation-fill-mode: forwards;</div><div class="line">    animation-direction: normal;</div><div class="line">    animation-iteration-count: 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>animation 有以下常用属性（其余和 transition 大致相似）：</p>
<p><strong>animation-iteration-count</strong>：指定动画播放次数，可指定为数值或 infinite（无限次）。</p>
<p><strong>animation-direction</strong>：指定动画播放方向，默认为 normal。其他可选值有 reverse，alternate 和 alternate-reverse（后两种浏览器支持情况不佳）。</p>
<p><strong>animation-fill-mode</strong>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。有四个可选值：</p>
<ol>
<li>forwards：让动画停留在结束状态；</li>
<li>none：回到动画没开始的状态；</li>
<li>backwards：让动画回到第一帧的状态；</li>
<li>both：根据 animation-direction 轮流应用 forwards 和 backwards 规则。</li>
</ol>
<p><strong>animation-play-state</strong>：指定动画播放突然终止时的状态，默认行为是跳回动画的开始状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 让动画保持突然终止时的状态</div><div class="line"></div><div class="line">div &#123;</div><div class="line">    animation: spin 1s linear infinite;</div><div class="line">    animation-play-state: paused;</div><div class="line">&#125;</div><div class="line"></div><div class="line">div:hover &#123;</div><div class="line">    animation-play-state: running;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>IE 10、Firefox 16.0、Chrome 43.0、Safari 9.0、Opera 30.0 以上支持没有前缀的 animation。详见 <a href="http://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="external">CSS3 animation（动画） 属性
</a> “浏览器支持”部分。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="打字机动效"><a href="#打字机动效" class="headerlink" title="打字机动效"></a>打字机动效</h3><p>依照 <a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/animate_your_page/index.html" target="_blank" rel="external">让页面动起来</a> 实现的打字机动效。图片素材为自制，因此部分数据与参照有出入。素材及代码见 <a href="https://github.com/bighuang624/Front-end_Learning/tree/master/%E6%89%93%E5%AD%97%E6%9C%BA%E5%8A%A8%E6%95%88" target="_blank" rel="external">bighuang624/Front-end_Learning/打字机动效</a>。</p>
<p><img src="/images/type-writer.jpg"></p>
<p>（gif图没搞好…）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="external">CSS动画简介 - 阮一峰的网络日志</a></p>
<p><a href="http://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="external">CSS3 animation（动画） 属性
</a></p>
<p><a href="https://github.com/junruchen/junruchen.github.io/wiki/CSS-%E5%8F%98%E6%8D%A2-%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" target="_blank" rel="external">CSS 变换 过渡 动画使用案例</a></p>
<p>补充：</p>
<p><a href="https://aotu.io/notes/2016/11/28/css3-animation-properties/" target="_blank" rel="external">css3 animation 属性众妙</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。&lt;/p&gt;
&lt;p&gt;通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。&lt;/p&gt;
&lt;p&gt;17.04.03更新：补充打字机动效。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS动画" scheme="http://kyonhuang.top/tags/CSS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>探究JS中的词法作用域</title>
    <link href="http://kyonhuang.top/20953/"/>
    <id>http://kyonhuang.top/20953/</id>
    <published>2017-03-22T13:58:50.000Z</published>
    <updated>2017-03-22T14:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 <a href="https://github.com/qibaoguang/Study-Step-by-Step/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/javascript_the_good_parts.md" target="_blank" rel="external">JavaScript 语言精粹</a> 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 <a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="external">箭头函数</a> 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。”</p>
<p>这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。</p>
<a id="more"></a>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>《JavaScript 权威指南》第5章“8.8.1 词法作用域”中对“词法作用域”的解释如下：</p>
<p>“JavaScript 中的函数是通过词法来划分作用域的，而不是动态地划分作用域的。这意味着它们在定义它们的作用域里运行，而不是在执行它们的作用域里运行。当定义了一个函数，当前的作用域链就保存起来，并且成为函数的内部状态的一部分。”</p>
<p>当然，这几句话还是玄之又玄，摸不着头脑。它还是没有具体解释“词法作用域”中的“词法”二字代表什么。不过我这学期的《编译原理》课程上经常见到这个词：编译过程被划分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成 6 个阶段（清华大学出版社《编译原理》）。在查阅资料后，我确信这个概念确实与编译有关。</p>
<p>JavaScript 引擎在代码执行前会对其进行编译，而所谓的词法作用域指作用域是由书写代码时<strong>函数声明的位置</strong>决定，在词法解析阶段就已经确定，之后不会改变。也就是说，JS 中的“词法作用域”等同于静态作用域，即与动态作用域（运行时确定）相对。</p>
<p>词法作用域关注函数在<strong>何处声明</strong>；而动态作用域关注函数从<strong>何处调用</strong>，其作用域链是基于运行时的调用栈的。换言之，在遇到既不是形参也不是函数内部定义的局部变量的变量时，词法作用域的函数会去函数定义时的环境中查询；而动态作用域的函数会到函数调用时的环境中查询。</p>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    print a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar()&#123;</div><div class="line">    var a = 3;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line">bar();</div></pre></td></tr></table></figure>
<p>采用词法作用域的语言会输出 2，而采用动态作用域的语言会输出 3。</p>
<p>顺便一提，在 JS 中<code>eval</code>和<code>with</code>可以产生动态作用域的效果。但《JavaScript 高级程序设计》不推荐使用此二者。</p>
<p>参考资料：</p>
<p><a href="https://www.zhihu.com/question/20032419" target="_blank" rel="external">动态作用域和词法域的区别是什么？- 知乎</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在对原生 JavaScript 的一些概念做一个回顾。在看一篇名为 &lt;a href=&quot;https://github.com/qibaoguang/Study-Step-by-Step/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/javascript_the_good_parts.md&quot;&gt;JavaScript 语言精粹&lt;/a&gt; 的文章时，看到作者认为 JavaScript 的优秀思想中有一条是“函数：基于词法来划分作用域，而不是动态划分作用域”。无独有偶，在二刷廖雪峰的 JavaScript 教程时，在 &lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000&quot;&gt;箭头函数&lt;/a&gt; 一节中有提到“箭头函数内部的 this 是词法作用域，由上下文确定。”&lt;/p&gt;
&lt;p&gt;这里的“词法作用域”这个概念我之前没有留意过，在《JavaScript 高级程序设计》中好像也没有看到过（也有可能是我压根没注意到）。作为一只刚入前端坑的菜鸡，我在查阅各种资料后总结了自己对词法作用域的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="概念理解" scheme="http://kyonhuang.top/tags/%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    
      <category term="JavaScript" scheme="http://kyonhuang.top/tags/JavaScript/"/>
    
      <category term="词法作用域" scheme="http://kyonhuang.top/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>在把玩中学习——typewriter.js</title>
    <link href="http://kyonhuang.top/typewriter/"/>
    <id>http://kyonhuang.top/typewriter/</id>
    <published>2017-03-17T03:28:32.000Z</published>
    <updated>2017-04-25T10:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。</p>
<p>好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。</p>
<p><img src="/images/typewriter.jpg"></p>
<a id="more"></a>
<p>这个有打字和仿光标闪烁效果的 <a href="http://www.jq22.com/jquery-info6035" target="_blank" rel="external">typewriter.js</a> 好像是我在看什么“程序员表白利器”时加到收藏夹里的。现在学习了 js，敢看看源码了，发现 js 代码只有20行不到。作者说：“原生JavaScript就是这么牛。”确实是这样的。虽然效果也很简单，但也能从里面学到一些东西。</p>
<p>HTML 源代码（大致结构）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;mainDiv&quot;&gt;</div><div class="line">        &lt;div id=&quot;content&quot;&gt;</div><div class="line">            &lt;div id=&quot;code&quot;&gt;</div><div class="line">                &lt;span class=&quot;comments&quot;&gt;/**&lt;/span&gt;&lt;br /&gt;</div><div class="line">                &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* We are both XXX Unversity  business administration and programmers,&lt;/span&gt;&lt;br /&gt;</div><div class="line">                &lt;span class=&quot;space&quot;/&gt;&lt;span class=&quot;comments&quot;&gt;* so I write some code to show my love to you.&lt;/span&gt;&lt;br /&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"> document.getElementById(&quot;code&quot;).typewriter();</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>JavaScript 源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Element.prototype.typewriter=function(a)&#123;</div><div class="line">			var d = this,</div><div class="line">				c = d.innerHTML,</div><div class="line">				b = 0;</div><div class="line">			d.innerHTML=&quot;&quot;;</div><div class="line">			var e = setInterval(function() &#123;</div><div class="line">				var f = c.substr(b, 1);</div><div class="line">				if (f == &quot;&lt;&quot;) &#123;</div><div class="line">					b = c.indexOf(&quot;&gt;&quot;, b) + 1</div><div class="line">				&#125; else &#123;</div><div class="line">					b++</div><div class="line">				&#125;</div><div class="line">				d.innerHTML=c.substring(0, b) + (b &amp; 1 ? &quot;_&quot; : &quot;&quot;);</div><div class="line">				if (b &gt;= c.length) &#123;</div><div class="line">					clearInterval(e)</div><div class="line">				&#125;</div><div class="line">			&#125;, 75)</div><div class="line">		return this</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在这份 js 代码中可以学习的点：</p>
<ol>
<li><strong>原型模式定义方法</strong>：给 Element 添加实例方法<code>typewriter()</code>（在 html 文件中调用），这里有一个参数 a，实际上没什么用。顺便一说，源码在 head 处引入了 js 文件，这是为了先加载 js 文件。如果按照代码规范将引入放在 body 部分的最后，则有一瞬间所有字先出现再消失，不符合效果要求。可见代码规范也要根据实际来遵守。</li>
<li>声明三个变量，d 保存当前对象（”code”）。这个操作是必要的，因为后面要给 “code” 的 innerHTML 赋值的时候有时在函数作用域中，this 取不到 “code”。</li>
<li>代码逻辑很清晰，包括对标签的处理、光标效果的实现和定时器的清除等。要对自己想要实现的效果有一个全面的认知和大致的构思再开始写代码。</li>
<li>末尾<code>return this</code>以<strong>支持链式操作</strong>。</li>
</ol>
<p>想要用功能强大的JavaScript实现一些小效果不难，但是怎样一步步规划、修改到实现对现在的我来说还是比较有挑战性的。希望自己能在欣赏、借鉴、吸收的过程中去实现一些有趣的 demo，重拾对代码的兴趣和创造力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。&lt;/p&gt;
&lt;p&gt;好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/typewriter.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（五）</title>
    <link href="http://kyonhuang.top/JS-notes-5/"/>
    <id>http://kyonhuang.top/JS-notes-5/</id>
    <published>2017-03-15T02:43:51.000Z</published>
    <updated>2017-04-28T07:50:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了看LESS。前端要研究的东西确实有点多，压力有点大。而且发现自己动手写代码的水平也有待提高。从今天开始理论学习要给实践让让路了，加油加油。</p>
<p>这篇博文总结了《JavaScript高级程序设计》的20~21章：JSON、AJAX与Comet。此外，关于CORS的部分还参考了廖雪峰的JavaScript教程。</p>
  <a id="more"></a>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是一种数据格式。虽然有相同的语法形式，但JSON不从属于JavaScript。很多编程语言都有针对JSON的解析器和序列化器。</p>
<p><strong>语法</strong></p>
<p>1.JSON的语法可以表示三种类型的值：简单值、对象、数组。</p>
<p>2.简单值：可表示字符串、数值、布尔值和 null，但不支持 undefined。JSON字符串必须使用双引号。</p>
<p>3.对象：表示一组无序的键值对。没有声明变量（JSON中没有变量概念），没有末尾分号，对象属性名必须加双引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;Kyon&quot;,</div><div class="line">    &quot;age&quot;: 20,</div><div class="line">    &quot;school&quot;: &#123;</div><div class="line">        &quot;name&quot;: &quot;Wuhan University&quot;,</div><div class="line">        &quot;major&quot;: &quot;Software Engineering&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.数组：表示一组有序的值的列表，可以通过数值索引来访问其中的值。</p>
<p><strong>解析与序列化</strong></p>
<p>5.JSON对象有两个方法：<code>stringify()</code>把JavaScript对象序列化为JSON字符串，<code>parse()</code>把JSON字符串解析为原生JavaScript值。</p>
<p>6.<code>JSON.stringify()</code>还可以接收另外两个参数：第一个参数是个过滤器（数组：结果中只包含数组列出的属性；函数：传入的函数接收两个参数，属性名和属性值，根据属性名判断如何处理属性）；第二个参数控制结果中的缩进和空白符，数值表示缩进空格数，字符串被用作缩进字符。</p>
<p>7.<code>toJSON</code>：自定义序列化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    &quot;name&quot;: &quot;Kyon&quot;,</div><div class="line">    age: 20,</div><div class="line">    toJSON: function()&#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var jsonText = JSON.stringify(person);</div></pre></td></tr></table></figure>
<p>8.<code>JSON.parse()</code>还可以接受一个参数：将在每个键值对上调用的还原函数（与<code>JSON.stringify()</code>的过滤函数相同）。</p>
<h2 id="AJAX与Comet"><a href="#AJAX与Comet" class="headerlink" title="AJAX与Comet"></a>AJAX与Comet</h2><p>Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR）。可以使用 XHR对象取得新数据，然后再通过 DOM 将新数据插入到页面中，无须刷新页面即可从服务器取得数据。</p>
<p><strong>XMLHttpRequest 对象</strong></p>
<p>1.用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">    if(xhr.readState === 4)&#123;</div><div class="line">        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123;</div><div class="line">            console.log(xhr.responseText);</div><div class="line">        &#125; else &#123;</div><div class="line">            console.log(&apos;Request was unsuccessful: &apos; + xhr.status);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// GET请求</div><div class="line">xhr.open(&apos;get&apos;, &apos;example.php&apos;);</div><div class="line">xhr.send(null);</div><div class="line"></div><div class="line">// POST请求</div><div class="line">xhr.open(&apos;open&apos;, &apos;postexample.php&apos;);</div><div class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</div><div class="line">var form = document.getElementById(&apos;user-info&apos;);</div><div class="line">xhr.send(serialize(form));</div><div class="line">// 将ID为user-info的表单中数据序列化后发送给服务器</div></pre></td></tr></table></figure>
<ul>
<li>创建XHR对象：<code>new XMLHttpRequest()</code>;</li>
<li><code>open()</code>：启动一个请求以备发送。接收三个参数：请求类型（”get”、”post”等）、请求的URL、是否异步发送请求（默认是true，一定不能为false，否则必须等到服务器响应后再继续执行）。</li>
<li><code>send()</code>：发送请求。GET请求不需要参数，POST请求要把body部分字符串或者<code>FormData</code>对象传进去。</li>
</ul>
<p>2.XHR对象的属性：</p>
<ul>
<li>responseText：返回的文本；</li>
<li>status：响应的HTTP状态；</li>
</ul>
<p>3.HTTP状态码：</p>
<ul>
<li>2xx：成功；</li>
<li>3xx：重定向，304 Not Modified 表示请求的资源没有被修改，可以直接用浏览器缓存的版本，302 Found 表示请求的资源现在临时从不同的URI响应请求；</li>
<li>4xx：客户端错误，403 Forbidden，404 NotFound；</li>
<li>5xx：服务器错误，500 Internal Server Error，503 Service Unavailable。</li>
</ul>
<p>4.XHR的 readyState 属性：表示请求/响应过程的当前活动阶段：</p>
<ul>
<li>0：未初始化；</li>
<li>1：启动，已调用<code>open()</code>，未发送；</li>
<li>2：发送，已调用<code>send()</code>，未收到响应；</li>
<li>3：接收到部分响应数据；</li>
<li>4：接收到全部响应数据。</li>
</ul>
<p>5.readystatechange事件：readystate属性的值由一个值变成另一个值，都会触发readystatechange事件。</p>
<p><strong>跨源资源共享</strong></p>
<p>6.跨域安全策略：XHR对象只能访问与包含它的页面位于同一个域的资源（域名、协议、端口号都要相同）。</p>
<p>7.CORS（跨源资源共享）：HTML5规范定义的如何跨域访问资源。当JavaScript 向外域发起请求后，浏览器收到响应后首先检查<code>Access-Control-Allow-Origin</code>是否包含本域。如果不是，请求失败，JavaScript 无法获取到响应的任何数据。</p>
<p>跨域是否成功，取决于对方服务器是否给本域设置一个正确的<code>Access-Control-Allow-Origin</code>。</p>
<p>以上“简单请求”包括GET、HEAD和POST（POST的Content-Type类型仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头。</p>
<p>对于PUT、DELETE以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">OPTIONS /path/to/resource HTTP/1.1</div><div class="line">Host: bar.com</div><div class="line">Origin: http://my.com</div><div class="line">Access-Control-Request-Method: POST</div></pre></td></tr></table></figure>
<p>服务器必须响应并明确指出允许的Method：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Access-Control-Allow-Origin: http://my.com</div><div class="line">Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS</div><div class="line">Access-Control-Max-Age: 86400</div></pre></td></tr></table></figure>
<p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>
<p><strong>其他跨域技术</strong></p>
<p>8.图像Ping：与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。</p>
<p>对于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.onload = img.onerror = function()&#123;</div><div class="line">    console.log(&quot;Done!&quot;);</div><div class="line">&#125;;</div><div class="line">// onload和onerror事件处理程序指定为同一函数，请求完成时无关响应得到通知</div><div class="line">img.src = &quot;http://www.example.com/test?name=Nicholas&quot;;</div><div class="line">// 请求从设置src属性那一刻开始</div></pre></td></tr></table></figure>
<p>两个主要缺点：只能发送GET请求；无法访问服务器的响应文本。因此只能用于浏览器与服务器间的单向通信。</p>
<p>9.JSONP（JSON with padding）：包含在函数调用中的JSON。由回调函数和数据组成。只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上利用了浏览器允许跨域引用JavaScript资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 得到的返回</div><div class="line">refreshPrice(&#123;&quot;0000001&quot;:&#123;&quot;code&quot;:&quot;0000001&quot;, ...&#125;&#125;);</div><div class="line"></div><div class="line">// 在页面中准备好回调函数</div><div class="line">function refreshPrice(data)&#123;</div><div class="line">    var p = document.getElementById(&apos;test-jsonp&apos;);</div><div class="line">    p.innerHTML = &apos;当前价格：&apos; + data[&apos;0000001&apos;].name + &quot;：&quot; + data[&apos;0000001&apos;].price;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 触发</div><div class="line">function getPrice()&#123;</div><div class="line">    var </div><div class="line">        js = document.createElement(&apos;script&apos;),</div><div class="line">        head = document.getElementByTagName(&apos;head&apos;)[0];</div><div class="line">        self = document.getElementById(&apos;dynamic-jsonp&apos;);</div><div class="line">    if(self)&#123;</div><div class="line">        var parent = self.parentElement;</div><div class="line">        parent.removeChild(self);</div><div class="line">    &#125;</div><div class="line">    js.id = &apos;dynamic-jsonp&apos;;</div><div class="line">    js.src = &apos;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&apos;;</div><div class="line">    head.appendChild(js);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：从其他域中加载代码执行，安全性不可靠；不易确定请求是否失败。</p>
<p>10.Comet：对AJAX的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现Comet的手段主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，只有部分浏览器原生支持HTTP流。</p>
<p>补充：轮询是指通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器是否有新消息。缺点：(1)实时性不够；(2)频繁请求会给服务器带来极大压力。</p>
<p>11.SSE（服务器发送事件）：一种实现Comet交互的浏览器API，既支持长轮询，也支持HTTP流。</p>
<p>12.Web Sockets：目标是在一个单独的持久连接上提供全双工、双向通信。使用一种专为快速传输小数据设计的自定义协议。</p>
<p><strong>安全</strong></p>
<p>13.为确保通过XHR访问的URL安全，通行做法是验证发送请求者是否有权限访问响应的资源。有下列方式：</p>
<ul>
<li>要求以SSL连接来访问可以通过XHR请求的资源。</li>
<li>要求每一次请求都要附带经过相应算法计算得到的验证码。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了看LESS。前端要研究的东西确实有点多，压力有点大。而且发现自己动手写代码的水平也有待提高。从今天开始理论学习要给实践让让路了，加油加油。&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的20~21章：JSON、AJAX与Comet。此外，关于CORS的部分还参考了廖雪峰的JavaScript教程。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（四）</title>
    <link href="http://kyonhuang.top/JS-notes-4/"/>
    <id>http://kyonhuang.top/JS-notes-4/</id>
    <published>2017-03-12T04:13:51.000Z</published>
    <updated>2017-04-28T07:50:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>花旗杯的团队已经组好了。自己要加快学习进度，保证不拖组织的后腿。全力以赴，尽善尽美，希望最后能够有好的成绩。</p>
<p>这篇博文总结了《JavaScript高级程序设计》的13~14章：事件，表单脚本。</p>
  <a id="more"></a>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><strong>事件流</strong></p>
<p>1.<strong>事件流</strong>描述从页面接收事件的顺序。IE提出事件冒泡流，Netscape提出事件捕获流。</p>
<p>2.<strong>事件冒泡</strong>：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p>
<p>3.事件捕获：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。由于老版本浏览器不支持，不推荐使用。</p>
<p>4.“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。</p>
<p><strong>事件处理程序</strong></p>
<p>5.HTML事件处理程序：扩展作用域，在函数内部可以像访问局部变量一样访问document及该元素本身的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(value)&quot;&gt;</div></pre></td></tr></table></figure>
<p>如果是一个表单输入元素，则作用域中还会包含访问表单元素的入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;post&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt;</div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;Echo username&quot; onclick=&quot;console.log(username.value)&quot;&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>缺点：(1)存在时差问题，函数被解析之前就触发事件会引发错误；(2)扩展处理程序的作用域链在不同浏览器中会导致不同结果；(3)HTML和JavaScript代码紧密耦合。</p>
<p>6.DOM0级事件处理程序：每个元素都有自己的事件处理程序属性，将其设置为一个函数，就可以指定事件处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 绑定事件处理程序</div><div class="line">var btn = document.getElementById(&quot;myBtn&quot;);</div><div class="line">btn.onclick = function()&#123;</div><div class="line">    console.log(this.id);  // &quot;myBtn&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 删除事件处理程序</div><div class="line">btn.onclick = null;</div></pre></td></tr></table></figure>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</p>
<p>7.DOM2级事件处理程序：<code>addEventListener()</code>和<code>removeEventListener()</code>，接受3个参数：要处理的事件名、事件处理程序函数和一个布尔值（true表示在捕获阶段调用事件处理程序，默认为false表示冒泡阶段调用）。</p>
<p>移除时传入的参数与添加处理程序时使用的参数相同，意味着通过<code>addEventListener()</code>添加的匿名函数无法移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">byn.addEventListener(&quot;click&quot;, handler, false);</div><div class="line">...</div><div class="line">btn.removeEventListener(&quot;click&quot;, handler, false);  // 有效</div></pre></td></tr></table></figure>
<p>8.IE事件处理程序：<code>attachEvent()</code>和<code>detachEvent()</code>，接收两个参数：要处理的事件名、事件处理程序函数。事件处理程序被添加到冒泡阶段，在全局作用域中运行（this 等于 window）。支持IE事件处理程序的浏览器有 IE 和 Opera。</p>
<p><strong>事件对象</strong></p>
<p>9.在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息。只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。</p>
<p>10.属性/方法：</p>
<ul>
<li>currentTarget：正在处理事件的那个元素。</li>
<li>target：事件的目标。</li>
<li>type：事件类型。</li>
<li>cancelable：可以阻止特定事件的默认行为。</li>
<li>preventDefault()：阻止特定事件的默认行为。</li>
<li>stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。</li>
<li>eventPhase：调用事件处理程序的阶段：捕获阶段为1，处于目标对象为2，冒泡阶段为3。</li>
</ul>
<p><strong>事件类型</strong></p>
<p>11.“DOM3级事件”规定了以下几类事件：</p>
<ul>
<li>UI（用户界面）事件，当用户与页面上的元素交互时触发：<code>load</code>、<code>unload</code>、<code>resize</code>、<code>scroll</code>。</li>
<li>焦点事件，当元素获得或失去焦点时触发。</li>
<li>鼠标与滚轮事件：<code>click</code>、<code>dblclick</code>、<code>mousedown</code>、<code>mouseenter</code>、<code>mouseleave</code>、<code>mouseout</code>、<code>mouseover</code>、<code>mouseup</code>。</li>
<li>键盘与文本事件：<code>keydown</code>、<code>keypress</code>、<code>keyup</code>、<code>textInput</code>。</li>
<li>复合事件，用于处理IME（输入法编辑器，让用户输入在物理键盘上找不到的字符）的输入序列。</li>
<li>变动事件，当DOM中的某一部分发生变化时给出提示。</li>
</ul>
<p><strong>内存和性能</strong></p>
<p>to be continued..</p>
<h2 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h2><p>to be continued..</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花旗杯的团队已经组好了。自己要加快学习进度，保证不拖组织的后腿。全力以赴，尽善尽美，希望最后能够有好的成绩。&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的13~14章：事件，表单脚本。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（三）</title>
    <link href="http://kyonhuang.top/JS-notes-3/"/>
    <id>http://kyonhuang.top/JS-notes-3/</id>
    <published>2017-03-10T02:23:02.000Z</published>
    <updated>2017-04-28T07:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>稍微大致翻了一下这本书后续的内容。为了尽快的进入ES6以及框架部分的学习，决定暂时跳过某些章节的学习。后面打算学习的章节有6、7、13、14、20、21、22、24章，剩下的章节等到用到或者时间富余的时候再看。</p>
<p>这篇博文总结了《JavaScript高级程序设计》的6~7章：面向对象的程序设计，以及函数表达式。</p>
  <a id="more"></a>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><p><strong>理解对象</strong></p>
<p>1.ECMAScript中有两种属性：数据属性和访问器属性。</p>
<p>特性：描述属性的各种特征。目的是实现JavaScript，因此在JavaScript中不能直接访问。为了表示特性是内部值，放在两对方括号中，例如<code>[[Enumerable]]</code>。</p>
<p>2.数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。</p>
<ul>
<li><code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。</li>
<li><code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。默认为 true。</li>
<li><code>[[Writable]]</code>：表示能否修改属性的值。默认为 true。</li>
<li><code>[[Value]]</code>：包含这个属性的数据值。默认为 undefined。</li>
</ul>
<p><code>Object.defineProperty()</code>方法可以修改属性默认的特性。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable、enumerable、writable 和 value 中的一或多个。</p>
<p>3.访问器属性：</p>
<ul>
<li><code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为 true。</li>
<li><code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。默认为 true。</li>
<li><code>[[Get]]</code>：在读取属性时调用的函数。默认为 undefined。</li>
<li><code>[[Set]]</code>：在写入属性时调用的函数。默认为 undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var book = &#123;</div><div class="line">    _year: 2016,  // 下划线表示只能通过对象方法访问的属性</div><div class="line">    edition: 1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.defineProperty(book, &quot;year&quot;, &#123;</div><div class="line">    get: function()&#123;</div><div class="line">        return this._year;</div><div class="line">    &#125;,</div><div class="line">    set: function(newValue) &#123;</div><div class="line">       if(newValue &gt; 2016) &#123;</div><div class="line">           this._year = newValue;</div><div class="line">           this.edition += newValue - 2004;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);  // year 是访问器属性</div><div class="line"></div><div class="line">book.year = 2017;</div><div class="line">console.log(book.edition);  // 2</div></pre></td></tr></table></figure>
<p>4.定义多个属性可用<code>Object.defineProperties()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var book = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperties(book, &#123;</div><div class="line">    _year: &#123;</div><div class="line">        value: 2016</div><div class="line">    &#125;,</div><div class="line">    edition: &#123;</div><div class="line">        value: 1</div><div class="line">    &#125;,</div><div class="line">    year: &#123;</div><div class="line">        get: function()&#123;</div><div class="line">            return this._year;</div><div class="line">        &#125;,</div><div class="line">        set: function(newValue)&#123;</div><div class="line">            if(newValue &gt; 2016)&#123;</div><div class="line">                this._year = newValue;</div><div class="line">                this.edition += newValue - 2016;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyDescriptor()</code>方法可以取得给定属性的描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);</div><div class="line">console.log(descriptor.value);  // 2016</div><div class="line">console.log(descriptor.configurable);  // false</div><div class="line">console.log(typeof descriptor.get);  // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<p><strong>创建对象</strong></p>
<p>5.工厂模式：虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age, job) &#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = function () &#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line">var p1 = createPerson(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">var p2 = createPerson(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);</div></pre></td></tr></table></figure>
<p>6.构造函数模式：以大写字母开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);</div><div class="line"></div><div class="line">// 对象的constructor属性指向其构造函数</div><div class="line">console.log(p1.constructor);  // function Person(name, age, job)&#123;...</div></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。</p>
<p>也可以使用<code>call()</code>（或者<code>apply()</code>）在某个特殊对象的作用域中调用构造函数，调用后这个对象就拥有了所有属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div><div class="line">Person.call(o, &apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">o.sayName();  // &apos;Kyon&apos;</div></pre></td></tr></table></figure>
<p>使用构造函数的主要问题：每个方法都要在每个实例上重新创建一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(p1.sayName === p2.sayName);  // false</div></pre></td></tr></table></figure>
<p>7.原型模式：每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向函数的原型对象。这个对象包含可以由该类型的所有实例共享的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line">console.log(p1.sayName === p2.sayName);  // true</div></pre></td></tr></table></figure>
<ul>
<li><p>理解原型对象：</p>
<p> – 只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，指向函数的原型对象。</p>
<p> – 默认所有原型对象都会获得一个 constructor 属性，指向 prototype 属性所在函数。</p>
<p> – 当调用构造函数创建一个新实例后，实例将有一个 <code>__proto__</code>属性，指向构造函数的原型对象，指针叫<code>[[Prototype]]</code>，默认原型指向Object。</p>
<p> – 实例和构造函数没有直接关系。</p>
<p> <img src="/images/jsNotes/proto.jpg"></p>
<p> – 读取属性：搜索先从对象实例本身开始，如果没找到，搜索原型对象。</p>
<p> – 使用<code>isPrototype()</code>来检测构造函数和实例之间是否有关系。</p>
<p> – <code>Object.getPrototypeOf()</code>返回<code>[[Prototype]]</code>的值。</p>
<p> – 使用<code>hasOwnProperty()</code>来检测属性存在于实例中还是原型中。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &apos;Kyon&apos;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &apos;Software Engineer&apos;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var p1 = new Person();</div><div class="line">var p2 = new Person();</div><div class="line"></div><div class="line">console.log(Person.prototype.isPrototypeOf(p1));  // true</div><div class="line"></div><div class="line">console.log(Object.getPrototypeOf(p1) === Person.prototype);  // true</div><div class="line">console.log(Object.getPrototypeOf(p1).name);  // &apos;Kyon&apos;</div><div class="line"></div><div class="line">console.log(p1.hasOwnProperty(&quot;name&quot;));  // false</div><div class="line"></div><div class="line">p1.name = &quot;someone&quot;;</div><div class="line">console.log(p1.hasOwnProperty(&quot;name&quot;));  // true</div><div class="line"></div><div class="line">delete p1.name;</div><div class="line">console.log(p1.hasOwnProperty(&quot;name&quot;));  // false</div></pre></td></tr></table></figure>
<ul>
<li>原型与 in 操作符：在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;name&apos; in p1);  // true</div></pre></td></tr></table></figure>
<ul>
<li>更简单的原型语法：用一个包含所有属性和方法的对象字面量来重写整个原型对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor: Person,  // 默认的 prototype 对象被重写，需设置</div><div class="line">    name: &apos;Kyon&apos;,</div><div class="line">    age: 20,</div><div class="line">    job: &apos;Software Engineer&apos;,</div><div class="line">    sayName: function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍是最初的原型。</p>
<p><img src="/images/jsNotes/yuanxingchongxie.jpg"></p>
<ul>
<li>原生对象的原型：通过原生对象的原型可以定义新方法。不推荐，可能导致命名冲突或意外重写原生方法。</li>
<li>原型对象的问题：包含引用类型值的属性会被共享。</li>
</ul>
<p>8.<strong>组合使用构造函数模式和原型模式</strong>：创建自定义类型最常见方式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 组合使用构造函数模式与原型模式</div><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.friends = [&quot;Sam&quot;, &quot;Judie&quot;];</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor: Person,</div><div class="line">    sayName: function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p1 = new Person(&apos;Kyon&apos;, 20, &apos;Software Engineer&apos;);</div><div class="line">var p2 = new Person(&apos;Someone&apos;, 19, &apos;Lawyer&apos;);</div><div class="line"></div><div class="line">p1.friends.push(&quot;Vue&quot;);</div><div class="line">console.log(p1.friends);  // &quot;Sam, Judie, Vue&quot;</div><div class="line">console.log(p2.friends);  // &quot;Sam, Judie&quot;</div><div class="line">console.log(p1.sayName === p2.sayName);  // true</div></pre></td></tr></table></figure>
<p>9.动态原型模式、寄生构造函数模式、稳妥构造函数模式</p>
<p><strong>继承</strong></p>
<p>10.许多OO语言都支持两种继承方式：接口继承（只继承方法签名）和实现继承（继承实际方法）。由于函数没有签名，ECMAScript 中无法实现接口继承，而实现继承主要依靠<strong>原型链</strong>实现。</p>
<p>11.原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法。</p>
<p>12.p182开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function () &#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">function SubType(name, age) &#123;</div><div class="line">	SuperType.call(this, name);  // 借用构造函数</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">SubType.prototype = new SuperType();  // 原型链</div><div class="line">SubType.prototype.constructor = SubType;  // construcotr在上一句中被重写</div><div class="line">SubType.prototype.sayAge = function () &#123;</div><div class="line">	console.log(this.age);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var instance = new SubType(&apos;Kyon&apos;, 20);</div><div class="line">instance.sayName();  // Kyon</div><div class="line">instance.sayAge();  // 20</div></pre></td></tr></table></figure>
<p>说实话，这部分看得我脑壳疼。要不我们直接用ES6引入的class可好？等我哪一天沐浴更衣虔诚焚香再来看…</p>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p><strong>递归</strong></p>
<p>1.在严格模式下，不能通过脚本访问<code>arguments.callee</code>来实现递归。可以用命名函数表达式来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var factorial = (function f(num)&#123;</div><div class="line">    if(num &lt;= 1)&#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * f(num-1);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>闭包</strong></p>
<p>2.<strong>闭包</strong>是指有权访问另一个函数作用域中的变量的函数（匿名函数的 function 关键字后没有标识符，二者不能混用）。</p>
<p>3.创建闭包的常见方式：在一个函数内部创建另一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outer()&#123;</div><div class="line">    var name = &quot;Kyon&quot;;</div><div class="line">    return function()&#123;</div><div class="line">        console.log(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var inner = outer();</div><div class="line">inner();  // Kyon</div><div class="line">inner = null;  // 解除对outer内部的匿名函数的引用，以释放内存</div></pre></td></tr></table></figure>
<p>在外部函数内部定义的内部函数将外部函数的活动对象（作为变量对象使用）添加到它的作用域链中；外部函数执行完毕后，其活动对象不会被销毁，因为内部函数的作用域链仍在引用这个活动对象；外部函数执行完毕后，内部函数仍然可以访问到其定义的所有变量。</p>
<p>4.由于闭包会携带包含它的函数的作用域，过度使用可能导致内存占用过多，要慎重使用。</p>
<p>5.返回的函数并没有立刻执行，而是等到调用<code>f()</code>才执行。因此返回函数不能引用任何循环变量，或者后续会发生变化的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function count()&#123;</div><div class="line">    var arr = [];</div><div class="line">    for(var i=1; i&lt;=3; i++)&#123;</div><div class="line">        arr[i] = function()&#123;</div><div class="line">             return i * i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var results = count();</div><div class="line">var f1 = results[0];</div><div class="line">var f2 = results[1];</div><div class="line">var f3 = results[2];</div><div class="line"></div><div class="line">// 返回的函数引用了变量i，但并非立即执行。执行时i已变成4</div><div class="line">f1();  // 16</div><div class="line">f2();  // 16</div><div class="line">f3();  // 16</div></pre></td></tr></table></figure>
<p>一定要引用循环变量的方法：再创建一个匿名函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function count()&#123;</div><div class="line">    var arr = [];</div><div class="line">    for(var i=1; i&lt;=3; i++)&#123;</div><div class="line">        arr[i] = function(num)&#123;</div><div class="line">            return function()&#123;</div><div class="line">                return num;</div><div class="line">            &#125;;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">// i的当前值复制给参数num，匿名函数内部又创建并返回一个访问num的闭包，使得result数组中的每个函数都有自己num变量的一个副本</div></pre></td></tr></table></figure>
<p>这里用了一个“创建一个匿名函数并立即执行”的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(x)&#123;</div><div class="line">    return x * x;</div><div class="line">&#125;)(3);  // 9</div></pre></td></tr></table></figure>
<p>6.闭包中使用 this 对象：匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getName: function()&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;; </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(object.getName());  // &quot;The Window&quot;(非严格模式)</div></pre></td></tr></table></figure>
<p>把外部作用域中的 this 对象保存在一个闭包能够访问的变量中，就可以让闭包访问该对象了（想访问作用域中的 arguments对象同理）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getName: function()&#123;</div><div class="line">        var that = this;</div><div class="line">        return function()&#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;; </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(object.getName());  // &quot;My Object&quot;</div></pre></td></tr></table></figure>
<p>7.补充：利用闭包可以实现私有变量的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 用JavaScript创建一个计数器</div><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">function create_counter(initial)&#123;</div><div class="line">    var x = initial || 0;</div><div class="line">    return &#123;</div><div class="line">        inc: function()&#123;</div><div class="line">            x += 1;</div><div class="line">            return x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">var c1 = create_counter();</div><div class="line">c1.inc();  // 1</div><div class="line">c1.inc();  // 2</div><div class="line">var c2 = create_counter(10);</div><div class="line">c2.inc();  // 11</div><div class="line">c2.inc();  // 12</div></pre></td></tr></table></figure>
<p><strong>模仿块级作用域</strong></p>
<p>8.用匿名函数模仿块级作用域：</p>
<p>JavaScript将 function 关键字当作一个函数声明的开始，而函数声明后不能加圆括号。</p>
<p>将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随的另一对圆括号会立即调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">function()&#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;();  ／／ Error!</div></pre></td></tr></table></figure>
<p>9.这种技术经常用于限制向全局作用域中添加过多的变量和函数；同时可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">    var now = new Date();</div><div class="line">    if(now.getMonth() == 11 &amp;&amp; now.getDate() == 25)&#123;</div><div class="line">        console.log(&quot;Merry Christmas!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p><strong>私有变量</strong></p>
<p>10.任何在函数中定义的变量，都可以认为是私有变量。</p>
<p>11.有权访问私有变量和私有函数的公有方法被称为<strong>特权方法</strong>。两种在对象上创建特权方法的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 1.构造函数中定义特权方法</div><div class="line">function MyObject()&#123;</div><div class="line"></div><div class="line">    // 私有变量和私有函数</div><div class="line">    var privateVar = 10;</div><div class="line">    function privateFunc()&#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 特权方法</div><div class="line">    this.publicMethod = function()&#123;</div><div class="line">        privateVar++;</div><div class="line">        return privateFunc();</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.利用私有和特权成员</div><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">    this.getName = function()&#123;</div><div class="line">        return name;</div><div class="line">    &#125;;</div><div class="line">    this.setName = function(value)&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>12.可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;稍微大致翻了一下这本书后续的内容。为了尽快的进入ES6以及框架部分的学习，决定暂时跳过某些章节的学习。后面打算学习的章节有6、7、13、14、20、21、22、24章，剩下的章节等到用到或者时间富余的时候再看。&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的6~7章：面向对象的程序设计，以及函数表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（二）</title>
    <link href="http://kyonhuang.top/JS-notes-2/"/>
    <id>http://kyonhuang.top/JS-notes-2/</id>
    <published>2017-03-03T09:33:08.000Z</published>
    <updated>2017-04-28T07:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续记录在读《JavaScript高级程序设计》时的零碎知识点。这几天在知乎上看到了别人使用 Electron 构建桌面应用，感觉还蛮有意思的。有兴趣的同学可以看看<a href="https://zhuanlan.zhihu.com/p/20225295?columnSlug=FrontendMagazine" target="_blank" rel="external">使用 Electron 构建桌面应用</a>和<a href="https://zhuanlan.zhihu.com/p/25415725" target="_blank" rel="external">用 ReactJs 创建Mac版的 keep</a>了解一下。也许在加深对JS的理解后，我也会选择用 Electron 做一个应用呢。Who knows?</p>
<p>这篇博文总结了《JavaScript高级程序设计》的4~5章：变量、作用域和内存问题，以及引用类型。</p>
  <a id="more"></a>
<h2 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h2><p><strong>基本类型和引用类型的值</strong></p>
<p>1.基本类型值在内存中占据固定大小的空间，因此被保存在<strong>栈内存</strong>中；引用类型的值是对象，保存在<strong>堆内存</strong>中。</p>
<p>2.当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。</p>
<p>3.从一个变量向另一个变量复制基本类型的值时，会创建这个值的一个副本；从一个变量向另一个变量复制引用类型的值时，复制的是指向存储在堆中的一个对象的指针，复制之后两个变量指向同一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var n1 = 1;</div><div class="line">var n2 = n1;</div><div class="line">n1 = 2;</div><div class="line">console.log(n2);  // 1</div><div class="line"></div><div class="line">var o1 = &#123;&#125;;</div><div class="line">var o2 = o1;</div><div class="line">o1.name = &apos;Kyon&apos;;</div><div class="line">console.log(o2.name);  // Kyon</div></pre></td></tr></table></figure>
<p>4.参数只能按值传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function setName(obj)&#123;</div><div class="line">    obj.name = &apos;Kyon&apos;;</div><div class="line">    obj = new Object();</div><div class="line">    obj.name = &apos;Huang&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">console.log(person.name);  // Kyon</div></pre></td></tr></table></figure>
<p>在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p>
<p>5.<code>typeof</code>检测基本数据类型，<code>instanceof</code>检测引用类型（根据其原型链来识别）。</p>
<p><strong>执行环境及作用域</strong></p>
<p>6.每个<strong>执行环境</strong>（简称为环境，可以理解为作用域）都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。每个函数都有自己的执行环境，全局执行环境（在Web浏览器中为window对象）是最外围的一个执行环境。</p>
<p>7.当执行流进入一个函数时，函数的环境就会被推入一个<strong>环境栈</strong>中。而在函数执行之后，栈将其环境弹出，把控制权返还给之前的执行环境。</p>
<p>8.当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，用于保证对执行环境有权访问的所有变量和函数的有序访问（搜索）。作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。</p>
<p>9.标识符解析：沿着作用域链一级一级地搜索标识符的过程。从作用域链的前端开始，逐级向后回溯，直到找到标识符为止（找不到通常导致错误）。</p>
<p>10.内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。</p>
<p>11.延长作用域链：当执行流进入 try-catch 语句的 catch 块或 with 语句时，作用域链就会得到加长。这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到作用域链中；对 catch 语句，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<p>12.JavaScript <strong>没有块级作用域，但有函数作用域</strong>（针对var）。</p>
<p>补充：在语法中的块级作用域是指if/else/for/while语句里2个大括号之间的部分。块级作用域里面定义的函数和变量在{}外部是可以被访问到的。但是函数就不行，比如你在函数体里面定义一个变量，那么函数执行完毕之后里面的变量就会直接被销毁，在函数体外部是不可能被访问到的。 </p>
<p>再补充：ES6标准引入了新的关键字 let 和 const。它们都具有块级作用域。</p>
<p><strong>垃圾收集</strong></p>
<p>13.JavaScript 具有自动垃圾收集机制，原理：垃圾收集器按照固定的时间间隔（或代码执行中预定的收集时间）释放不再继续使用的变量所占用的内存。</p>
<p>14.最常用的垃圾收集方式是<strong>标记清除</strong>：垃圾回收器在运行时会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记，而在此之后还有标记的变量被视为准备删除的变量，因为这些变量无法被访问到了。</p>
<p>此外，<strong>引用计数</strong>是另一种不太常用的垃圾收集策略，这种算法的思想是跟踪记录所有值被引用的次数。当代码中存在循环引用现象时，“引用计数”算法就会导致问题。JavaScript 引擎目前都不再使用这种算法，但IE访问非原生 JavaScript 对象（如DOM元素）时仍可能导致问题。</p>
<p>15.管理内存：优化内存占用的最佳方式为<strong>解除引用</strong>——一旦数据不再有用，通过将其值设置为null来释放其引用。解除引用的真正作用是让其值脱离执行环境，以便垃圾搜集器下次运行时将其回收，而并非自动回收该值所占的内存。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型的值（对象）是<strong>引用类型</strong>的一个实例。</p>
<p><strong>Object类型</strong></p>
<p>1.创建Object实例的两种方式：Object构造函数；<strong>对象字面量</strong>表示法。通过对象字面量定义对象时，实际不会调用Object构造函数（Firefox 2 及更早版本除外）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Kyon&quot;;</div><div class="line">person.age = 19;</div><div class="line"></div><div class="line">var person = &#123;</div><div class="line">     name : &quot;Kyon&quot;,</div><div class="line">     age : 19</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>2.访问对象属性常用点表示法，也可使用方括号表示法。除非必须用变量来访问属性，否则建议使用点表示法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(person.name);  // 点表示法</div><div class="line">console.log(person[&quot;name&quot;]);  // 方括号表示法</div><div class="line"></div><div class="line">var propertyName = &quot;name&quot;;</div><div class="line">console.log(person[propertyName]);</div><div class="line"></div><div class="line">console.log(person[&quot;first name&quot;]);</div></pre></td></tr></table></figure>
<p><strong>Array类型</strong></p>
<p>3.ECMAScript 数组的每一项可以保存任何类型的数据，并且大小可以动态调整。</p>
<p>4.创建数组的两种基本方式：使用Array构造函数；使用数组字面量表示法。通过数组字面量表示法时，实际不会调用Array构造函数（Firefox 3 及更早版本除外）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var colors = new Array();</div><div class="line">var colors = new Array(20);</div><div class="line">var colors = new Array(&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;);</div><div class="line"> </div><div class="line">var colors = [];</div><div class="line">var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</div></pre></td></tr></table></figure>
<p>5.<code>length</code>：利用<code>length</code>属性可以方便地在数组末尾添加新项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;blue&quot;];</div><div class="line">colors[colors.length] = &quot;green&quot;;</div></pre></td></tr></table></figure>
<p>6.<code>Array.isArray()</code>：ECMAScript新增<code>Array.isArray()</code>确定某个值是否数组，其解决了存在两个以上全局执行环境时<code>instanceof</code>检测结果出错的情况。</p>
<p>7.数组继承的<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。<code>join()</code>方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</div><div class="line">console.log(colors.join(&quot;,&quot;));  //red,green,blue</div><div class="line">console.log(colors.join(&quot;||&quot;));  //red||green||blue</div></pre></td></tr></table></figure>
<p>8.栈方法和队列方法：</p>
<ul>
<li><code>push()</code>添加一项到数组末尾；</li>
<li><code>pop()</code>移除数组末尾一项；</li>
<li><code>shift()</code>移除数组第一项；</li>
<li><code>unshift()</code>添加一项到数组前端。</li>
</ul>
<p>9.重排序方法：</p>
<ul>
<li><code>reverse()</code>翻转数组项的顺序；</li>
<li><code>sort()</code>默认将数组项转换成字符串后按升序排列（可以接收一个比较函数作为参数，第一个参数应位于第二个之前则返回一个负数）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = [0, 1, 15, 10, 5];</div><div class="line">a.sort();</div><div class="line">console.log(a);  // [0, 1, 10, 15, 5]</div><div class="line"></div><div class="line">function compare(value1, value2)&#123;</div><div class="line">   return value1 - value2;</div><div class="line">&#125;</div><div class="line">a.sort(compare);</div><div class="line">console.log(a);  // [0, 1, 5, 10, 15]</div></pre></td></tr></table></figure>
<p>10.操作方法：</p>
<ul>
<li><code>concat()</code>：添加项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a1 = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</div><div class="line">var a2 = a1.concat(&apos;yellow&apos;, [&apos;black&apos;, &apos;brown&apos;]);</div><div class="line">console.log(a2);  // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</div></pre></td></tr></table></figure>
<ul>
<li><code>slice()</code>：截取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;black&apos;, &apos;brown&apos;];</div><div class="line">console.log(a.slice(1), a.slice(1,4));  </div><div class="line">// [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;][&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;]</div></pre></td></tr></table></figure>
<ul>
<li><code>splice()</code>：删除插入替换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;black&apos;, &apos;brown&apos;];</div><div class="line">console.log(a.splice(2, 1), a);  </div><div class="line">// [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;][&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;]</div></pre></td></tr></table></figure>
<p>11.位置方法：<code>indexOf()</code>和<code>lastIndexOf()</code>都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。<code>indexOf()</code>从数组开头（位置0）向后查找，<code>lastIndexOf()</code>从数组末尾向前查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&quot;red&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];</div><div class="line">console.log(a.indexOf(&apos;red&apos;));  // 0</div><div class="line">console.log(a.lastIndexOf(&apos;red&apos;));  // 4</div><div class="line">console.log(a.indexOf(&apos;red&apos;, 1));  // 4</div><div class="line">console.log(a.lastIndexOf(&apos;red&apos;, 1));  // 0</div></pre></td></tr></table></figure>
<p>12.迭代方法：每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。给定函数会接收三个参数：<strong>数组项的值</strong>、<strong>该项在数组中的位置</strong>和<strong>数组对象本身</strong>。</p>
<ul>
<li><code>every()</code>：如果给定函数对每一项都返回true，则返回true。</li>
<li><code>filter()</code>：返回给定函数会返回true的项组成的数组。</li>
<li><code>foreach()</code>：这个方法没有返回值。</li>
<li><code>map()</code>：返回每次函数调用的结果组成的数组。</li>
<li><code>some()</code>：如果给定函数对任一项返回true，则返回true。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];</div><div class="line"></div><div class="line">var everyResult = a.every(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">console.log(everyResult);   // false</div><div class="line"></div><div class="line">var filterResult = a.filter(function()&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">console.log(filterResult);  // [3, 4, 5, 4, 3]</div><div class="line"></div><div class="line">var forEachResult = a.forEach(function(item, index, array)&#123;</div><div class="line">    console.log(item);</div><div class="line">&#125;);</div><div class="line">console.log(forEachResult);  // undefined</div><div class="line"></div><div class="line">var mapResult = a.map(function(item, index, array)&#123;</div><div class="line">    return (item * 2);</div><div class="line">&#125;);</div><div class="line">console.log(mapResult);  // [2, 4, 6, 8, 10, 8, 6, 4, 2]</div><div class="line"></div><div class="line">var someResult = a.some(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">console.log(someResult);  // true</div></pre></td></tr></table></figure>
<p>13.归并方法：都会迭代数组的所有项，然后构建一个最终返回的值。都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。给定函数接收4个参数：前一个值、当前值、项的索引和数组对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 2, 1];</div><div class="line"></div><div class="line">var sum1 = a.reduce(function(prev, cur, index, array)&#123;</div><div class="line">    console.log(index);  // 1 2 3 4</div><div class="line">    return prev + cur;</div><div class="line">&#125;); </div><div class="line">console.log(sum1);  // 9</div><div class="line"></div><div class="line">var sum2 = a.reduceRight(function(prev, cur, index, array)&#123;</div><div class="line">    console.log(index);  // 3 2 1 0</div><div class="line">    return prev + cur;</div><div class="line">&#125;);</div><div class="line">console.log(sum2);  // 9</div></pre></td></tr></table></figure>
<p><strong>Date类型</strong></p>
<p>12.创建日期对象：月份基于0（一月是0，二月是1，以此类推）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var d1 = new Date();</div><div class="line"></div><div class="line">var d2 = new Date(2017, 2, 3, 15, 33, 33);  // 2017年3月3日下午3点33分33秒</div></pre></td></tr></table></figure></p>
<p>13.获取调用时的日期和时间和毫秒数，可以用来分析代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var start = Date.now();</div><div class="line">doSomething();</div><div class="line">var stop = Date.now();</div><div class="line">var result = stop - start;</div></pre></td></tr></table></figure></p>
<p>14.日期格式化方法：local表示以特定于地区的格式显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var d2 = new Date(2017, 2, 3, 15, 33, 33);</div><div class="line">d2.toString();  // &quot;Fri Mar 03 2017 15:33:33 GMT+0800 (CST)&quot;</div><div class="line">d2.toDateString();  // &quot;Fri Mar 03 2017&quot;</div><div class="line">d2.toTimeString();  // &quot;15:33:33 GMT+0800 (CST)&quot;</div><div class="line">d2.toLocaleString();  // &quot;2017/3/3 下午3:33:33&quot;</div><div class="line">d2.toLocaleDateString();  // &quot;2017/3/3&quot;</div><div class="line">d2.toLocaleTimeString();  // &quot;下午3:33:33&quot;</div></pre></td></tr></table></figure></p>
<p><strong>RegExp类型</strong></p>
<p>15.pattern：正则表达式；flags：标志，表明正则表达式的行为。g全局模式，i不区分大小写，m多行模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var exp1 = /pattern/flags</div><div class="line">var exp2 = new RegExp(&apos;pattern&apos;,&apos;flags&apos;);</div></pre></td></tr></table></figure></p>
<p>16.RegExp实例方法：</p>
<ul>
<li><code>exec()</code>专门为捕获组而设计，返回第一个匹配项信息的数组（或 null），数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。包含两个额外的属性：index 和 input。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var text = &quot;mom and dad and baby&quot;;</div><div class="line">var pattern = /mom( and dad( and baby)?)?/gi;</div><div class="line"></div><div class="line">var matches = pattern.exec(text);</div><div class="line">console.log(matches.index);  // 0</div><div class="line">console.log(matches.input);  // &quot;mom and dad and baby&quot;</div><div class="line">console.log(matches[0]);  // &quot;mom and dad and baby&quot;</div><div class="line">console.log(matches[1]);  // &quot; and dad and baby&quot;</div><div class="line">console.log(matches[2]);  // &quot; and baby&quot;</div></pre></td></tr></table></figure>
<ul>
<li><code>test()</code>接收一个字符串参数，在模式与该参数匹配的情况下返回 true，否则返回flase。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;1234-56-7890&quot;;</div><div class="line">var pattern = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</div><div class="line"></div><div class="line">if(pattern.test(text))&#123;</div><div class="line">    console.log(&quot;The pattern was matched.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>17.RegExp构造函数属性：适用于作用域中的所有正则表达式，记录一些最近一次正则表达式操作的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var text = &quot;This has been a short summer&quot;;</div><div class="line">var pattern = /(.)hort/g;</div><div class="line"></div><div class="line">// Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</div><div class="line">// IE 不支持 multiline 属性</div><div class="line">if(pattern.test(text))&#123;</div><div class="line">     console.log(RegExp.input);  // This has been a short summer</div><div class="line">     console.log(RegExp.leftContext);  // This has been a</div><div class="line">     console.log(RegExp.rightContext);  // summer</div><div class="line">     console.log(RegExp.lastMatch);  // short</div><div class="line">     console.log(RegExp.lastParen);  // s</div><div class="line">     console.log();   // false  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Function类型</strong></p>
<p>18.函数实际上是 Function 类型的实例，因此函数也是对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">// 使用函数声明语法</div><div class="line">function f1 (n1, n2) &#123;</div><div class="line">	return n1 + n2;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 使用函数表达式</div><div class="line">var f2 = function (n1, n2) &#123;</div><div class="line">	return n1 + n2;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 使用构造函数，不推荐（会导致解析两次代码，影响性能）</div><div class="line">var f3 = new Function(&apos;n1&apos;, &apos;n2&apos;, &apos;return n1 + n2&apos;);</div></pre></td></tr></table></figure>
<p>19.函数名是一个指向函数对象的指针，因此 ECMAScript 中没有函数重载。</p>
<p>20.函数声明与函数表达式：解析器会率先通过名为<strong>函数声明提升</strong>的过程，读取并将函数声明添加到执行环境中，使其在执行任何代码之前可用。</p>
<p>而函数表达式必须等到解析器执行到它所在的代码行，才会真正被解析执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">console.log(sum(10, 10));</div><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 把函数声明改为等价的函数表达式，会在执行期间导致错误</div><div class="line">console.log(sum(10, 10));</div><div class="line">var sum = function(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>21.函数内部属性：callee、this、caller。</p>
<ul>
<li>arguments 有 callee 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。可用于递归中消除紧密耦合现象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">console.log(sum(10, 10));</div><div class="line">function factorial(num)&#123;</div><div class="line">    if(num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num-1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>this 引用的是函数据以执行的环境对象。</li>
<li>caller 属性保存着调用当前函数的函数的引用（如果在全局作用域中调用当前函数，它的值为 null）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">function outer()&#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function inner()&#123;</div><div class="line">    console.log(inner.caller);</div><div class="line">    // 为了实现更松散的耦合，也可以用 arguments.callee.caller 访问相同的信息</div><div class="line">&#125;</div><div class="line"></div><div class="line">outer();  // 打印 outer() 函数的源代码</div></pre></td></tr></table></figure>
<p>严格模式下访问 arguments.callee 和 arguments.caller 会导致错误，且不能为函数的 caller 属性赋值。</p>
<p>22.函数属性：length 和 prototype。</p>
<p>length 属性表示函数希望接收的命名参数的个数。</p>
<p>23.函数方法：<code>apply()</code>和<code>call()</code>。用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值，区别仅在于接收参数的方式不同。</p>
<p><code>apply()</code>方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中第二个参数可以是 Array 的实例，也可以是 arguments 对象。</p>
<p><code>call()</code>方法中，传递给函数的参数必须逐个列举出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">function callSum1(num1, num2)&#123;</div><div class="line">    return sum.apply(this, arguments);  // 传入 arguments 对象</div><div class="line">&#125;</div><div class="line">function callSum2(num1, num2)&#123;</div><div class="line">    return sum.apply(this, [num1, num2]);  // 传入数组</div><div class="line">&#125;</div><div class="line">    </div><div class="line">function callSum(num1, num2)&#123;</div><div class="line">    return sum.call(this, num1, num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>apply()</code>和<code>call()</code>真正强大之处在于扩充函数赖以生存的作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o =&#123; color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor()&#123;</div><div class="line">    console.log(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor.call(this);  // red</div><div class="line">sayColor.call(window);  // red</div><div class="line">sayColor.call(o);  // blue</div></pre></td></tr></table></figure>
<p>在严格模式下，未制定环境对象而调用函数，则 this 值不会转型为 window。除非明确把函数添加到某个对象或者调用<code>apply()</code>或<code>call()</code>，否则 this 值将是 undefined。</p>
<p><strong>基本包装类型</strong></p>
<p>24.三种基本包装类型：Boolean类型、Number类型、String类型。在读取模式下访问基本类型值时，就会创造对应的基本包装类型的一个对象，从而方便数据操作。</p>
<p>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁（这意味不能在运行时为基本类型值添加属性和方法）。</p>
<p><strong>单体内置对象</strong></p>
<p>25.在所有代码执行之前，内置对象：Global 和 Math 已经实例化，开发人员不必显式地实例化内置对象。</p>
<p>在大多数ECMAScript实现中都不能直接访问 Global 对象，不过Web浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续记录在读《JavaScript高级程序设计》时的零碎知识点。这几天在知乎上看到了别人使用 Electron 构建桌面应用，感觉还蛮有意思的。有兴趣的同学可以看看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20225295?columnSlug=FrontendMagazine&quot;&gt;使用 Electron 构建桌面应用&lt;/a&gt;和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25415725&quot;&gt;用 ReactJs 创建Mac版的 keep&lt;/a&gt;了解一下。也许在加深对JS的理解后，我也会选择用 Electron 做一个应用呢。Who knows?&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的4~5章：变量、作用域和内存问题，以及引用类型。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【中文填词】三つ叶の结びめ -TV size.-</title>
    <link href="http://kyonhuang.top/lyrics-seaStory/"/>
    <id>http://kyonhuang.top/lyrics-seaStory/</id>
    <published>2017-03-01T03:25:26.000Z</published>
    <updated>2017-04-25T10:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/lyrics/sea.jpeg"></p>
<p>大一下学期考试周复习得好压抑，我就作死地补了《来自风平浪静的明天》。看完就感觉：啊，不愧是冈妈。虽然我不是那种容易被催泪的类型，但是还是有些胃痛的。</p>
<p>《来自风平浪静的明天》的音乐质量真的不错。两首OP两首ED加上几首bgm都很出彩（bgm里推荐 海の涙 和 Cry for the moon）。我当时就忍不住花了几个小时填了一个ED2的TV size（复习什么的已经无所谓了），之后基本没有修改，还算一气呵成。现在贴出来。自己感觉写的好小女生啊，哈哈。但是我就喜欢写这种暗恋的心酸。</p>
<p>欢迎翻唱w希望亚人的词能填的出色</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28724500&auto=0&height=66"></iframe>

  <a id="more"></a>
<hr>
<p>【中文填词】三つ叶の结びめ（三片葉的花結） -TV size.-</p>
<p>曲：出羽良彰<br>词：@摸鱼小能手大黄菌</p>
<p>等你转身 故事升温 久疏重逢的我们<br>谈笑之间 却捕捉到 你偏离的眼神<br>情绪慢慢下沉 听着潮声 看天空变得好陌生<br>你笑容依旧的单纯 而我难过一直在铺陈</p>
<p>沉睡的心事 安静了 一整个寒冬 在春天来前解冻<br>最后 却汇成了咸涩的洋流 经过谁的码头</p>
<p>把思念 只想对这片海表白<br>泪水打湿的喜欢好像 怎么也 晒不干<br>攒够了失望 终于才学会离开<br>你出于礼貌的关怀 都怪我 太过分 的期待</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/lyrics/sea.jpeg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;大一下学期考试周复习得好压抑，我就作死地补了《来自风平浪静的明天》。看完就感觉：啊，不愧是冈妈。虽然我不是那种容易被催泪的类型，但是还是有些胃痛的。&lt;/p&gt;
&lt;p&gt;《来自风平浪静的明天》的音乐质量真的不错。两首OP两首ED加上几首bgm都很出彩（bgm里推荐 海の涙 和 Cry for the moon）。我当时就忍不住花了几个小时填了一个ED2的TV size（复习什么的已经无所谓了），之后基本没有修改，还算一气呵成。现在贴出来。自己感觉写的好小女生啊，哈哈。但是我就喜欢写这种暗恋的心酸。&lt;/p&gt;
&lt;p&gt;欢迎翻唱w希望亚人的词能填的出色&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=28724500&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
      <category term="中文填词" scheme="http://kyonhuang.top/categories/%E4%B8%AD%E6%96%87%E5%A1%AB%E8%AF%8D/"/>
    
    
      <category term="中文填词" scheme="http://kyonhuang.top/tags/%E4%B8%AD%E6%96%87%E5%A1%AB%E8%AF%8D/"/>
    
      <category term="TV_size." scheme="http://kyonhuang.top/tags/TV-size/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（一）</title>
    <link href="http://kyonhuang.top/JS-notes-1/"/>
    <id>http://kyonhuang.top/JS-notes-1/</id>
    <published>2017-02-28T00:57:45.000Z</published>
    <updated>2017-04-28T07:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》，俗称红宝书。本来因为不太清楚的知识点零零碎碎，打算默默地看。但是学习热情不高，加上看到某大佬的对于这本书的读书笔记，最终决定做一个比较零散的、私人化的读书笔记，激励自己。</p>
<p>顺便，这里有我的Java读书笔记：<a href="https://github.com/bighuang624/JAVALearningNotes" target="_blank" rel="external">Kyon Huang的java学习笔记 - Github</a>，内容比较多，就不放在博客上了。大概包含了Java核心卷一的内容，之后停了有一段时间了。这学期会继续更新的。</p>
<p>这篇博文总结了《JavaScript高级程序设计》的前三章：JavaScript简介、在HTML中使用JavaScript、基本概念。</p>
  <a id="more"></a>
<h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><p>1.ECMAScript 是一种开放的、国际上广为接受的脚本语言规范。它本身并不是一种脚本语言。而JavaScript 是 ECMAScript 规范的一种实现。</p>
<p>2.一个完整的 JavaScript 实现应该由三个部分组成：<strong>核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）</strong>。</p>
<p>3.ECMAScript 提供核心语言功能；DOM 提供访问和操作网页内容的方法和接口；BOM 提供与浏览器交互的方法和接口。</p>
<h2 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h2><p><strong><code>&lt;script&gt;</code>元素</strong></p>
<p>1.为了避免浏览器在呈现页面时出现明显延迟，现代Web应用程序一般都把全部 JavaScript 引用放在主要内容后面，<code>&lt;/body&gt;</code>标签前面的位置。</p>
<p>2.延迟脚本：<code>&lt;script&gt;</code>标签的 defer 属性表明脚本在执行时不会影响页面构造，会延迟到整个页面都解析完毕后再运行。延迟脚本总按指定它们的顺序执行。defer 属性只适用于外部脚本文件。</p>
<p>3.异步脚本：<code>&lt;script&gt;</code>标签的 async 属性告诉浏览器立即下载文件，不必等待其他脚本或阻塞文档呈现，目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。不保证异步脚本按照页面出现的先后顺序执行。async 属性只适用于外部脚本文件。</p>
<p><strong>嵌入代码与外部文件</strong></p>
<p>4.使用外部文件的优点：可维护性、可缓存、适应未来。</p>
<p><strong>文档模式</strong></p>
<p>5.所有浏览器默认开启混杂模式，不同浏览器在这种模式下的行为差异非常大。通过文档类型（doctype）开启标准模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- HTML 5 --&gt;</div><div class="line">&lt;!DOCTYPE html&gt;</div></pre></td></tr></table></figure>
<p><strong><code>&lt;noscript&gt;</code>元素</strong></p>
<p>6.包含在<code>&lt;noscript&gt;</code>元素中的内容只有在浏览器不支持脚本，或浏览器支持脚本但脚本被禁用时才会显示出来。因此，它用于指定在不支持脚本的浏览器中显示的替代内容。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>严格模式</strong></p>
<p>1.通过在顶部添加<code>&quot;use strict&quot;;</code>开启严格模式。这个编译指令告诉支持的JavaScript引擎切换到严格模式，以处理 ECMAScript3 中一些不确定的行为，并对某些不安全的操作抛出错误。</p>
<p><strong>变量</strong></p>
<p>2.省略<code>var</code>操作符可以定义全局变量（难维护，不推荐）。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</p>
<p><strong>数据类型</strong></p>
<p>3.五种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number和String，一种复杂数据类型 Object。ECMAScript 不支持任何创建自定义类型的机制。</p>
<ul>
<li><p>Undefined类型：未初始化的变量会自动被赋予 undefined 值。</p>
</li>
<li><p>Null类型：null 值表示一个空对象指针。只要意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存 null 值，以体现 null 作为空指针对象的惯例。</p>
</li>
<li><p>Boolean类型：使用函数<code>Boolean()</code>将其他类型转换为Boolean类型。</p>
</li>
<li><p>Number类型：其他类型转换为Number类型，常用函数parseInt()，转换字符串时，如果第一个字符不是数字字符或者负号，会返回NaN，第二个可选参数表示进制（建议始终明确指定基数）。</p>
</li>
<li><p>String类型：不可变。其他类型转换为String类型，使用函数toString()或String()或加一个空字符串（””）。</p>
</li>
<li><p>Object类型：Object 的每个实例都具有下列属性和方法：</p>
<p> – constructor：保留着用于创建当前对象的函数（即构造函数）；</p>
<p> – hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在（属性名必须以字符串形式指定）；</p>
<p> – isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型；</p>
<p> – propertyIsEnumerable(propertyName)：用于检查给定的属性是否能使用 for-in 语句来枚举；</p>
<p> – toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应；</p>
<p> – toString()：返回对象的字符串表示（null 和 undefined 伪对象没有此方法，整数 number 类型需要在整数末尾多加一个<code>.</code>再调用）；</p>
<p> – valueOf()：返回对象的字符串、数值或布尔值表示；</p>
</li>
</ul>
<p>4.typeof 操作符可检测给定变量的数据类型，包括 number、boolean、string、function、undefined。</p>
<p>判断 Array：<code>Array.isArray(myArr);</code>。</p>
<p>判断 null：用<code>myArr === null;</code>。</p>
<p>补充：判断某个全局变量是否存在：<code>typeof window.myVar === &#39;undefined&#39;;</code>。</p>
<p>判断函数内部某个变量是否存在：<code>typeof myVar === &#39;undefined === &#39;undefined&#39;；</code>。</p>
<p><strong>操作符</strong></p>
<p>5.如果两个操作数都是字符串，则比较两个字符串对应的字符串编码值。</p>
<p>6.如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较；如果该操作数不能被转换为合理数值，则转换成 NaN。</p>
<p>7.任何操作数与 NaN 比较，结果都是false。</p>
<p>8.相等（==）与全等（===）：全等只在两个操作数未经转换就相等的情况下返回true。</p>
<p><strong>语句</strong></p>
<p>9.由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var count = 10;</div><div class="line">for (var i = ; i &lt; count; i++)&#123;</div><div class="line">    var j = 1;</div><div class="line">&#125;</div><div class="line">alert(i, j);   //10, 1</div></pre></td></tr></table></figure>
<p>10.for-in 语句可以用来遍历对象的属性名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(property in expression)&#123;</div><div class="line">    statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。</p>
<p>补充：一个 Array 数组实际也是一个对象，它的每个元素的索引被视为一个属性。所以当手动给 Array 添加额外的属性时，for-in 语句也会将其遍历。要循环集合本身的元素，建议使用 ES 6 提供的 for-of 语句。</p>
<p>11.break 语句会立即退出循环，强制继续执行循环后面的语句；continue 语句退出循环后会从循环的顶部继续执行。break 和 continue 语句与 label 语句联合使用多发生在循环嵌套的情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var num = 0;</div><div class="line"></div><div class="line">outermost:</div><div class="line">for(var i=0; i &lt; 10; i++)&#123;</div><div class="line">    for(var j=0; j &lt; 10; j++)&#123;</div><div class="line">        if(i == 5 &amp;&amp; j == 5)&#123;</div><div class="line">            break outermost;</div><div class="line">        &#125;</div><div class="line">        num++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(num);    //55</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var num = 0;</div><div class="line"></div><div class="line">outermost:</div><div class="line">for(var i=0; i &lt; 10; i++)&#123;</div><div class="line">    for(var j=0; j &lt; 10; j++)&#123;</div><div class="line">        if(i == 5 &amp;&amp; j == 5)&#123;</div><div class="line">            continue outermost;</div><div class="line">        &#125;</div><div class="line">        num++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(num);    //95</div></pre></td></tr></table></figure>
<p><strong>函数</strong></p>
<p>12.ECMAScript中没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。所以ECMAScript函数不能重载。</p>
<p>13.可以向ECMAScript函数传递任意数量的参数，并通过 arguments对象来访问这些参数。没有传递值的命名参数将自动被赋予 undefined 值。arguments对象中的值与对应的命名参数的内存空间是独立的，但它们的值会同步。</p>
<p>15.ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》，俗称红宝书。本来因为不太清楚的知识点零零碎碎，打算默默地看。但是学习热情不高，加上看到某大佬的对于这本书的读书笔记，最终决定做一个比较零散的、私人化的读书笔记，激励自己。&lt;/p&gt;
&lt;p&gt;顺便，这里有我的Java读书笔记：&lt;a href=&quot;https://github.com/bighuang624/JAVALearningNotes&quot;&gt;Kyon Huang的java学习笔记 - Github&lt;/a&gt;，内容比较多，就不放在博客上了。大概包含了Java核心卷一的内容，之后停了有一段时间了。这学期会继续更新的。&lt;/p&gt;
&lt;p&gt;这篇博文总结了《JavaScript高级程序设计》的前三章：JavaScript简介、在HTML中使用JavaScript、基本概念。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScipt" scheme="http://kyonhuang.top/tags/JavaScipt/"/>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://kyonhuang.top/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端布局知识点(3)——圣杯布局与双飞翼布局</title>
    <link href="http://kyonhuang.top/cup-doubleWings/"/>
    <id>http://kyonhuang.top/cup-doubleWings/</id>
    <published>2017-02-25T01:54:43.000Z</published>
    <updated>2017-04-28T07:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是完成<a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001" target="_blank" rel="external">百度前端学院2015的task1</a>后对前端布局知识点总结的第三篇博文。上两篇总结了一下overflow属性（<a href="http://kyonhuang.top/something-about-margin-overflow/">前端布局知识点(1)——overflow属性</a>）和负边距及文档流（<a href="http://kyonhuang.top/something-about-margin-nega/">前端布局知识点(2)——负边距</a>）。</p>
<p>在淘宝UED探讨中诞生的双飞翼布局主要解决了两个需求：</p>
<ol>
<li>要求三列布局，左右两边定宽，中间宽度自适应；</li>
<li>要求浏览器优先渲染中间栏。</li>
</ol>
<p>其实这两个要求已经有圣杯布局实现了。双飞翼布局是沿着圣杯布局的思路加以改良探讨出来的。两者有什么区别呢？</p>
<p>17.04.27更新：时至今日，Grid 布局为实现各类布局提供了非常简便的解决方案。可以通过<a href="http://www.w3cplus.com/css3/playing-with-css-grid-layout.html" target="_blank" rel="external">CSS Grid布局这样玩</a>这篇文章来对 CSS Grid 进行初步了解。</p>
  <a id="more"></a>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>我们首先来看看出现时间更早的圣杯布局（这个名字让我想到Fate系列）。圣杯布局用到了浮动、负边距和相对定位来实现需求。</p>
<p>html代码（浏览器按照html中写的顺序渲染，因此div.main写在最前面）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> &lt;div class=&quot;yellow header&quot;&gt;</div><div class="line">	task4:header</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;page&quot;&gt;</div><div class="line">	&lt;div id=&quot;container&quot;&gt;</div><div class="line">		&lt;div class=&quot;main red&quot;&gt;main&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;left green&quot;&gt;left&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;right blue&quot;&gt;right&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;yellow footer&quot;&gt;</div><div class="line">	footer</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">	margin: 0;</div><div class="line">&#125;</div><div class="line">.red&#123;</div><div class="line">	background-color: red;</div><div class="line">&#125;</div><div class="line">.blue&#123;</div><div class="line">	background-color: blue;</div><div class="line">&#125;</div><div class="line">.green&#123;</div><div class="line">	background-color: green;</div><div class="line">&#125;</div><div class="line">.yellow&#123;</div><div class="line">	background-color: yellow;</div><div class="line">&#125;</div><div class="line">.page&#123;</div><div class="line">	padding:0 150px 0 180px;</div><div class="line">	overflow: hidden;</div><div class="line">	zoom: 1;</div><div class="line">&#125;</div><div class="line">.header,.footer&#123;</div><div class="line">	width: 100%;</div><div class="line">	height: 100px;</div><div class="line">	clear: both;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	width: 180px;</div><div class="line">	float: left;</div><div class="line">	margin-left: -100%;</div><div class="line">	height: 400px;</div><div class="line">	position: relative;</div><div class="line">	left: -180px;</div><div class="line">&#125;</div><div class="line">.main&#123;</div><div class="line">	width: 100%;</div><div class="line">	float: left;</div><div class="line">	height: 400px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	width: 150px;</div><div class="line">	float: left;</div><div class="line">	margin-left: -150px;</div><div class="line">	height: 400px;</div><div class="line">	position: relative;</div><div class="line">	right: -150px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/overflow/shengbei1.jpg"></p>
<p>首先，我们给div.page设置一个左右的padding值，这个值要和左右两边宽度相等。固定好div.page后，再分别设置div.left和div.right。以div.left为例，设置float: left使其浮动，margin-left: -100%，这里将div.left左移至左边与main平齐。再加上 position: relative，left: -180px 固定位置，让它能够挤进左右两边空白的同时不会遮住中间部分。</p>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>圣杯布局有什么缺陷呢？</p>
<ol>
<li>圣杯布局使用了相对定位。这样的话，以后再添加额外标签时布局是有局限性的；</li>
<li>左右两边的宽度只能为固定像素而不能设定为百分比。因为元素宽度设定为百分比时根据父级元素宽度计算，而我们给父级元素设定了padding值，其宽度不明确。我们无法精确计算所需要的百分比。</li>
<li>浏览器宽度缩小时，随着两边定宽的部分向中间靠拢，中间部分有被挤下去的可能。</li>
</ol>
<p><img src="/images/overflow/shengbei2.jpg"></p>
<p>怎么能够优化圣杯布局？淘宝UED探讨的结果是增加一个div。这样，我们就可以不再使用相对布局，而仅仅用浮动和负边距来达到我们的需求。这就是双飞翼布局。</p>
<p>html代码（main内层增加一个div）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> &lt;div class=&quot;page&quot;&gt;</div><div class="line">	&lt;div class=&quot;header yellow&quot;&gt;</div><div class="line">		task4:header</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div id=&quot;container&quot;&gt;</div><div class="line">		&lt;div class=&quot;main red&quot;&gt;</div><div class="line">			&lt;div class=&quot;inner&quot;&gt;  //增加的div</div><div class="line">				main</div><div class="line">			&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;left green&quot;&gt;left&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;right blue&quot;&gt;right&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;footer yellow&quot;&gt;</div><div class="line">		footer</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS代码（去掉左右栏的相对定位和包裹层的padding，增加新div的margin）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">.red&#123;</div><div class="line">	background-color: red;</div><div class="line">&#125;</div><div class="line">.blue&#123;</div><div class="line">	background-color: blue;</div><div class="line">&#125;</div><div class="line">.green&#123;</div><div class="line">	background-color: green;</div><div class="line">&#125;</div><div class="line">.yellow&#123;</div><div class="line">	background-color: yellow;</div><div class="line">&#125;</div><div class="line">.header,.footer&#123;</div><div class="line">	width: 100%;</div><div class="line">	height: 30px;</div><div class="line">	clear: both;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	width: 150px;</div><div class="line">	float: left;</div><div class="line">	margin-left: -100%;</div><div class="line">	height: 400px;</div><div class="line">&#125;</div><div class="line">.main&#123;</div><div class="line">	width: 100%;</div><div class="line">	float: left;</div><div class="line">	height: 400px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	width: 180px;</div><div class="line">	float: left;</div><div class="line">	margin-left: -180px;</div><div class="line">	height: 400px;</div><div class="line">&#125;</div><div class="line">.inner&#123;</div><div class="line">	margin-left: 150px;</div><div class="line">	margin-right: 180px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/overflow/doubleWings1.jpg"></p>
<p>将浏览器宽度缩小，可以看到左右两边宽度一定，中间宽度为自适应。</p>
<p><img src="/images/overflow/doubleWings2.jpg"></p>
<p>div.inner的 margin-left: 150px;margin-right: 180px 负责将两边内容挤开，避免在没有padding的包裹层时两边内容遮住中间。</p>
<hr>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/front-end/archive/2012/08/29/zq_001.html" target="_blank" rel="external">CSS圣杯布局</a></p>
<p><a href="http://www.cnblogs.com/front-end/archive/2012/08/29/zq_0406.html" target="_blank" rel="external">css双飞翼布局</a></p>
<p>上面两篇出自同一作者，可谓一语道破，清晰明了。</p>
<p><a href="http://www.cnblogs.com/tinyphp/p/4742922.html" target="_blank" rel="external">圣杯布局的实现过程</a></p>
<p><a href="http://www.imooc.com/wenda/detail/254035" target="_blank" rel="external">双飞翼布局介绍-始于淘宝UED</a></p>
<p><a href="https://zhidao.baidu.com/question/2267561297621475628.html" target="_blank" rel="external">CSS双飞翼布局_百度知道</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是完成&lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001&quot;&gt;百度前端学院2015的task1&lt;/a&gt;后对前端布局知识点总结的第三篇博文。上两篇总结了一下overflow属性（&lt;a href=&quot;http://kyonhuang.top/something-about-margin-overflow/&quot;&gt;前端布局知识点(1)——overflow属性&lt;/a&gt;）和负边距及文档流（&lt;a href=&quot;http://kyonhuang.top/something-about-margin-nega/&quot;&gt;前端布局知识点(2)——负边距&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;在淘宝UED探讨中诞生的双飞翼布局主要解决了两个需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要求三列布局，左右两边定宽，中间宽度自适应；&lt;/li&gt;
&lt;li&gt;要求浏览器优先渲染中间栏。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实这两个要求已经有圣杯布局实现了。双飞翼布局是沿着圣杯布局的思路加以改良探讨出来的。两者有什么区别呢？&lt;/p&gt;
&lt;p&gt;17.04.27更新：时至今日，Grid 布局为实现各类布局提供了非常简便的解决方案。可以通过&lt;a href=&quot;http://www.w3cplus.com/css3/playing-with-css-grid-layout.html&quot;&gt;CSS Grid布局这样玩&lt;/a&gt;这篇文章来对 CSS Grid 进行初步了解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="布局" scheme="http://kyonhuang.top/tags/%E5%B8%83%E5%B1%80/"/>
    
      <category term="双飞翼布局" scheme="http://kyonhuang.top/tags/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    
      <category term="圣杯布局" scheme="http://kyonhuang.top/tags/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端布局知识点(2)——负边距</title>
    <link href="http://kyonhuang.top/something-about-margin-nega/"/>
    <id>http://kyonhuang.top/something-about-margin-nega/</id>
    <published>2017-02-24T03:54:37.000Z</published>
    <updated>2017-04-28T07:46:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是完成<a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001" target="_blank" rel="external">百度前端学院2015的task1</a>后对前端布局知识点总结的第二篇博文。上一篇总结了一下overflow这个属性：<a href="http://kyonhuang.top/something-about-overflow/">前端布局知识点(1)——overflow属性</a>。</p>
<p>CSS中的负边距是布局中一个常用的技巧。因为在后面学习的双飞翼布局的实现就依赖于负边距，负边距又与文档流息息相关，所以我先对这部分的知识进行查询学习。</p>
  <a id="more"></a>
<h2 id="文档流与文本流"><a href="#文档流与文本流" class="headerlink" title="文档流与文本流"></a>文档流与文本流</h2><p>在我了解负边距的时候出现了一个词：文档流。而在查阅文档流相关资料的时候又出现一个词叫文本流。两者有什么区别？知乎上相关问题 <a href="https://www.zhihu.com/question/21911352" target="_blank" rel="external">HTML 的文档流和文本流分别是什么？- 知乎</a> 的高票答案提供了一个辨析的思路：文档流是相对于盒子模型讲的，而文本流是相对于文字段落讲的。</p>
<p>在overflow的那篇文章中我们提到，浮动(float)是一个立体的浮动。当一个元素浮动时，它后面的元素会在它身下布局。但是文字会认为浮动元素是占据了一个区域而围绕它布局。我们可以将浮动元素想象成一个在海上浮动的人，鱼可以在他的身下，但海面上的泡沫会围绕在他周围。这时，这个元素脱离了文档流，但没有脱离文本流。</p>
<p>但是绝对定位(absolute)会将元素从文档流和文本流中脱离，也就是说其他元素和文本都不认同绝对定位元素占据了区域，而在它身下布局。</p>
<p>float、absolute和fixed三种方式定位会让元素脱离文档流。</p>
<h2 id="负边距的表现"><a href="#负边距的表现" class="headerlink" title="负边距的表现"></a>负边距的表现</h2><p>当 margin-top、margin-left 为负值的时候，会把元素上移、左移，同时文档流中的位置也发生相应变化，这点与 position:relative 的元素设置top、left后元素还占据原来位置不同。</p>
<p>而当 margin-bottom、margin-right 设为负值的时候，元素本身没有位置变化，后面的元素会上移、左移。</p>
<h2 id="负边距的实例"><a href="#负边距的实例" class="headerlink" title="负边距的实例"></a>负边距的实例</h2><p>多说无益，来看实例。我们可以利用负边距和绝对定位来实现一种经典的居中方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">  .middle&#123;</div><div class="line">	position: absolute;</div><div class="line">	width: 200px;</div><div class="line">	height: 200px;</div><div class="line">	left: 50%;</div><div class="line">	margin-left: -100px; </div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div class=&quot;middle red&quot;&gt;</div><div class="line">  middle div</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="/images/overflow/margin1.jpg"></p>
<p>把div设置为绝对定位，然后设置top和left为50%，这时候div的上边、左边就到了父元素（这里是页面）的50%处，再对div设置其自身高度、长度一般的负边距，使div的中心移动到页面中心，实现宽度上的居中对齐。我们当然也可以用同样的方式设置高度的居中。</p>
<p>关于负边距更多的应用可以看参考资料：</p>
<p><a href="http://www.cnblogs.com/dolphinX/p/4071725.html" target="_blank" rel="external">负边距在布局中的使用</a></p>
<p>在接下来谈到的双飞翼布局中，负边距将成为主角。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是完成&lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001&quot;&gt;百度前端学院2015的task1&lt;/a&gt;后对前端布局知识点总结的第二篇博文。上一篇总结了一下overflow这个属性：&lt;a href=&quot;http://kyonhuang.top/something-about-overflow/&quot;&gt;前端布局知识点(1)——overflow属性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;CSS中的负边距是布局中一个常用的技巧。因为在后面学习的双飞翼布局的实现就依赖于负边距，负边距又与文档流息息相关，所以我先对这部分的知识进行查询学习。&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="布局" scheme="http://kyonhuang.top/tags/%E5%B8%83%E5%B1%80/"/>
    
      <category term="负边距" scheme="http://kyonhuang.top/tags/%E8%B4%9F%E8%BE%B9%E8%B7%9D/"/>
    
      <category term="文档流" scheme="http://kyonhuang.top/tags/%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>前端布局知识点(1)——从overflow属性看浮动</title>
    <link href="http://kyonhuang.top/something-about-overflow/"/>
    <id>http://kyonhuang.top/something-about-overflow/</id>
    <published>2017-02-23T02:34:12.000Z</published>
    <updated>2017-04-28T07:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>完成了 <a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001" target="_blank" rel="external">百度前端学院2015的task1</a> 后，感觉自己之前学习CSS以及前端布局确实不太全面，有很多知识点现在才接触到，而且也很久没有用过CSS写前端布局了。查漏补缺，总结了几个以前没有注意的知识点：overflow、负边距、圣杯布局和双飞翼布局。一开始想把所有知识点总结成一篇，写着写着发现较短的篇幅不足以把这些都总结清楚，所以还是每个知识点单写一篇。</p>
<p>顺便推荐 <a href="http://zh.learnlayout.com/" target="_blank" rel="external">学习CSS布局</a>，很好的布局学习资料，值得反复学习。用詹俊老师的话来说就是，好文不妨一看再看！</p>
  <a id="more"></a>
<h2 id="探究由来"><a href="#探究由来" class="headerlink" title="探究由来"></a>探究由来</h2><p>task1中有一道题是这样的：实现一个浮动布局，红色容器中每一行的蓝色容器数量随着浏览器宽度的变化而变化。很快写出代码如下：</p>
<p>html代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> &lt;div class=&quot;red task5&quot;&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;1&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;2&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;3&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;4&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;5&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;6&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;7&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;8&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;blue bfloat&quot;&gt;9&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.red&#123;</div><div class="line">	background-color: red;</div><div class="line">&#125;</div><div class="line">.blue&#123;</div><div class="line">	background-color: blue;</div><div class="line">&#125;</div><div class="line">.task5&#123;</div><div class="line">	margin-top: 10px;</div><div class="line">	height: 100px;</div><div class="line">&#125;</div><div class="line">.bfloat&#123;</div><div class="line">	height: 50px;</div><div class="line">	width: 90px;</div><div class="line">	margin: 10px;</div><div class="line">	float: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里说一声，根据 OO CSS 的思想，结构和样式应该相互独立（不太了解 OO CSS 的话可以看一下我之前的博文 <a href="http://kyonhuang.top/8637/">对几个前端相关概念的理解——OO CSS、语义化、CSS hack</a>）。尽管对于这种小 Demo，OO CSS显得不实用且有些累赘，我还是坚持去实现。因此我单独写了 red 和 blue 两个 class 来控制皮肤。</p>
<p>以上代码的效果图：</p>
<p><img src="/images/overflow/overflow.jpg"></p>
<p>可以看到，效果图中红色容器的高度没有随着蓝色容器的行数的变化而变化，与我们理想的效果有些差距。这是因为我们在task5这个class中写死了容器的高度，而设置了浮动的蓝色容器脱离了红色容器，行数的变化无法再影响到红色容器的高度。从这里我们可以看出，所谓“浮动”不只是平面上的浮动，而是一个立体的浮动。当然，如果不写高度的话连红色容器都看不到。那怎么解决这个问题呢？我当时没有想到好的解决方法。查看了别人的代码后，发现是要把 task5 这个 class 中高度删掉，再加一行：</p>
<p><code>overflow: hidden;</code></p>
<h2 id="overflow-属性"><a href="#overflow-属性" class="headerlink" title="overflow 属性"></a>overflow 属性</h2><p>overflow 属性规定当内容溢出元素框时发生的事情。这个属性的默认值为 visible，这时内容不会被修剪，会呈现在元素框之外，就像之前的效果图一样；而值为 hidden 时，内容会被修剪，并且其余内容是不可见的。也就是说，如果这时height属性还设置了定值的话，超出这个定值的部分不可见。这个时候显示的效果如下(height: 100px)：</p>
<p><img src="/images/overflow/overflow2.jpg"></p>
<p>删掉height属性后，overflow: hidden 在这个案例的真正用途是清除浮动。这里清除的是立体的，可以理解为z轴上的浮动。因此，蓝色容器的高度现在可以受其内部，也就是红色容器的总体高度影响。现在显示的效果是符合我们要求的，实际效果图如下：</p>
<p><img src="/images/overflow/overflow3.jpg"></p>
<p>overflow 属性的值还可以为 scroll 和 auto。值为 scroll 时，内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。而值为 auto 时，如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。两者区别是如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。</p>
<h2 id="浮动元素特点"><a href="#浮动元素特点" class="headerlink" title="浮动元素特点"></a>浮动元素特点</h2><p>17.04.14补充：摘自 <a href="http://efe.baidu.com/blog/float/" target="_blank" rel="external">回归CSS标准之Float</a> 。</p>
<p>float 属性被设置为非 none 的元素：</p>
<ol>
<li>元素被视作块级元素，相当于 display 设置为“block”；</li>
<li>元素具备包裹性，会根据它所包含的元素实现宽度、高度自适应；</li>
<li>浮动元素前后的块级兄弟元素忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过 z-index 属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素；</li>
<li>浮动元素前后的行内元素环绕浮动元素排列；</li>
<li>浮动元素之前的元素如果也是浮动元素，且方向相同，它会紧跟在它们后面；父元素宽度不够，换行展示；</li>
<li>浮动元素之间的水平间距不会重叠；</li>
<li>当包含元素中只有浮动元素时，包含元素将会高度塌陷；</li>
<li>浮动元素的父元素的非浮动兄弟元素，忽视浮动元素存在，覆盖浮动元素；</li>
<li>浮动元素的父元素的浮动兄弟元素，会跟随浮动元素布局，仿佛处在同一父元素中。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.w3school.com.cn/cssref/pr_pos_overflow.asp" target="_blank" rel="external">CSS overflow 属性</a></p>
<p><a href="http://zh.learnlayout.com/clearfix.html" target="_blank" rel="external">CSS - 清除浮动（clearfix hack）</a></p>
<p>17.02.07更新：</p>
<p><a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="external">那些年我们一起清除过的浮动</a> 一文中将 overflow: hidden 所带来的清除浮动的效果称为“闭合浮动”，以区别于 clear: left|right|both|none 。我们通过闭合浮动来解决 wrap 高度塌陷的问题。</p>
<p>17.04.07更新：</p>
<p><a href="http://www.w3cplus.com/css/clear-float" target="_blank" rel="external">Clear Float</a> 介绍了解决浮动带来的高度塌陷问题的另外两种方法：“clear:both”和“clearfix”。</p>
<p><a href="http://efe.baidu.com/blog/float/" target="_blank" rel="external">回归CSS标准之Float</a> 百度EFE的文章，加深对 float 的理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;完成了 &lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001&quot;&gt;百度前端学院2015的task1&lt;/a&gt; 后，感觉自己之前学习CSS以及前端布局确实不太全面，有很多知识点现在才接触到，而且也很久没有用过CSS写前端布局了。查漏补缺，总结了几个以前没有注意的知识点：overflow、负边距、圣杯布局和双飞翼布局。一开始想把所有知识点总结成一篇，写着写着发现较短的篇幅不足以把这些都总结清楚，所以还是每个知识点单写一篇。&lt;/p&gt;
&lt;p&gt;顺便推荐 &lt;a href=&quot;http://zh.learnlayout.com/&quot;&gt;学习CSS布局&lt;/a&gt;，很好的布局学习资料，值得反复学习。用詹俊老师的话来说就是，好文不妨一看再看！&lt;/p&gt;
    
    </summary>
    
      <category term="前端学习笔记" scheme="http://kyonhuang.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="前端" scheme="http://kyonhuang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="布局" scheme="http://kyonhuang.top/tags/%E5%B8%83%E5%B1%80/"/>
    
      <category term="overflow" scheme="http://kyonhuang.top/tags/overflow/"/>
    
  </entry>
  
  <entry>
    <title>又是一个新学期开始了</title>
    <link href="http://kyonhuang.top/new-term/"/>
    <id>http://kyonhuang.top/new-term/</id>
    <published>2017-02-19T09:52:31.000Z</published>
    <updated>2017-04-25T10:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>大二的下学期就要开始了。在寒假里，我自学了JavaScript和jQuery，看完了极客学院这两部分以及AngularJS入门的视频，廖雪峰JS教程学到underscore为止。由于缺乏系统学习和动手实践，掌握肯定不甚牢固。寒假的充实度可以说差强人意吧。</p>
<p>新学期课感觉要比上学期略少一点，但都是专业课，也有一定难度。希望自己在课业不放松的同时尽力实现以下学习目标，并产出有质量的博文以进行总结：</p>
<ol>
<li><strong>前端</strong>：学习《JavaScript高级程序设计》以及ES6，研究React框架（这个放在后面）。</li>
<li><strong>后端</strong>：继续Java的深入学习，Servlet、JSP、SSH三大框架。</li>
<li><strong>算法</strong>：学习《算法(Java描述)》，搭配LintCode练习。</li>
<li><strong>英语</strong>：以尽量高的分数过六级。</li>
</ol>
<a id="more"></a>
<p>理论学习永远离不开实践，要经常给自己找项目。前端方面可以跟着百度前端学院2015的小项目动手试试。新学期也希望自己在包括足球、人际等各方面有所突破。</p>
<p>新学期，新气象。写下这篇博文给自己打气！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大二的下学期就要开始了。在寒假里，我自学了JavaScript和jQuery，看完了极客学院这两部分以及AngularJS入门的视频，廖雪峰JS教程学到underscore为止。由于缺乏系统学习和动手实践，掌握肯定不甚牢固。寒假的充实度可以说差强人意吧。&lt;/p&gt;
&lt;p&gt;新学期课感觉要比上学期略少一点，但都是专业课，也有一定难度。希望自己在课业不放松的同时尽力实现以下学习目标，并产出有质量的博文以进行总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;前端&lt;/strong&gt;：学习《JavaScript高级程序设计》以及ES6，研究React框架（这个放在后面）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后端&lt;/strong&gt;：继续Java的深入学习，Servlet、JSP、SSH三大框架。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算法&lt;/strong&gt;：学习《算法(Java描述)》，搭配LintCode练习。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;英语&lt;/strong&gt;：以尽量高的分数过六级。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
</feed>
