<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大黄菌的个人博客</title>
  <subtitle>天下武功，无勤不破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kyonhuang.top/"/>
  <updated>2018-03-30T03:16:25.120Z</updated>
  <id>http://kyonhuang.top/</id>
  
  <author>
    <name>Kyon Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据清理 5 天挑战</title>
    <link href="http://kyonhuang.top/5-days-data-cleaning/"/>
    <id>http://kyonhuang.top/5-days-data-cleaning/</id>
    <published>2018-03-30T03:14:21.000Z</published>
    <updated>2018-03-30T03:16:25.120Z</updated>
    
    <content type="html"><![CDATA[<p>偶然看到了 Kaggle 的数据清理 5 天挑战，大致看了一下，还是比较实用的。因此全部做完后记录一下。不是很想在无谓的整理上花太多时间，因此各类标题直接使用原文中的英文标题，用于串联内容的文字较少，且代码不一定完整（主要是缺少导入包和数据的语句）。如果你希望能够全面地了解这 5 次挑战的内容，以下是 Kaggle 上原 kernel 的地址：</p>
<ul>
<li>Day 1: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-handling-missing-values" target="_blank" rel="external">Data Cleaning Challenge: Handling missing values | Kaggle</a></li>
<li>Day 2: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data" target="_blank" rel="external">Data Cleaning Challenge: Scale and Normalize Data | Kaggle</a></li>
<li>Day 3: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/" target="_blank" rel="external">Data Cleaning Challenge: Parsing Dates | Kaggle</a></li>
<li>Day 4: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-character-encodings/" target="_blank" rel="external">Data Cleaning Challenge: Character Encodings | Kaggle</a></li>
<li>Day 5: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-inconsistent-data-entry" target="_blank" rel="external">Data Cleaning Challenge: Inconsistent Data Entry | Kaggle</a></li>
</ul>
<a id="more"></a>
<h2 id="Handling-missing-values"><a href="#Handling-missing-values" class="headerlink" title="Handling missing values"></a>Handling missing values</h2><h3 id="Take-a-first-look-at-the-data"><a href="#Take-a-first-look-at-the-data" class="headerlink" title="Take a first look at the data"></a>Take a first look at the data</h3><p>看一下数据的前几行有没有缺失值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nfl_data.sample(<span class="number">5</span>)</div><div class="line"><span class="comment"># 使用 nfl_data.head() 效果相同</span></div></pre></td></tr></table></figure>
<h4 id="See-how-many-missing-data-points-we-have"><a href="#See-how-many-missing-data-points-we-have" class="headerlink" title="See how many missing data points we have"></a>See how many missing data points we have</h4><p>统计每种属性包含的缺失值的数量：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># get the number of missing data points per column</span></div><div class="line">missing_values_count = nfl_data.isnull().sum()</div><div class="line"></div><div class="line"><span class="comment"># look at the # of missing points in the first ten columns</span></div><div class="line">missing_values_count[<span class="number">0</span>:<span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>看一看缺失值占总体数量的百分比：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># how many total missing values do we have?</span></div><div class="line">total_cells = np.product(nfl_data.shape)</div><div class="line">total_missing = missing_values_count.sum()</div><div class="line"></div><div class="line"><span class="comment"># percent of data that is missing</span></div><div class="line">(total_missing/total_cells) * <span class="number">100</span></div></pre></td></tr></table></figure>
<h4 id="Figure-out-why-the-data-is-missing"><a href="#Figure-out-why-the-data-is-missing" class="headerlink" title="Figure out why the data is missing"></a>Figure out why the data is missing</h4><p>分析数据缺失的原因以及缺失对数据分析所造成的影响被称为<strong>“data intution”</strong>，决定了是否需要填充该缺失，以及填充的策略。</p>
<p>面对数据缺失，一个必须要考虑的问题是：</p>
<blockquote>
<p>某个数据的缺失是因为它没有被记录还是根本不存在？</p>
</blockquote>
<p>对于根本不存在的缺失数据，没有必要对其进行操作；而没有被记录的缺失值，则应该基于同行同列的其他值来猜想其可能的值，尝试进行填充。</p>
<p>例如，<code>Street Number Suffix</code>应该是其本身不存在，而<code>Zipcode</code>则应该是没有记录。</p>
<h3 id="Drop-missing-values"><a href="#Drop-missing-values" class="headerlink" title="Drop missing values"></a>Drop missing values</h3><p>移除包含缺失值的<strong>行</strong>是可行的，但是如果缺失值较多且分布较散，可能导致所有的数据全部被移除：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nfl_data.dropna()</div></pre></td></tr></table></figure>
<p>也可以移除包含至少一个缺失值的<strong>列</strong>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">columns_with_na_dropped = nfl_data.dropna(axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<h3 id="Filling-in-missing-values-automatically"><a href="#Filling-in-missing-values-automatically" class="headerlink" title="Filling in missing values automatically"></a>Filling in missing values automatically</h3><p>将某个数值型属性的缺失值全部补 0：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># get a small subset of the NFL dataset</span></div><div class="line">subset_nfl_data = nfl_data.loc[:, <span class="string">'EPA'</span>:<span class="string">'Season'</span>].head()</div><div class="line">subset_nfl_data</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># replace all NA's with 0</span></div><div class="line">subset_nfl_data.fillna(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>若存在字符串类型的数据，也可以通过<code>method = &#39;bfill&#39;</code>，选择将空值置为与它相邻的下一行对应的数据，没有下一行数据就置为 0：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># replace all NA's the value that comes directly after it in the same column, </span></div><div class="line"><span class="comment"># then replace all the reamining na's with 0</span></div><div class="line">subset_nfl_data.fillna(method = <span class="string">'bfill'</span>, axis=<span class="number">0</span>).fillna(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h2 id="Scale-and-Normalize-Data"><a href="#Scale-and-Normalize-Data" class="headerlink" title="Scale and Normalize Data"></a>Scale and Normalize Data</h2><p>主要搞清两个概念：</p>
<ul>
<li>scaling（缩放）: change the <strong>range</strong> of data</li>
<li>normalize（标准化）: change the <strong>shape of the distribution</strong> of data，即将数据尽可能地描述为正态分布。常用于 t-tests, ANOVAs, linear regression, linear discriminant analysis (LDA) and Gaussian naive Bayes</li>
</ul>
<h3 id="import-packages"><a href="#import-packages" class="headerlink" title="import packages"></a>import packages</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># for Box-Cox Transformation</span></div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</div><div class="line"></div><div class="line"><span class="comment"># for min_max scaling</span></div><div class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> minmax_scaling</div><div class="line"></div><div class="line"><span class="comment"># plotting modules</span></div><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div></pre></td></tr></table></figure>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># select the usd_goal_real column</span></div><div class="line">usd_goal = kickstarters_2017.usd_goal_real</div><div class="line"></div><div class="line"><span class="comment"># scale the goals from 0 to 1</span></div><div class="line">scaled_data = minmax_scaling(usd_goal, columns = [<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="comment"># plot the original &amp; scaled data together to compare</span></div><div class="line">fig, ax=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">sns.distplot(kickstarters_2017.usd_goal_real, ax=ax[<span class="number">0</span>])</div><div class="line">ax[<span class="number">0</span>].set_title(<span class="string">"Original Data"</span>)</div><div class="line">sns.distplot(scaled_data, ax=ax[<span class="number">1</span>])</div><div class="line">ax[<span class="number">1</span>].set_title(<span class="string">"Scaled data"</span>)</div></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/18595460/38077516-c4b4a1c0-336b-11e8-9f14-8cdbf6ec6919.png" alt="scale"></p>
<h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>使用 Box-Cox 转换法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># get the index of all positive pledges (Box-Cox only takes postive values)</span></div><div class="line">index_of_positive_pledges = kickstarters_2017.usd_pledged_real &gt; <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment"># get only positive pledges (using their indexes)</span></div><div class="line">positive_pledges = kickstarters_2017.usd_pledged_real.loc[index_of_positive_pledges]</div><div class="line"></div><div class="line"><span class="comment"># normalize the pledges (w/ Box-Cox)</span></div><div class="line">normalized_pledges = stats.boxcox(positive_pledges)[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment"># plot both together to compare</span></div><div class="line">fig, ax=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">sns.distplot(positive_pledges, ax=ax[<span class="number">0</span>])</div><div class="line">ax[<span class="number">0</span>].set_title(<span class="string">"Original Data"</span>)</div><div class="line">sns.distplot(normalized_pledges, ax=ax[<span class="number">1</span>])</div><div class="line">ax[<span class="number">1</span>].set_title(<span class="string">"Normalized data"</span>)</div></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/18595460/38077612-1e69eb80-336c-11e8-8783-7cd178cfecef.png" alt="normalize"></p>
<h2 id="Parsing-Dates"><a href="#Parsing-Dates" class="headerlink" title="Parsing Dates"></a>Parsing Dates</h2><h3 id="Get-our-environment-set-up"><a href="#Get-our-environment-set-up" class="headerlink" title="Get our environment set up"></a>Get our environment set up</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div></pre></td></tr></table></figure>
<h3 id="Check-the-data-type-of-our-date-column"><a href="#Check-the-data-type-of-our-date-column" class="headerlink" title="Check the data type of our date column"></a>Check the data type of our date column</h3><p>pandas 用<code>object</code>表示各类数据类型，一般含有字符串。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">landslides[<span class="string">'date'</span>].dtype</div><div class="line"><span class="comment"># dtype('O')</span></div><div class="line"><span class="comment"># 'O' 表示 'object'</span></div></pre></td></tr></table></figure>
<h3 id="Convert-our-date-columns-to-datetime"><a href="#Convert-our-date-columns-to-datetime" class="headerlink" title="Convert our date columns to datetime"></a>Convert our date columns to datetime</h3><p>将字符串转化为 datetime 时，要注明原字符串在表示日期时所遵循的格式，例如：</p>
<ul>
<li>1/17/07 has the format “%m/%d/%y”</li>
<li>17-1-2007 has the format “%d-%m-%Y”</li>
</ul>
<p>可以看到，<code>%y</code>代表 2 个数字表示的年份，<code>%Y</code>代表 4 个数字表示的年份。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">landslides[<span class="string">'date_parsed'</span>] = pd.to_datetime(landslides[<span class="string">'date'</span>], format = <span class="string">"%m/%d/%y"</span>)</div></pre></td></tr></table></figure>
<p>补充：由于数据中还有个别不是 “month/day/four-digit year” 格式，直接转换的话会报错，Pandas 提供了一个可选的参数 errors，传入 errors=’coerce’，当遇到不能转换的数据就会将其置为 NaN，我们之后再对其进行手工处理。但如果我们不设定 format，这个错误就会被忽略，不过就无法得到特定格式的日期数据了，可能影响之后分析工作。详见<a href="https://zhuanlan.zhihu.com/p/35058099" target="_blank" rel="external">Kaggle 数据清洗挑战 Day 3 - 快速解析日期（date）数据</a></p>
<h3 id="Select-just-the-day-of-the-month-from-our-column"><a href="#Select-just-the-day-of-the-month-from-our-column" class="headerlink" title="Select just the day of the month from our column"></a>Select just the day of the month from our column</h3><p>在处理后的数据中按 month 选取 day：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">day_of_month_landslides = landslides[<span class="string">'date_parsed'</span>].dt.day</div></pre></td></tr></table></figure>
<h3 id="Plot-the-day-of-the-month-to-check-the-date-parsing"><a href="#Plot-the-day-of-the-month-to-check-the-date-parsing" class="headerlink" title="Plot the day of the month to check the date parsing"></a>Plot the day of the month to check the date parsing</h3><p>可视化，用于确认没有搞混“月“和”日“：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># remove na's</span></div><div class="line">day_of_month_landslides = day_of_month_landslides.dropna()</div><div class="line"></div><div class="line"><span class="comment"># plot the day of the month</span></div><div class="line">sns.distplot(day_of_month_landslides, kde=<span class="keyword">False</span>, bins=<span class="number">31</span>)</div></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><a href="https://www.kaggle.com/residentmario/time-series-plotting-optional" target="_blank" rel="external">时间序列可视化</a></p>
<h2 id="Character-Encodings"><a href="#Character-Encodings" class="headerlink" title="Character Encodings"></a>Character Encodings</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># helpful character encoding module</span></div><div class="line"><span class="keyword">import</span> chardet</div></pre></td></tr></table></figure>
<h3 id="What-are-encodings"><a href="#What-are-encodings" class="headerlink" title="What are encodings?"></a>What are encodings?</h3><p>UTF-8 天下第一！</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># start with a string</span></div><div class="line">before = <span class="string">"This is the euro symbol: €"</span></div><div class="line"></div><div class="line"><span class="comment"># check to see what datatype it is</span></div><div class="line">type(before)</div><div class="line"><span class="comment">#str</span></div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">after = before.encode(<span class="string">"utf-8"</span>, errors = <span class="string">"replace"</span>)</div><div class="line"></div><div class="line"><span class="comment"># check the type</span></div><div class="line">type(after)</div><div class="line"><span class="comment"># bytes</span></div><div class="line"></div><div class="line"><span class="comment"># take a look at what the bytes look like</span></div><div class="line">after</div><div class="line"><span class="comment"># b'This is the euro symbol: \xe2\x82\xac'</span></div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># convert it back to utf-8</span></div><div class="line">print(after.decode(<span class="string">"utf-8"</span>))</div><div class="line"><span class="comment"># This is the euro symbol: €</span></div></pre></td></tr></table></figure>
<h3 id="Reading-in-files-with-encoding-problems"><a href="#Reading-in-files-with-encoding-problems" class="headerlink" title="Reading in files with encoding problems"></a>Reading in files with encoding problems</h3><p>读取非 UTF-8 编码的文件会出错。先试着读取前几行看一下能不能判断编码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># look at the first ten thousand bytes to guess the character encoding</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">"../input/kickstarter-projects/ks-projects-201801.csv"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> rawdata:</div><div class="line">    result = chardet.detect(rawdata.read(<span class="number">10000</span>))</div><div class="line"></div><div class="line"><span class="comment"># check what the character encoding might be</span></div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>判断为 Windows-1252 编码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># read in the file with the encoding detected by chardet</span></div><div class="line">kickstarter_2016 = pd.read_csv(<span class="string">"../input/kickstarter-projects/ks-projects-201612.csv"</span>, encoding=<span class="string">'Windows-1252'</span>)</div><div class="line"></div><div class="line"><span class="comment"># look at the first few lines</span></div><div class="line">kickstarter_2016.head()</div></pre></td></tr></table></figure>
<h3 id="Saving-your-files-with-UTF-8-encoding"><a href="#Saving-your-files-with-UTF-8-encoding" class="headerlink" title="Saving your files with UTF-8 encoding"></a>Saving your files with UTF-8 encoding</h3><p>默认以 UTF-8 编码保存。</p>
<h2 id="Inconsistent-Data-Entry"><a href="#Inconsistent-Data-Entry" class="headerlink" title="Inconsistent Data Entry"></a>Inconsistent Data Entry</h2><p>将包括加了空格、大小写不一致、个别拼写错误等类型的不同值整理为一致。</p>
<h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> fuzzywuzzy</div><div class="line"><span class="keyword">from</span> fuzzywuzzy <span class="keyword">import</span> process</div><div class="line"><span class="keyword">import</span> chardet</div></pre></td></tr></table></figure>
<h3 id="Do-some-preliminary-text-pre-processing"><a href="#Do-some-preliminary-text-pre-processing" class="headerlink" title="Do some preliminary text pre-processing"></a>Do some preliminary text pre-processing</h3><p>看一看有哪些值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># get all the unique values in the 'City' column</span></div><div class="line">cities = suicide_attacks[<span class="string">'City'</span>].unique()</div><div class="line"></div><div class="line"><span class="comment"># sort them alphabetically and then take a closer look</span></div><div class="line">cities.sort()</div><div class="line">cities</div></pre></td></tr></table></figure>
<p>去空格、全部调小写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># convert to lower case</span></div><div class="line">suicide_attacks[<span class="string">'City'</span>] = suicide_attacks[<span class="string">'City'</span>].str.lower()</div><div class="line"><span class="comment"># remove trailing white spaces</span></div><div class="line">suicide_attacks[<span class="string">'City'</span>] = suicide_attacks[<span class="string">'City'</span>].str.strip()</div></pre></td></tr></table></figure>
<h3 id="Use-fuzzy-matching-to-correct-inconsistent-data-entry"><a href="#Use-fuzzy-matching-to-correct-inconsistent-data-entry" class="headerlink" title="Use fuzzy matching to correct inconsistent data entry"></a>Use fuzzy matching to correct inconsistent data entry</h3><p><code>fuzzywuzzy</code>包可以帮助辨认那些拼写接近的字符串。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># get the top 10 closest matches to "d.i khan"</span></div><div class="line">matches = fuzzywuzzy.process.extract(<span class="string">"d.i khan"</span>, cities, limit=<span class="number">10</span>, scorer=fuzzywuzzy.fuzz.token_sort_ratio)</div><div class="line"></div><div class="line"><span class="comment"># take a look at them</span></div><div class="line">matches</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">[('d. i khan', 100),</div><div class="line"> ('d.i khan', 100),</div><div class="line"> ('d.g khan', 88),</div><div class="line"> ('khanewal', 50),</div><div class="line"> ('sudhanoti', 47),</div><div class="line"> ('hangu', 46),</div><div class="line"> ('kohat', 46),</div><div class="line"> ('dara adam khel', 45),</div><div class="line"> ('chaman', 43),</div><div class="line"> ('mardan', 43)]</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>可以考虑写一个函数做总体的转化：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># function to replace rows in the provided column of the provided dataframe</span></div><div class="line"><span class="comment"># that match the provided string above the provided ratio with the provided string</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_matches_in_column</span><span class="params">(df, column, string_to_match, min_ratio = <span class="number">90</span>)</span>:</span></div><div class="line">    <span class="comment"># get a list of unique strings</span></div><div class="line">    strings = df[column].unique()</div><div class="line">    </div><div class="line">    <span class="comment"># get the top 10 closest matches to our input string</span></div><div class="line">    matches = fuzzywuzzy.process.extract(string_to_match, strings, </div><div class="line">                                         limit=<span class="number">10</span>, scorer=fuzzywuzzy.fuzz.token_sort_ratio)</div><div class="line"></div><div class="line">    <span class="comment"># only get matches with a ratio &gt; 90</span></div><div class="line">    close_matches = [matches[<span class="number">0</span>] <span class="keyword">for</span> matches <span class="keyword">in</span> matches <span class="keyword">if</span> matches[<span class="number">1</span>] &gt;= min_ratio]</div><div class="line"></div><div class="line">    <span class="comment"># get the rows of all the close matches in our dataframe</span></div><div class="line">    rows_with_matches = df[column].isin(close_matches)</div><div class="line"></div><div class="line">    <span class="comment"># replace all rows with close matches with the input matches </span></div><div class="line">    df.loc[rows_with_matches, column] = string_to_match</div><div class="line">    </div><div class="line">    <span class="comment"># let us know the function's done</span></div><div class="line">    print(<span class="string">"All done!"</span>)</div></pre></td></tr></table></figure>
<p>之后只需要对那些疑似相同的字符串逐个调用该函数即可：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># use the function we just wrote to replace close matches to "d.i khan" with "d.i khan"</span></div><div class="line">replace_matches_in_column(df=suicide_attacks, column=<span class="string">'City'</span>, string_to_match=<span class="string">"d.i khan"</span>)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶然看到了 Kaggle 的数据清理 5 天挑战，大致看了一下，还是比较实用的。因此全部做完后记录一下。不是很想在无谓的整理上花太多时间，因此各类标题直接使用原文中的英文标题，用于串联内容的文字较少，且代码不一定完整（主要是缺少导入包和数据的语句）。如果你希望能够全面地了解这 5 次挑战的内容，以下是 Kaggle 上原 kernel 的地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Day 1: &lt;a href=&quot;https://www.kaggle.com/rtatman/data-cleaning-challenge-handling-missing-values&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Data Cleaning Challenge: Handling missing values | Kaggle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 2: &lt;a href=&quot;https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Data Cleaning Challenge: Scale and Normalize Data | Kaggle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 3: &lt;a href=&quot;https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Data Cleaning Challenge: Parsing Dates | Kaggle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 4: &lt;a href=&quot;https://www.kaggle.com/rtatman/data-cleaning-challenge-character-encodings/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Data Cleaning Challenge: Character Encodings | Kaggle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 5: &lt;a href=&quot;https://www.kaggle.com/rtatman/data-cleaning-challenge-inconsistent-data-entry&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Data Cleaning Challenge: Inconsistent Data Entry | Kaggle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据科学笔记" scheme="http://kyonhuang.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据科学" scheme="http://kyonhuang.top/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
      <category term="数据清理" scheme="http://kyonhuang.top/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>记CIPS 青工委武汉大学系列讲座</title>
    <link href="http://kyonhuang.top/whu-CIPS-academic-salon/"/>
    <id>http://kyonhuang.top/whu-CIPS-academic-salon/</id>
    <published>2018-03-24T11:39:29.000Z</published>
    <updated>2018-03-29T14:40:17.196Z</updated>
    
    <content type="html"><![CDATA[<p>趁着余兴未尽，来将今天早上参加的讲座记录一下。很幸运周四在教学楼下看到了这次活动的海报。本次系列讲座是 CIPS 青工委（中国中文信息学会青年工作委员会）在武汉大学的一次活动，主持人是武大的李晨亮老师，嘉宾包括清华的刘洋老师、刘知远老师、张敏老师，天津大学的张鹏老师和北大的严睿老师。五名老师在其所关注的细分领域各有建树，全是自然语言处理和信息检索领域的大牛。接下来以老师报告的顺序大概介绍一下各位老师的报告内容，和我对各位老师的感受。因为我忘记带拍照用的手机了，因此没有照片，而且笔记也不完整，部分理解可能有偏差，尽请见谅。</p>
<a id="more"></a>
<h2 id="刘洋《基于深度学习的机器翻译》"><a href="#刘洋《基于深度学习的机器翻译》" class="headerlink" title="刘洋《基于深度学习的机器翻译》"></a>刘洋《基于深度学习的机器翻译》</h2><p>首先是委员会主任刘洋老师的报告。PPT 与他主页上 <a href="http://nlp.csai.tsinghua.edu.cn/~ly/talks/cwmt2016_ly_v3_160826.pptx" target="_blank" rel="external">Advances in Neural Machne Translation</a> 的内容有 70% 是一致的，可以据此了解一下。</p>
<p>刘洋老师主要介绍了机器翻译的发展，从规则机器翻译 -&gt; 统计机器翻译 -&gt; 神经机器翻译，人们关注的重点也从规则到特征，最后变到架构。他认为神经机器翻译的可研究方向还包括架构学习（让机器学习架构来得到表现更好的，而非人类手工调整）、先验知识融合、单词学习、高效算法、可解释性等等。</p>
<p>总体来说，刘洋老师的报告是五场报告中最容易理解的，他在其中加入了很多例子帮助理解，而非一味堆积 paper 成果。</p>
<p>有观众提出问题，认为目前的机器翻译还缺少和人的感觉相配的评价指标。例如，如果机器将人名翻译错误，相似度降低很少，但是用户的使用体验就很差。另外，机器翻译用于商业时达成度不够。刘洋老师也认同目前存在这问题。</p>
<p>刘洋老师真人比主页上的照片看起来帅一些，年轻一些。另外，坐在我前面一排的小朋友应该是刘洋老师的儿子，整个讲座过程中都非常安静，很难得，也显出刘洋老师家教有方。</p>
<h2 id="严睿《人工智能在人机对话系统中的技术现状与挑战》"><a href="#严睿《人工智能在人机对话系统中的技术现状与挑战》" class="headerlink" title="严睿《人工智能在人机对话系统中的技术现状与挑战》"></a>严睿《人工智能在人机对话系统中的技术现状与挑战》</h2><p>严睿老师主要介绍了人机对话的一些现状，包括：</p>
<ul>
<li><p>分类：</p>
<ul>
<li>按领域：开放领域 / 垂直领域：医疗、金融、法律…</li>
<li>按回复方式：检索式（目前业界主流） / 生成式（下一代潮流：深度学习加持） / 综合式</li>
<li>主动 / 被动</li>
<li>…</li>
</ul>
</li>
<li><p>算法：</p>
<ul>
<li>上下文信息</li>
<li>知识库信息（世界知识）</li>
<li>语意逻辑信息 </li>
</ul>
</li>
<li><p>挑战：</p>
<ul>
<li>源自人类认知直觉的剖析</li>
<li>相关性、趣味性、信息量、情感化</li>
</ul>
</li>
</ul>
<p>另外，介绍了较多的 paper 的工作。</p>
<p>严睿老师语速比较快，给我的感觉是思路很活跃。另外，讲完后不久他就离场了，不知道是不是去看樱花去了，哈哈。</p>
<h2 id="张敏《用户满意的异质可解释的推荐：THUIR工作进展》"><a href="#张敏《用户满意的异质可解释的推荐：THUIR工作进展》" class="headerlink" title="张敏《用户满意的异质可解释的推荐：THUIR工作进展》"></a>张敏《用户满意的异质可解释的推荐：THUIR工作进展》</h2><p>张敏老师主要介绍了自己所在的 THUIR 研究组对于推荐系统的一些工作，包括：</p>
<ol>
<li>可解释推荐。</li>
<li>时间对推荐的影响（也算是可解释性）：ARIMA 时间序列模型。</li>
<li>社会关系对推荐的影响（抑制的信息）：不认识不代表负类，而是在之后会认识的概率上在进行标识。并且也使用了迁移学习。</li>
<li>用户满意度：多样性 vs 满意度。</li>
<li>用户理解：群体推荐的公平性和满意度。</li>
</ol>
<p>张敏老师的工作应该是五场报告中我最感兴趣的。活动后我斗胆去询问她是否还有学硕或者直博的名额，可惜她的名额已经满了（抢手到可怕），让我给她发邮件看研究组里另外两位老师是否还有名额。</p>
<h2 id="张鹏《量子力学启发的信息检索和自然语言处理》"><a href="#张鹏《量子力学启发的信息检索和自然语言处理》" class="headerlink" title="张鹏《量子力学启发的信息检索和自然语言处理》"></a>张鹏《量子力学启发的信息检索和自然语言处理》</h2><p>张鹏老师研究的问题比较新颖，将深度学习和量子计算结合起来。他所在的 TJU’s Quantum IR/NLP group 应该在这方面做了不少工作，但是我们可能就对这个方向不是很了解了。讲着讲着薛定谔的猫也出来了，有点懵…唯一一个报告完后没有学生提问的。老师人还是很和蔼的。</p>
<h2 id="刘知远《知识表示学习及其应用》"><a href="#刘知远《知识表示学习及其应用》" class="headerlink" title="刘知远《知识表示学习及其应用》"></a>刘知远《知识表示学习及其应用》</h2><p>最后是知乎网红刘知远老师。PPT 和他主页上的<a href="http://thunlp.org/~lzy/talks/nrl2017.pdf" target="_blank" rel="external">社会计算与表示学习</a> 前一半内容基本相同，后一半是介绍自己的近期工作。</p>
<p>刘老师首先介绍了知识图谱实体与关系。知识图谱的典型表示方案是基于符号表示的三元组（RDF），但是无法有效计算实体间的语义关系，解决方案是将知识映射到低维向量空间。</p>
<p>之后，介绍了 TransE：将关系表示为从 head 到 tail 的翻译操作，和融合文本和知识进行关系抽取等。具体内容可以看 PPT，个人水平有限，难以总结。</p>
<p>老师目前主要关注大规模知识图谱的应用，包括关系抽取、实体对齐（不同领域的知识图谱的结合）、实体分类等。介绍了开源平台：<a href="http://openke.thunlp.org/" target="_blank" rel="external">http://openke.thunlp.org/</a>。顺便一提，刘老师凌晨两点发了一条微博，表示整理了自己的一些工作，开源了相关代码，赞！</p>
<p>未来工作方向：</p>
<ul>
<li>利用表示学习技术将知识图谱用于相关领域（信息检索、推荐系统）</li>
<li>利用表示学习技术改进知识获取能力（富语境信息抽取、开放关系抽取、开放事件抽取）</li>
</ul>
<p>刘知远老师在知乎上对于学术科研写了不少回答，对我很有帮助。个人关注了他的微博和知乎。不过现场感觉刘老师比知乎上给人的感觉要更威慑一些…</p>
<h2 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h2><p>五位老师都介绍了各自研究的领域、面临的问题以及目前的一些工作，让我能够在走上学术之路前能够充分了解自然语言处理和信息检索的一些研究方向，对我有很大的启发。</p>
<p>现场的人数还是比较多的，临时换了一个更大的教室。刘知远老师报告时统计了一下在场的本科生，包括我在内的大约 10 人。让我没有想到的是，在场很多的研究生确实对不同老师的方向各有见解，提出了比较有深度的问题。武大啥时候冒出这么多自然语言处理方向的研究生啊，以前完全不知道，原来计院卧虎藏龙。</p>
<p>也不知道该怎么结束这篇博文了。给大家欣赏一下我下午摄影实习照的樱花好了。</p>
<p><img src="/images/sakura/1.jpg"></p>
<p><img src="/images/sakura/2.jpg"></p>
<p><img src="/images/sakura/3.jpg"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;趁着余兴未尽，来将今天早上参加的讲座记录一下。很幸运周四在教学楼下看到了这次活动的海报。本次系列讲座是 CIPS 青工委（中国中文信息学会青年工作委员会）在武汉大学的一次活动，主持人是武大的李晨亮老师，嘉宾包括清华的刘洋老师、刘知远老师、张敏老师，天津大学的张鹏老师和北大的严睿老师。五名老师在其所关注的细分领域各有建树，全是自然语言处理和信息检索领域的大牛。接下来以老师报告的顺序大概介绍一下各位老师的报告内容，和我对各位老师的感受。因为我忘记带拍照用的手机了，因此没有照片，而且笔记也不完整，部分理解可能有偏差，尽请见谅。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="讲座" scheme="http://kyonhuang.top/tags/%E8%AE%B2%E5%BA%A7/"/>
    
      <category term="CIPS 青工委" scheme="http://kyonhuang.top/tags/CIPS-%E9%9D%92%E5%B7%A5%E5%A7%94/"/>
    
      <category term="NLP" scheme="http://kyonhuang.top/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle Titanic 生存预测（上）--特征工程</title>
    <link href="http://kyonhuang.top/kaggle-titanic-1/"/>
    <id>http://kyonhuang.top/kaggle-titanic-1/</id>
    <published>2018-02-26T11:12:03.000Z</published>
    <updated>2018-03-25T11:19:52.295Z</updated>
    
    <content type="html"><![CDATA[<p>注册著名的数据科学竞赛平台 Kaggle 四个多月了，当初是为了要一份数据集，而一直没有参加比赛。这个寒假终于按耐不住，决定拿入门级的 Titanic: Machine Learning from Disaster 打响革命第一枪。</p>
<p>Titanic 生存预测比赛是一个二分类问题。题目提供了一份乘客名单，包含了乘客的名字、性别、年龄、船票等级等信息，以及是否成功获救的标记，最终需要提交一份对测试集中的乘客是否成功获救的 csv 文件。</p>
<p>经过了四次提交，最后我的 Public Score 暂时定格在 0.80861，这个成绩目前在前 7%。这篇博文主要简述一下我所做的尝试和改进，并对最后一次换用 XGBoost 所得到的最好成绩的代码进行一个详细的说明，也是对相似题目处理流程的一个总结。</p>
<p><img src="/images/Titanic-public-score.jpg" alt="Titanic-public-score"></p>
<a id="more"></a>
<h2 id="过程简述"><a href="#过程简述" class="headerlink" title="过程简述"></a>过程简述</h2><h3 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h3><p>在探索数据后，我决定选用以下特征进行预测<code>&#39;Pclass&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;Embarked&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Fare&#39;</code>。其中 Age、Embarked 和 Fare 有缺失，考虑使用出现频率最高的值来填充 Embarked 特征（类别型）的缺失值，使用平均值来填充 Age 和 Fare 特征（数值型）的缺失值。而类别特征不能直接作为输入，因此采用 DictVectorizer 对特征抽取和特征向量化。</p>
<p>最后使用 RandomForest 分类器来进行预测。Public Score 为 0.73205。</p>
<h3 id="第二次提交"><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h3><p>Fare 只有一个缺失，而 Age 存在 86 个缺失值。因此，直接使用平均值来填充 Age 的缺失值可能对预测结果影响较大。我将 Age 从选取的有效特征中剔除，其他不变，Public Score 提高到 0.75598。</p>
<h3 id="第三次提交"><a href="#第三次提交" class="headerlink" title="第三次提交"></a>第三次提交</h3><p>在对别人分享的 kernel 进行学习后，这次我做了比较详细的特征工程（具体操作在下一节），并且进行了 sklearn 中常用分类器效果的比较，最终选用了 SVC 分类器。本次的 Public Score 提高到 0.79904。</p>
<h2 id="代码详述"><a href="#代码详述" class="headerlink" title="代码详述"></a>代码详述</h2><p>这里针对最后一次提交对应的代码进行一个说明总结。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> re <span class="keyword">as</span> re</div><div class="line"></div><div class="line"><span class="keyword">import</span> warnings</div><div class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">train = pd.read_csv(<span class="string">'../input/train.csv'</span>, header=<span class="number">0</span>, dtype=&#123;<span class="string">'Age'</span>: np.float64&#125;)</div><div class="line">test = pd.read_csv(<span class="string">'../input/test.csv'</span>, header=<span class="number">0</span>, dtype=&#123;<span class="string">'Age'</span>: np.float64&#125;)</div><div class="line">full_data = [train, test]</div></pre></td></tr></table></figure>
<p>我们可以通过<code>info</code>方法来大致地了解训练集和测试集：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(train.info())</div><div class="line">print(test.info())</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</div><div class="line">RangeIndex: 891 entries, 0 to 890</div><div class="line">Data columns (total 12 columns):</div><div class="line">PassengerId    891 non-null int64</div><div class="line">Survived       891 non-null int64</div><div class="line">Pclass         891 non-null int64</div><div class="line">Name           891 non-null object</div><div class="line">Sex            891 non-null object</div><div class="line">Age            714 non-null float64</div><div class="line">SibSp          891 non-null int64</div><div class="line">Parch          891 non-null int64</div><div class="line">Ticket         891 non-null object</div><div class="line">Fare           891 non-null float64</div><div class="line">Cabin          204 non-null object</div><div class="line">Embarked       889 non-null object</div><div class="line">dtypes: float64(2), int64(5), object(5)</div><div class="line">memory usage: 83.6+ KB</div><div class="line">None</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</div><div class="line">RangeIndex: 418 entries, 0 to 417</div><div class="line">Data columns (total 11 columns):</div><div class="line">PassengerId    418 non-null int64</div><div class="line">Pclass         418 non-null int64</div><div class="line">Name           418 non-null object</div><div class="line">Sex            418 non-null object</div><div class="line">Age            332 non-null float64</div><div class="line">SibSp          418 non-null int64</div><div class="line">Parch          418 non-null int64</div><div class="line">Ticket         418 non-null object</div><div class="line">Fare           417 non-null float64</div><div class="line">Cabin          91 non-null object</div><div class="line">Embarked       418 non-null object</div><div class="line">dtypes: float64(2), int64(4), object(5)</div><div class="line">memory usage: 36.0+ KB</div><div class="line">None</div></pre></td></tr></table></figure>
<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><h4 id="Pclass"><a href="#Pclass" class="headerlink" title="Pclass"></a>Pclass</h4><p>Pclass 特征没有缺失值，因此可以通过<code>groupby</code>函数来计算船舱每一档的生还率：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(train[[<span class="string">'Pclass'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Pclass'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>可以看到结果显示船舱档位和生还率还是有较大联系的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   Pclass  Survived</div><div class="line">0       1  0.629630</div><div class="line">1       2  0.472826</div><div class="line">2       3  0.242363</div></pre></td></tr></table></figure>
<h4 id="Sex"><a href="#Sex" class="headerlink" title="Sex"></a>Sex</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(train[[<span class="string">'Sex'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Sex'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>可以看到女性的生还率更高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Sex  Survived</div><div class="line">0  female  0.742038</div><div class="line">1    male  0.188908</div></pre></td></tr></table></figure>
<h4 id="SibSp-and-Parch"><a href="#SibSp-and-Parch" class="headerlink" title="SibSp and Parch"></a>SibSp and Parch</h4><p>这两个特征是船上表亲和直亲数量。通过这两个特征可以创造一个新的特征 - Family Size：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    dataset[<span class="string">'FamilySize'</span>] = dataset[<span class="string">'SibSp'</span>] + dataset[<span class="string">'Parch'</span>] + <span class="number">1</span></div><div class="line">print(train[[<span class="string">'FamilySize'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'FamilySize'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>可以看到生还率和家庭成员数不是单纯的线性关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   FamilySize  Survived</div><div class="line">0           1  0.303538</div><div class="line">1           2  0.552795</div><div class="line">2           3  0.578431</div><div class="line">3           4  0.724138</div><div class="line">4           5  0.200000</div><div class="line">5           6  0.136364</div><div class="line">6           7  0.333333</div><div class="line">7           8  0.000000</div><div class="line">8          11  0.000000</div></pre></td></tr></table></figure>
<p>我们可以再创建一个新特征 IsAlone，用来表示是否是单独出行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    dataset[<span class="string">'IsAlone'</span>] = <span class="number">0</span></div><div class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">1</span>, <span class="string">'IsAlone'</span>] = <span class="number">1</span></div><div class="line">print(train[[<span class="string">'IsAlone'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'IsAlone'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   IsAlone  Survived</div><div class="line">0        0  0.505650</div><div class="line">1        1  0.303538</div></pre></td></tr></table></figure>
<p>现在特征值对结果的影响就比较明显了。</p>
<h4 id="Embarked"><a href="#Embarked" class="headerlink" title="Embarked"></a>Embarked</h4><p>注意 Embarked 特征有极少的缺失值，对于类别特征，可以考虑用最频繁的特征值进行填充：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train[<span class="string">'Embarked'</span>].value_counts()</div></pre></td></tr></table></figure>
<p>可以看到，最频繁的特征值为<code>S</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">S    644</div><div class="line">C    168</div><div class="line">Q     77</div><div class="line">Name: Embarked, dtype: int64</div></pre></td></tr></table></figure>
<p>因此，我们用<code>S</code>对缺失值进行填充：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    dataset[<span class="string">'Embarked'</span>] = dataset[<span class="string">'Embarked'</span>].fillna(<span class="string">'S'</span>)</div><div class="line">print(train[[<span class="string">'Embarked'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Embarked'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>结果如下。可以看到明显的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  Embarked  Survived</div><div class="line">0        C  0.553571</div><div class="line">1        Q  0.389610</div><div class="line">2        S  0.339009</div></pre></td></tr></table></figure>
<h4 id="Fare"><a href="#Fare" class="headerlink" title="Fare"></a>Fare</h4><p>测试集中 Fare 特征有一个缺失值。对于数值特征，可以用中位数（或者平均值）填充缺失值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    dataset[<span class="string">'Fare'</span>] = dataset[<span class="string">'Fare'</span>].fillna(train[<span class="string">'Fare'</span>].median())</div></pre></td></tr></table></figure>
<p>因为每个 Fare 的值对应的样本数量太少，因此我们考虑划分区间。这里，我根据每个区间的样本数量将样本划分为四个区间，形成新特征 CategoricalFare：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">train[<span class="string">'CategoricalFare'</span>] = pd.qcut(train[<span class="string">'Fare'</span>], <span class="number">4</span>)</div><div class="line">print(train[[<span class="string">'CategoricalFare'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'CategoricalFare'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   CategoricalFare  Survived</div><div class="line">0   (-0.001, 7.91]  0.197309</div><div class="line">1   (7.91, 14.454]  0.303571</div><div class="line">2   (14.454, 31.0]  0.454955</div><div class="line">3  (31.0, 512.329]  0.581081</div></pre></td></tr></table></figure>
<h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p>之前提到过，Age 特征的缺失值太多，不能简单的用平均值或者中位数进行填充。这里，我们不再简单的舍弃 Age 特征，而是换用不同的填充思路 - <strong>根据已有数据的平均值和标准差随机生成填充数</strong>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    age_avg = dataset[<span class="string">'Age'</span>].mean()</div><div class="line">    age_std = dataset[<span class="string">'Age'</span>].std()</div><div class="line">    age_null_count = dataset[<span class="string">'Age'</span>].isnull().sum()</div><div class="line">    </div><div class="line">    age_null_random_list = np.random.randint(age_avg - age_std, age_avg + age_std, size=age_null_count)</div><div class="line">    dataset[<span class="string">'Age'</span>][np.isnan(dataset[<span class="string">'Age'</span>])] = age_null_random_list</div><div class="line">    dataset[<span class="string">'Age'</span>] = dataset[<span class="string">'Age'</span>].astype(int)</div></pre></td></tr></table></figure>
<p>同样，将数据划分为区间。这里我按等区间跨度划分，生成新特征 CategoricalAge：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">train[<span class="string">'CategoricalAge'</span>] = pd.cut(train[<span class="string">'Age'</span>], <span class="number">5</span>)</div><div class="line"></div><div class="line">print(train[[<span class="string">'CategoricalAge'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'CategoricalAge'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  CategoricalAge  Survived</div><div class="line">0  (-0.08, 16.0]  0.504274</div><div class="line">1   (16.0, 32.0]  0.345372</div><div class="line">2   (32.0, 48.0]  0.394422</div><div class="line">3   (48.0, 64.0]  0.434783</div><div class="line">4   (64.0, 80.0]  0.090909</div></pre></td></tr></table></figure>
<p>也有别的填充思路，例如用<code>Sex, Title, Pclass</code>三个特征构建随机森林模型，来生成填充值。</p>
<h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>姓名是我们一开始忽略掉的特征。实际上，通过人名前的头衔也可以进行分析：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_title</span><span class="params">(name)</span>:</span></div><div class="line">    title_search = re.search(<span class="string">' ([A-Za-z]+)\.'</span>, name)</div><div class="line">    <span class="keyword">if</span> title_search:</div><div class="line">        <span class="keyword">return</span> title_search.group(<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> <span class="string">''</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Name'</span>].apply(get_title)</div><div class="line">    </div><div class="line">print(pd.crosstab(train[<span class="string">'Title'</span>], train[<span class="string">'Sex'</span>]))</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Sex       female  male</div><div class="line">Title                 </div><div class="line">Capt           0     1</div><div class="line">Col            0     2</div><div class="line">Countess       1     0</div><div class="line">Don            0     1</div><div class="line">Dr             1     6</div><div class="line">Jonkheer       0     1</div><div class="line">Lady           1     0</div><div class="line">Major          0     2</div><div class="line">Master         0    40</div><div class="line">Miss         182     0</div><div class="line">Mlle           2     0</div><div class="line">Mme            1     0</div><div class="line">Mr             0   517</div><div class="line">Mrs          125     0</div><div class="line">Ms             1     0</div><div class="line">Rev            0     6</div><div class="line">Sir            0     1</div></pre></td></tr></table></figure>
<p>由于存在一些次数较少的头衔，我们将头衔分类，把部分含义相近的头衔归在一起：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace([<span class="string">'Lady'</span>, <span class="string">'Countess'</span>, <span class="string">'Capt'</span>, <span class="string">'Col'</span>, <span class="string">'Sir'</span>, <span class="string">'Don'</span>, <span class="string">'Dr'</span>, <span class="string">'Major'</span>, <span class="string">'Rev'</span>, <span class="string">'Jonkheer'</span>, <span class="string">'Dona'</span>], <span class="string">'Rare'</span>)</div><div class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Mlle'</span>, <span class="string">'Miss'</span>)</div><div class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Ms'</span>, <span class="string">'Miss'</span>)</div><div class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Mme'</span>, <span class="string">'Mrs'</span>)</div><div class="line">    </div><div class="line">print(train[[<span class="string">'Title'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Title'</span>], as_index=<span class="keyword">False</span>).mean())</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    Title  Survived</div><div class="line">0  Master  0.575000</div><div class="line">1    Miss  0.702703</div><div class="line">2      Mr  0.156673</div><div class="line">3     Mrs  0.793651</div><div class="line">4    Rare  0.347826</div></pre></td></tr></table></figure>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>sklearn 要求数据都是数值型的，因此要进行数据的清理和转换。也可以用各种包内现成的算法，例如<code>pd.get_dummies()</code>。这里我们就简单的自己动手来将数据映射为数值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将数据映射为数值</span></div><div class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</div><div class="line">    <span class="comment"># Mapping Sex</span></div><div class="line">    dataset[<span class="string">'Sex'</span>] = dataset[<span class="string">'Sex'</span>].map( &#123;<span class="string">'female'</span>: <span class="number">0</span>, <span class="string">'male'</span>: <span class="number">1</span>&#125; ).astype(int)</div><div class="line">    </div><div class="line">    <span class="comment"># Mapping titles</span></div><div class="line">    title_mapping = &#123;<span class="string">"Mr"</span>: <span class="number">1</span>, <span class="string">"Miss"</span>: <span class="number">2</span>, <span class="string">"Mrs"</span>: <span class="number">3</span>, <span class="string">"Master"</span>: <span class="number">4</span>, <span class="string">"Rare"</span>: <span class="number">5</span>&#125;</div><div class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].map(title_mapping)</div><div class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].fillna(<span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># Mapping Embarked</span></div><div class="line">    dataset[<span class="string">'Embarked'</span>] = dataset[<span class="string">'Embarked'</span>].map( &#123;<span class="string">'S'</span>: <span class="number">0</span>, <span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'Q'</span>: <span class="number">2</span>&#125; ).astype(int)</div><div class="line">    </div><div class="line">    <span class="comment"># Mapping Fare</span></div><div class="line">    dataset.loc[ dataset[<span class="string">'Fare'</span>] &lt;= <span class="number">7.91</span>, <span class="string">'Fare'</span>] 						        = <span class="number">0</span></div><div class="line">    dataset.loc[(dataset[<span class="string">'Fare'</span>] &gt; <span class="number">7.91</span>) &amp; (dataset[<span class="string">'Fare'</span>] &lt;= <span class="number">14.454</span>), <span class="string">'Fare'</span>] = <span class="number">1</span></div><div class="line">    dataset.loc[(dataset[<span class="string">'Fare'</span>] &gt; <span class="number">14.454</span>) &amp; (dataset[<span class="string">'Fare'</span>] &lt;= <span class="number">31</span>), <span class="string">'Fare'</span>]   = <span class="number">2</span></div><div class="line">    dataset.loc[ dataset[<span class="string">'Fare'</span>] &gt; <span class="number">31</span>, <span class="string">'Fare'</span>] 							        = <span class="number">3</span></div><div class="line">    dataset[<span class="string">'Fare'</span>] = dataset[<span class="string">'Fare'</span>].astype(int)</div><div class="line">    </div><div class="line">    <span class="comment"># Mapping Age</span></div><div class="line">    dataset.loc[ dataset[<span class="string">'Age'</span>] &lt;= <span class="number">16</span>, <span class="string">'Age'</span>] 					       = <span class="number">0</span></div><div class="line">    dataset.loc[(dataset[<span class="string">'Age'</span>] &gt; <span class="number">16</span>) &amp; (dataset[<span class="string">'Age'</span>] &lt;= <span class="number">32</span>), <span class="string">'Age'</span>] = <span class="number">1</span></div><div class="line">    dataset.loc[(dataset[<span class="string">'Age'</span>] &gt; <span class="number">32</span>) &amp; (dataset[<span class="string">'Age'</span>] &lt;= <span class="number">48</span>), <span class="string">'Age'</span>] = <span class="number">2</span></div><div class="line">    dataset.loc[(dataset[<span class="string">'Age'</span>] &gt; <span class="number">48</span>) &amp; (dataset[<span class="string">'Age'</span>] &lt;= <span class="number">64</span>), <span class="string">'Age'</span>] = <span class="number">3</span></div><div class="line">    dataset.loc[ dataset[<span class="string">'Age'</span>] &gt; <span class="number">64</span>, <span class="string">'Age'</span>]                           = <span class="number">4</span></div></pre></td></tr></table></figure>
<h3 id="特征选取"><a href="#特征选取" class="headerlink" title="特征选取"></a>特征选取</h3><p>我们将一些无用的特征去掉，只保留部分原始特征和我们生成的新特征：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Feature Selection</span></div><div class="line">drop_elements = [<span class="string">'PassengerId'</span>, <span class="string">'Name'</span>, <span class="string">'Ticket'</span>, <span class="string">'Cabin'</span>, <span class="string">'SibSp'</span>, <span class="string">'Parch'</span>, <span class="string">'FamilySize'</span>]</div><div class="line">train = train.drop(drop_elements, axis = <span class="number">1</span>)</div><div class="line">train = train.drop([<span class="string">'CategoricalAge'</span>, <span class="string">'CategoricalFare'</span>], axis = <span class="number">1</span>)</div><div class="line"></div><div class="line">test  = test.drop(drop_elements, axis = <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> (train.head(<span class="number">10</span>))</div><div class="line"></div><div class="line">train = train.values</div><div class="line">test  = test.values</div></pre></td></tr></table></figure>
<p>打印的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   Survived  Pclass  Sex  Age  Fare  Embarked  IsAlone  Title</div><div class="line">0         0       3    1    1     0         0        0      1</div><div class="line">1         1       1    0    2     3         1        0      3</div><div class="line">2         1       3    0    1     1         0        1      2</div><div class="line">3         1       1    0    2     3         0        0      3</div><div class="line">4         0       3    1    2     1         0        1      1</div><div class="line">5         0       3    1    1     1         2        1      1</div><div class="line">6         0       1    1    3     3         0        1      1</div><div class="line">7         0       3    1    0     2         0        0      4</div><div class="line">8         1       3    0    1     1         0        0      3</div><div class="line">9         1       2    0    0     2         1        0      3</div></pre></td></tr></table></figure>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>首先生成训练集的特征和标记：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">X = train[<span class="number">0</span>::, <span class="number">1</span>::]</div><div class="line">y = train[<span class="number">0</span>::, <span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>引入并初始化 xgboost：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</div><div class="line">xgbc = XGBClassifier()</div></pre></td></tr></table></figure>
<p>我们先使用 5 折交叉验证来看一看 xgboost 算法的预测效果如何：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> cross_val_score</div><div class="line"><span class="comment"># 使用 5 折交叉验证</span></div><div class="line">cross_val_score(xgbc, X, y, cv=<span class="number">5</span>).mean()</div></pre></td></tr></table></figure>
<p>结果为 0.80595516611715701，还不错。之后就可以正式的训练和预测了：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">xgbc.fit(X, y)</div><div class="line">xgbc_y_predict = xgbc.predict(test)</div><div class="line"></div><div class="line">test_data = pd.read_csv(<span class="string">'../input/test.csv'</span>, header=<span class="number">0</span>, dtype=&#123;<span class="string">'Age'</span>: np.float64&#125;)</div><div class="line">xgbc_submission = pd.DataFrame(&#123;</div><div class="line">    <span class="string">'PassengerId'</span>: test_data[<span class="string">'PassengerId'</span>],</div><div class="line">    <span class="string">'Survived'</span>: xgbc_y_predict</div><div class="line">&#125;)</div><div class="line">xgbc_submission.to_csv(<span class="string">'xgbc_submission.csv'</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<h3 id="分类器比较"><a href="#分类器比较" class="headerlink" title="分类器比较"></a>分类器比较</h3><p>尽管这一次我直接选用了 XGBoost，但是我还是想把第三次提交时所用的分类器比较代码贴一下。首先是引入所有参与比较的分类器（全部是 sklearn 包中的），以及用于可视化的 matplotlib 和 seaborn。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</div><div class="line"></div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedShuffleSplit</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, log_loss</div><div class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</div><div class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</div><div class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</div><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier</div><div class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</div><div class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis</div><div class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</div></pre></td></tr></table></figure>
<p>初始化各分类器，并使用数据集划分函数 StratifiedShuffleSplit：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">classifiers = [</div><div class="line">    KNeighborsClassifier(<span class="number">3</span>),</div><div class="line">    SVC(probability=<span class="keyword">True</span>),</div><div class="line">    DecisionTreeClassifier(),</div><div class="line">    RandomForestClassifier(),</div><div class="line">    AdaBoostClassifier(),</div><div class="line">    GradientBoostingClassifier(),</div><div class="line">    GaussianNB(),</div><div class="line">    LinearDiscriminantAnalysis(),</div><div class="line">    QuadraticDiscriminantAnalysis(),</div><div class="line">    LogisticRegression()</div><div class="line">]</div><div class="line"></div><div class="line">log_cols = [<span class="string">'Classifier'</span>, <span class="string">'Accuracy'</span>]</div><div class="line">log = pd.DataFrame(columns=log_cols)</div><div class="line"></div><div class="line">sss = StratifiedShuffleSplit(n_splits=<span class="number">10</span>, test_size=<span class="number">0.1</span>, random_state=<span class="number">0</span>)</div><div class="line"></div><div class="line">X = train[<span class="number">0</span>::, <span class="number">1</span>::]</div><div class="line">y = train[<span class="number">0</span>::, <span class="number">0</span>]</div><div class="line"></div><div class="line">acc_dict = &#123;&#125;</div></pre></td></tr></table></figure>
<p>分别计算各分类器的准确率：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> sss.split(X, y):</div><div class="line">    X_train, X_test = X[train_index], X[test_index]</div><div class="line">    y_train, y_test = y[train_index], y[test_index]</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> clf <span class="keyword">in</span> classifiers:</div><div class="line">        name = clf.__class__.__name__</div><div class="line">        clf.fit(X_train, y_train)</div><div class="line">        train_predictions = clf.predict(X_test)</div><div class="line">        acc = accuracy_score(y_test, train_predictions)</div><div class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> acc_dict:</div><div class="line">            acc_dict[name] += acc</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            acc_dict[name] = acc</div><div class="line"></div><div class="line"><span class="keyword">for</span> clf <span class="keyword">in</span> acc_dict:</div><div class="line">    acc_dict[clf] = acc_dict[clf] / <span class="number">10.0</span></div><div class="line">    log_entry = pd.DataFrame([[clf, acc_dict[clf]]], columns=log_cols)</div><div class="line">    log = log.append(log_entry)</div><div class="line">    </div><div class="line">plt.xlabel(<span class="string">'Accuracy'</span>)</div><div class="line">plt.title(<span class="string">'Classifier Accuracy'</span>)</div><div class="line"></div><div class="line">sns.set_color_codes(<span class="string">'muted'</span>)</div><div class="line">sns.barplot(x=<span class="string">'Accuracy'</span>, y=<span class="string">'Classifier'</span>, data=log, color=<span class="string">'b'</span>)</div></pre></td></tr></table></figure>
<p>这里的指标其实有更好的选择，因为当训练集中大量例子属于某一个类时，分类器可能通过简单地全部预测为较大类来达到更高的准确率。用 F1 Score，即精确率和召回率的调和平均数会更为科学。</p>
<p>比较结果如图：</p>
<p><img src="data:image/png;base64,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%0A" alt=""></p>
<p>根据这幅图，第三次提交时我选用了效果相对较好的 SVC 分类器。</p>
<h3 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h3><h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h4><p>在上述代码中我们没有进行数据可视化，一是因为这次的数据还是比较容易去分析，不太需要数据可视化；二是我对 matplotlib、seaborn 的使用还不太熟练。</p>
<p>实际上，数据可视化是数据科学的核心技术之一。有效的数据可视化可以帮助深入地研究变量，因此通过数据可视化来对数据集和单独的特征进行了解应该成为机器学习项目的第一步。如果想要了解如何在这个项目中使用数据可视化进行分析，可以在最下面的参考资料中查看别人的方案；如果想全面的学习数据可视化，Kaggle 也提供了数据可视化的<a href="https://www.kaggle.com/learn/data-visualisation" target="_blank" rel="external">课程</a>。</p>
<h4 id="关于缺失值"><a href="#关于缺失值" class="headerlink" title="关于缺失值"></a>关于缺失值</h4><p>不同的机器学习模型对缺失值的敏感度不同。实际上，xgboost 对缺失值有默认的处理方法。根据作者 Tianqi Chen 在论文中的介绍，xgboost 把缺失值当做稀疏矩阵来对待，本身的在节点分裂时不考虑的缺失值的数值。缺失值数据会被分到左子树和右子树分别计算损失，选择较优的那一个。如果训练中没有数据缺失，预测时出现了数据缺失，那么默认被分类到右子树。</p>
<p>根据知乎上<a href="https://www.zhihu.com/question/58230411" target="_blank" rel="external">怎么理解决策树、xgboost能处理缺失值？而有的模型(svm)对缺失值比较敏感呢?</a>问题赞同数最高的回答，有一些经验法则可供参考：</p>
<ol>
<li>树模型对于缺失值的敏感度较低，大部分时候可以在数据有缺失时使用。</li>
<li>涉及到距离度量（distance measurement）时，如计算两个点之间的距离，缺失数据就变得比较重要。因为涉及到“距离”这个概念，那么缺失值处理不当就会导致效果很差，如 K 近邻算法（KNN）和支持向量机（SVM）。</li>
<li>线性模型的代价函数（loss function）往往涉及到距离（distance）的计算，计算预测值和真实值之间的差别，这容易导致对缺失值敏感。</li>
<li>神经网络的鲁棒性强，对于缺失数据不是非常敏感，但一般没有那么多数据可供使用。</li>
<li>贝叶斯模型对于缺失数据也比较稳定，数据量很小的时候首推贝叶斯模型。</li>
</ol>
<p>总结来看，对于有缺失值的数据在经过缺失值处理后：</p>
<ul>
<li>数据量很小，用朴素贝叶斯</li>
<li>数据量适中或者较大，用树模型，优先 xgboost</li>
<li>数据量较大，也可以用神经网络</li>
<li>避免使用距离度量相关的模型，如 KNN 和 SVM</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>亲自参加一次比赛才发觉 Kaggle 是好文明，像我这种菜鸡可以通过高质量的比赛了解到数据分析的很多基本流程和方法，收获的经验远不是书上例题所能比的。而且社区讨论里面个个都是人才，分享的经验技巧又干货满满，我超喜欢里面的。</p>
<p>这篇博文主要整理一开始所用的基本方法，以及通过特征工程实现的改良。下一步我打算试着去用模型集成去进一步提高预测准确率，并且进行总结。</p>
<p><strong>18.03.25 补充：</strong>尝试了模型集成，但是效果没有提升（反而降了），猜想是因为 xgboost 的效果已经足够好。系列的下篇搁置中…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/31743196" target="_blank" rel="external">Kaggle Titanic 生存预测 – 详细流程吐血梳理</a>：推荐阅读第四部分“变量转换”</li>
<li><a href="https://zhuanlan.zhihu.com/p/33733586" target="_blank" rel="external">Kaggle Titanic 生存预测(Top1.4%)完整代码分享</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27550334" target="_blank" rel="external">分分钟，杀入Kaggle TOP 5% 系列（1）</a></li>
<li><a href="https://www.kaggle.com/sinakhorami/titanic-best-working-classifier" target="_blank" rel="external">Titanic best working Classifier | Kaggle</a></li>
</ul>
<p>推荐一下这个 kernel：<a href="https://www.kaggle.com/kanncaa1/data-sciencetutorial-for-beginners/notebook" target="_blank" rel="external">Data ScienceTutorial for Beginners
</a>。包含了包括数据可视化、Python 基本语法、pandas 基本用法等 Kaggle 比赛所需要的基础知识。很全面，而且主要的数据集是精灵宝可梦数据，加分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注册著名的数据科学竞赛平台 Kaggle 四个多月了，当初是为了要一份数据集，而一直没有参加比赛。这个寒假终于按耐不住，决定拿入门级的 Titanic: Machine Learning from Disaster 打响革命第一枪。&lt;/p&gt;
&lt;p&gt;Titanic 生存预测比赛是一个二分类问题。题目提供了一份乘客名单，包含了乘客的名字、性别、年龄、船票等级等信息，以及是否成功获救的标记，最终需要提交一份对测试集中的乘客是否成功获救的 csv 文件。&lt;/p&gt;
&lt;p&gt;经过了四次提交，最后我的 Public Score 暂时定格在 0.80861，这个成绩目前在前 7%。这篇博文主要简述一下我所做的尝试和改进，并对最后一次换用 XGBoost 所得到的最好成绩的代码进行一个详细的说明，也是对相似题目处理流程的一个总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Titanic-public-score.jpg&quot; alt=&quot;Titanic-public-score&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习笔记" scheme="http://kyonhuang.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="特征工程" scheme="http://kyonhuang.top/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Kaggle" scheme="http://kyonhuang.top/tags/Kaggle/"/>
    
      <category term="Titanic 生存预测" scheme="http://kyonhuang.top/tags/Titanic-%E7%94%9F%E5%AD%98%E9%A2%84%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>寒假总结及新学期展望</title>
    <link href="http://kyonhuang.top/2018-new-term/"/>
    <id>http://kyonhuang.top/2018-new-term/</id>
    <published>2018-02-23T03:24:11.000Z</published>
    <updated>2018-03-10T14:47:52.443Z</updated>
    
    <content type="html"><![CDATA[<p>还有几天寒假就结束了。这个寒假没有干太多事，主要是准备美赛，以及继续了解一些机器学习的东西。剩余的时间放松了一下，补了一些不错的电影、日剧、轻小说。在这里把自己的寒假生活总结一下，然后展望一下接下来非常重要的一个学期，确定一个大致的目标，以鼓励自己更高效地学习、生活。</p>
<a id="more"></a>
<h2 id="美赛总结"><a href="#美赛总结" class="headerlink" title="美赛总结"></a>美赛总结</h2><p>这个寒假第一次参加了美国大学生数学建模比赛。虽然赛前也做了一些知识储备，看了很多经验贴，比赛时才发觉完全力不从心。开始时三个人雄心壮志意气风发，做题时无从下手备受煎熬，整天在多个美赛交流群吹水交换段子和表情包，最后变成按时提交就心满意足；尽管如此，我第二晚熬到一点多，第三晚熬到四点，最后一晚只睡了一个半小时，这个痛苦的过程明年也不打算再尝试了，哈哈。</p>
<p>虽然这次美赛的经历不能算成功，但是我也不是特别在意。如果学弟学妹想要参加美赛并且认真考虑争取奖项，我认为最重要的还是团结合作，一鼓作气。美赛是三个人的团队合作，每个人应该各有所长，应该要有对数学建模比较了解并有经验的，要有编程水平较好的，要有英文写作水平较好的。尽管这么说，美赛毕竟是很多建模参赛者的第一站（以及最后一站），还是一个学习的过程，水平不足也不必太过焦虑，只要在赛前半个月确定大致分工，各自抽出时间做知识补强即可。我觉得<strong>比较重要，也是我们团队比较遗憾的一点是</strong>，我们团队没有参加学校的模拟赛，最后也没有在学校一起参加比赛，而是在各自家中网上交流。事实证明，在一起面对面参赛更有助于团队交流和工作，并对团队的积极性有着极大地提高。</p>
<p>至于要了解哪方面的知识，做哪些准备，数学家和数学中国论坛都有很多经验贴，稍微看几篇即可。这次我也了解了很多数学建模的算法，有些和机器学习领域也有共通，也算是宝贵收获之一。另外也算是稍许接触了论文写作。最后希望还是要有个稍微好点的成绩，以告慰熬过的那些夜、死过的那些脑细胞。</p>
<h2 id="读观后感"><a href="#读观后感" class="headerlink" title="读观后感"></a>读观后感</h2><p>美赛完赛后实在是心力交瘁，加上上学期各方面压力还是有一些大，决定给自己放个假，好好放松一下。除开看球赛、追番（今年的一月真的是最强一月，佳作辈出），我还补了一些不错的电影、日剧、轻小说，有一些感想不吐不快。</p>
<ul>
<li><p><strong>日剧《四重奏》</strong>：我查了一下豆瓣的评分，这部剧的口碑非常好，于是一口气补完了。四个蹩脚的音乐爱好者怀揣着各自的故事，生活在同一个屋檐下，相互靠近，相互依偎，拉出一曲酸甜苦辣的四重奏。才能与平庸，兴趣与谋生，爱情与婚姻，关于这些主题的探讨让这部剧非常有意思。感觉用梵高在那封著名的信里写的话来描述我对这部剧的感触再合适不过：“也许在我们的灵魂中有一团烈火，但没有一个人前来取暖。过路人只看见烟囱中冒出的一缕青烟，便接着走自己的路去了。那么，听我说，应该怎么办呢？难道不应该守护着心中的这团火，保持自己的热情，耐心等待着有人前来取暖的时刻吗？”</p>
</li>
<li><p><strong>电影《爱乐之城》</strong>：我极少去电影院，很多电影都是在假期看的。这部盛名在外的《爱乐之城》让我心念已久，最终也确实打动了我。《樱花庄的宠物女孩》小说的最后一卷和这部电影有相似之处，很多读者不能理解空太和真白的冲突到底在哪里、为何分开，其实在生活面前，他人眼中的天才也不过是普通人，没有能力兼顾梦想和爱情，这不是两个人单纯的坚持就能够解决的问题。只不过，樱花庄的故事最终给了一个 HE，而爱乐之城的两个人相忘于江湖。电影最后的一段蒙太奇是点睛之笔，曾经沧海难为水，枕边人是梦中人，我们也曾经有美好的可能。我也很喜欢这部电影的配乐，已经在网易云开始循环了。最后，这部确实适合很适合上映时情侣在电影院一起观看啊，气哭。</p>
</li>
<li><p><strong>轻小说《哥布林杀手》</strong>：这部轻小说刚刚传出动画化的消息，不过一石激起千层浪，小说（其实主要是漫画）的某些情节引起了很多群众的讨论。虽然哥布林杀手这种不好高骛远、沉稳谨慎、一心消灭所有哥布林的反龙傲天式男主角在如今套板式的奇幻类轻小说中十分稀缺，不过比起小说的内容，我更想简单聊一些别的。这部小说是作者跑团的衍生品，很久之前在读《红龙》时我就对跑团有点兴趣了，这次借此机会一鼓作气去了解了跑团、TRPG、D20、龙与地下城。不得不说，游戏也是人类文化史上不可磨灭的一部分，尽管可能没有机会去跑一次团，但我也会继续去了解这些有魅力的另类文化。</p>
</li>
<li><p><strong>剧场版《东离剑游纪之生死一剑》</strong>：当初的《东离剑游纪》我是按时追完一集没落。这次 B 站买下了这部剧场版的版权，上线时间恰好和美赛撞车，比赛一完我就迫不及待的看完了。我只能说，这部剧场版实在是太赞了！看了我博客个人介绍的朋友应该了解到我是虚渊玄老师的铁粉，而作为霹雳布袋戏的忠实迷笛，这次老虚的剧本既具有服务观众的娱乐性，又有与古龙一脉相承的武侠风。而老虚的最大特点也没有落下，那就是在其笔下散发着独特魅力的绝望与悲剧。辅以泽野弘之的配乐、霹雳的精彩制作，这是一部我个人能给出满分的作品！当然，如果要推荐给其他人，我认为首先要能够欣赏布袋戏（当时《东离剑游纪》的 TV 版我看到有些人不太能够接受这一表现形式）；另外，虽然不必补《东离剑游纪》也能享受这部剧场版，但是如果先看完了《东离剑游纪》，那么观看这一部《生死一剑》，尤其是在后一半的剧情会享受到更多的乐趣。最后，这部剧场版的片尾剪辑了一些布袋剧的拍摄记录，看完后我对包括操偶师在内的所有制作人员抱有了更深的敬意，他们的匠心造就了精彩的历部霹雳布袋戏。也希望布袋戏这一传统艺术形式能够借着这股东风有更好的发展，在国际上有更大的影响力。</p>
</li>
</ul>
<h2 id="新学期展望"><a href="#新学期展望" class="headerlink" title="新学期展望"></a>新学期展望</h2><ul>
<li><p><strong>课业</strong>：下学期还有几门必修课，还是必须要拿到满绩。课余时间除了保证运动外要自觉去图书馆，集中精力，提高学习效率。</p>
</li>
<li><p><strong>作息与锻炼</strong>：这个假期过得有些日夜颠倒，生活作息不太健康。加上也没怎么运动，因此身体和精神状态也不太好。新学期一是要保持一个相对规律的生活作息，二是要下决心来制定一个减肥的目标，控制饮食，定期测量。最重要的是积极锻炼，每天保持一定的活动量，球队那边也要跟着训练，争取打上今年的振兴杯。</p>
</li>
<li><p><strong>机器学习</strong>：目前感觉算是一只脚踏入了机器学习的大门了。自己对这个领域还是比较感兴趣的，寒假也抽时间做了一下 Kaggle 的 Titanic 生存预测比赛，这几天写总结性的文章，可惜是没有读太多书。接下来的计划是先把周志华《机器学习》通读一遍，主要是理解各算法，然后努力结合《统计学习方法》把重要的算法推一遍。同时去看 CV、NLP 的东西，主要先是把吴恩达《深度学习》系列课程的最后两门课学完，然后争取参加一次 Kaggle 的相关比赛。之后再确定接下来的学习路径。</p>
</li>
<li><p><strong>算法</strong>：继续每天至少一道 LeetCode，另外根据《算法导论》、《算法竞赛入门经典（第 2 版）》重点复习竞赛常用算法。</p>
</li>
<li><p><strong>专业复习</strong>：每周复习一门重要的专业课（高数、线代、离散、概率论、操作系统、数据结构与算法、数据库、计算机网络），将主要知识点形成可供再次查阅的纸质笔记。</p>
</li>
<li><p><strong>paper</strong>：根据实验室任务和自己的学习进度主动读 paper，要锻炼自己这方面的能力，并做好笔记。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还有几天寒假就结束了。这个寒假没有干太多事，主要是准备美赛，以及继续了解一些机器学习的东西。剩余的时间放松了一下，补了一些不错的电影、日剧、轻小说。在这里把自己的寒假生活总结一下，然后展望一下接下来非常重要的一个学期，确定一个大致的目标，以鼓励自己更高效地学习、生活。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="学习之路" scheme="http://kyonhuang.top/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="观后感" scheme="http://kyonhuang.top/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《C 程序设计语言》读书笔记</title>
    <link href="http://kyonhuang.top/C-programming-language-notes/"/>
    <id>http://kyonhuang.top/C-programming-language-notes/</id>
    <published>2018-02-02T11:25:32.000Z</published>
    <updated>2018-02-08T01:45:30.460Z</updated>
    
    <content type="html"><![CDATA[<p>我所在的专业没有开设 C 语言的课程，而大一虽然有开设 C++，但一是两门语言还是有一些区别，二是也过去了一年，很多东西都差不多忘干净了。这学期的系统级程序设计课程（即著名的“csapp”）和 C 语言密不可分，因此我借来了《C 程序设计语言》来补一补相关知识，并记了一些笔记。最终这门课拿了满绩，还是对得起自己的付出。</p>
<p>我认为《C 程序设计语言》是一本很好的 C 语言入门书籍，简洁清晰。这里的笔记也都是 C 语言最基础的语法。越往深里学，越会感觉 C 语言和计算机系统的相辅相成，博大精深，也越烧脑。但是现在都必须要按需所学了，还是希望有机会能够继续深入挖掘 C 语言的精粹。</p>
<a id="more"></a>
<h2 id="序与引言"><a href="#序与引言" class="headerlink" title="序与引言"></a>序与引言</h2><p>C 语言的 ANSI 标准的目的是制定“一个无歧义性的且<strong>与具体机器无关</strong>的 C 语言定义”。比起之前的标准，ANSI 标准要求对变量进行正确的声明和显式的强制类型转换，并为 C 语言定义了一个函数库。</p>
<p>指针提供了与具体机器无关的地址算术运算。</p>
<p>编译的<strong>预处理阶段</strong>将对程序文本进行<strong>宏替换</strong>、<strong>包含其他源文件</strong>以及进行<strong>条件编译</strong>。</p>
<p>C 语言不提供直接处理诸如字符串、集合、列表或数组等符合对象的操作。所有高层的机制必须由显式调用的函数提供。</p>
<h2 id="第-1-章-导言"><a href="#第-1-章-导言" class="headerlink" title="第 1 章  导言"></a>第 1 章  导言</h2><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> 名字 替换文本</span></div><div class="line"></div><div class="line"><span class="comment">// 如：</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOWER  0</span></div></pre></td></tr></table></figure>
<p><code>#define</code>指令行的末尾没有分号。</p>
<h3 id="参数－传值调用"><a href="#参数－传值调用" class="headerlink" title="参数－传值调用"></a>参数－传值调用</h3><p>在 C 语言中，所有函数参数都是“<strong>通过值</strong>”传递的。也就是说，传递给被调用函数的参数值存放在临时变量中。被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值。</p>
<p>必要时，也可以让函数能够修改主调函数中的变量。这种情况下，调用者需要向被调用函数提供设置值的变量的<strong>地址</strong>（从技术角度看，地址就是指向变量的<strong>指针</strong>），而被调用函数则需要将对应的参数声明为指针类型，并通过它间接访问变量。</p>
<p>当<strong>把数组名作为参数时</strong>，传递给函数的值是<strong>数组起始元素的位置或地址</strong>——它并不复制数组元素本身。在被调用函数中，可以通过数组下标访问或<em>修改</em>数组元素的值。</p>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>当在 C 语言程序中出现类似<code>&quot;hello\n&quot;</code>的字符串常量时，它将以字符数组的形式存储，数组的各元素分别存储字符串的各个字符，并<strong>以<code>\0</code>标志字符串的结束</strong>。因此，存储字符串的物理存储单元数比括在双引号中的字符数多一个。</p>
<h3 id="外部变量与作用域"><a href="#外部变量与作用域" class="headerlink" title="外部变量与作用域"></a>外部变量与作用域</h3><p>函数在使用外部变量之前，必须要知道外部变量的名字。如果在外部变量的作用范围内就无所谓，<strong>而如果在另外一个文件中使用，则需要在函数中使用 extern 类型的声明</strong>。</p>
<p>人们通常把变量和函数的 extern 声明放在一个单独的文件中（习惯上称之为头文件），并在每个源文件的开头使用<code>#include</code>语句将所要用的头文件包含进来。</p>
<p>为了与老版本的 C 语言程序兼容，ANSI C 语言把空参数表看成老版本 C 语言的声明方式，并且对参数表不再进行任何检查。<strong>在 ANSI C 中，如果要声明空参数表，则必须使用关键字 void 进行显式声明</strong>。</p>
<p>请注意分以下两个概念：</p>
<ul>
<li>定义（define）：创建变量或分配存储单元；</li>
<li>声明（declaration）：说明变量的性质，但并不分配存储单元。</li>
</ul>
<h2 id="第-2-章-类型、运算符和表达式"><a href="#第-2-章-类型、运算符和表达式" class="headerlink" title="第 2 章  类型、运算符和表达式"></a>第 2 章  类型、运算符和表达式</h2><h3 id="数据类型及长度"><a href="#数据类型及长度" class="headerlink" title="数据类型及长度"></a>数据类型及长度</h3><p>short 类型通常为 16 位，long 类型通常为 32 位，int 类型可以为 16 位或 32 位。各编译器可以根据硬件特性自主选择合适的类型长度。</p>
<p>类型限定符 signed 与 unsigned 可用于限定 char 类型或任何整型。unsigned 类型的数总是正值或 0，而 signed 类型的数可为负值。例如对于 8 位的 char 对象，则 unsigned char 类型变量的取值范围为 0 ~ 255，而 signed char 类型变量的取值范围 -128 ~ 127（在采用对二的补码的机器上）。不带限定符的 char 类型对象是否带符号取决于具体机器，但可打印字符总是正值。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>无符号整数常量以字母 u 或 U 结尾。后缀 ul 或 UL 表明是 unsigned long 类型。</p>
<p>没有后缀的浮点数常量为 double 类型。后缀 f 或 F 表示 float 类型，而后缀 l 或 L 则表示 long double 类型。</p>
<p>字符常量<code>\0</code>表示值为 0 的字符，也就是空字符（null）。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>对数组而言，const 限定符指定数组所有元素的值都不能被修改。const 限定符也可配合数组参数使用，以表明函数不能修改数组元素的值。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>取模运算符 % 不能应用于 float 或 double 类型。</p>
<h3 id="关系运算符与逻辑运算符"><a href="#关系运算符与逻辑运算符" class="headerlink" title="关系运算符与逻辑运算符"></a>关系运算符与逻辑运算符</h3><p>关系运算符<code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code>的优先级比算术运算符低。</p>
<p>不等于运算符<code>!=</code>的优先级比赋值运算符<code>=</code>的优先级要高。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="字符型转换为整型"><a href="#字符型转换为整型" class="headerlink" title="字符型转换为整型"></a>字符型转换为整型</h4><p>C 语言没有指定 char 类型的变量是无符号变量（unsigned）还是带符号变量（signed）。当把一个 char 类型的值转换为 int 类型的值时，对于不同的机器，其结果有可能为负整数，这反映了不同机器结构之间的区别。</p>
<p>在某些机器中，如果 char 类型值的最左一位为 1，则转换为负整数（进行“符号扩展”）。而在另一些机器中，会在 char 类型值的左边添加 0，这样导致的转换结果值总是正值。</p>
<p>为了保证程序的可移植性，如果要在 char 类型的变量中存储非字符数据，最好指定 signed 或 unsigned 限定符。</p>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>详见附录 A.6</p>
<p>表达式中 float 类型的操作数不会自动转换为 double 类型，这种设计考虑到节省空间和机器执行时间的需要。</p>
<p>在把参数传递给函数时也可能进行类型转换。在没有函数原型的情况下，char 与 short 类型都将被转换为 int 类型，float 类型也将被转换为 double 类型。因此，即使调用函数的参数为 char 或 float 类型，我们也把函数参数声明为 int 或 double 类型。</p>
<h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><p>C 语言提供了 6 个只能作用于整型操作数（带符号或无符号的 char、short、int 与 long 类型）的操作运算符。</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">按位与（AND）</td>
</tr>
<tr>
<td style="text-align:center"><code>｜</code></td>
<td style="text-align:center">按位或（OR）</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">按位异或（XOR）</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">右移</td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center">按位求反（一元运算符）</td>
</tr>
</tbody>
</table>
<p>按位与运算符<code>&amp;</code>常用于屏蔽某些二进制位，例如<code>n = n &amp; 0177</code>将 n 中除 7 个低二进制位外的其他各位均置为 0（注意 0177 是八进制，转换为二进制位 1111111）。</p>
<p>按位或运算符<code>|</code>常用于将某些二进制位置为 1，例如<code>x = x | SET_ON;</code>将 x 中对应于 SET_ON 中为 1 的那些二进制位置为 1。 </p>
<p>在对 unsigned 类型的无符号值进行右移位时，左边空出的部分用 0 填补；当对 signed 类型的带符号值进行右移时，某些机器将对左边空出的部分用符号位填补（即“算术移位”，正负不变），而另一些机器则对左边空出的部分用 0 填补（即“逻辑移位”，取绝对值）。</p>
<p>一元运算符<code>~</code>用于求整数的二进制反码，例如<code>x = x &amp; ~077</code>将把 x 的最后六位设置为 0（注意 077 是八进制，转换为二进制位 111111）。</p>
<h2 id="第-4-章-函数与程序结构"><a href="#第-4-章-函数与程序结构" class="headerlink" title="第 4 章  函数与程序结构"></a>第 4 章  函数与程序结构</h2><h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>由于 C 语言不允许在一个函数中定义其他函数，因此函数本身是“外部的”。外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。</p>
<p>如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性使用关键字 extern。</p>
<p>外部变量的定义中必须指定数组的长度，但 extern 声明则不一定要指定数组的长度。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>用 static 声明限定外部变量与函数，可以<strong>将其后声明的对象的作用域限定为被编译源文件的剩余部分</strong>。</p>
<p>static 也可用于声明内部变量。static 类型的内部变量与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，<strong>static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量</strong>。</p>
<h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p>register 声明只适用于自动变量以及函数的形式参数，它告诉编译器，它所声明的变量在程序中使用频率较高，可以放在寄存器中。然而，编译器可以忽略过量的或不支持的寄存器变量声明，所以每个函数中实际只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。无论寄存器变量实际是不是存放在寄存器中，它的地址都不能访问。</p>
<h3 id="程序块结构"><a href="#程序块结构" class="headerlink" title="程序块结构"></a>程序块结构</h3><p><strong>C 语言有块作用域</strong>。在<code>{</code>和<code>}</code>构成的程序块中，局部变量（块开头声明的变量）可以隐藏程序块外同名的变量。自动变量（包括形式参数）也可以隐藏同名的外部变量与函数。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在不进行显式初始化的情况下，<strong>外部变量和静态变量</strong>都将被初始化为 0，而<strong>自动变量和寄存器变量</strong>的初值则没有定义（即初值为无用的信息）。</p>
<p>对于<strong>外部变量与静态变量</strong>来说，初始化表达式必须是<strong>常量表达式</strong>，且只初始化一次。</p>
<p>对于<strong>自动变量和寄存器变量</strong>来说，初始化表达式可以不是<strong>常量表达式</strong>；表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。</p>
<h3 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h3><p>从概念上讲，预处理器是编译过程中单独执行的第一个步骤。</p>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p><code>#include &quot;文件名&quot;</code>或<code>#include &lt;文件名&gt;</code>的行都被替换为由<em>文件名</em>指定的文件的内容。<code>#include &quot;文件名&quot;</code>在源文件所在位置查找该文件；没有找到或<code>#include &lt;文件名&gt;</code>则根据相应规则查找该文件。</p>
<h4 id="宏替换"><a href="#宏替换" class="headerlink" title="宏替换"></a>宏替换</h4><p>想将一个较长的宏定义分成若干行，需要在持续的行末尾加上一个反斜杠符<code>\</code>。</p>
<p>宏定义也可以带参数，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(A, B)  ((A) &gt; (B) ? (A) : (B))</span></div><div class="line"></div><div class="line"><span class="comment">// 使用语句</span></div><div class="line">x = max(p+q, r+s);</div><div class="line"><span class="comment">// 将被替换为</span></div><div class="line"><span class="comment">// x = ((p+q) &gt; (r+s) ? (p+q) : (r+s));</span></div></pre></td></tr></table></figure>
<p>可以看到，要适当使用圆括号以保证计算次序的正确性。</p>
<p>可以通过<code>#undef</code>指令取消名字的宏定义。</p>
<p>如果在替换文本中，参数名以<code>#</code>作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> dprint(expr) printf(#expr <span class="meta-string">" = %g\n"</span>, expr)</span></div><div class="line"></div><div class="line"><span class="comment">// 使用语句</span></div><div class="line">dprint(x/y);</div><div class="line"><span class="comment">// 该宏将被扩展为</span></div><div class="line"><span class="comment">// dprint("x/y" " = %g\n", x/y)</span></div></pre></td></tr></table></figure>
<p>预处理器运算符<code>##</code>为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与<code>##</code>相邻，则该参数将被实际参数替换，<code>##</code>与前后的空白符将被删除，并对替换后的结果重新扫描。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> paste(front, back) front ## back</span></div></pre></td></tr></table></figure>
<p>因此，宏调用<code>paste(name, 1)</code>的结果将建立记号<code>name1</code>。</p>
<h4 id="条件包含"><a href="#条件包含" class="headerlink" title="条件包含"></a>条件包含</h4><p><code>#if</code>语句对其中的常量整型表达式（其中不能包含<code>sizeof</code>、类型转换运算符或<code>enum</code>常量）进行求值，若该表达式的值不等于 0，则包含其后的各行，直到遇到<code>#endif</code>、<code>#elif</code>或<code>#else</code>语句为止。</p>
<p>在<code>#if</code>语句中可以使用表达式<code>defined(名字)</code>，当名字已经定义时其值为 1，否则为 0。</p>
<p>C 语言专门定义了两个预处理语句<code>#ifdef</code>与<code>#ifndef</code>，它们用来测试某个名字是否已经定义。</p>
<h2 id="第-5-章-函数与程序结构"><a href="#第-5-章-函数与程序结构" class="headerlink" title="第 5 章  函数与程序结构*"></a>第 5 章  函数与程序结构*</h2><p><strong>指针</strong>是一种<strong>保存变量地址</strong>的变量。</p>
<p>ANSI C 使用类型<code>void*</code>（指向<code>void</code>的指针）代替<code>char*</code>作为通用指针的类型。</p>
<h3 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h3><p>指针是能够存放一个地址的一组存储单元（通常是两个或四个字节）。</p>
<p>一元运算符<code>&amp;</code>可用于<strong>取一个对象的地址</strong>。因此，下列语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p = &amp;c;</div></pre></td></tr></table></figure>
<p>将把 c 的地址赋值给变量 p，我们称 p 为“指向” c 的指针。地址运算符<code>&amp;</code>只能应用于<strong>内存</strong>中的对象，即变量和数组元素。它不能作用于表达式、常量或 register 类型的变量。</p>
<p>一元运算符<code>*</code>是<strong>间接寻址</strong>或<strong>间接引用</strong>运算符。<strong>当它作用于指针时，将访问指针所指向的对象</strong>。如果指针 ip 指向整型变量 x，那么在 x 可以出现的任何上下文中都可以使用<code>*ip</code>代替：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> *ip;    <span class="comment">/* ip 是指向 int 类型的指针 */</span></div><div class="line"></div><div class="line">ip = &amp;x;    <span class="comment">/* ip 现在指向 x */</span></div><div class="line">y = *ip;    <span class="comment">/* y 的值现在为 1 */</span></div><div class="line">*ip = <span class="number">0</span>;    <span class="comment">/* x 的值现在为 0 */</span></div><div class="line">ip = &amp;z[<span class="number">0</span>];    <span class="comment">/* ip 现在指向 z[0] */</span></div></pre></td></tr></table></figure>
<p>注意：类似<code>*</code>和<code>++</code>这样的一元运算符遵循<strong>从右至左</strong>的结合顺序。例如，语句<code>(*ip)++</code>中的圆括号是必需的，否则该表达式将对 ip 进行加一运算，而不是对 ip 指向的对象进行加一运算。</p>
<h3 id="指针和函数参数"><a href="#指针和函数参数" class="headerlink" title="指针和函数参数"></a>指针和函数参数</h3><p>C 语言是以<strong>传值</strong>的方式将参数值传递给被调用函数，因此被调用函数不能直接修改主调函数中变量的值。但指针参数使得被调用函数能够访问和修改主调函数中对象的值。</p>
<p>由于一元运算符<code>&amp;</code>用来取变量的地址，这样<code>&amp;a</code>就是一个指向变量 a 的指针。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p><strong>数组名所代表的就是该数组最开始的一个元素的地址</strong>，所以，赋值语句<code>pa = &amp;a[0]</code>也可以写成<code>pa = a</code>。<code>*(pa+1)</code>引用的是数组元素<code>a[1]</code>的内容。<code>&amp;a[i]</code>和<code>a+i</code>的含义也是相同的。</p>
<p>但是，数组名和指针之间有一个不同之处。<strong>指针是一个变量，而数组名不是</strong>。因此，类似于<code>a = pa</code>和<code>a++</code>形式的语句是非法的。</p>
<p>如果将数组名传递给函数，函数可以根据情况判定是按照数组处理还是按照指针处理。</p>
<h3 id="地址算术运算"><a href="#地址算术运算" class="headerlink" title="地址算术运算"></a>地址算术运算</h3><p>C 语言保证，0 永远不是有效的数据地址。因此，若需要返回指针的函数返回 0，则表示发生了异常事件。</p>
<p>指针与整数之间不能相互转换，但 0 是唯一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 进行比较。程序中经常用符号 NULL 代替常量 0，这样便于更清晰地说明常量 0 是指针的一个特殊值。</p>
<p>如果指针 p 和 q 指向同一个数组的成员，那么它们之间就可以进行关系比较运算。同时，这两个指针的减法运算也有意义：若 p &lt; q，那么 q-p+1 就是位于 p 和 q 指向的元素之间的元素的数目。 </p>
<p><strong>有效的指针运算</strong>包括：</p>
<ul>
<li><strong>相同类型</strong>指针之间的赋值运算（两个指针之一是<code>void*</code>类型的情况除外）；</li>
<li>指针同整数之间的加法或减法运算；</li>
<li>指向<strong>相同数组</strong>中元素的两个指针间的减法或比较运算；</li>
<li>将指针赋值为 0 或指针与 0 之间的比较运算。</li>
</ul>
<h3 id="字符指针与函数"><a href="#字符指针与函数" class="headerlink" title="字符指针与函数"></a>字符指针与函数</h3><p>字符串常量是一个字符数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</div></pre></td></tr></table></figure>
<p>当类似于这样的一个字符串出现在程序中时，实际上是通过<strong>字符指针</strong>访问该字符串的。在上述语句中，<code>printf</code>接受的是<strong>一个指向字符数组第一个字符的指针</strong>。也就是说，字符串常量可通过一个指向其第一个元素的指针访问。</p>
<p>语句<code>pmessage = &quot;now is the time&quot;;</code>将把一个指向该字符数组的指针赋值给<code>pmessage</code>。<strong>该过程并没有进行字符串的复制，而只是涉及到指针的操作。</strong>C 语言没有提供将整个字符串作为一个整体进行处理的运算符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> amessage[] = <span class="string">"now is the time"</span>;    <span class="comment">/* 定义一个数组 */</span></div><div class="line"><span class="keyword">char</span> *pmessage = <span class="string">"now is the time"</span>;     <span class="comment">/* 定义一个指针 */</span></div></pre></td></tr></table></figure>
<p>上述声明中，数组中单个字符可以进行修改，但<code>amessage</code>始终指向同一个存储位置；另一方面，<code>pmessage</code>是一个指针，之后可以被修改以指向其他地址，但如果试图修改字符串的内容，结果是没有定义的。</p>
<h3 id="指针数组以及指向指针的指针"><a href="#指针数组以及指向指针的指针" class="headerlink" title="指针数组以及指向指针的指针"></a>指针数组以及指向指针的指针</h3><p>由于<strong>指针本身也是变量</strong>，所以它们也可以像其他变量一样存储在数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *lineptr[MAXLINES]</div></pre></td></tr></table></figure>
<p>表示<code>lineptr</code>是一个<strong>指针数组</strong>。详细地说，它是一个具有 MAXLINES 个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说，<code>lineptr[i]</code>是一个字符指针，而<code>*lineptr[i]</code>是该指针指向的第 i 个文本行的首字母。</p>
<p>每执行一次自增运算，都使得<code>*lineptr</code>指向下一行。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组*"></a>多维数组*</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">daytab[i][j]    <span class="comment">/* [行][列] */</span></div></pre></td></tr></table></figure>
<p>如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须<strong>指明数组的列数</strong>。数组的行数没有太大关系，因为函数调用时传递的是一个指针，它指向由行向量构成的一维数组。因此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(<span class="keyword">int</span> daytab[<span class="number">2</span>][<span class="number">13</span>]) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>也可以写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(<span class="keyword">int</span> daytab[][<span class="number">13</span>]) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>还可以写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(<span class="keyword">int</span> (*daytab)[<span class="number">13</span>]) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这种声明形式表明参数是一个指针，它指向具有 13 个整型元素的一维数组（包裹在外的第二维数组的首地址）。因为<strong>方括号<code>[]</code>的优先级高于<code>*</code>的优先级</strong>，所以上述声明中必须使用圆括号。如果去掉括号，则声明变为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *daytab[<span class="number">13</span>]</div></pre></td></tr></table></figure>
<p>相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。</p>
<p>一般来说，除数组的第一维（下标）可以不指定大小外，其余各维都必须明确指定大小。</p>
<h3 id="指针与多维数组"><a href="#指针与多维数组" class="headerlink" title="指针与多维数组"></a>指针与多维数组</h3><p>假如有下面两个定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">20</span>];</div><div class="line"><span class="keyword">int</span> *b[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<p>从语法角度讲，<code>a[3][4]</code>和<code>b[3][4]</code>都是对一个 int 对象的合法应用。但 a 是一个真正的二维数组，它分配了 200 个 int 类型长度的存储空间；</p>
<p>而对于 b 来说，该定义仅仅分配了 10 个指针，并且没有对它们初始化。假定 b 的每个元素都指向一个具有 20 个元素的数组，那么编译器就要为它分配 200 个 int 类型长度的存储空间以及 10 个指针的存储空间。</p>
<p>指针数组的一个重要优点在于，数组的每一行长度可以不同。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>根据 C 语言的约定，<code>argv[0]</code>的值是启动该程序的程序名，因此<code>argc</code>的值至少为 1。ANSI 标准要求<code>argv[argc]</code>的值必须为一空指针。</p>
<h3 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h3><p>在 C 语言中，函数本身不是变量，但<strong>可以定义指向函数的指针</strong>。</p>
<p>和数组名一样，当一个变量为函数的地址时，前面不需要加上取地址符<code>&amp;</code>；</p>
<p>由于任何类型的指针都可以转换为<code>void *</code>类型，并且在将它转换为原来的类型时不会丢失信息，所以，调用函数时可以将参数强制转换为<code>void*</code>类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*comp)(<span class="keyword">void</span> *, <span class="keyword">void</span> *)</div></pre></td></tr></table></figure>
<p>表明<code>comp</code>是一个<strong>指向函数的指针</strong>，该函数具有两个<code>void*</code>类型的参数，其返回值类型为<code>int</code>。<code>*comp</code>代表一个函数。</p>
<h3 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h3><p>C 语言的复杂声明容易让人混淆，因为 C 语言的声明不能从左至右阅读，并且使用了太多的圆括号。例如下面两个声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* f: 是一个函数，它返回一个指向 int 类型的指针 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* pf: 是一个指向函数的指针，该函数返回一个 int 类型的对象 */</span></div><div class="line"><span class="keyword">int</span> (*pf)();</div></pre></td></tr></table></figure>
<p>他们之间的含义差别说明：<code>*</code>是一个前缀运算符，其优先级低于<code>()</code>。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>ANSI 标准在结构方面最主要的变化是定义了结构的赋值操作–结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值。</p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>关键字 struct 引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字 struct 后面的名字是可选的，称为<strong>结构标记</strong>。结构标记用于为结构命名，在定义后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。</p>
<p>结构中定义的变量称为<strong>成员</strong>。<strong>结构成员、结构标记和普通变量（即非成员）可以采用相同的名字</strong>，因为通过上下文分析总可以对它们进行区分，因此不会冲突。另外，不同结构中的成员可以使用相同的名字。</p>
<p>struct 声明定义了一种数据类型。在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其他基本类型的变量声明是相同的。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> ... &#125; x, y, z;</div></pre></td></tr></table></figure>
<p>如果结构声明的后面<strong>不带变量表</strong>，则<strong>不需要为它分配存储空间</strong>，它仅仅描述了一个结构的模版或轮廓。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可使用该标记定义，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span>;</span></div></pre></td></tr></table></figure>
<p>结构的<strong>初始化</strong>可以在定义的后面使用初值表进行，初值表中同每个成员对应的初值必须是常量表达式，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">maxpt</span> = &#123;</span> <span class="number">320</span>, <span class="number">200</span> &#125;;</div></pre></td></tr></table></figure>
<p>自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构的函数进行初始化。</p>
<h3 id="结构和函数"><a href="#结构和函数" class="headerlink" title="结构和函数"></a>结构和函数</h3><p>如果传递给函数的结构很大，使用<strong>指针</strong>方式的效率通常比复制整个结构的效率要高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">origin</span>, *<span class="title">pp</span>;</span></div><div class="line"></div><div class="line">pp = &amp;origin;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"origin is (%d,%d)\n"</span>, (*pp).x, (*pp).y);</div></pre></td></tr></table></figure>
<p>其中，<code>(*pp).x</code>中的圆括号是必须的，因为结构成员运算符<code>.</code>的优先级高于<code>*</code>的优先级。</p>
<p>鉴于结构指针的使用频率非常高，为了使用方便，C 语言对于使用指向结构的指针 p 引用相应结构成员提供另一种简写方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p-&gt;结构成员</div></pre></td></tr></table></figure>
<h3 id="类型定义（typedef）"><a href="#类型定义（typedef）" class="headerlink" title="类型定义（typedef）"></a>类型定义（typedef）</h3><p>typedef 声明并没有创建一个新类型，只是为某个已存在的类型增加了一个新的名称而已。实际上，typedef 类似于 #define 语句，但由于 typedef 是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。</p>
<p>除了使表达方式更简洁之外，使用 typedef 还有两个重要原因：</p>
<ol>
<li>使程序参数化，以提高程序的可移植性；</li>
<li>为程序提供更好的说明。</li>
</ol>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p><strong>联合</strong>是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。联合提供了一种方式，以在单块存储区中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息。</p>
<p>联合的目的：一个变量可以合法地保存多种数据类型中任何一种类型的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> u_tag &#123;</div><div class="line">    <span class="keyword">int</span> ival;</div><div class="line">    <span class="keyword">float</span> fval;</div><div class="line">    <span class="keyword">char</span> *sval;</div><div class="line">&#125; u;</div></pre></td></tr></table></figure>
<p>变量 u 必须足够大，以保存这 3 种类型中最大的一种，具体长度同具体的实现有关。</p>
<p>实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都为 0，此结构空间要大到足够容纳最“宽”的成员，并且，其对齐方式要适合于联合中所有类型的成员。对联合允许的操作与对结构允许的操作相同。</p>
<p>联合只能用其第一个成员类型的值进行初始化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我所在的专业没有开设 C 语言的课程，而大一虽然有开设 C++，但一是两门语言还是有一些区别，二是也过去了一年，很多东西都差不多忘干净了。这学期的系统级程序设计课程（即著名的“csapp”）和 C 语言密不可分，因此我借来了《C 程序设计语言》来补一补相关知识，并记了一些笔记。最终这门课拿了满绩，还是对得起自己的付出。&lt;/p&gt;
&lt;p&gt;我认为《C 程序设计语言》是一本很好的 C 语言入门书籍，简洁清晰。这里的笔记也都是 C 语言最基础的语法。越往深里学，越会感觉 C 语言和计算机系统的相辅相成，博大精深，也越烧脑。但是现在都必须要按需所学了，还是希望有机会能够继续深入挖掘 C 语言的精粹。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://kyonhuang.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C 语言" scheme="http://kyonhuang.top/tags/C-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>吴恩达《深度学习》系列课程个人笔记</title>
    <link href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/"/>
    <id>http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/</id>
    <published>2018-01-14T08:50:29.000Z</published>
    <updated>2018-01-14T09:04:57.754Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Andrew-Ng-Deep-Learning-notes.png" alt="Andrew-Ng-Deep-Learning-notes"></p>
<p>早在吴恩达（deeplearning.ai）的《深度学习》系列课程在网易云课堂刚刚发布时，它就已经躺在我的计划列表中了。当时还没有特别坚定说要深入学习这方面的知识，因此搁置了一段时间。这几个月终于下定决心，排除万难，开始对这个系列的课程进行学习。</p>
<p>这个系列的课程给我的感觉是，对 DL 新人，以及像我这样数学不是非常好的学习者非常友好。吴恩达老师真正做到了深入浅出，但又没有抛弃那些重要的细节。在我一边看视频，一边想看看花书对应章节时，发现晦涩到根本看不动。而这个系列的课程作为入门启蒙，是再合适不过的。</p>
<p>另外，这个系列课程的作业全都是精心设计过的，虽然难度不大，但对巩固视频所学知识、帮助理解细节非常有帮助。如果只是听课而不独立完成作业，我认为和没有学过没有什么区别。我也打算过一段时间再重新将这些作业再写一遍。</p>
<p>在学习的同时，像网上很多同学一样，我也记录了自己的笔记，并将其发布在 Github 上。因为在 Github 上，在 md 文件中用 LaTex 写的公式不能正常显示，之前都是用 MacDown 由 md 文件生成 html，虽然公式可以看了，但是不太美观。之后，我恰好发现了 docsify ，一个可以由 md 文件动态生成文档网站的库。于是折腾了一会，将自己的笔记全部用它生成，最终效果如题图所示，非常美观（虽然折腾的途中也踩了几个小坑）。</p>
<p>因为在学习的过程中，我也看了很多网上的笔记。它们对我起到了很大的帮助，因此我也想将我的笔记分享出来，也许能够帮助到其他的同学。两周前在学完前两门课时，我在知乎的专栏发了一篇<a href="https://zhuanlan.zhihu.com/p/32527718" target="_blank" rel="external">文章</a>（即这篇博文的前身）。到目前为止，知乎的文章收获了 147 个赞，而 Github 上的 repo 得到了 42 个 star。这对我简直是受宠若惊。因此，即使这两周是考试周，我还是抽出时间学完了第三门课，并更新了笔记。一方面，这个系列课程的内容确实非常吸引我，另一方面，也是很多同道中人的认可对我有着很大的鼓励。</p>
<p>第四门课是有关计算机视觉和卷积神经网络的。我们知道近年来深度学习的爆红很大程度上是缘于 2012 年 ImageNet 图像识别比赛中 Hinton 课题组构建的 CNN 网络 AlexNet 有着碾压级的表现，因此我对这门课也是非常期待，希望能够在寒假结束前完成对这门课的学习。</p>
<p>最后，再次将笔记的 Github 的 repo 地址公布如下：</p>
<ul>
<li>笔记：<a href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/">吴恩达《深度学习》系列课程笔记</a></li>
<li>Github 仓库（包含写完的作业）：<a href="https://github.com/bighuang624/Andrew-Ng-Deep-Learning-notes" target="_blank" rel="external">bighuang624/Andrew-Ng-Deep-Learning-notes</a></li>
</ul>
<p>欢迎查阅，欢迎在 Issues 中交流或提出意见，更欢迎 star 一下以兹鼓励！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Andrew-Ng-Deep-Learning-notes.png&quot; alt=&quot;Andrew-Ng-Deep-Learning-notes&quot;&gt;&lt;/p&gt;
&lt;p&gt;早在吴恩达（deeplearning.ai）的《深度学习》系列课程在网易云课堂刚
    
    </summary>
    
      <category term="深度学习笔记" scheme="http://kyonhuang.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="http://kyonhuang.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="吴恩达" scheme="http://kyonhuang.top/tags/%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>用浏览器也能挖矿！把力量借给我吧</title>
    <link href="http://kyonhuang.top/miner-for-my-website/"/>
    <id>http://kyonhuang.top/miner-for-my-website/</id>
    <published>2018-01-12T08:46:36.000Z</published>
    <updated>2018-02-05T02:03:31.326Z</updated>
    
    <content type="html"><![CDATA[<p>18.02.05 更新：<strong>挖矿现已停止，一是因为用部分浏览器访问本博客时会因为挖矿被拦截，二是避免对各位读者的电脑造成损伤。因此，下述文字仅是对这次尝试的一个小介绍。</strong></p>
<hr>
<p>昨天读到了余博伦老师的<a href="https://zhuanlan.zhihu.com/p/32853925" target="_blank" rel="external">前端开发者转行挖矿的特别技巧</a>一文，觉得很有意思，于是在 <a href="https://coinhive.com/" target="_blank" rel="external">Coinhive</a> 上折腾了几个小时。通过加了几行 JavaScript 代码，尝试在本博客开启挖门罗币的功能。这意味着，当你阅读本博客的同时，你电脑的 CPU 在帮我做一些计算。我把浏览器挖矿的线程调整有 70% 的空闲时间（即速度只有满速的 30%），因此一般来说对你的电脑运行不会有什么大的影响。而使用手机浏览本博客不会启动挖矿，避免因性能较差而导致手机发热。</p>
<p>其实，由于本博客目前的日均 PV 只有 10 左右，因此实际上在限速后基本挖不了多少。但是这是一次非常有趣的尝试，而且，因为暂时没找到申请 Google 账号以开启 Google Analysis 的方法，我也通过把 Coinhive Dashboard 当作一个更好的访问数据统计，间接了解本博客活跃时段。</p>
<p><img src="/images/miner/Coinhive-Dashboard-Analysis.png" alt="Coinhive-Dashboard-Analysis"></p>
<p>通过这种方式，<strong>阅读本博客进行阅读、学习的行为本身，成为一种对博主的赞赏与激励</strong>，我认为这是一种很有趣的互惠形式的探索。尽管实质上的经济影响极小，但是<strong>你的帮助会鼓励我更勤奋地写高质量的博客</strong>，也为我接触了解现在炙手可热的加密货币提供了途径和动力。</p>
<p><strong>你可以拉到页面最下方查看挖矿的速度和总量</strong>。如果你想对浏览器挖矿有个更直观的感受的话，你可以通过下面这个最简单的实例来查看每秒钟计算出的 hash 数等数据，还可以调整参数以了解其对挖矿速度的影响。</p>
<p><script src="https://authedmine.com/lib/simple-ui.min.js" async></script></p>
<div class="coinhive-miner" style="width: 256px; height: 200px; margin: auto" data-key="QbgpjAPTac4TDxpWZto4zId8XNCiISZo"><br>    <em>Loading…</em><br></div>

<p>而如果你想要了解更多有关门罗币、Coinhive、浏览器挖矿的事情，推荐你阅读文章开头提到的那篇文章，即使不是前端开发者也可以轻松阅读。</p>
<p>最后提一下我对加密货币目前火热的市场的个人观点。对绝大多数普通人（或者说，散户）来说，现在才开始炒币是不会赚的，而且大概率成为韭菜。加密货币的匿名性、无政府监管性使得它有更大的可操作空间。就算侥幸小赚，也很难弥补你付出的时间、精力和焦虑。因此学习可以，发家致富的想法还是尽早掐灭为好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;18.02.05 更新：&lt;strong&gt;挖矿现已停止，一是因为用部分浏览器访问本博客时会因为挖矿被拦截，二是避免对各位读者的电脑造成损伤。因此，下述文字仅是对这次尝试的一个小介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;昨天读到了余博伦老师的&lt;a href=&quot;https
    
    </summary>
    
      <category term="程序猿喜欢折腾" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%96%9C%E6%AC%A2%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="挖矿" scheme="http://kyonhuang.top/tags/%E6%8C%96%E7%9F%BF/"/>
    
      <category term="门罗币" scheme="http://kyonhuang.top/tags/%E9%97%A8%E7%BD%97%E5%B8%81/"/>
    
      <category term="Coinhive" scheme="http://kyonhuang.top/tags/Coinhive/"/>
    
  </entry>
  
  <entry>
    <title>算法一篇通——贪心算法</title>
    <link href="http://kyonhuang.top/Greedy-algorithm/"/>
    <id>http://kyonhuang.top/Greedy-algorithm/</id>
    <published>2017-12-29T13:24:35.000Z</published>
    <updated>2017-12-30T08:47:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在写<a href="http://kyonhuang.top/Dynamic-programming/">算法一篇通——动态规划</a>时，看到不少相关的资料都谈到了贪心算法。原本我对贪心算法的认知比较简单，但是越看越混，尤其是和动态规划的差异，少有文章能说的准确透彻。因此，这几天也对贪心算法加以了解学习。</p>
<p>给出 n 个物体，第 i 个物体重量为 wi，要求选择尽量多的物体，使得总重量不超过 C。对于这个问题，我们很容易想到，因为在对总重量有要求的情况下要选择尽量多的物体，因此挑轻的肯定比挑重的划算。这样，我们将所有物体按重量从小到大排序，依次选择每个物体，直到装不下为止。</p>
<p>这就一种典型的贪心算法，只顾眼前利益，做出局部最优的选择，寄希望于这样的选择能导致全局最优解。</p>
<a id="more"></a>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p><strong>贪心算法（Greedy Algorithm，又称贪婪算法）</strong>，指在对问题求解时，不从整体最优上加以考虑，而总是做出在当前看来是最好的选择。也就是说，所做出的是在某种意义上的<strong>局部最优解</strong>。</p>
<p>贪心算法<strong>不是对所有问题都能得到整体最优解</strong>，关键是贪心策略的选择，选择的贪心策略必须具备<strong>无后效性</strong>，即某个状态只与它前面出现的状态有关，而独立于后面的状态。</p>
<p>贪心算法的两个性质是<strong>贪心选择性质</strong>和<strong>最优子结构性质</strong>：</p>
<ul>
<li><p><strong>贪心选择性质</strong>：指所求的问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。</p>
</li>
<li><p><strong>最优子结构（optimal substructure）性质</strong>：如果<strong>原问题的最优解包含的子问题的最优解</strong>，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“<strong>全局最优解包含局部最优解</strong>”的思想。</p>
</li>
</ul>
<h2 id="贪心算法与动态规划的区别"><a href="#贪心算法与动态规划的区别" class="headerlink" title="贪心算法与动态规划的区别"></a>贪心算法与动态规划的区别</h2><ol>
<li>贪心算法的每一次操作都<strong>对结果产生直接影响</strong>，而动态规划则不是。</li>
<li>贪心算法对每个子问题的解决方案都做出选择，<strong>不能回退</strong>；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li>
<li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li>
</ol>
<p>实际上，贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算。</p>
<p>尽管贪心算法和动态规划都有最优子结构性质，我认为这个性质在两种算法中有着不太一样的含义：贪心的局部最优能达成全局最优，而动态规划的全局最优值中不一定全是局部最优，只是求解全局最优时要以局部最优作为基础。或者，我们可以认为，贪心算法通常都是自顶向下进行设计的，而动态规划则自顶向上。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，<strong>选取应该满足局部优化的条件</strong>。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/images/brush-is-the-best.png"></p>
<h3 id="菜鸟级"><a href="#菜鸟级" class="headerlink" title="菜鸟级"></a>菜鸟级</h3><p>这里我选了 LeetCode 的第 122 题 Best Time to Buy and Sell Stock II。题目是这样的：给定一个数组，第 i 个元素代表第 i 天石头的买卖价。找到一种赚取最大利润的方法，你可以进行任意次交易，但是不能同时处于两笔交易中（即必须先将手上的石头卖出去才能再买）。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>根据贪心选择的性质，只要能赚到钱，我们就卖掉手上的石头。那么，只要后一天的价格比前一天高，我们就做买入卖出这一笔买卖。于是有代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)</div><div class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>] &gt; prices[i]) </div><div class="line">            total += prices[i+<span class="number">1</span>]-prices[i];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的思路是简单粗暴而有效的，但是可能需要结合多种情况考虑一下，为什么这样做是对的（我们设第 i 天的价格为 s[i]）：</p>
<ul>
<li>s[i] &lt; s[i+1] &lt; s[i+2]：这样的话，按照之前的解法，相当于省略掉中间那一笔卖出买入，只考虑第 i 天和第 i+2 天；</li>
<li>s[i] &gt; s[i+1] &lt; s[i+2]：这样的话，我们的算法会当作没有买入过第 i 天的石头。</li>
</ul>
<h3 id="普通级"><a href="#普通级" class="headerlink" title="普通级"></a>普通级</h3><h3 id="挑战者级"><a href="#挑战者级" class="headerlink" title="挑战者级"></a>挑战者级</h3><p>这里我选择的是 LeetCode 的第 135 题，是一道 hard 难度的题目。N 个小朋友排排坐，每个小朋友有一个分值。你需要给小朋友发糖，遵循以下规则：</p>
<ul>
<li>每个小朋友保底一块糖；</li>
<li>若比左右邻居得分高，则得到的糖更多。</li>
</ul>
<p>求最少发多少糖。</p>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><p>需要拿一个与输入数组同样大小的数组来存储每个孩子的糖果树。</p>
<p>先从 0 开始向右遍历一次：第 0 个孩子先拿一块；i &gt; 0 时，如果 ratings[i] &gt; ratings[i-1]，那么第 i 个孩子在第 i-1 个孩子所拥有的糖果数上多拿一块，否则拿保底的一块。这一次遍历将右边的 rating 比左边大的情况全部搞定。</p>
<p>再从 len-1 开始向左遍历一次：第 len-1 个孩子不变，如果 ratings[i] &lt; ratings[i-1]，那么，除非第 i-1 个孩子本身拥有的糖果数已经比多拿这一块后还要多，否则第 i－1 个孩子在第 i 个孩子所拥有的糖果数上多拿一块。这一次遍历将左边的 rating 比右边大的情况全部搞定，并且不会影响到上一次遍历所完成的工作。</p>
<p>因为每一次发糖都遵循贪心选择性质，最多多给一块，并且没有后效性，因此也是贪心算法的运用。</p>
<p>尽管时间复杂度和空间复杂度都不是最优的，但上述解法能够 AC，并且简洁易懂。当然，这个思路还是比较巧妙的，也很难短时间内想出来。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>和动态规划一样，贪心算法也扩展许多衍生的问题与算法。例如，深度学习中的梯度下降算法就是贪心的。更著名的一些如下。</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>我们可以用 01 编码串来代表一个字符，例如 a 为 0，c 为 00，f 为 1100。这样，可能因为其中一个字符的编码是另一个字符的前缀而导致歧义。满足<strong>任何一个编码都不是另一个的前缀的编码</strong>被称为<strong>前缀码（Prefix Code）</strong>。</p>
<p>这样，我们很容易想到，给定 n 个字符在文件中的出现频率 ci，求一套总长度（每个字符的频率与编码长度乘积的总和）尽量小的编码。根据一个已知结论：<strong>任何一个前缀编码都可以表示成每个非叶结点恰好有两个子结点的二叉树</strong>，我们可以通过构造一棵最优的编码树来解决这个问题。</p>
<p><strong>Huffman 算法</strong>：把每个字符看作一个单结点子树放在一个树集合中，每棵子树的权值等于对应字符的频率。每次取权值最小的两棵子树合并成一棵新树，并重新放到集合中。新树的权值等于两棵子树权值之和。</p>
<p>从以下结论可以体现 Huffman 算法是一种贪心算法：</p>
<ul>
<li>设 x 与 y 是频率最小的两个字符，则存在前缀码使得 x 和 y 具有相同码长，且仅有最后一位编码不同。这体现了贪心算法的<strong>贪心选择性质</strong>。</li>
<li>设 T 是加权字符集 C 的最优编码树，x 和 y 是树 T 中的两个叶子，且互为兄弟结点，z 是它们的父结点。若把 z 看作具有频率 f(z) = f(x) + f(y) 的字符，则树 T’ = T - {x, y} 是字符集 C’ = C - {x, y}U{z} 的一棵最优编码树。这体现了贪心算法的<strong>最优子结构性质</strong>。</li>
</ul>
<h3 id="Prim-算法-和-Kruskal-算法"><a href="#Prim-算法-和-Kruskal-算法" class="headerlink" title="Prim 算法 和 Kruskal 算法"></a>Prim 算法 和 Kruskal 算法</h3><p>Prim 算法 和 Kruskal 算法都是在加权无向图找到最小生成树的算法，它们也都是贪心算法。</p>
<p><strong>Prim 算法</strong>：每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加 V-1 条边，每次总是将下一条<strong>连接树中的顶点与不在树中的顶点且权重最小的边加入树中</strong>。</p>
<p><strong>Kruskal 算法</strong>：按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，<strong>加入的边不会与已经加入的边构成环</strong>，直到树中含有 V-1 条边为止。我们从一片由 V 棵单顶点的树构成的森林开始并不断将两颗树合并（用可以找到的最短边），直到只剩下一棵树，它就是最小生成树。</p>
<p>如果你想要更详细地了解这部分内容，可以查看我《算法》笔记的相关章节：<a href="https://github.com/bighuang624/Algorithms-notes/blob/master/%E7%AC%94%E8%AE%B0/4.3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.md" target="_blank" rel="external">Algorithms-notes/笔记/4.3 最小生成树
</a>。</p>
<h3 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h3><p>很多的<strong>启发式算法</strong>（也叫智能算法），例如遗传算法，模拟退火算法，本质上就是<strong>贪心算法和随机化算法结合</strong>。这样的算法结果虽然也是局部最优解，但是比单纯的贪心算法更佳靠近最优解。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>随着第二篇算法学习的总结笔记出炉，我发现除开大二上学期《算法与数据结构》课程提到的基础而有限的算法之外，还有很多算法处于我的认知边缘之外。我准备把对这些算法的学习全部汇总到一个系列，取名为“算法一篇通”，希望写作效果能够恰如其名。</p>
<p>贪心算法也不简单。之后我可能还会再做一些这个方面的题，届时再进行补充。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作参考"><a href="#写作参考" class="headerlink" title="写作参考"></a>写作参考</h3><ul>
<li><a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800?fr=aladdin" target="_blank" rel="external">贪心算法_百度百科</a></li>
<li>《算法竞赛入门经典（第 2 版）》第 8 章</li>
<li>《算法导论》第 16 章</li>
</ul>
<h3 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h3><ul>
<li><a href="http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html" target="_blank" rel="external">大白话解析模拟退火算法 - 苍梧 - 博客园</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在写&lt;a href=&quot;http://kyonhuang.top/Dynamic-programming/&quot;&gt;算法一篇通——动态规划&lt;/a&gt;时，看到不少相关的资料都谈到了贪心算法。原本我对贪心算法的认知比较简单，但是越看越混，尤其是和动态规划的差异，少有文章能说的准确透彻。因此，这几天也对贪心算法加以了解学习。&lt;/p&gt;
&lt;p&gt;给出 n 个物体，第 i 个物体重量为 wi，要求选择尽量多的物体，使得总重量不超过 C。对于这个问题，我们很容易想到，因为在对总重量有要求的情况下要选择尽量多的物体，因此挑轻的肯定比挑重的划算。这样，我们将所有物体按重量从小到大排序，依次选择每个物体，直到装不下为止。&lt;/p&gt;
&lt;p&gt;这就一种典型的贪心算法，只顾眼前利益，做出局部最优的选择，寄希望于这样的选择能导致全局最优解。&lt;/p&gt;
    
    </summary>
    
      <category term="算法笔记" scheme="http://kyonhuang.top/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://kyonhuang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心算法" scheme="http://kyonhuang.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Goodbye 2017, hello 2018</title>
    <link href="http://kyonhuang.top/bye2017hello2018/"/>
    <id>http://kyonhuang.top/bye2017hello2018/</id>
    <published>2017-12-22T10:24:53.000Z</published>
    <updated>2017-12-25T03:27:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2017 年过去了，我很怀念它。</p>
</blockquote>
<p>时间匆匆，转眼又到了一年的结尾。现在我坐在图书馆里，周围很多考研的学长学姐明天就要奔赴考场，其中也包括院队的几个老大哥。明年的这时我在哪里？在做什么？没有答案。</p>
<p>这个博客的第一篇文章在去年的 12 月 4 号写下，迄今也有一年有余了。看了看去年的总结和展望，大部分的计划都实现了，大概是因为写的比较保守的缘故。而“早睡早起”、“尽量不翘课”、“在自己真正的兴趣上利用时间”、“每天过得健康、充实、开心”这几点没有做到，尤其是最后一点。</p>
<p>2017 年，尤其是下半年，我时常想要遵从兴趣、学习技术、保持自信、做到更好，但又日复一日地跟懒惰、压力、无所适从、自我怀疑、对未知的未来的恐惧作着斗争。20 岁的路口有了更多的分岔，很多以前从来没有想过的东西不停地折磨着我，而我又不是那种十分豁达开朗的性格，只能尽力不在这些负面情绪中沉沦。也许在新的一年里斗争还会继续下去，我希望最终乐观战胜忧郁，我战胜过去的自己。</p>
<p>总之，无论是论取得的各种成果，还是既有价值观的动荡，2017 年于我个人都是重要的一年。让所有的改变在 2018 年来得更猛烈一些吧，我喜欢这种改变。</p>
<a id="more"></a>
<h2 id="2017-年终总结"><a href="#2017-年终总结" class="headerlink" title="2017 年终总结"></a>2017 年终总结</h2><h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p>到落笔为止，值得一提的成果有：</p>
<ul>
<li>2017 年更新了博客 45 篇，总访问量达到 2400 余次（估计有一半是自己贡献的，哈哈）。</li>
<li>Github 有 599 次 contributions，9 个 star。</li>
<li>LeetCode 做了 106 道题，还在每日增加中。</li>
<li>砍下了花旗杯的三等奖，这是我第一个含金量比较高的奖，还是很有纪念意义的。</li>
<li>必修绩点保持在 3.52，不算高，但是应该可以保研。</li>
</ul>
<p>课余学习的技术：</p>
<ul>
<li>大二下学期自己学习前端，主要是玩 Vue 框架以及相关生态环境；</li>
<li>暑假在花旗杯项目开发的空余时间稍微学了一些 Node.js；</li>
<li>大三上学期在朱老师这里，初步地学了一些机器学习和 Spark 的东西，并有了包括读论文在内的学术研究的意识。</li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>我的一些观念和思想在这一年有了很大的变化，其中一些我觉得比较通用的，在这里和大家分享：</p>
<ul>
<li><p><strong>敏捷学习</strong>：在软件工程领域，有些知识是需要稳扎稳打的：数据结构与算法、Unix、数据库、计算机组织与体系结构、操作系统、计算机网络…但是，在实际开发中，也有很多东西需要快速上手，读一遍官方文档就可以慢慢地开始使用，在实践中加深理解。“工程师的工作大部分就是造轮子与用轮子，而工具的逐渐标准化使得重复造轮子的需求越来越弱，越来越多的工程师核心任务并不是研发，而是整合。”要善于利用各类工具，快速地实现自己的想法。尤其对于轮子满天飞的前端来说，快速地使用各类工具是必备的技能。很多工具可能只用一次，但对于更多比较常用的工具，需要记录自己的使用经验，方便自己下一次迅速上手。这也是为什么要写博客的原因之一。敏捷学习不代表用完就忘，也是要形成自己的知识体系的，我在这方面还有欠缺。</p>
</li>
<li><p><strong>敢于实践</strong>：紧接上一条。相信在学习的过程中，我们都会产生很多有意思的想法。对于我个人来言，很多想法都因为不愿投入时间和精力、担心半途而废，或是直接被难度给吓倒而成为空想，相关技术也失去了学习和实践的机会，目前只有 <a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a> 算是写出来了。但是看到别人很多有意思的东西，又非常眼馋。这个月我创了一个 repo 作为专门记录这些想法的<a href="https://github.com/bighuang624/ideas" target="_blank" rel="external">想法库</a>，以提醒自己，希望一步一步地去实现它们。</p>
</li>
<li><p><strong>社交</strong>：真正熟悉我的人，应该会知道我是一个大多数时候都喜欢独处的人，性格偏内向，不爱和陌生人打交道。通过这一年的很多经历和体验，我开始发觉社交的重要性。例如，当你想要找一些有技术特长、有时间的队友参加比赛，当你需要了解某方面的消息，当你需要获取一些资源和机会，等等。在新的一年里，我想要鼓励自己去开展更广泛的社交。当然，我还是比较偏爱有效交流以及不受他人打扰的独处时光。这需要一定的功力去保持平衡。</p>
</li>
<li><p><strong>个人品牌（个人影响力）</strong>：这一年开始通过 Github、知乎、掘金、微博、个人博客、微信公众号等途径了解一些大牛。他们在分享自身的技术心得、工作经验、生活体验的同时，也在打造自己的个人品牌，辐射自己的个人影响力。良好的个人品牌使得他们拥有更多机会结识同样优秀的业内外人士、在寻找新工作时能收获更多橄榄枝、更方便与人展开交流等优势。从博客和 Github 开始，我试着也去慢慢打造这样一张隐形的名片，也是社交的一种，并锻炼着我包括写作在内的各种能力。想要打造好这张名片，也需要更多技术历练和人生阅历。</p>
</li>
<li><p><strong>财务自由、投资理财</strong>：我一直是一个不太重视财务的人，因为我平时除了生活必需外基本不花钱，或者说，比较抠。随着愈发地喜欢这个行业，我也会发现很多时候，你的贫穷确实限制了你的想象力。比如我现在都不舍得掏钱买服务器，更别说买一些有意思的东西或者换电脑了。我希望自己开始培养投资理财的思维，慢慢实现财务自由，至少能够有一些收入来让自己的生活更舒服。</p>
</li>
<li><p><strong>程序员的第二技能（收入）</strong>：和上一条有关。这两天中兴技术主管跳楼的事也是沸沸扬扬，都说程序员吃青春饭，被认为是中年危机最严重的一个群体。我认为<a href="https://zhuanlan.zhihu.com/p/32147842" target="_blank" rel="external">程序员如何保护自己？</a>这篇文章中有一个观点很棒：程序员一定要根据个人兴趣爱好选择第二技能并加以培养，使其成为特殊时期能够支撑自己的存在。第二技能也有助于树立之前说到的个人品牌。</p>
</li>
</ul>
<h2 id="2018-未来展望"><a href="#2018-未来展望" class="headerlink" title="2018 未来展望"></a>2018 未来展望</h2><ul>
<li><p><strong>各领域知识的查漏补缺</strong>：数据结构与算法、Unix、数据库、计算机组织与体系结构、操作系统、计算机网络等等。因为要找实习和夏令营，这大概会是 2018 上半年的主旋律。</p>
</li>
<li><p><strong>前端 / ML 学习</strong>：把这两个主攻方向单独拎出来。机器学习就跟着自己的节奏保持学习进度即可，当然也要重视实践。前端方面跟身边人聊了一下，可能考虑要暂时放一下了，以科研方面的学习为主。</p>
</li>
<li><p><strong>博客</strong>：继续保持高质量、较频繁的更新，将自己觉得不错的文章向知乎和掘金转移。其中，一些以前的、比较乱的读书笔记可能会根据知识点进行编排重整。另外，试着做一下 SEO，关注一下各类数据。</p>
</li>
<li><p><strong>学术研究</strong>：慢慢培养看论文的习惯。按照标准认真读，做一些简短的笔记。和朱老师经常交流一下，争取一些项目、论文的机会。</p>
</li>
<li><p><strong>社交</strong>：可以在在其他社区适当推广自己 Github 上的项目以及博客的文章，和他人保持友好的互动交流。</p>
</li>
<li><p><strong>比赛</strong>：到暑假为止可能还要参加一到两个比赛。做好准备工作，到时全身心投入，不后悔即可。</p>
</li>
<li><p><strong>实习</strong>：希望能找到行业领先的、氛围良好的、自成文化的公司，去体验，去学习。顺其自然吧。</p>
</li>
<li><p><strong>保研</strong>：尽力去追求更好的、更适合自己的。</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>新的一年，博客继续努力更新，欢迎保持关注，经常来逛逛（如果你使用 RSS，也是极好的）。另外，你可以在博客的左边栏中的“站点梗概”找到我的 <strong>Github 和知乎账号</strong>，在这里我会经常点赞、分享我看到的有价值的 repo 和文章。<strong>关注</strong>它们可以更详细地了解我最近在学什么、做什么、玩什么，也欢迎在这些地方分享、点赞我的 repo 和文章。</p>
<p>感谢你看到这里。让更好的我们在 2018 相会！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017 年过去了，我很怀念它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时间匆匆，转眼又到了一年的结尾。现在我坐在图书馆里，周围很多考研的学长学姐明天就要奔赴考场，其中也包括院队的几个老大哥。明年的这时我在哪里？在做什么？没有答案。&lt;/p&gt;
&lt;p&gt;这个博客的第一篇文章在去年的 12 月 4 号写下，迄今也有一年有余了。看了看去年的总结和展望，大部分的计划都实现了，大概是因为写的比较保守的缘故。而“早睡早起”、“尽量不翘课”、“在自己真正的兴趣上利用时间”、“每天过得健康、充实、开心”这几点没有做到，尤其是最后一点。&lt;/p&gt;
&lt;p&gt;2017 年，尤其是下半年，我时常想要遵从兴趣、学习技术、保持自信、做到更好，但又日复一日地跟懒惰、压力、无所适从、自我怀疑、对未知的未来的恐惧作着斗争。20 岁的路口有了更多的分岔，很多以前从来没有想过的东西不停地折磨着我，而我又不是那种十分豁达开朗的性格，只能尽力不在这些负面情绪中沉沦。也许在新的一年里斗争还会继续下去，我希望最终乐观战胜忧郁，我战胜过去的自己。&lt;/p&gt;
&lt;p&gt;总之，无论是论取得的各种成果，还是既有价值观的动荡，2017 年于我个人都是重要的一年。让所有的改变在 2018 年来得更猛烈一些吧，我喜欢这种改变。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://kyonhuang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="年终总结" scheme="http://kyonhuang.top/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="未来展望" scheme="http://kyonhuang.top/tags/%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>算法一篇通——动态规划</title>
    <link href="http://kyonhuang.top/Dynamic-programming/"/>
    <id>http://kyonhuang.top/Dynamic-programming/</id>
    <published>2017-12-18T10:23:41.000Z</published>
    <updated>2018-01-19T13:12:47.324Z</updated>
    
    <content type="html"><![CDATA[<p>上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。</p>
<p>另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，但是如果抱着只能二选一的心态去学习，只能说明自己不够勤奋。之后的学习目标首先是为读研打好稳固基石，然后也要涉及多方面的知识。</p>
<p>回到正题。这次实习考试的第一题在当时没有思路，出来后同学讨论说要用到动态规划思想。之前有听过几次这个词，但是没有去了解，恰逢这个机会（以及为之后的美赛做准备），查阅了很多资料。在此总结一下我对动态规划的了解，以及用几个例子来说明，希望能尽可能地把动态规划给弄通。</p>
<a id="more"></a>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p><strong>动态规划（Dynamic programming）</strong>是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常用于求解<strong>最优化问题（Optimization problem）</strong>。动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构性质</strong>的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题，我们就称其为原问题的<strong>子问题</strong>。</p>
<p><strong>动态规划的核心</strong>是<strong>状态</strong>和<strong>状态转移方程</strong>：</p>
<ul>
<li><p><strong>状态</strong>：描述该问题的子问题的解，即根据子问题来定义状态。</p>
</li>
<li><p><strong>状态转移方程</strong>：状态和状态之间的关系式。大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态（<strong>无后效性</strong>）。</p>
</li>
</ul>
<p>能使用动态规划思想解决的问题都有最优子结构性质和重叠子问题：</p>
<ul>
<li><p><strong>最优子结构（Optimal substructure）</strong>性质：如果问题的最优解所包含的子问题的解也是最优的，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“<strong>全局最优解包含局部最优解</strong>”的思想。</p>
</li>
<li><p>重叠子问题：指在用<strong>递归</strong>算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划的解题思路如下：</p>
<ol>
<li>将原问题分解为子问题；</li>
<li>确定状态：状态不是随便定义的，一般定义完就要找到状态转移方程；</li>
<li>确定一些初始状态（边界状态）的值；</li>
<li>确定状态转移方程。</li>
</ol>
<p>如果问题看起来是个动态规划问题，但是无法定义出状态，那么试着将问题规约到一个已知的 DP 问题。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>讲了这么多，让我们一起做几道题目来练练手！</p>
<h3 id="菜鸟级"><a href="#菜鸟级" class="headerlink" title="菜鸟级"></a>菜鸟级</h3><p>这里我选了 LeetCode 的第 70 题 Climbing Stairs。说来惭愧，我第一次做这个题的时候半天没做出来，还先跳过去了。</p>
<p>题目是这样的：假设你在爬梯子，需要 n 步爬到顶。每一次只能爬 1 或 2 格，爬到顶一共有多少种不同的方法？</p>
<p>一步步沿着前面提到的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：这里的子问题即“爬到 i 格共有多少种不同的方法（i &lt; n）”；</li>
<li>确定状态：我们通常用一个函数表达式来表示状态。这里我们可以用<code>d(i)</code>来表示“爬到 i 格共有的不同的方法数”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = 1</code>、<code>d(2) = 2</code>；</li>
<li>确定状态转移方程：当我们得知<code>d(i-2)</code>时，再往上爬一次 2 格即可到达 i 格；当我们得知<code>d(i-1)</code>时，再往上爬一次 1 格即可到达 i 格。因此有<code>d(i) = d(i - 1) + d(i - 2)</code>。没有重叠的解法，因为最后一步要么爬 1 格，要么爬 2 格，我们将这两种自然分开了。</li>
</ol>
<p>使用递归，我们写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>) + climbStairs(n-<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Submit 就可以看到红红的 Time Limit Exceeded。计算时间超了，这是因为对于每一个 i，由于递归调用，我们反复求解相同的子问题，使得所作的工作量爆炸性增长。想要节省这些计算，我们可以采用拿空间换时间的方法，用一个大小为 n 的数组来记录子问题的计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</div><div class="line">        fill(i, arr);</div><div class="line">    <span class="keyword">return</span> arr[n];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        arr[n] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</div><div class="line">        arr[n] = <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        arr[n] = arr[n-<span class="number">1</span>] + arr[n-<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AC，Run Time 5ms。</p>
<p>也可以用递推法来解决，本质是一个 fibonacci。这里借 Discuss 里的解法一用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// base cases</span></div><div class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> one_step_before = <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> two_steps_before = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> all_ways = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</div><div class="line">    	all_ways = one_step_before + two_steps_before;</div><div class="line">    	two_steps_before = one_step_before;</div><div class="line">        one_step_before = all_ways;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> all_ways;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="普通级"><a href="#普通级" class="headerlink" title="普通级"></a>普通级</h3><p>稍微加点难度，来试一下 LeetCode 的第 198 题 House Robber。</p>
<p>题目：你是一个超高校级的小偷，唯一能阻止你的是你同一夜不能偷相邻的两家，否则警报装置会响。给一个全是非负整数的数组来代表每家有的钱，求你在不惊动警报的基础上今晚的最大收获。</p>
<p>还是一步步沿着动态规划的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：假设数组长度为 n，则这里的子问题即“有 i 家可偷时最大收获（i &lt; n）”；</li>
<li>确定状态：用<code>g(i)</code>代表第 i 家有的钱，用<code>d(i)</code>来表示“有 i 家可偷时最大收获”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = g(1)</code>、<code>d(2) = max(g(1), g(2))</code>；</li>
<li>确定状态转移方程：可以想到，到第 i（i &gt; 2）间屋子时，可能之前偷了第 i-1 间，那这间就不能偷；如果没偷第 i-1 间，那这间可以偷。于是有<code>d(i) = max(d(i-2)+g(i), d(i-1))</code>。</li>
</ol>
<p>用数组来记录偷过第 i 间屋子时最大收获，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = nums.length;</div><div class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">        fill(d, nums, i);</div><div class="line">    <span class="keyword">return</span> d[n-<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)</div><div class="line">        d[i] = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</div><div class="line">        d[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        d[i] = Math.max(d[i-<span class="number">2</span>]+nums[i], d[i-<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Run Time 接近 0，非常理想。</p>
<p>也有非常巧妙的递推方案，空间复杂度 O(1)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> prevNo = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> prevYes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</div><div class="line">        <span class="keyword">int</span> temp = prevNo;</div><div class="line">        prevNo = Math.max(prevNo, prevYes);</div><div class="line">        prevYes = n + temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(prevNo, prevYes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="挑战者级"><a href="#挑战者级" class="headerlink" title="挑战者级"></a>挑战者级</h3><p>来试试 LeetCode 的第 646 题 Maximum Length of Pair Chain。这是一道难度为 medium 的题，建议先跳过这一小节，看完“扩展”中的“<a href="http://kyonhuang.top/Dynamic-programming/#%E6%9C%80%E9%95%BF%E9%9D%9E%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89">最长非降子序列（LIS）</a>”再回来，有助于解决和理解这道题。</p>
<p>题目：给定 n 对数，每一对中前一个数总小于后一个数。现在，我们定义当且仅当<code>b &lt; c</code>时<code>(c, d)</code>可以跟在<code>(a, b)</code>后，来形成一条链。给定一系列对，求出<em>用上述方法形成的链条的最大长度</em>。不需要用完所有的给定对，而且可以以任意顺序选取。</p>
<p>可以看到，这题和 LIS 问题比较相似，但又有一些不同。由于可以以任意顺序选取，而非 LIS 问题中选取最长非降子序列的顺序固定，因此需要对一系列数对进行一个从小到大的排序。</p>
<p>状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d(i) = max&#123;1, d(j)+1&#125;，其中 j &lt; i，pairs[j][1] &lt; pairs[i][0]</div></pre></td></tr></table></figure>
<p>想要求<code>d(i)</code>，就把 i 前面的各个链中，最后一个数对的最大值不大于<code>pairs[i][0]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个链中最后一个数对的最大值都大于<code>pairs[i][0]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</div><div class="line">    Arrays.sort(pairs, (a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</div><div class="line">    <span class="keyword">int</span> len = pairs.length;</div><div class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</div><div class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        arr[i] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</div><div class="line">            <span class="keyword">if</span>(pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>] &amp;&amp; arr[j] + <span class="number">1</span> &gt; arr[i])</div><div class="line">                arr[i] = arr[j] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; l)</div><div class="line">            l = arr[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度是 O(n^2)，不是最佳解法。由于根据数对的最大值排好了序，因此可以直接用下列方法来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</div><div class="line">    Arrays.sort(pairs, (a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = pairs.length, i = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (++i &lt; n) &#123;</div><div class="line">        sum++;</div><div class="line">        <span class="keyword">int</span> curEnd = pairs[i][<span class="number">1</span>];</div><div class="line">        <span class="keyword">while</span> (i+<span class="number">1</span> &lt; n &amp;&amp; pairs[i+<span class="number">1</span>][<span class="number">0</span>] &lt;= curEnd) i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="具体实现方法总结"><a href="#具体实现方法总结" class="headerlink" title="具体实现方法总结"></a>具体实现方法总结</h2><p>经过以上三个例题的锻炼，一般难度的动态规划问题应该都能解决了。总结一下，动态规划思想具体实现有以下两种方法：</p>
<ol>
<li><p>可以用<strong>带备忘的自顶向下法（top-down with memoization）</strong>的方法计算状态转移方程。此方法仍然按自然的递归形式编写过程，但是用一个数组或者散列表来存储每个子问题的解，当需要时先检查是否已经保存过此解并取用。</p>
</li>
<li><p>还可以采用<strong>递推法</strong>自底向上地计算状态转移方程。递推的关键是边界和计算顺序，将子问题按照规模从小到大进行求解，当求解某个子问题时，其所依赖的更小的子问题都已求解完毕。在多数情况下，递推法的时间复杂度是：状态总数 <em> 每个状态的决策个数 </em> 决策时间。如果不同状态的决策个数不同，需具体问题具体分析。注意递归和递推的区别：一个自顶向下，一个自底向上。</p>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="最长非降子序列（LIS）"><a href="#最长非降子序列（LIS）" class="headerlink" title="最长非降子序列（LIS）"></a>最长非降子序列（LIS）</h3><p>给定一个序列<code>A[1]、A[2]、...、A[n]</code>，求其最长非降子序列（LIS，longest increasing subsequence）的长度。这是讲动态规划时基本都会讲到的一个问题。</p>
<p>其最小子问题即求<code>A[1]、A[2]、...、A[i]</code>的最长非降子序列的长度，其中<code>i &lt; N</code>；而状态则定义有<code>d(i)</code>表示前 i 个数中以<code>A[i]</code>结尾的最长非降子序列。</p>
<p>当要考虑初始状态（边界状态）的值时，最好是以一个实际输入为例。假定要求的序列是：<code>5, 3, 4, 8, 6, 7</code>，则有：</p>
<ul>
<li>前 1 个数的 LIS 长度<code>d(1) = 1</code>；</li>
<li>前 2 个数的 LIS 长度<code>d(2) = 1</code>（序列：3；3 前面没有比 3 小的）；</li>
<li>前 3 个数的 LIS 长度<code>d(3) = 2</code>（序列：3，4；4 前面有个比它小的 3，所以<code>d(3)=d(2)+1</code>）；</li>
<li>前 4 个数的 LIS 长度<code>d(1) = 1</code>（序列：3，4，8；8 前面比它小的有 3 个数，所以<code>d(4) = max{d(1),d(2),d(3)}+1 = 3</code>）；</li>
</ul>
<p>由此得到状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d(i) = max&#123;1, d(j) + 1&#125;，其中 i &gt; j，A[i] &gt;= A[j]</div></pre></td></tr></table></figure>
<p>想要求<code>d(i)</code>，就把 i 前面的各个子序列中，最后一个数不大于<code>A[i]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个子序列中最后一个数都大于<code>A[i]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = A.length;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        d[i] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </div><div class="line">            <span class="keyword">if</span>(A[j] &lt;= A[i])</div><div class="line">                d[i] = Math.max(d[i], d[j] + <span class="number">1</span>);</div><div class="line">        len = Math.max(d[i], len);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度为 O(n^2)，不是最优解法。可以看看<a href="https://www.felix021.com/blog/read.php?1587" target="_blank" rel="external">最长递增子序列 O(NlogN)算法</a>，有点复杂，这里就不多谈了。</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1 背包问题是最广为人知的动态规划问题之一，拥有很多变形。</p>
<p>有 n 种物品，每种只有一个。第 i 种物品的体积为 V[i]，价值为 W[i]。选一些物品装到一个容量为 C 的背包，使得背包内物品在总体积不超过 C 的前提下价值尽量大。1 &lt;= n &lt;= 100，1 &lt;= V[i] &lt;= C &lt;= 10000，1 &lt;= W[i] &lt;= 10^6。</p>
<p>将原问题分解为子问题后，状态还是比较好找的。我们可以用<code>d(i, j)</code>来表示前 i 个物品装到剩余体积为 j 的背包里能达到的最大价值。</p>
<p>对于第 i 个物品，可以装进或不装进背包。不装进背包，则背包中物品最大总价值为<code>d(i-1, j)</code>；而如果装进背包，对于前 i-1 个物品的空间就只有 j-V[i] 了。</p>
<p>由此得到状态转移方程：</p>
<p><code>d(i, j) = max{d(i-1, j), d(i-1, j-V[i]) + W[i]}</code></p>
<p>得到状态转移方程后，代码也不难写出了。这里就不贴了，有兴趣可以自己试试。</p>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>Dijkstra 算法也是以动态规划为基础的。你可以到我《算法》笔记的相关章节对 Dijkstra 算法进行进一步了解：<a href="https://github.com/bighuang624/Algorithms-notes/blob/master/%E7%AC%94%E8%AE%B0/4.4_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.md" target="_blank" rel="external">Algorithms-notes/笔记/4.4 最短路径
</a>（Dijkstra 算法相关内容正在添加中）。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>动态规划有着很强的理论性和实践性，可以考验出算法能力，因此经常在各类算法竞赛、面试题中出现。想要完全掌握，光搞定这一篇博客的几个例题远远不够，只有多做经典题目，才能当再碰到动态规划相关题目的时候做到游刃有余。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作参考"><a href="#写作参考" class="headerlink" title="写作参考"></a>写作参考</h3><ul>
<li><a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="external">动态规划：从新手到专家</a></li>
<li><a href="http://blog.csdn.net/baidu_28312631/article/details/47418773" target="_blank" rel="external">教你彻底学会动态规划——入门篇 - CSDN博客</a></li>
<li>《算法竞赛入门经典（第 2 版）》第 9 章</li>
</ul>
<h3 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h3><ul>
<li><a href="https://juejin.im/post/5a29d52cf265da43333e4da7" target="_blank" rel="external">漫画：什么是动态规划？ - 掘金</a>：可以借助这个漫画来理解动态规划，并了解动态规划在某些背包问题的特例上计算速度的局限性。</li>
<li><a href="http://www.hawstein.com/posts/dp-knapsack.html" target="_blank" rel="external">动态规划之背包问题（一）</a></li>
<li><a href="https://www.zhihu.com/question/23995189" target="_blank" rel="external">什么是动态规划？动态规划的意义是什么？ - 知乎</a></li>
<li><a href="https://segmentfault.com/a/1190000012829866" target="_blank" rel="external">javascript背包问题详解 - 个人文章 - SegmentFault</a></li>
</ul>
<h3 id="姊妹篇"><a href="#姊妹篇" class="headerlink" title="姊妹篇"></a>姊妹篇</h3><ul>
<li><a href="http://kyonhuang.top/Greedy-algorithm/">算法一篇通——贪心算法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。&lt;/p&gt;
&lt;p&gt;另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，但是如果抱着只能二选一的心态去学习，只能说明自己不够勤奋。之后的学习目标首先是为读研打好稳固基石，然后也要涉及多方面的知识。&lt;/p&gt;
&lt;p&gt;回到正题。这次实习考试的第一题在当时没有思路，出来后同学讨论说要用到动态规划思想。之前有听过几次这个词，但是没有去了解，恰逢这个机会（以及为之后的美赛做准备），查阅了很多资料。在此总结一下我对动态规划的了解，以及用几个例子来说明，希望能尽可能地把动态规划给弄通。&lt;/p&gt;
    
    </summary>
    
      <category term="算法笔记" scheme="http://kyonhuang.top/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://kyonhuang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://kyonhuang.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="DP" scheme="http://kyonhuang.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>花旗杯-新的终点，新的起点</title>
    <link href="http://kyonhuang.top/new-end-new-start/"/>
    <id>http://kyonhuang.top/new-end-new-start/</id>
    <published>2017-11-27T05:22:24.000Z</published>
    <updated>2018-03-10T14:46:41.333Z</updated>
    
    <content type="html"><![CDATA[<p>在从成都回武汉的火车上开始写这一篇博客。</p>
<p>历时共七个月的花旗杯终于结束了。作为创队元老，我从头到尾参与了这个项目，从每个组员的奇思妙想中挖掘出我们现在的选题，在一次次的争论中始终坚持它就是最好的选择。我也投入了大量的时间和精力，写完了整个网站前端开发的每一行代码，并参与了部分的算法研究工作。整个项目也数次从被放弃的边缘拉回来，成员也有一定的变动，可以说历经波折。</p>
<p>到达成都后，临行前请人算了一卦的浦先生幸运地抽到答辩的最后一位，这让我们可以观摩其他队伍的答辩、对评委的关注点进行揣摩，并有较为充足的准备时间。之后，前往成都的核心队员开始昼夜不分地修改项目计划书、PPT、展示讲稿等各种材料，直到上台答辩的最后一秒。这个过程中，另外四名成员应该比我要更为辛苦，在答辩前一夜，负责算法的曹队和冯大佬更是直到凌晨三点还在讨论评委可能提出的问题（他们也确实命中了绝大部分问题，功居甚伟），而王同学也果断承担起本来属于队长的项目展示的重任。在这样的准备强度下，尽管也有遗憾，我对我们组的答辩表现可以打到 100 分。我也十分感激他们能够用尽全力来准备项目的展示。</p>
<p>最终，我们的“探方网——网络文学 IP 价值评估及预测系统”获得了第十三届“花旗杯”金融创新应用大赛的三等奖。可惜的是，我们是最后一个宣布的三等奖，也就是说离二等奖仅有一步之遥。但能在全国二十强中最终名列第四，也是大赛诸多评委老师对我们项目极大肯定。</p>
<p>从比较现实的角度来看，这次参赛经历带给我个人大约 1000 元的奖金，以及大学期间第一个有分量、对保研有加分的奖项。当然，我还有一些对我而言更为重要的东西与看到这篇博文的每一位分享。</p>
<p><img src="/images/huaqi-prize.jpg" alt="huaqi-prize"></p>
<a id="more"></a>
<h2 id="参加比赛的经历"><a href="#参加比赛的经历" class="headerlink" title="参加比赛的经历"></a>参加比赛的经历</h2><p>在成都备战的深夜里，几名核心大佬都表示“再也不参加花旗杯这样的非技术类比赛了”。“非技术类”确实对花旗杯是一个不太正当的评价，但准备花旗的开发周期之长、团队管理之累、准备工作之繁琐，对我们这些软件工程专业的 nerd 来说，是醉心于技术的阻碍。我们花了相当比例的精力在项目的包装上，而在实际技术层面可能没有达到我们想要的高度。</p>
<p>但我还是很享受这个过程，因为比起纯粹的技术人员，我感觉可能我会更多地接触，也更为喜欢这样的项目包装、推广过程。我认为没有任何一个成功的项目能够单纯成长在技术的温室中，项目的包装是项目真正成为<strong>产品</strong>所不得不经历的工作。通过这样的工作，让技术人的智慧成果被更多人了解、使用和赏识，我认为这是十分有意义的。何况，在花旗的答辩场上，金玉其外、败絮其中的项目都被资深的评委老师们毫不留情地迅速戳破。</p>
<p>整个过程确实很累很苦，尤其是最末期，网站的前端基本上一天加好几个功能，我也很骄傲我坚持了下来。在走出答辩场地后，我们五个人在楼下花旗杯决赛的展牌前合影。在空间 po 出照片时，我配的字是“我感觉毕了业”。因为我在那一刻的感觉大概和《中国有嘻哈》欧阳靖在结束最后一次的表演时一样，如释重负，而又如获新生。</p>
<p>看看自己的码云，整个前端项目都是我的 commit，哈哈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-472d42ef0cb3ff5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="huaqi-commit.jpg"></p>
<p>这次花旗杯的参赛经历对我来说是一次十分难忘的经历。鉴于国软院有通知渠道并推荐参加的有含金量的比赛确实不多，我十分推荐学弟学妹们参加花旗杯。当然，下一届的学弟学妹如若进入决赛，大概要去东北挨冻了。另外，我也很欢迎有学弟学妹在明年联系我进入团队，作为前端、算法开发人员，或者作为项目方向、团队管理、答辩展示的一个咨询人员。</p>
<h2 id="团队开发的经验"><a href="#团队开发的经验" class="headerlink" title="团队开发的经验"></a>团队开发的经验</h2><p><img src="/images/huaqi-team.png" alt="huaqi-team"></p>
<p>这次花旗杯应该就是我本科中第一次，也是最后一次相对来说的大型团队开发项目了。数十人的团队开发在大学里是十分难得的经验，我也学到了很多，尤其是那些我们没有做的很好的环节，例如分工、沟通、日程规划等。</p>
<ul>
<li>队长应该主动和各部分负责人沟通，确定进度。</li>
<li>工作分配和修改必须要明确到人，并且利用好在线可查看可修改的备忘文件，例如石墨文档等。</li>
</ul>
<p>作为最初始的成员，我看着团队成员不断增加，也看到有些成员因为各种原因退出了这个项目。对于中途退出的成员，我虽然没有给他们前期的努力以回报，但理解他们并心存感激；但我也看到有极少部分成员对这个项目缺少投入。不论是因为确实身兼数职、分身乏术，还是企图偷懒、不劳而获，我都认为这是缺乏责任心的表现。我理解在接近七个月的项目开发中，感到怠惰、信心不足是正常的表现，我自己也有过这样的心理。但是在整个项目中，如果你所做的努力远远少于其他人，最终却分享同样的荣誉，这不但拖累了项目的进度，对整个项目组的士气更有着极其不良的影响。因此，选择团队成员也是修行的一种。对我自己来说，由于我个人的交际不是很广，没有太多的参与这次项目成员的挑选过程。通过这次经历，我也认识到广交朋友的益处，会努力在保证交友质量的前提去结识更多人。</p>
<p>另外，在以后的项目开发中，我希望在个人技术水平达标的前提下，我能够承担起组长的重任，让整个团队有更好的开发积极性和管理秩序，同时挑战自我，获得进步。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在这七个月里，我也对自己的性格缺陷进行了审视。我不太好意思向大家列举这些性格缺陷，但它们使我在包括花旗项目在内的学习过程中，甚至是在大学生涯的为人处事、个人发展等各方面遇到了不少挫折。我对未来我在性格方面的改善和转变有一些期许。我也不是很喜欢我现在的生活方式，希望能让它变得更加多彩。</p>
<p>我走到了花旗杯的终点。但对我来说，还有很多的起点。我希望在未来的日子里，我能够更加坚定、更加拼搏、更加成熟、更加不甘平庸。这很难，我希望我能够做到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在从成都回武汉的火车上开始写这一篇博客。&lt;/p&gt;
&lt;p&gt;历时共七个月的花旗杯终于结束了。作为创队元老，我从头到尾参与了这个项目，从每个组员的奇思妙想中挖掘出我们现在的选题，在一次次的争论中始终坚持它就是最好的选择。我也投入了大量的时间和精力，写完了整个网站前端开发的每一行代码，并参与了部分的算法研究工作。整个项目也数次从被放弃的边缘拉回来，成员也有一定的变动，可以说历经波折。&lt;/p&gt;
&lt;p&gt;到达成都后，临行前请人算了一卦的浦先生幸运地抽到答辩的最后一位，这让我们可以观摩其他队伍的答辩、对评委的关注点进行揣摩，并有较为充足的准备时间。之后，前往成都的核心队员开始昼夜不分地修改项目计划书、PPT、展示讲稿等各种材料，直到上台答辩的最后一秒。这个过程中，另外四名成员应该比我要更为辛苦，在答辩前一夜，负责算法的曹队和冯大佬更是直到凌晨三点还在讨论评委可能提出的问题（他们也确实命中了绝大部分问题，功居甚伟），而王同学也果断承担起本来属于队长的项目展示的重任。在这样的准备强度下，尽管也有遗憾，我对我们组的答辩表现可以打到 100 分。我也十分感激他们能够用尽全力来准备项目的展示。&lt;/p&gt;
&lt;p&gt;最终，我们的“探方网——网络文学 IP 价值评估及预测系统”获得了第十三届“花旗杯”金融创新应用大赛的三等奖。可惜的是，我们是最后一个宣布的三等奖，也就是说离二等奖仅有一步之遥。但能在全国二十强中最终名列第四，也是大赛诸多评委老师对我们项目极大肯定。&lt;/p&gt;
&lt;p&gt;从比较现实的角度来看，这次参赛经历带给我个人大约 1000 元的奖金，以及大学期间第一个有分量、对保研有加分的奖项。当然，我还有一些对我而言更为重要的东西与看到这篇博文的每一位分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/huaqi-prize.jpg&quot; alt=&quot;huaqi-prize&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="花旗杯" scheme="http://kyonhuang.top/tags/%E8%8A%B1%E6%97%97%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据预处理及常用处理方法</title>
    <link href="http://kyonhuang.top/intro-to-data-preprocessing/"/>
    <id>http://kyonhuang.top/intro-to-data-preprocessing/</id>
    <published>2017-10-31T12:45:28.000Z</published>
    <updated>2018-03-30T01:44:47.593Z</updated>
    
    <content type="html"><![CDATA[<p>作为互联网上最著名的数据科学竞赛平台之一，Kaggle 无疑是数据从业者和爱好者最喜欢的社区之一。最近，Kaggle 发布了 <a href="https://www.kaggle.com/amberthomas/kaggle-2017-survey-results" target="_blank" rel="external">2017 用户调查报告</a>，共有 16000 余名用户参与的这份调查可以让我们对数据工作者的各类信息有一个了解。</p>
<p>其中，对于“工作中遇到的障碍主要是什么？”这个问题，有 49.4% 的被调查者选择了“脏数据（dirty data）”这一项，占该问题所有选项的第一位。也就是说，数据科学家一般最常见的困扰就是要对手头的数据进行大量的预处理工程。</p>
<p>在业界有一句广泛流传的话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。从这句话可以看出，数据的好坏对于机器学习模型的最终效果有着极大的影响。</p>
<p>然而，现实世界中数据大体上都是不完整、不一致、含噪声的脏数据，无法直接使用，或结果差强人意。为了提高数据的质量，数据预处理技术应运而生。实际上，在一个基于机器学习模型的实际应用中，对于数据的预处理工作所需的时间和精力可能远大于模型和算法的选择和应用。</p>
<a id="more"></a>
<h2 id="数据预处理的概念"><a href="#数据预处理的概念" class="headerlink" title="数据预处理的概念"></a>数据预处理的概念</h2><p><strong>数据预处理</strong>是指对所收集数据进行分类或分组前所做的审核、筛选、排序、变换、规约、汇总等必要的处理。</p>
<h2 id="数据预处理针对的问题"><a href="#数据预处理针对的问题" class="headerlink" title="数据预处理针对的问题"></a>数据预处理针对的问题</h2><p>通过数据获取，我们能够得到未经处理的数据，这时的数据可能存在一些问题。在解决这些问题后，我们才能选择和提取合适的特征进行模型的训练。</p>
<p>这里简述了一部分问题及其解决方法，还有一些问题的解决方案会在下节展开讨论：</p>
<ul>
<li><p>不属于同一量纲：特征的规格不同，不能放在一起比较。后文提到的无量纲化可以解决这一问题。</p>
</li>
<li><p>信息不规整：由于数据收集或存储时的错误、技术问题或漏洞，以及软硬件故障等因素，可能存在一些不规整数据。这些不规整的数据需要被过滤掉。</p>
</li>
<li><p>数据点缺失：缺失或不规整的数据需要根据其他数据进行填充，方法包括用零值、全局期望或中值，或是根据相邻或类似的数据点来做插值等。需要根据数据、应用场景和个人经验来选择正确的方式。</p>
</li>
<li><p>异常值问题：异常值的主要问题在于即使它们是极值也不一定就是错的，对错非常难以分辨。异常值可被移除或是填充，但鲁棒回归等统计技术可用于处理异常值或是极值。另外，利用如对数或高斯核对异常值进行转换也有利于降低值跳跃的影响。</p>
</li>
<li><p>数据类型不合要求：对于某些类型的特征，我们可能希望将其转换为另一类型进行使用。比如，我们可以将考试分数这个数值特征转换为是否及格这个二元特征，这个可以通过二值化（设定一个阀值）实现。其他的转换也可以通过自己定义的函数实现。</p>
</li>
<li><p>数据不能直接使用：对于例如文本特征、类别特征等特定类别的特征，机器学习算法和模型不能直接使用，那么需要对其做一些转化。对于文本特征，可以使用词袋（bag-of-word）表示法；而对于类别特征，可以使用 One-hot 编码进行处理。这些方法的核心都是编码，会在下一节再出现。</p>
</li>
</ul>
<h2 id="数据预处理的常用方法"><a href="#数据预处理的常用方法" class="headerlink" title="数据预处理的常用方法"></a>数据预处理的常用方法</h2><p>除开过滤、填充等方法之外，下列方法在实际问题的数据预处理中也比较常用。</p>
<h3 id="无量纲化"><a href="#无量纲化" class="headerlink" title="无量纲化"></a>无量纲化</h3><p><strong>无量纲化</strong>使不同规格的数据转换到同一规格。常见的无量纲化方法有<strong>标准化</strong>和<strong>归一化</strong>。</p>
<p>标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布。</p>
<p>归一化利用了边界值信息，将特征的取值区间缩放到某个特点的范围，例如[0, 1]等。</p>
<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>标准化也叫 <strong>z-score</strong> 规范化（零均值规范化）。公式如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a1b64f8328595283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标准化.png"></p>
<p>其中 μ 是样本数据的<strong>均值（mean）</strong>， σ 是样本数据的<strong>标准差（std）</strong>。</p>
<p>通过标准化，样本数据被变为一个均值为 0，方差为 1 的分布。对于梯度下降，标准化可以达到<strong>加速收敛</strong>的效果，且不改变原始数据的几何分布。</p>
<h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p><strong>归一化</strong>一般是将数据按比例缩放到指定的范围，用于<strong>去除不同维度数据的量纲以及量纲单位</strong>。</p>
<p>最常见的归一化方法就是 <strong>Min-Max</strong> 归一化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-8a1730b90c9336f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归一化.png"></p>
<p>经过归一化处理过后的数据，各个特征维度对目标函数的影响权重是一致的，不会发生某一特征因维度过高而起主导作用，从而遮盖住其他特征的问题。</p>
<p><strong>注意</strong>，归一化和标准化的英文都为 Normalization，需要<strong>根据其用途（或公式）的不同去理解或翻译</strong>。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p><strong>编码</strong>将无法作为输入的原始类别特征或文本特征表示为数字形式。其思想为用一个变量的字典来实现变量到索引序号的映射。</p>
<p>编码的方式也有很多，下面介绍两个常用的编码方式－One-hot 编码和哑编码。</p>
<h4 id="One-hot-编码"><a href="#One-hot-编码" class="headerlink" title="One-hot 编码"></a>One-hot 编码</h4><p>假设变量可取的值有 k 个，如果对这些值用 1 到 k 编序，则可以用长度为 k 的二元向量来表示一个变量的取值。在这个向量里，该取值对应的序号所在的元素为 1，其他元素都为 0。</p>
<h4 id="哑编码"><a href="#哑编码" class="headerlink" title="哑编码"></a>哑编码</h4><p><strong>哑编码</strong>是一种状态编码，前文提到的词袋表示法用的是这种编码方式。将这些文本特征转化为数字时，数字与数字之间是没有大小关系的，纯粹只是分类标记，这时候就需要用哑编码对其进行编码。比如 0 用 0001，1 用 0010，2 用 0100 以此类推。有点类似文本矩阵，最终会构成一个<strong>稀疏矩阵</strong>。一份文本数据中各种词可能达数百万，因此使用稀疏矩阵表示能够节省内存和磁盘空间，以及计算时间。</p>
<h5 id="补充：稀疏矩阵"><a href="#补充：稀疏矩阵" class="headerlink" title="补充：稀疏矩阵"></a>补充：稀疏矩阵</h5><p>在矩阵中，若数值为 0 的元素数目远远多于非 0 元素的数目，并且非 0 元素分布没有规律时，则称该矩阵为<strong>稀疏矩阵</strong>；与之相反，若非 0 元素数目占大多数时，则称该矩阵为<strong>稠密矩阵</strong>。定义非零元素的总数比上矩阵所有元素的总数为<strong>矩阵的稠密度</strong>。</p>
<p>稀疏矩阵算法的最大特点是通过只存储和处理非零元素从而大幅度降低存储空间需求以及计算复杂度，代价则是必须使用专门的稀疏矩阵压缩存储数据结构。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上介绍的只是一些数据预处理中的常用方法。实际上，还有许多根据不同场合选用的效果更好的处理方法。对于这些暂时没有机会使用的处理方法，限于个人水平和文章篇幅，就不一一详谈了。</p>
<p>在进行完数据预处理后，我们还需要选择和提取有意义的特征，将其作为输入来训练机器学习的算法和模型。之后还有选择模型、调整参数、评估、交叉验证等步骤，之后会继续整理这些方面的学习成果。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/30603579?group_id=908678758198726656" target="_blank" rel="external">Kaggle发布首份数据科学&amp;机器学习从业者现状调查</a></li>
<li><a href="https://www.zhihu.com/question/29316149/answer/110159647" target="_blank" rel="external">特征工程到底是什么？ - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29957294" target="_blank" rel="external">ML 入门：归一化、标准化和正则化</a></li>
<li>《Spark 机器学习》第三章：Spark 上数据的获取、处理与准备</li>
<li><a href="http://blog.csdn.net/big_talent/article/details/53887238" target="_blank" rel="external">关于特征工程入门中的一些基本知识（整理） - CSDN博客</a></li>
<li><a href="http://blog.csdn.net/pipisorry/article/details/52247379" target="_blank" rel="external">数据标准化/归一化normalization - 皮皮blog - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为互联网上最著名的数据科学竞赛平台之一，Kaggle 无疑是数据从业者和爱好者最喜欢的社区之一。最近，Kaggle 发布了 &lt;a href=&quot;https://www.kaggle.com/amberthomas/kaggle-2017-survey-results&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2017 用户调查报告&lt;/a&gt;，共有 16000 余名用户参与的这份调查可以让我们对数据工作者的各类信息有一个了解。&lt;/p&gt;
&lt;p&gt;其中，对于“工作中遇到的障碍主要是什么？”这个问题，有 49.4% 的被调查者选择了“脏数据（dirty data）”这一项，占该问题所有选项的第一位。也就是说，数据科学家一般最常见的困扰就是要对手头的数据进行大量的预处理工程。&lt;/p&gt;
&lt;p&gt;在业界有一句广泛流传的话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。从这句话可以看出，数据的好坏对于机器学习模型的最终效果有着极大的影响。&lt;/p&gt;
&lt;p&gt;然而，现实世界中数据大体上都是不完整、不一致、含噪声的脏数据，无法直接使用，或结果差强人意。为了提高数据的质量，数据预处理技术应运而生。实际上，在一个基于机器学习模型的实际应用中，对于数据的预处理工作所需的时间和精力可能远大于模型和算法的选择和应用。&lt;/p&gt;
    
    </summary>
    
      <category term="数据科学笔记" scheme="http://kyonhuang.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://kyonhuang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据科学" scheme="http://kyonhuang.top/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
      <category term="数据预处理" scheme="http://kyonhuang.top/tags/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="特征工程" scheme="http://kyonhuang.top/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据分析" scheme="http://kyonhuang.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>虎山行</title>
    <link href="http://kyonhuang.top/escorts-over-tiger-hill/"/>
    <id>http://kyonhuang.top/escorts-over-tiger-hill/</id>
    <published>2017-10-22T03:43:24.000Z</published>
    <updated>2017-12-19T11:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>更新</strong>：10 月 26 日我跟朱老师进行了一次时间较长的近期学习成果展示，并且对于接下来的学习方向聊了一会。结合花旗杯进入决赛的事情，将此文做一次更新。</p>
<hr>
<p>这段时间博客更得不勤，因为实在太忙。解释器构造、系统级程序设计、Spark、公选课作业、算法、英语、大创…每天睁开眼睛就想起这么多学习任务，让人不免感觉身在虎山，危机四伏，战战兢兢。</p>
<p>只有在这种强度的学习压力下，才会发现自己的很多问题，其中最致命的就是自己的学习效率太低了，很难集中注意力去解决手头即时的任务。快速学习和解决问题的能力是程序员必备之一，我在这方面可以说不及格。再就是还有惰性心理，浮躁，不能保持健康的作息，以至于高效学习的时间不足。</p>
<p>同时，每天忙碌的同时也会胡思乱想：我真的适合读研吗？自己学习前端知识的时候还是比较开心的，和现在学习 Spark 的态度可能还是有一些差别，并且也在要不要向机器学习方向深入学习而犹豫。读研以后，不是说完全不可能，但是基本上以后就不会从事前端领域的工作了。确定喜欢的领域和确定喜欢的人一样，难以割舍的感觉似有若无。但是对我来说，父母和老师都给了很大的期望，自己也没有做好找工作的准备，争取保研是箭在弦上，不得不发。我能做的，只有将弦拉的更满，箭一发便是千钧之力，穿越更高的云霄。</p>
<p>现在确实有些迷茫，每天过的感觉不到自己有实打实的进步。希望狮子座的天性能够帮助我顺利度过这段大学最忙碌也最缥缈的时期。</p>
<h2 id="定期任务"><a href="#定期任务" class="headerlink" title="定期任务"></a>定期任务</h2><h3 id="每天"><a href="#每天" class="headerlink" title="每天"></a>每天</h3><ul>
<li>一道 LeetCode</li>
<li>六级单词</li>
</ul>
<h3 id="每周"><a href="#每周" class="headerlink" title="每周"></a>每周</h3><ul>
<li>《算法》一节</li>
<li>Coursera 华盛顿大学《机器学习基础：案例研究》课程一节（尽早刷完这个）[已完成]</li>
<li>六级练习题若干（有时间可以做一整套题）</li>
<li>一篇会议论文阅读（abstract 和 introduction）［按照标准认真读，做一些简短的笔记］</li>
<li>12 月后<a href="http://wdxtub.com/2016/04/16/thin-csapp-0/" target="_blank" rel="external">读薄 CSAPP 系列</a>每周两篇</li>
</ul>
<h2 id="学期计划"><a href="#学期计划" class="headerlink" title="学期计划"></a>学期计划</h2><p>给这个最重要的学期列一个总体的学期计划。</p>
<h3 id="课业"><a href="#课业" class="headerlink" title="课业"></a>课业</h3><p><strong>三门必修课</strong>，解释器构造实验以及系统级程序设计的理论和实验课，<strong>必须满绩</strong>。</p>
<h3 id="花旗"><a href="#花旗" class="headerlink" title="花旗"></a>花旗</h3><p>一个月的时间，逼自己尽全力去争取最好的结果。</p>
<h3 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h3><p>积极完成朱老师布置的任务，并且和他交流。也要关心组里其他同学的工作。</p>
<p>朱老师建议我先学习机器学习的应用。根据这个建议，我把对吴恩达的《机器学习》课程的学习计划暂时改为华盛顿大学《机器学习基础：案例研究》课程的学习。这门课更偏重实际应用，也可以避免我绕到数学内容里。</p>
<h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>阅读朱老师推荐的会议，积累感觉找方向。多和朱老师交流心得。</p>
<p>每周抽时间细看一篇，也算是练习英语阅读。重点读 abstract 和 introduction。可以参考 <a href="https://zhuanlan.zhihu.com/p/29568504" target="_blank" rel="external">[Paper Reading] Efficient Estimation of Word Representations in Vector Space</a> 的格式来做笔记。为了督促自己，可以考虑申请一个新的知乎专栏或者在 PaperWeekly 做笔记。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>每天一道 LeetCode 加上自己控制页数的《算法》阅读。下学期可以做九度 OJ 和北大 OJ 练手。</p>
<h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>不要放弃六级，老师们都很看重英语能力。每天还是要抽时间背背单词，有时间练习一下听力、翻译、阅读、作文等。<strong>题目重在整理，而非数量。</strong></p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>有时间自己做一些开源小项目。没时间就算了，还是以自己参与度较高的科研项目为重。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>暂时考虑按照以下路径，这个学习肯定搞不定，但是要自己把握进度：</p>
<ol>
<li>学完 Coursera 华盛顿大学《机器学习基础：案例研究》课程并完成所有作业</li>
<li>通过《利用Python进行数据分析》的阅读学习，掌握 sklearn、numpy、pandas、matplotlib 的使用</li>
<li>吴恩达《机器学习》课程：绕不开的必修课</li>
<li>建立大局观的书籍：中文：周志华老师的西瓜书《机器学习》和李航老师的《统计学习方法》；英文：《Patten Recognition and Machine Learning》，《Elements of Statistical Learning》</li>
<li>kaggle、阿里巴巴天池实战</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>组队参加美赛。抽时间了解一下赛事信息和要求。有时间点一些技能点。</li>
<li>可以考虑申请软件著作权（当然要有比较好的项目）。</li>
<li>坚持把日记给记好。</li>
</ul>
<p>忙乱时方显修为，管理好自己的时间，专心于自己的事业。自己能走多远，很大程度上取决于这个学期。</p>
<blockquote>
<p>那就继续人间游 虽说不太平<br>明知山有虎 偏向虎山行</p>
<p>—  GAI / 艾福杰尼 / Kungfu-Pen 《虎山行》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：10 月 26 日我跟朱老师进行了一次时间较长的近期学习成果展示，并且对于接下来的学习方向聊了一会。结合花旗杯进入决赛的事情，将此文做一次更新。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这段时间博客更得不勤，因为实在太忙。解释器构造、系统级程序设计、
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="目标" scheme="http://kyonhuang.top/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>理清 Spark 2.2 的概念－RDD、Dataset、MLlib</title>
    <link href="http://kyonhuang.top/spark2.2-with-old-conceptions/"/>
    <id>http://kyonhuang.top/spark2.2-with-old-conceptions/</id>
    <published>2017-10-05T02:43:16.000Z</published>
    <updated>2017-10-05T05:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据实验室的要求，现在在啃《Spark 机器学习》。这本书和市面上大多数 Spark 书籍一样，全都基于 Spark 1.x。在 Spark 版本已经升到 2.2 的今天，敲这本书上的代码可以说是遍地是坑了，很多东西都已经变更，而且很难找到正确的解决方案，弄的我很是烦躁。</p>
<p>没办法，问题要一点一点解决。我决定先从理清《Spark 机器学习》提到的某些 Spark 2.2 提供的概念、模块和配合工具下手，主要关心一下几点：</p>
<ol>
<li>RDD 是什么？在升级到 Spark2.2+ 后有什么改动？</li>
<li>Dataset 是什么？DataFrame 又是什么？</li>
<li>MLlib 是什么？在升级到 Spark2.2+ 后有没有变动？如何使用？</li>
<li>IPython 是什么？如何配合 Spark2.2+ 使用？</li>
</ol>
<a id="more"></a>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Apache Spark 是一个快速的, 多用途的集群计算系统。 它提供了 Java, Scala, Python 和 R 的高级 API，以及一个支持通用的执行图计算的优化过的引擎. 它还支持一组丰富的高级工具, 包括使用 SQL 处理结构化数据处理的 Spark SQL, 用于机器学习的 MLlib, 用于图形处理的 GraphX, 以及 Spark Streaming。</p>
<h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RDD（Resilien Distributed Dataset，弹性分布式数据集）是 Spark 的核心概念之一。一个 RDD 代表一系列的“记录”（严格来说是某种类型的对象）。这些记录被分配或分区到一个集群的多个节点上（在本地模式下，可以类似地理解为单个进程里的多个线程上）。</p>
<p>Spark 中的 RDD 具备容错性，即当某个节点或任务失败时（非用户代码错误引起，如硬件故障、网络连接失败等），RDD 会在余下的节点上自动重建，以便任务最终能够完成。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>RDD 可以从一个驱动程序中已存在的 Scala 集合创建，也可以基于 Hadoop 的输入源（任何其他 Hadoop 支持的文件系统）创建，以及通过转换（transforming）来创建。</p>
<p>RDD 支持两种类型的操作：<strong>转换（transformation）</strong>和<strong>执行（action）</strong>。一般来说，转换操作是对一个数据集里的所有记录执行某种函数，从而使记录发生改变；而执行通常是运行某些计算或聚合操作，并将结果返回给驱动程序。</p>
<p>值得注意的是，Spark 中的<strong>转换操作是懒加载的</strong>（lazy），即在 RDD 上调用一个转换操作不会立即触发相应的计算，而是会将转换操作链接起来，并在执行操作被调用时才被高效计算。</p>
<p>调用一个 RDD 的<code>cache</code>（或<code>persist</code>）函数将会告诉 Spark 将这个 RDD 缓存在集群的内存中，以加快下一次访问数据集的速度。</p>
<p>更多 RDD 功能及实际编程方法可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/rdd-programming-guide.html" target="_blank" rel="external">Spark 编程指南 - Spark 2.2.0 中文文档 - ApacheCN</a>里的相关部分。</p>
<h3 id="升级变动"><a href="#升级变动" class="headerlink" title="升级变动"></a>升级变动</h3><p>在 Spark 2.0 之前，Spark 的主要编程接口是 RDD。而在 Spark 2.0 之后，RDD 被 Dataset（数据集）替换。</p>
<p>Dataset 很像 RDD，也是强类型的，并能够使用强大的 lambda 函数。但 Dataset 在引擎盖（hood）有更好的优化，因此性能要更优于 RDD。RDD 接口仍然受支持，但是建议切换使用 Dataset。</p>
<h2 id="Dataset-和-DataFrame"><a href="#Dataset-和-DataFrame" class="headerlink" title="Dataset 和 DataFrame"></a>Dataset 和 DataFrame</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>Dataset 是一个分布式的数据集合。一个 Dataset 可以从 JVM 对象来构造并使用转换功能。Dataset API 在 Scala 和 Java 是可用的，遗憾的是，Python 暂不支持 Dataset API。但是由于 Python 的动态特性, 许多 Dataset API 的优点已经可用了。</p>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>一个 DataFrame 是一个 Dataset 组成的指定列。它的概念与一个关系型数据库中的表或者在 R/Python 中的数据帧（data frame）是相等的，但优化得更好。</p>
<p>DataFrames 可以从结构化的文本文件、Hive中的表、外部数据库，或者已经存在的 RDD 构造而来。DataFrame API 可以在 Scala、Java、Python 和 R 中实现。在 Scala 和 Java 中，一个 DataFrame 所代表的是一个多行的 Dataset。</p>
<p>更多相关信息可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/sql-programming-guide.html" target="_blank" rel="external">Spark SQL and DataFrames - Spark 2.2.0 中文文档 - ApacheCN</a>。</p>
<h2 id="MLlib"><a href="#MLlib" class="headerlink" title="MLlib"></a>MLlib</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>MLlib 是 Spark 的机器学习库。其目标是使实用的机器学习具有可扩展性并且变得容易。在较高的水平上，它提供了以下工具：</p>
<ul>
<li>ML Algorithms（ML 算法）：常用的学习算法，如分类，回归，聚类和协同过滤；</li>
<li>Featurization（特征）：特征提取，变换，降维和选择；</li>
<li>Pipelines（管道）：用于构建，评估和调整 ML Pipelines 的工具；</li>
<li>Persistence（持久性）：保存和加载算法，模型和 Pipelines；</li>
<li>Utilities（实用）：线性代数，统计学，数据处理等。</li>
</ul>
<h3 id="升级变动-1"><a href="#升级变动-1" class="headerlink" title="升级变动"></a>升级变动</h3><p>MLlib 包括基于 RDD 的 API 和基于 DataFrame 的 API。从 Spark 2.0 开始，基于 RDD 的 API 处于维护模式，这意味着这些 API 仍然被支持且会修复 bug，但不会再添加新功能。在基于 DataFrame 的 API 能够开发到相同功能时，基于 RDD 的 API 将被弃用，并预计在 Spark 3.0 中删除。</p>
<p>更多相关信息可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/ml-guide.html" target="_blank" rel="external">MLlib: 主要指南 - Spark 2.2.0 中文文档 - ApacheCN</a>。</p>
<h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>书中的 3.2 节开始也涉及到 IPython 的使用，并且在实际使用中也有一些坑。因此也需要了解一下。</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>IPython 是一个 Python 的高级交互式 shell，基于 BSD 开源，比默认的 Python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，并且内置了许多很有用的功能和函数。IPython 内置的 pylab 包括用于数值计算的 NumPy 和 SciPy，以及用于交互式绘图和可视化的 matplotlib。</p>
<h3 id="升级变动-2"><a href="#升级变动-2" class="headerlink" title="升级变动"></a>升级变动</h3><p>书中想在启动 PySpark 终端时使用 IPython 而非标准的 Python shell。启动时也可以向 IPython 传入其他参数，包括让它启动时也启动 pylab 功能。</p>
<p>但是实际操作时，在 Spark 主目录下输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IPYTHON=1 IPYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark</div></pre></td></tr></table></figure>
<p>会报错，提示信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error in pyspark startup:</div><div class="line">IPYTHON and IPYTHON_OPTS are removed in Spark 2.0+. Remove these from the environment and set PYSPARK_DRIVER_PYTHON and PYSPARK_DRIVER_PYTHON_OPTS instead.</div></pre></td></tr></table></figure>
<p><strong>解决方法：</strong></p>
<p>把输入命令变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark</div></pre></td></tr></table></figure>
<p>如果要使用 IPython 提供的 Notebook 应用，<br>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&apos;notebook&apos; ./bin/pyspark</div></pre></td></tr></table></figure>
<p>参考资料：<a href="https://stackoverflow.com/questions/42658694/starting-ipython-with-spark-2" target="_blank" rel="external">Starting Ipython with Spark 2 - Stack Overflow</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Spark 机器学习》</li>
<li><a href="http://spark.apachecn.org/docs/cn/2.2.0/" target="_blank" rel="external">概述 - Spark 2.2.0 中文文档 - ApacheCN</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据实验室的要求，现在在啃《Spark 机器学习》。这本书和市面上大多数 Spark 书籍一样，全都基于 Spark 1.x。在 Spark 版本已经升到 2.2 的今天，敲这本书上的代码可以说是遍地是坑了，很多东西都已经变更，而且很难找到正确的解决方案，弄的我很是烦躁。&lt;/p&gt;
&lt;p&gt;没办法，问题要一点一点解决。我决定先从理清《Spark 机器学习》提到的某些 Spark 2.2 提供的概念、模块和配合工具下手，主要关心一下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RDD 是什么？在升级到 Spark2.2+ 后有什么改动？&lt;/li&gt;
&lt;li&gt;Dataset 是什么？DataFrame 又是什么？&lt;/li&gt;
&lt;li&gt;MLlib 是什么？在升级到 Spark2.2+ 后有没有变动？如何使用？&lt;/li&gt;
&lt;li&gt;IPython 是什么？如何配合 Spark2.2+ 使用？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Spark 学习笔记" scheme="http://kyonhuang.top/categories/Spark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Spark" scheme="http://kyonhuang.top/tags/Spark/"/>
    
      <category term="RDD" scheme="http://kyonhuang.top/tags/RDD/"/>
    
      <category term="Dataset" scheme="http://kyonhuang.top/tags/Dataset/"/>
    
      <category term="MLlib" scheme="http://kyonhuang.top/tags/MLlib/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR v4 学习笔记（三）－特性拾遗</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-3/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-3/</id>
    <published>2017-09-25T13:12:26.000Z</published>
    <updated>2017-12-22T12:27:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习解释器构造和 ANTLR。在系列博文的上一篇 <a href="http://kyonhuang.top/ANTLR-learning-notes-2/">ANTLR v4 学习笔记（二）－实现变种计算器</a>，我们用 ANTLR 实现了一个变种计算器，从而对 ANTLR 语法、访问器（Visitor）机制、集成以及 ANLTR 的错误处理机制有了更深的理解。</p>
<p>上篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但没有覆盖整个 Chapter 4 的所有内容。因此这篇博文将介绍一下 Chapter 4 的剩余内容——监听器（Listener）机制、代码片段嵌入语法，以及词法分析的一些很棒的特性。</p>
<a id="more"></a>
<h2 id="监听器机制"><a href="#监听器机制" class="headerlink" title="监听器机制"></a>监听器机制</h2><p>监听器机制和访问器机制有着很多共通的特点，我们也需要通过监听语法分析树遍历器触发的“事件”来完成某些工作。它们之间最大的区别在于，监听器的方法会被 ANTLR 提供的遍历器对象自动调用，而在访问器的方法中，必须显式调用<code>visit</code>方法来访问子节点，否则对应的子树将不会被访问。</p>
<p>ANTLR 会自动生成一个接口 xxListener，它定义了 ANTLR 的运行库中的 ParseTreeWalker 类在遍历语法分析树时能够触发的全部方法。当然，和访问器机制一样，我们无需实现接口中的全部方法。ANTLR 自动生成一个名为 xxBaseListener 的类，我们可以继承这个类并只重写那些我们感兴趣的方法。</p>
<h2 id="代码片段嵌入语法"><a href="#代码片段嵌入语法" class="headerlink" title="代码片段嵌入语法"></a>代码片段嵌入语法</h2><p>监听器机制和访问器一样，能够使语法分析过程和应用程序本身保持低耦合，也让语法更具有可读性。但有时候，为了满足比较苛刻的需求，我们需要将代码片段（动作）嵌入到语法中，这些动作会被拷贝到 ANTLR 自动生成的递归下降语法分析器的代码中。</p>
<h3 id="将任意动作嵌入语法"><a href="#将任意动作嵌入语法" class="headerlink" title="将任意动作嵌入语法"></a>将任意动作嵌入语法</h3><p>拿下面这一份用于解析类表格文件的语法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">grammar Rows;</div><div class="line"></div><div class="line"><span class="meta">@parser</span>::members &#123;  <span class="comment">// 在生成的 RowsParser 中添加一些成员</span></div><div class="line">    <span class="keyword">int</span> col;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RowsParser</span><span class="params">(TokenStream input, <span class="keyword">int</span> col)</span> </span>&#123;  <span class="comment">// 自定义的构造器</span></div><div class="line">      <span class="keyword">this</span>(input);</div><div class="line">      <span class="keyword">this</span>.col = col;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">file: (row NL)+ ;</div><div class="line"></div><div class="line">row</div><div class="line">locals [<span class="keyword">int</span> i=<span class="number">0</span>]</div><div class="line">    : (   STUFF</div><div class="line">          &#123;</div><div class="line">          $i++;</div><div class="line">          <span class="keyword">if</span> ($i == col) System.out.println($STUFF.text);</div><div class="line">          &#125;</div><div class="line">      )+</div><div class="line">    ;</div><div class="line"></div><div class="line">TAB   : <span class="string">'\t'</span> -&gt; skip ;    <span class="comment">// 匹配但是不将其传递给语法分析器</span></div><div class="line">NL    : <span class="string">'\r'</span>? <span class="string">'\n'</span> ;      <span class="comment">// 匹配并将其传递给语法分析器</span></div><div class="line">STUFF : ~[\t\r\n]+ ;      <span class="comment">// 匹配除 tab 符和换行符之外的任何字符</span></div></pre></td></tr></table></figure>
<p><code>@parser::members</code>表示在生成的 RowsParser 中添加一些成员，即大括号里的所有元素（包括）会原封不动的添加到 RowsParser 类中。我们通过加入的构造器来传入希望提取的列号。</p>
<p>row 规则的<code>(...)+</code>循环放置了一些动作，访问了之前使用 locals 子句定义的局部变量<code>$i</code>。同时 row 规则也使用了<code>$STUFF.text</code>来获得刚刚匹配的 STUFF 词法符号中包含的文本。关于动作的更多内容会在 Chapter 10 深入研究。</p>
<h3 id="用语义判定改变语法分析过程"><a href="#用语义判定改变语法分析过程" class="headerlink" title="用语义判定改变语法分析过程"></a>用语义判定改变语法分析过程</h3><p>用一个读取一列整数的语法作为例子。首先看一下需求：输入的其中的一部分整数指定了接下来的多少个整数分为一组。例如输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2 8 43 3 1 4 6</div></pre></td></tr></table></figure>
<p>第一个数字 2 表示匹配接下来的两个数字 8 和 43，数字 3 表示匹配接下来的三个数字。</p>
<p>语法文件如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">grammar Data;</div><div class="line"></div><div class="line">file : group+ ;</div><div class="line"></div><div class="line">group: INT sequence[$INT.<span class="keyword">int</span>] ;</div><div class="line"></div><div class="line">sequence[<span class="keyword">int</span> n]</div><div class="line">locals [<span class="keyword">int</span> i = <span class="number">1</span>;]</div><div class="line">     : ( &#123;$i&lt;=$n&#125;? INT &#123;$i++;&#125; )*  <span class="comment">// 匹配 n 个整数</span></div><div class="line">     ;</div><div class="line"></div><div class="line">INT :   [<span class="number">0</span>-<span class="number">9</span>]+ ;     <span class="comment">// 匹配整数</span></div><div class="line">WS  :   [ \t\n\r]+ -&gt; skip ;   <span class="comment">// 丢弃所有的空白字符</span></div></pre></td></tr></table></figure>
<p>Data 语法的关键在于<code>{$i&lt;=$n}?</code>，这段动作的值是布尔类型的，它被称为一个语义判定。在匹配到 n 个输入整数之前，它的值保持为 true，其中 n 是 sequence 语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 时，<code>(...)*</code>循环终止，从 sequence 规则返回。</p>
<h2 id="词法分析特性"><a href="#词法分析特性" class="headerlink" title="词法分析特性"></a>词法分析特性</h2><p>ANTLR 有三个与词法符号有关非常棒的特性。</p>
<h3 id="孤岛语法：处理同一文件中的不同格式"><a href="#孤岛语法：处理同一文件中的不同格式" class="headerlink" title="孤岛语法：处理同一文件中的不同格式"></a>孤岛语法：处理同一文件中的不同格式</h3><p>有很多常见的文件格式包含了多重语言，例如 Java 文件中有注释和 Java 代码，ejs 等模板引擎有模板语言表达式和文本。不同格式的语言需要按照不同的方式进行处理，这样的现象被称为<strong>“孤岛语法”</strong>。</p>
<p>ANTLR 提供了一个名为<strong>词法分析模式（lexical modes）</strong>的词法分析器特性，帮助我们方便地处理混合了不同格式数据的文件。它的基本思想是，当遇到特殊的“哨兵”字符序列时，执行不同模式的切换。</p>
<p>我们不妨以 XML 作为例子。一个 XML 解析器会将除标签和实体转义（例如<code>&amp;pound;</code>）之外的内容全部当作普通文本。当看到<code>&lt;</code>时，词法分析器会切换到 “INSIDE” 模式；当看到<code>&gt;</code>或者<code>/&gt;</code>时，它就切换回默认模式。</p>
<p>下面的语法展示了 XML 解析器的工作方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Define a lexer grammar called XMLLexer</div><div class="line"> */</div><div class="line">lexer grammar XMLLexer;</div><div class="line"></div><div class="line"><span class="comment">// 默认模式：所有在标签之外的东西</span></div><div class="line">OPEN        : <span class="string">'&lt;'</span>                 -&gt; pushMode(INSIDE) ;</div><div class="line">COMMENT     : <span class="string">'&lt;!--'</span> .*? <span class="string">'--&gt;'</span>    -&gt; skip ;</div><div class="line">EntityRef   : <span class="string">'&amp;'</span> [a-z]+ <span class="string">';'</span> ;</div><div class="line">TEXT        : ~(<span class="string">'&lt;'</span>|<span class="string">'&amp;'</span>)+ ;           <span class="comment">// 匹配任意除 &lt; 和 &amp; 之外的 16 位字符</span></div><div class="line"></div><div class="line"><span class="comment">// ----------------------    所有在标签之内的东西    ----------------------</span></div><div class="line">mode INSIDE;</div><div class="line">CLOSE       : <span class="string">'&gt;'</span>                 -&gt; popMode ;  <span class="comment">// 回到默认模式</span></div><div class="line">SLASH_CLOSE : <span class="string">'/&gt;'</span>                -&gt; popMode ;</div><div class="line">EQUALS      : <span class="string">'='</span> ;</div><div class="line">STRING      : <span class="string">'"'</span> .*? <span class="string">'"'</span> ;</div><div class="line">SlashName   : <span class="string">'/'</span> Name ;</div><div class="line">Name        : ALPHA (ALPHA|DIGIT)* ;</div><div class="line">S           : [ \t\r\n]           -&gt; skip ;</div><div class="line"></div><div class="line">fragment</div><div class="line">ALPHA       : [a-zA-Z] ;</div><div class="line"></div><div class="line">fragment</div><div class="line">DIGIT       : [<span class="number">0</span>-<span class="number">9</span>] ;</div></pre></td></tr></table></figure>
<p>提供一份如下所示的样例输入文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tools</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tool</span> <span class="attr">name</span>=<span class="string">"ANTLR"</span>&gt;</span>A parser generator<span class="tag">&lt;/<span class="name">tool</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tools</span>&gt;</span></div></pre></td></tr></table></figure>
<p>测试步骤与结果如下所示：</p>
<p><img src="/images/antlr/note3/XMLLexer.jpg"></p>
<p>值得一提的是，在上述启动测试组件的命令行中，使用的参数是 XML tokens，在正常情况下，这里应该是一个语法名加一个起始规则名。如果需要令测试组件只运行词法分析器而不运行语法分析器，我们可以指定参数为语法名加上一个特殊的规则名<code>tokens</code>。</p>
<h3 id="重写输入流"><a href="#重写输入流" class="headerlink" title="重写输入流"></a>重写输入流</h3><p>我们可以通过 TokenStreamRewriter 对象对输入流进行修改，然后再加以输出，从而实现对源代码插桩或重构。例如，我们可以通过以下代码实现一个监听器，来给每个类定义中加上一行序列化版本标示符（serialVersionUID）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStream;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStreamRewriter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSerialIDListener</span> <span class="keyword">extends</span> <span class="title">JavaBaseListener</span> </span>&#123;</div><div class="line">    TokenStreamRewriter rewriter;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsertSerialIDListener</span><span class="params">(TokenStream tokens)</span> </span>&#123;</div><div class="line">        rewriter = <span class="keyword">new</span> TokenStreamRewriter(tokens);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterClassBody</span><span class="params">(JavaParser.ClassBodyContext ctx)</span> </span>&#123;</div><div class="line">        String field = <span class="string">"\n\tpublic static final long serialVersionUID = 1L;"</span>;</div><div class="line">        rewriter.insertAfter(ctx.start, field);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后，我们在 main 程序中初始化一个 InsertSerialIDListener，并当遍历结束时打印词法符号流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();  <span class="comment">// 新建一个标准的遍历器</span></div><div class="line">InsertSerialIDListener extractor = <span class="keyword">new</span> InsertSerialIDListener(tokens);</div><div class="line">walker.walk(extractor, tree);  <span class="comment">// 使用监听器初始化对语法分析树的遍历</span></div><div class="line"></div><div class="line"><span class="comment">// 打印出修改后的词法符号流</span></div><div class="line">System.out.println(extractor.rewriter.getText());</div></pre></td></tr></table></figure>
<p>注意，TokenStreamRewriter 实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。因此每次我们调用<code>getText()</code>的时候，rewriter 对象都会执行上述队列中的指令。</p>
<h3 id="将-Tokens-送入不同通道"><a href="#将-Tokens-送入不同通道" class="headerlink" title="将 Tokens 送入不同通道"></a>将 Tokens 送入不同通道</h3><p>语法分析器只处理一个通道，因此当我们想要忽略但保留某些 tokens 时（例如注释和空白字符），我们可以通过在语法文件书写特殊的指令，来将其送入其他通道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">COMMENT</div><div class="line">    :    <span class="string">'/*'</span> .*? <span class="string">'*/'</span>    -&gt; channel(HIDDEN)  <span class="comment">// 匹配 /* 和 */ 之间的任何东西</span></div><div class="line">    ;</div><div class="line">WS  :    [ \r\t\u000c\n]+ -&gt; channel(HIDDEN)</div><div class="line">    ;</div></pre></td></tr></table></figure>
<p><code>-&gt;channel(HIDDEN)</code>和<code>-&gt;skip</code>类似，也是一个词法分析器指令。在这里，它设置了这些 tokens 的通道号。这样，这些 tokens 就会被语法分析器忽略。token 流中仍然保存着这些原始的 tokens 序列，但在向语法分析器提供数据时忽略了那些处于已关闭通道的 tokens。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ANTLR 学习的第三篇笔记到这里就结束了。尽管这一篇笔记很短，但是涵盖了 ANTLR 实践中一些比较现实的问题的解决方式。在了解这三篇笔记所涉及的学习内容后，如果还有兴趣，就可以正式展开对使用 ANTLR 开发语言类应用程序的学习了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习解释器构造和 ANTLR。在系列博文的上一篇 &lt;a href=&quot;http://kyonhuang.top/ANTLR-learning-notes-2/&quot;&gt;ANTLR v4 学习笔记（二）－实现变种计算器&lt;/a&gt;，我们用 ANTLR 实现了一个变种计算器，从而对 ANTLR 语法、访问器（Visitor）机制、集成以及 ANLTR 的错误处理机制有了更深的理解。&lt;/p&gt;
&lt;p&gt;上篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但没有覆盖整个 Chapter 4 的所有内容。因此这篇博文将介绍一下 Chapter 4 的剩余内容——监听器（Listener）机制、代码片段嵌入语法，以及词法分析的一些很棒的特性。&lt;/p&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR v4 学习笔记（二）－实现变种计算器</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-2/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-2/</id>
    <published>2017-09-21T11:25:56.000Z</published>
    <updated>2017-09-23T02:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习解释器构造和 ANTLR。在系列博文的上一篇 <a href="http://kyonhuang.top/ANTLR-learning-notes-1/">ANTLR v4 学习笔记（一）－ANTLR 初体验</a>，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。</p>
<p>我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。</p>
<p>这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。</p>
<a id="more"></a>
<h2 id="计算器描述"><a href="#计算器描述" class="headerlink" title="计算器描述"></a>计算器描述</h2><p>计算器接受四则运算表达式为输入（如下所示）。如果表达式语法正确，则输出计算结果，否则报错，指出错误位置及原因。</p>
<p>例子1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input <span class="number">1</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-a/<span class="number">2</span>;    print(b);    print(a);Output <span class="number">1</span>:    <span class="number">5246.04</span>    <span class="number">3497.36</span></div></pre></td></tr></table></figure>
<p>例子2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input <span class="number">2</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-c/<span class="number">2</span>;    print(b);Output <span class="number">2</span>:    Error(line <span class="number">2</span>,position <span class="number">6</span>): undefined identifier.</div></pre></td></tr></table></figure>
<p>以上两个示例包含了这个计算器的全部特性：</p>
<ol>
<li>每个语句需要以“<code>;</code>”结束；</li>
<li>涉及的操作符只要求加减乘除；支持括号；</li>
<li>操作数为整数或浮点数；</li>
<li>变量不需要先声明，可直接赋值，它的类型由右边表达式的类型决定；每个变量在使用之前必须要已经有赋值；</li>
<li>变量名可以是由数字和字母组成，但首字符必须是字母； </li>
<li>输出语句使用<code>print()</code>函数，输出并换行；</li>
<li><code>print()</code>函数不仅可以输出变量，还可以直接输出表达式的值，例如<code>print(1+2)</code>；</li>
<li>尽量考虑周全，顾及corner cases。例如除零；</li>
<li>程序不需要 GUI，接受一个源文件路径为命令行参数。</li>
</ol>
<h2 id="匹配运算表达式的语法"><a href="#匹配运算表达式的语法" class="headerlink" title="匹配运算表达式的语法"></a>匹配运算表达式的语法</h2><p>在经过之前的学习后，我们可以比较轻松地写出一份匹配运算表达式的 ANTLR 语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a grammar called Calculator</div><div class="line"> */</div><div class="line">grammar Calculator;</div><div class="line">// 程序起始规则，语法分析的起点</div><div class="line">program : stat+;</div><div class="line"></div><div class="line">stat: define NEWLINE?            # defineStat</div><div class="line">    | print NEWLINE?             # printStat</div><div class="line">    | NEWLINE                    # blank</div><div class="line">    ;</div><div class="line">// 声明</div><div class="line">define: VAR '=' expr ';';</div><div class="line">// 计算表达式</div><div class="line">expr: expr op=('*'|'/') expr     # MulDiv </div><div class="line">     | expr op=('+'|'-') expr    # AddSub</div><div class="line">     | '('expr')'                # parens</div><div class="line">     | NUMBER                    # number</div><div class="line">     | VAR                       # var</div><div class="line">     ;</div><div class="line"></div><div class="line">// 输出</div><div class="line">print: 'print''('VAR')'';'       # printVAR</div><div class="line">      | 'print''('expr')'';'     # printExpr </div><div class="line">      ;</div><div class="line">// 操作数类别</div><div class="line">NUMBER: INT|FLOAT;</div><div class="line">VAR : [a-zA-Z][a-zA-Z0-9]*;</div><div class="line">INT : [0-9]+;</div><div class="line">FLOAT : [0-9]+'.'[0-9]+;</div><div class="line">NEWLINE: '\r'? '\n'? ;</div><div class="line">WS : [ \t]+ -&gt; skip;</div><div class="line">MUL : '*' ;  </div><div class="line">DIV : '/' ;  </div><div class="line">ADD : '+' ;  </div><div class="line">SUB : '-' ;</div></pre></td></tr></table></figure>
<p>这份语法有一些值得注意的地方：</p>
<ul>
<li>语法分析器的规则以小写字母开头；</li>
<li>词法分析器的规则以大写字母开头；</li>
<li>我们使用<code>|</code>来分隔同一个语言规则的若干备选分支，并使用圆括号把一些符号组合成子规则；</li>
<li>WS 词法规则中，<code>-&gt; skip</code>是一条指令，告诉词法分析器匹配并丢弃空白字符；</li>
<li>你也许会注意到一些<code>#</code>开头的标签。如果备选分支上没有标签，ANTLR 就只为每条规则生成一个方法；</li>
<li>我们为运算符等词法符号定义了一些名字，这样，在之后访问器的编写中，我们可以将这些词法符号的名字当作常量使用，使代码更加清晰。</li>
</ul>
<p>现在我们已经可以通过 ANTLR 内置的测试组件来进行测试。由于 Eclipse 的最新版本 ANTLR 插件里的 ANTLR 版本仍然是 4.4（官网的 ANTLR 包已到 4.7 版本），所以我们还是自己通过命令行生成 java 文件并编译：</p>
<p><img src="/images/antlr/note2/cal1.jpg"></p>
<p>添加的<code>-gui</code>参数使我们可以看到关于输入的语法分析树：</p>
<p><img src="/images/antlr/note2/caltree.jpg"></p>
<p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复。例如，我们的输入少一个<code>;</code>，语法分析器会自动输出错误信息：</p>
<p><img src="/images/antlr/note2/cal1-error.jpg"></p>
<p>添加<code>-gui</code>参数生成的可视化语法分析树会将错误节点自动标红：</p>
<p><img src="/images/antlr/note2/caltree-error.jpg"></p>
<h3 id="语法优化"><a href="#语法优化" class="headerlink" title="语法优化"></a>语法优化</h3><p>这里的“优化”不是指对语法本身，而是对 ANTLR 语法文件，即<code>.g4</code>作为扩展名的文件。ANTLR 允许我们将非常大的语法拆分为多个部分，根据习惯，我们将其分为语法分析器的语法和词法分析器的语法两部分。</p>
<p>这样做的好处是对于两种词法规则或者语法规则相同的语言，我们可以复用这些“模块”来构建语法分析器。</p>
<p>词法规则文件 CalculatorLexerRules.g4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意开头是 "lexer grammer"</span></div><div class="line">lexer grammar CalculatorLexerRules;</div><div class="line"></div><div class="line"><span class="comment">// 操作数类别</span></div><div class="line">NUMBER: INT|FLOAT;</div><div class="line">VAR : [a-zA-Z][a-zA-Z0-<span class="number">9</span>]*;</div><div class="line">INT : [<span class="number">0</span>-<span class="number">9</span>]+;</div><div class="line">FLOAT : [<span class="number">0</span>-<span class="number">9</span>]+<span class="string">'.'</span>[<span class="number">0</span>-<span class="number">9</span>]+;</div><div class="line">NEWLINE: <span class="string">'\r'</span>? <span class="string">'\n'</span>? ;</div><div class="line">WS : [ \t]+ -&gt; skip;</div><div class="line">MUL : <span class="string">'*'</span> ;  </div><div class="line">DIV : <span class="string">'/'</span> ;  </div><div class="line">ADD : <span class="string">'+'</span> ;  </div><div class="line">SUB : <span class="string">'-'</span> ;</div></pre></td></tr></table></figure>
<p>语法规则文件 CalculatorExpr.g4，之前语法中的词法规则全部通过 import 语句导入：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a grammar called CalculatorExpr</div><div class="line"> */</div><div class="line">// 注意 grammer 要和文件名相同</div><div class="line">grammar CalculatorExpr;</div><div class="line">// 引入词法规则</div><div class="line">import CalculatorLexerRules;</div><div class="line">// 程序起始规则，语法分析的起点</div><div class="line">program : stat+;</div><div class="line"></div><div class="line">stat: define NEWLINE?            # defineStat</div><div class="line">    | print NEWLINE?             # printStat</div><div class="line">    | NEWLINE                    # blank</div><div class="line">    ;</div><div class="line">// 声明</div><div class="line">define: VAR '=' expr ';';</div><div class="line">// 计算表达式</div><div class="line">expr: expr op=('*'|'/') expr     # MulDiv </div><div class="line">     | expr op=('+'|'-') expr    # AddSub</div><div class="line">     | '('expr')'                # parens</div><div class="line">     | NUMBER                    # number</div><div class="line">     | VAR                       # var</div><div class="line">     ;</div><div class="line"></div><div class="line">// 输出</div><div class="line">print: 'print''('VAR')'';'       # printVAR</div><div class="line">      | 'print''('expr')'';'     # printExpr </div><div class="line">      ;</div></pre></td></tr></table></figure>
<p>要生成 java 文件，我们只需要对语法文件使用<code>antlr4</code>命令即可。这样我们就得到了和之前一样的 java 文件（测试就不贴图了）：</p>
<p><img src="/images/antlr/note2/import-java.jpg"></p>
<p>import 语句赋予我们编写模块化语法的能力，这使得 ANTLR 语法文件的耦合度降低，复用性提高。</p>
<h2 id="使用-Visitor-构建计算器"><a href="#使用-Visitor-构建计算器" class="headerlink" title="使用 Visitor 构建计算器"></a>使用 Visitor 构建计算器</h2><p>我们最终的目的是将生成的语法分析器集成到程序中，因此我们需要写一些 Java 代码。我们会用 Visitor（访问者模式）来实现我们的变种计算器。</p>
<p>由于我的实现代码基于 Calculator.g4 生成的 java 文件，而非拆分后的 CalculatorExpr.g4，所以之后的文件名、类名和方法名还是会以 Calculator 开头。当然，所有功能都是相同的，使用哪份语法文件生成的 java 文件都不会有影响。</p>
<p>我们通过以下命令来让 ANTLR 生成 Visitor 而非 Listener：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antlr4 -no-listener -visitor -encoding UTF-8 Calculator.g4</div></pre></td></tr></table></figure>
<p>这样，ANTLR 会自动生成一个访问器接口文件 CalculatorVisitor.java，以及该访问器的一个默认实现类 CalculatorBaseVisitor。实现时，我们需要自己写一个 Visitor 的子类，继承<br>CalculatorBaseVisitor<float>（这样表达式的计算结果都是浮点数），并重写其中的方法，以实现变量键值对存储、计算、打印等需求。</float></p>
<p>以下是我们实现的 Visitor 子类 MainVisitor 的完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainVisitor</span> <span class="keyword">extends</span> <span class="title">CalculatorBaseVisitor</span>&lt;<span class="title">Float</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 声明一个 map，存放变量与值的键值对</span></div><div class="line">    Map&lt;String, Float&gt; memory = <span class="keyword">new</span> HashMap&lt;String, Float&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * define: VAR '=' expr ';';</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitDefine</span><span class="params">(CalculatorParser.DefineContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">float</span> value = visit(ctx.expr());</div><div class="line">        memory.put(var, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * expr op=('*'|'/') expr</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitMulDiv</span><span class="params">(CalculatorParser.MulDivContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</div><div class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.MUL)</div><div class="line">            <span class="keyword">return</span> left * right;</div><div class="line">        <span class="keyword">return</span> left / right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * expr op=('+'|'-') expr</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitAddSub</span><span class="params">(CalculatorParser.AddSubContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</div><div class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.ADD)</div><div class="line">            <span class="keyword">return</span> left + right;</div><div class="line">        <span class="keyword">return</span> left - right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * NUMBER</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitNumber</span><span class="params">(CalculatorParser.NumberContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Float.valueOf(ctx.NUMBER().getText());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * VAR</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitVar</span><span class="params">(CalculatorParser.VarContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">if</span> (memory.containsKey(var))</div><div class="line">            <span class="keyword">return</span> memory.get(var);</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>) <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * '('expr')'</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitParens</span><span class="params">(CalculatorParser.ParensContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> visit(ctx.expr());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * print: ('print''('VAR')'';');</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintVAR</span><span class="params">(CalculatorParser.PrintVARContext ctx)</span> </span>&#123;</div><div class="line">        String var = ctx.VAR().getText();</div><div class="line">        <span class="keyword">if</span> (memory.containsKey(var))</div><div class="line">            System.out.println(memory.get(var));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            System.err.println(<span class="string">"undefined identifier"</span>);</div><div class="line">        <span class="keyword">return</span> visitChildren(ctx);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * print: ('print''('expr')'';');</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> </span>&#123;</div><div class="line">        System.out.println(visit(ctx.expr()));</div><div class="line">        <span class="keyword">return</span> visitChildren(ctx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我们需要写一个 Calculator.java 来新建所需要的所有对象，并针对 program 规则启动语法分析器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        </div><div class="line">        String inputFile = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Usage:\n\tjava -jar Calculator.jar [sourceFile]"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</div><div class="line">            inputFile = args[<span class="number">0</span>];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.err.println(<span class="string">"The file path cannot be recognized"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        InputStream instream = System.in;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(inputFile != <span class="keyword">null</span>)</div><div class="line">            instream = <span class="keyword">new</span> FileInputStream(inputFile);</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(instream);</div><div class="line">        <span class="comment">// 新建词法分析器对象</span></div><div class="line">        CalculatorLexer lexer = <span class="keyword">new</span> CalculatorLexer(input);</div><div class="line">        <span class="comment">// 新建词法符号流管道</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        <span class="comment">// 新建语法分析器对象</span></div><div class="line">        CalculatorParser parser = <span class="keyword">new</span> CalculatorParser(tokens);</div><div class="line">        <span class="comment">// 启动语法分析器，从 program 规则开始进行语法分析</span></div><div class="line">        ParseTree tree = parser.program();</div><div class="line">        </div><div class="line">        MainVisitor cal = <span class="keyword">new</span> MainVisitor();</div><div class="line">        </div><div class="line">        cal.visit(tree);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，现在我们的变种计算器就有了一个初步版本。打包成 jar 包后，我们可以看一下效果：</p>
<p><img src="/images/antlr/note2/Calculator-effect.jpg"></p>
<p>我觉得可以。</p>
<h2 id="继续完善"><a href="#继续完善" class="headerlink" title="继续完善"></a>继续完善</h2><p>那么这时候，一般就会有人跳出来说：“我觉得不行。我觉得很普通。”</p>
<p>其实我也是这么认为的（阿黄真的很严格！）。</p>
<p>实际上，我们这个计算器还有一些需要继续完善的地方。比如下面这种情况：</p>
<p><img src="/images/antlr/note2/exception.jpg"></p>
<p>可以看到并未赋值的变量 c 被当作 0。然而在我们的要求中，这样的变量应该当作未初始化，使用时要报错。另外，当被除数为 0 时，输出的结果会是 “Infinity”，而我们还是希望这种情况发生时会报错。以上情况说明<strong>我们定义的语法没有覆盖到所有设想中的错误</strong>。</p>
<p>另外，ANTLR 自带的错误报告采用以下的语句，基本算是直接输出了行号、错误信息等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.err.println(<span class="string">"line "</span> + line + <span class="string">":"</span> + charPositionInLine + <span class="string">" "</span> + msg);</div></pre></td></tr></table></figure>
<p>说实话，不是很显眼。我还是喜欢错误报告开头有一些比较明显的标示，比如<code>Error(line 2,position 6): undefined identifier</code>感觉就要好一些。</p>
<p>不幸的是，Chapter 4 尚未涉及到 ANTLR 的错误处理机制。这部分内容在 Chapter 9 Error Reporting and Recovery 中。为了不用麻烦糖糖先记着，我们不妨先对这部分内容进行一些学习。</p>
<h3 id="错误报告格式优化"><a href="#错误报告格式优化" class="headerlink" title="错误报告格式优化"></a>错误报告格式优化</h3><p>先从错误报告格式优化开始。ANTLR 的错误报告通过 ANTLRErrorListener 接口，由 ConsoleErrorListener 实现，输出信息比较简单。</p>
<p>ANTLRErrorListener 包含四个方法：<strong>syntaxError</strong>、reportAmbiguity、reportAttemptingFullContext、reportContextSensitivity。其中 syntaxError 顾名思义用于处理语法错误，而后三个用于二义性处理。</p>
<p>ANTLR 也内置了一些 ANTLRErrorListener 的实现。除开默认采用的 ConsoleErrorListener，还有一个空实现 <strong>BaseErrorListener</strong>。我们可以 new 一个 BaseErrorListener 来自定义一些错误的处理方法，然后通过 addErrorListener 把它添加到语法分析器上。</p>
<p>根据以上思路，我们可以在 Calculator.java 中新建语法分析器对象的语句后加上几行代码，用于移除 ANTLR 默认的错误处理，以及添加一个我们自定义的错误监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除默认的错误处理</span></div><div class="line">parser.removeErrorListeners();</div><div class="line"><span class="comment">// 添加自定义错误监听器</span></div><div class="line">parser.addErrorListener(<span class="keyword">new</span> BaseErrorListener() &#123;</div><div class="line">    <span class="comment">//出现语法错误</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syntaxError</span><span class="params">(Recognizer&lt;?, ?&gt; recognizer, Object offendingSymbol, <span class="keyword">int</span> line, <span class="keyword">int</span> charPositionInLine, String msg, RecognitionException e)</span> </span>&#123;</div><div class="line">        System.err.println(<span class="string">"Error(line "</span> + line + <span class="string">", position "</span> + charPositionInLine + <span class="string">"): "</span> + msg);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在的错误报告看起来就更加有条理了：</p>
<p><img src="/images/antlr/note2/newErrorReport.jpg"></p>
<h3 id="部分错误特例的处理方式"><a href="#部分错误特例的处理方式" class="headerlink" title="部分错误特例的处理方式"></a>部分错误特例的处理方式</h3><p>不幸的是，读完了 Chapter 9，我仍然没有找到关于调用未初始化变量、被除数为 0 时报错应该怎么写。<br>现在我的权宜之计是直接<code>System.err.println</code>，也就是跳过错误机制。由于上下文对象会记录根据规则识别词组时产生的所有信息，可以通过<code>ctx.start.getLine()</code>获得<code>ctx.start.getCharPositionInLine()</code>错误出现的行数和行内具体位置。</p>
<p><img src="/images/antlr/note2/undefined-error.jpg"></p>
<p>可以看到所显示的位置好像并不是特别准确，个人认为是 ctx 给出的位置会追溯到所在规则开始的地方。也许随着学习更加深入，我会找到比较优雅的实现方法。</p>
<h2 id="计算器运行截图"><a href="#计算器运行截图" class="headerlink" title="计算器运行截图"></a>计算器运行截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-952930bcab492aee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-891de540a356c539.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result2.jpg"></p>
<h2 id="计算器实现中遇到的问题"><a href="#计算器实现中遇到的问题" class="headerlink" title="计算器实现中遇到的问题"></a>计算器实现中遇到的问题</h2><p>实现这个变种计算器的过程当然也不是一帆风顺的，尤其我是先动手摸索再看的 Chapter 4。以下几个小坑可能还会有新司机踩上，特此写明：</p>
<ul>
<li>开始的语法写输出语句为<code>print: (&#39;print&#39;&#39;(&#39;VAR|expr&#39;)&#39;&#39;;&#39;);</code>没有在<code>VAR|expr</code>外加一层括号，导致后续开发匹配错误。当然，我认为现在开两个备选分支的写法应该更好。</li>
<li>第一次实现时，没有给备选分支加上标签，之后实现 Visitor 时很多方法就需要自己写 if 判断，十分麻烦。通过标签来对每种输入都获得一个不同的事件是坠吼的。</li>
<li>开始的语法写的是<code>WS : [ \t\r\n]+ -&gt; skip;</code>。后来测试时感觉直接跳过换行符好像有时对错误定位会有影响，于是改成现在的样子。</li>
</ul>
<h2 id="我对-ANTLR-的理解"><a href="#我对-ANTLR-的理解" class="headerlink" title="我对 ANTLR 的理解"></a>我对 ANTLR 的理解</h2><p>那么到现在为止，我已经使用 ANTLR 写了几个示例，并完成了一个小项目。经过实际体验，ANTLR 真的可以使我们开发语言类应用程序时，少做很多繁琐的工作。</p>
<p>只要输入一份合法的语法（当然用户需要自行保证语法的准确性），无论多复杂，ANTLR 的语法分析器都能够自动识别，并在运行时以<strong>动态方式</strong>对语法执行分析。相比静态分析必须考虑所有可行的输入序列，动态分析使得我们不必为了适应底层的语法分析策略而扭曲我们语法，从而省略了很多不必要的工作。这是 ANTLR 4 相比其他语法分析器的一个很大的优势。</p>
<p>举个例子，选择使用 ANTLR 进行编译相关的开发工作有一个重要的原因，是它能够自动处理直接左递归（间接左递归暂时不能够）。</p>
<p>我们知道，左递归指某个语言规则在某个备选分支的起始位置调用了自身。由于含有左递归的文法必然不是 LL(1) 文法，也就不可能使用确定的自顶向下分析法。然而，允许使用左递归的文法来表示语言规则又要简洁的多。ANTLR 可以将直接左递归规则自动重写为等价的非左递归形式，省却了不少麻烦。</p>
<p>此外，ANLTR 语法文件独立于程序。在生成的所需的语法分析器之后，我们只需要用熟悉的 Java 来实现我们所需要的语法分析树遍历器（重写部分方法），以符合我们的要求即可。不需要自己去写词法分析器、语法分析器，ANLTR 大大降低了语言类应用程序开发的门槛。</p>
<p>当然，无论工具有多方便，终究只能帮助人完成事务、减少工作量，而非完全替代。想要使用好 ANTLR，还是得对编译原理有透彻的理解。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ANTLR 学习的第二篇笔记到这里就结束了。在这之后我会继续学习解释器构造，阅读《The Definitive ANTLR 4 Reference》，并博客上持续记录学习过程中的一点心得。敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/yuexiang321/article/details/52770283" target="_blank" rel="external">antlr入门实例——计算器 - Yue Xiang - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习解释器构造和 ANTLR。在系列博文的上一篇 &lt;a href=&quot;http://kyonhuang.top/ANTLR-learning-notes-1/&quot;&gt;ANTLR v4 学习笔记（一）－ANTLR 初体验&lt;/a&gt;，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。&lt;/p&gt;
&lt;p&gt;我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。&lt;/p&gt;
&lt;p&gt;这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。&lt;/p&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>yuki-目录文档生成工具</title>
    <link href="http://kyonhuang.top/yuki-intro/"/>
    <id>http://kyonhuang.top/yuki-intro/</id>
    <published>2017-09-14T13:56:35.000Z</published>
    <updated>2017-09-14T15:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。<br>——沃兹基硕德</p>
</blockquote>
<p>受到掘金上看到的 <a href="https://github.com/kenshinji/yddict" target="_blank" rel="external">yddict：一个命令行查单词的工具</a> 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。</p>
<p>看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 <a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a>，蕴含了我个人满满的宅趣味。</p>
<p><img src="/images/yuki/Yuki.jpg"></p>
<p>幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。</p>
<p>这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。</p>
<a id="more"></a>
<h2 id="关于-yuki"><a href="#关于-yuki" class="headerlink" title="关于 yuki"></a>关于 yuki</h2><p>使用 Node.js 开发的项目目录管理工具，能够将项目内文件结构自动映射并生成为 README.md</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/yuki/master/example.gif"></p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">bighuang624/yuki</a></p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>当一份 README.md 的主体内容是项目目录，而你又厌倦了每次增加、修改、删除项目中文件时都要对 README 进行维护，那么不妨试试 yuki！</p>
<p>它可以在极短时间内帮你生成符合要求的 README.md 文档。你更可以通过配置一份 yuki.config.json 来满足你的以下需求：</p>
<ul>
<li>固定文档标题</li>
<li>目录前后增加固定内容</li>
<li>映射时忽略指定文件夹、文件、扩展名</li>
<li>根据指定扩展名选择是否去掉文件名的扩展名或加上书名号</li>
<li>让每个文件都带上 Github 的链接以方便在线跳转查看</li>
</ul>
<p>你可以用 yuki 帮助你轻松维护 github 上类似博客、笔记、代码汇总等项目！</p>
<h3 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h3><p>我的<a href="https://github.com/bighuang624/Algorithms-notes" target="_blank" rel="external">《算法》笔记及代码</a>项目的 README.md 完全通过 yuki 生成。你可以点击以查看效果。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>请确认你使用的电脑有 Node 环境，越新越好。</p>
<h4 id="安装-yuki"><a href="#安装-yuki" class="headerlink" title="安装 yuki"></a>安装 yuki</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g yuki</div></pre></td></tr></table></figure>
<h4 id="进入需要生成-README-md-的文件夹"><a href="#进入需要生成-README-md-的文件夹" class="headerlink" title="进入需要生成 README.md 的文件夹"></a>进入需要生成 README.md 的文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 请将 &lt;dirname&gt; 换为文件夹路径</span></div><div class="line"><span class="built_in">cd</span> &lt;dirname&gt;</div></pre></td></tr></table></figure>
<h4 id="创建-yuki-config-json（可选）"><a href="#创建-yuki-config-json（可选）" class="headerlink" title="创建 yuki.config.json（可选）"></a>创建 yuki.config.json（可选）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch yuki.config.json</div></pre></td></tr></table></figure>
<h4 id="配置-yuki-config-json（可选）"><a href="#配置-yuki-config-json（可选）" class="headerlink" title="配置 yuki.config.json（可选）"></a>配置 yuki.config.json（可选）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  // README.md的大标题（h1），默认为所在文件夹名</div><div class="line">  &quot;title&quot;: &quot;《算法（第4版）》笔记及代码&quot;,</div><div class="line">  // github库地址，如果配置了这项会给每个文件加上超链接</div><div class="line">  // 如果配置，请保证index填写无误，且所有文件名不含空格（否则链接无法正确表示）</div><div class="line">  // branch默认为master</div><div class="line">  &quot;repository&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;https://github.com/bighuang624/Algorithms-notes&quot;,</div><div class="line">    &quot;branch&quot;: &quot;master&quot;</div><div class="line">  &#125;,</div><div class="line">  // 目录开始的标题等级</div><div class="line">  // 默认为2，即该目录下的文件夹名等级从3开始，随层级深入递减</div><div class="line">  &quot;startLevel&quot;: 2,</div><div class="line">  // 需要忽略的目录、扩展名和文件，都以数组表示</div><div class="line">  &quot;ignore&quot;: &#123;</div><div class="line">    &quot;dir&quot;: [&quot;.git&quot;],</div><div class="line">    &quot;extname&quot;: [&quot;.json&quot;],</div><div class="line">    &quot;file&quot;: [</div><div class="line">      &quot;yuki.config.json&quot;,</div><div class="line">      &quot;.gitignore&quot;,</div><div class="line">      &quot;README.md&quot;,</div><div class="line">      &quot;.DS_Store&quot;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  // 根据扩展名选择对展示的文件名做一些处理</div><div class="line">  // 每个扩展名的配置需要单独一个对象</div><div class="line">  // 目前支持省略扩展名&quot;withoutExt&quot;: true</div><div class="line">  // 和加上书名号&quot;withBookmark&quot;: true</div><div class="line">  &quot;format&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;extname&quot;: &quot;.md&quot;,</div><div class="line">      &quot;withoutExt&quot;: true,</div><div class="line">      &quot;withBookmark&quot;: true</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  // 在大标题之后，目录之前添加的内容</div><div class="line">  // 每个对象可选择包含标题、标题等级和内容</div><div class="line">  // 其中，标题和标题等级需在一个对象中一同填写</div><div class="line">  &quot;prefix&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;content&quot;: &quot;[![作者](https:\//img.shields.io\/badge/%E4%BD%9C%E8%80%85-KyonHuang-7AD6FD.svg)](http:\//kyonhuang.top)&quot;</div><div class="line">    &#125;, &#123;</div><div class="line">      &quot;title&quot;: &quot;目录&quot;,</div><div class="line">      &quot;level&quot;: &quot;2&quot;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  // 在README.md末尾添加的内容</div><div class="line">  // 和prefix相同，每个对象可选择包含标题、标题等级和内容</div><div class="line">  &quot;append&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;title&quot;: &quot;维护&quot;,</div><div class="line">      &quot;level&quot;: &quot;2&quot;,</div><div class="line">      &quot;content&quot;: &quot;本文档由 [yuki](https://github.com/bighuang624/yuki) 维护&quot;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 JSON 标准中不含注释，请在使用时将注释去掉。项目中也提供一份不带注释、可供修改使用的 yuki.config.json 模版。</p>
<p>不需要的配置选项请全部删除。</p>
<h4 id="创建-README-md"><a href="#创建-README-md" class="headerlink" title="创建 README.md"></a>创建 README.md</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yuki</div></pre></td></tr></table></figure>
<h3 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h3><p><a href="https://github.com/bighuang624/yuki/blob/master/LICENSE" target="_blank" rel="external">Apache License 2.0</a></p>
<h2 id="开发中的那些事"><a href="#开发中的那些事" class="headerlink" title="开发中的那些事"></a>开发中的那些事</h2><h3 id="Cli-命令工具开发的准备工作"><a href="#Cli-命令工具开发的准备工作" class="headerlink" title="Cli 命令工具开发的准备工作"></a>Cli 命令工具开发的准备工作</h3><p>我们来了解一下围绕 NPM 开发的准备工作。第一步自然是在文件夹下使用命令<code>npm init</code>生成 package.json 文件。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>可以通过以下命令在 NPM 资源库中注册用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm adduser</div></pre></td></tr></table></figure>
<p>之后跟着要求填写 Username、Password、Email 就 ok 了。项目发布前可能需要<code>npm login</code>一下。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>NPM 使用语义版本号来管理代码。语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：</p>
<ul>
<li>如果只是修复 bug，需要更新 Z 位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新 Y 位。</li>
<li>如果有大变动，向下不兼容，需要更新 X 位。</li>
</ul>
<p>当然我这个小项目比较随便，bug 修的多了次版本号看心情也往上升一次。</p>
<p>你可以用<code>npm view &lt;pkg&gt; version</code>来查看你发布到 NPM 项目的现在版本号。</p>
<h4 id="测试小窍门"><a href="#测试小窍门" class="headerlink" title="测试小窍门"></a>测试小窍门</h4><p>这两个小窍门可以节省你在一边开发一边测试的时间（没发现之前，3 天的开发时间花在这上面的不少…）。</p>
<ul>
<li><p>在 package.json 所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;pkg&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
</ul>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><p>想要在全局使用你编写的 cli 工具，你需要在 package.json 加一个 bin 属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"bin": &#123;</div><div class="line">  "yuki": "./index.js"</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>yuki 换做你启动这个程序所要在命令行输入的命令。属性的值是项目的入口文件。添加这个属性后，在命令行执行<code>yuki</code>就等同于执行<code>node ./index.js</code>。</p>
<h4 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h4><p>项目写了一个版本准备发布，先在 package.json 所在目录下用<code>npm version</code>看一下版本号，然后就可以 publish 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> yuki</div><div class="line">npm version</div><div class="line">npm publish</div></pre></td></tr></table></figure>
<p>之后就可以通过全局安装来使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g yuki</div></pre></td></tr></table></figure>
<h3 id="获得程序运行的路径"><a href="#获得程序运行的路径" class="headerlink" title="获得程序运行的路径"></a>获得程序运行的路径</h3><p>说实话，一个我很不擅长的东西就是 API，哪怕是那些非常常用的。这次我一开始就遇到了麻烦：如何获得程序开始遍历的“根目录”路径？</p>
<p>在查找的同时顺便了解了一下获得各种路径的方法，有以下几种：</p>
<ul>
<li><p><code>process.cwd()</code>获得 Node.js 进程当前工作的路径（即执行命令行时候的路径，而非代码路径。例如在根目录下执行<code>node ./xxx/xxx/example.js</code>，则<code>process.cwd()</code>返回的是根目录地址）；</p>
</li>
<li><p><code>__dirname</code>: 获得代码存放的位置（例如运行位于<code>/usr/a</code>目录下的<code>example.js</code>文件：<code>node example.js</code>，则<code>__dirname</code>返回<code>/usr/a</code>）；</p>
</li>
<li><p><code>process.execPath</code>: 返回返回启动 Node.js 进程的可执行文件所在的绝对路径（也就是当前执行的 Node 自身的路径，例如：<code>/usr/local/bin/node</code>）。</p>
</li>
</ul>
<p>根据查询结果和实际需求，应该使用<code>process.cwd()</code>（我们要求在 package.json 所在目录下使用 yuki）。不过实际上使用的是<code>path.resolve()</code>。<code>path.resolve()</code>不含参数时，返回返回当前工作目录的绝对路径，也符合要求。</p>
<p>yuki 的编写也帮助我熟悉了 Node 里的很多 API，尤其是和 path 和 fs 相关的。</p>
<h3 id="先遍历文件再深度遍历文件夹"><a href="#先遍历文件再深度遍历文件夹" class="headerlink" title="先遍历文件再深度遍历文件夹"></a>先遍历文件再深度遍历文件夹</h3><p>开发的过程中发现一个问题：遍历文件夹 a 下的所有文件时，经常先深度遍历了其中的文件夹，导致文件排在这些文件夹深度遍历的结果之后，在生成的 README 中无法看出其准确位置。</p>
<p>解决方法还比较简单，就是在每一次递归的遍历方法中都建立一个队列，遍历到文件夹先推入队列，遍历到文件则展示。所有文件遍历结束后，将队列中的文件夹依次取出并遍历。这样既满足了要求，也没有对深度优先遍历造成影响。</p>
<p>更好的是，JS 的数组原生支持了<code>push</code>方法，使得我不用再写一个队列的实现。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管只是一个微不足道的小工具，我还是很开心能够根据自己的实际需求开发了 yuki，更开心有机会开发一个能在名字中夹私货的项目（早在看到 vue 的版本名时我就一直心心念念了）。</p>
<p>如果你觉得这个小工具还不错，或者使用时觉得很方便、减轻了重复的工作负担，那么不妨为 <a href="https://github.com/bighuang624/yuki" target="_blank" rel="external">yuki</a> 点一个 star，因为我憧憬着能在毕业前拥有一个自己的 100+ star 项目。</p>
<p><img src="/images/yuki/give-him-first.jpg"></p>
<p>当然，我更希望这些 star 是凭借我自己的开发创意和技术所得到的认可的。而我的开发经验确实不太足，所以如果你觉得这个工具不太好使、代码糟糕、发现了 bug，或是有可以增加的功能，也欢迎你开 issue 或者提交 PR 来告知我。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。&lt;br&gt;——沃兹基硕德&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;受到掘金上看到的 &lt;a href=&quot;https://github.com/kenshinji/yddict&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yddict：一个命令行查单词的工具&lt;/a&gt; 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。&lt;/p&gt;
&lt;p&gt;看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 &lt;a href=&quot;https://github.com/bighuang624/yuki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yuki&lt;/a&gt;，蕴含了我个人满满的宅趣味。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/yuki/Yuki.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。&lt;/p&gt;
&lt;p&gt;这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="开源小项目" scheme="http://kyonhuang.top/categories/%E5%BC%80%E6%BA%90%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="yuki" scheme="http://kyonhuang.top/tags/yuki/"/>
    
      <category term="NPM" scheme="http://kyonhuang.top/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s start Python!</title>
    <link href="http://kyonhuang.top/lets-start-Python/"/>
    <id>http://kyonhuang.top/lets-start-Python/</id>
    <published>2017-09-11T15:03:19.000Z</published>
    <updated>2017-09-20T11:20:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！</p>
<p>今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，Python 这方面的生态环境还是要比 Node 强大不少。当然我也希望不丢掉之前的 JS 和 Node 基础，要时常写点东西或者看看书保持状态。</p>
<p>顺便谈一下，朱老师让我学 Python 2.7，大概是有一些历史遗留问题。但是我在知乎上查了一下，还是决定先看廖雪峰 3.x 版本的 Python 教程。我觉得知乎里一个回答给的建议不错，摘抄一下：</p>
<ul>
<li>学习 Python 前，先了解在 Python 3 里面已经弃用的 Python 2 语法，对这些部分简单带过不要花太多时间；</li>
<li>使用 Python 2，不要使用 Python 2.7 以前的版本；</li>
<li>使用 Python 3，不要使用 Python 3.4 以前的版本；</li>
<li>多了解 Python 2 的<code>__future__</code>库；</li>
<li>对同一份代码，不要为 Python 2 和 Python 3 分别维护分支，努力在一套代码中兼容 Python 2 和 Python 3。</li>
</ul>
<p>根据以上建议，我在 Anaconda 配置了 2.7.13 和 3.6.0 的两种版本。当然这份回答里最重要的还有一句话：</p>
<p><strong>stop talking, just do it！</strong></p>
<p>这一篇大概就讲这么些废话。人生苦短，我用 Python，常听到这句话，现在我就来体验啦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！&lt;/p&gt;
&lt;p&gt;今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，P
    
    </summary>
    
      <category term="程序员的生活" scheme="http://kyonhuang.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://kyonhuang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="http://kyonhuang.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR v4 学习笔记（一）－ANTLR 初体验</title>
    <link href="http://kyonhuang.top/ANTLR-learning-notes-1/"/>
    <id>http://kyonhuang.top/ANTLR-learning-notes-1/</id>
    <published>2017-09-06T07:34:19.000Z</published>
    <updated>2017-12-20T12:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。</p>
<p>课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。</p>
<p>ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。</p>
<p>更新记录：</p>
<ul>
<li>17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布</li>
<li>17.09.11 Chapter 3 阅读完毕，增加动手上路章节。</li>
<li>17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译</li>
</ul>
<a id="more"></a>
<h2 id="我对编译技术的认识"><a href="#我对编译技术的认识" class="headerlink" title="我对编译技术的认识"></a>我对编译技术的认识</h2><p>在正式进行 ANTLR 的学习前，先让我们聊一聊在经过上学期《编译技术及应用》的学习，以及查阅了有关资料后，我对编译技术和编译工具的一点认识。</p>
<p>说实话，如果单单是谈在《编译技术及应用》这门课上的认识的话，我可能只能像孔乙己一样，接连便是难懂的话，什么“上下文无关文法”，什么“LL(1)”，引得各位都哄笑起来，屏幕内外充满了快活的空气…  </p>
<p>尽管经过了计算器和 JSONCompiler 两次实验，但我们可能对编译技术的应用还没有什么认识，觉得编译器的唯一用处就是写一个能把 xx 语言翻译成 xx 然后再运行成功…</p>
<p>基于写这篇博文的契机，我查了一下编译技术的各种应用，才发现其实“编译”这个概念应用还是很广泛的。</p>
<p>比如我的博客是用 hexo 这个博客框架搭建的，而你现在看到的这篇博文是 hexo 将我写的 markdown 文件解析成 html 生成的，这其中自然有编译模块的功劳。</p>
<p>再比如作为一个前端，有不少我使用过或日常接触的工具、框架其实都是编译相关知识的应用：Babel 作为 ES 6 的所有新特性还没有在主流浏览器全面推广的一个暂时的解决方法，将 ES 6 编译成 ES 5 等浏览器能够运行的 JavaScript 代码；在 Vue 中频繁出现的模版引擎、<code>v-for=&quot;item in list&quot;</code>等也有编译的身影。如果真正对编译原理理解透彻，大概可以去摸摸 v8 ，帮助提高一下 Node.js 的运行效率。</p>
<p>编程，本质上是程序员通过语言来控制计算机按照人的意志去进行各种运算和操作。自 20 世纪 50 年代早期，第一个只能进行单目运算的编译程序诞生起，编译技术一直作为人与计算机之间的传声筒，支撑着计算机语言的发展，使其更加系统化、合理化。</p>
<p>在知乎上“编译原理学了有什么用？”这个提问下，有答主贴了一幅《C 编译器解剖》序的照片，其中有一段话：</p>
<blockquote>
<p>操作系统和编译器就如武侠小说中的“九阴真经”，没看过“九阴真经”的侠客也可以行走江湖，但看过并练成九阴真经的人最终才更有机会登上华山之巅。</p>
</blockquote>
<p>怀着对程序员之巅的心向往之，我也对编译原理更生敬畏。</p>
<p>当然，如何让这门古老的屠龙术落地，而不至于成为学生心中虚无缥缈的空中楼阁。我个人认为可以再开设一些相关的新课题，让学生能够充分了解编译技术的实用性，从而能够自主学习、实践。我也希望《解释器构造实践》能成为一个不错的起点。</p>
<h2 id="初识-ANTLR"><a href="#初识-ANTLR" class="headerlink" title="初识 ANTLR"></a>初识 ANTLR</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 1 Meet ANTLR。书里的这一章主要是介绍 ANTLR 的下载安装方法，并运行了一个简单的 demo。</p>
</blockquote>
<h3 id="安装-ANTLR"><a href="#安装-ANTLR" class="headerlink" title="安装 ANTLR"></a>安装 ANTLR</h3><p>ANTLR 是用 Java 编写的，所以就算你想使用 C# 或者 C++ 来配合 ANTLR 生成解释器，安装 ANTLR 前也需要有 Java 环境。</p>
<p>之后需要下载 antlr-4.x-complete.jar（越新越好，4.x 指最新版本的版本号）并把它放在你记得住的地方。这个 jar 包包含了运行 ANTLR 工具所需要的所有依赖，还包含两个支持库：一个树状排版库，以及 StringTemplate，一个用于生成代码以及其他结构化文本的模版引擎。</p>
<p>安装的具体步骤请直接看<a href="http://www.antlr.org/" target="_blank" rel="external">官网</a>的 Quick Start，在此不作展示。</p>
<h2 id="ANTLR-全貌"><a href="#ANTLR-全貌" class="headerlink" title="ANTLR 全貌"></a>ANTLR 全貌</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 2 The Big Picture，书中这一章介绍了从字符流到语法分析树的过程、ANTLR 运行流程中的一些重要术语，以及ANTLR 自带的 Listener、Visitor 这两种遍历树的机制。</p>
</blockquote>
<p>想要实现一种语言，我们就需要构建读取句子的应用，并对输入的元素做出正确的反应。</p>
<p>如果一个应用可以计算或执行句子，我们就叫它<strong>解释器（interpreter）</strong>。包括计算器、配置文件读取器、Python 解释器都属于解释器。</p>
<p>而如果一个应用将句子转换成另一种语言，我们就叫它<strong>翻译器（translator）</strong>。例如 Java 到 C# 的翻译器和<strong>编译器</strong>都属于翻译器。</p>
<p>不管是解释器还是翻译器，想要正确运行，应用首先都要识别出所有有效的句子、词组、字词组等，识别语言的程序就叫<strong>解析器（parser）</strong>或<strong>语法分析器（syntax analyzer）</strong>。</p>
<p>完全 DIY 一个解析器非常麻烦，所以我们需要 ANTLR 的帮助。ANTLR 是一种能写出程序的程序，只需编写 ANTLR 的语法（grammars）文件，描述我们要解析的语言的语法，ANTLR 就能够自动生成用来解析这种语言的解析器。而用来声明我们语言的ANTLR语言的语法，就是<strong>元语言（meta-language）</strong>。</p>
<h3 id="最基本的解析过程"><a href="#最基本的解析过程" class="headerlink" title="最基本的解析过程"></a>最基本的解析过程</h3><p>为了简单起见，我们将解析分为两个阶段，第一阶段是<strong>词法分析（lexical analysis）</strong>，对应的分析程序叫做<strong>词法分析器（lexer）</strong>，负责将符号（token）分组成<strong>符号类（token class or token type）</strong>。而第二阶段就是真正的<em>语法分析</em>，默认 ANTLR 会构建出一棵<strong>语法分析树（parse tree / syntax tree）</strong>。下图展示了一个简单的赋值表达式的解析过程：</p>
<p><img src="/images/antlr/note1/antlr1.jpg"></p>
<p>语法树的叶子是输入的 token，而上级结点是包含其孩子结点的词组名（phase），线性的句子其实是语法树的序列化。最终生成语法树的好处是：</p>
<ol>
<li>树形结构易于遍历和处理，并且容易被程序员理解，方便了应用代码做进一步处理。</li>
<li>多种解释或翻译的应用代码都可以重用一个解析器。但 ANTLR 也支持像传统解析器生成器那样，将应用处理代码直接嵌入到语法中。</li>
<li>对于因为计算依赖而需要多趟处理的翻译器来说，比起多次调用解析器去解析，遍历语法树多次更加高效。</li>
</ol>
<h3 id="深入-ANTLR-的解析过程"><a href="#深入-ANTLR-的解析过程" class="headerlink" title="深入 ANTLR 的解析过程"></a>深入 ANTLR 的解析过程</h3><p>ANTLR 生成的解析器叫做<strong>递归下降语法分析器（recursive-descent parser）</strong>，属于自顶向下语法分析器（top-down parser）的一种。</p>
<p>顾名思义，递归下降指的就是解析过程是从语法树的根开始，向叶子（token）递归。还是以前面的赋值表达式解析为例，其递归下降语法分析器的代码大概是下面这个样子：</p>
<p><img src="/images/antlr/note1/antlr2.jpg"></p>
<p>很酷的一点是<code>stat()</code>、<code>assign()</code>、<code>expr()</code>等方法调用所形成的调用栈能与语法分析树的内部节点一一对应。<code>match()</code>的调用对应树的叶子，而<code>assign()</code>方法直接顺序读取输入字符，而不用做任何选择。相比之下，<code>stat()</code>方法要复杂一些，因为在解析时，它需要<strong>向前看（lookahead）</strong>一些字符才能确认走哪个代码分支，有时甚至要读取完所有输入才能得出预测结果。</p>
<p>虽然 ANTLR 默默地为我们处理了这整个过程，但对这个选择过程有一个基本的了解会使得对生成的解析器进行 debug 变得更加容易。</p>
<h3 id="用语法分析树构建语言应用"><a href="#用语法分析树构建语言应用" class="headerlink" title="用语法分析树构建语言应用"></a>用语法分析树构建语言应用</h3><p>在内部，ANTLR 的数据结构会尽可能地共享数据来节约内存。如下图所示，语法分析树的叶子节点指向 token 流中的 token，而 token 中的起止字符索引指向字符流，并不拷贝子字符串。而像空格这种不与任何 token 相关的字符会直接被 Lexer 丢弃掉。</p>
<p><img src="/images/antlr/note1/antlr3.jpg"></p>
<p>ANTLR 为每条规则都会生成一个 RuleNode，叫做<strong>上下文（Context）对象</strong>，它会记录根据规则识别词组时产生的所有上下文信息。每一个上下文对象都知道已经识别的短语的起始 token 和结束 token，并且提供了对这些短语的访问。例如，<code>AssignContext</code>提供<code>ID()</code>和<code>expr()</code>方法来访问标识符节点和表达式子树。</p>
<h3 id="语法分析树的-Listener-和-Visitor-机制"><a href="#语法分析树的-Listener-和-Visitor-机制" class="headerlink" title="语法分析树的 Listener 和 Visitor 机制"></a>语法分析树的 Listener 和 Visitor 机制</h3><p>ANTLR 在其运行库提供了 Listener 和 Visitor 两种语法分析树遍历机制。</p>
<h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>Listener 的特点是全自动化，我们不必写一个语法分析树的遍历器，ANTLR 会生成一个 ParseTreeWalker 的子类来主导深度优先遍历过程，我们只需处理各种事件就可以了。例如当遍历器遍历到<code>assign</code>规则的节点时，会触发<code>enterAssign()</code>并向其传递<code>AssignContext</code>参数；而当遍历器遍历完<code>assign</code>节点的所有子节点时，触发<code>exitAssign()</code>。下图展示了 ParseTreeWalker 如何进行深度优先遍历：</p>
<p><img src="/images/antlr/note1/antlr4.jpg"></p>
<p>而下图展示了 ParseTreeWalker 的完整监听器方法调用队列：</p>
<p><img src="/images/antlr/note1/antlr5.jpg"></p>
<h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h4><p>而 Visitor 则提供了可控的遍历方式，我们可以自行决定是否将子结点作为参数调用<code>visit()</code>方法。</p>
<p>在使用 ANTLR 生成时加上参数<code>-visitor</code>，会生成带有默认实现的 Visitor 实现类。我们不必实现接口中的每一个方法，只需要覆盖我们感兴趣的方法。</p>
<p><img src="/images/antlr/note1/antlr6.jpg"></p>
<h2 id="动手上路"><a href="#动手上路" class="headerlink" title="动手上路"></a>动手上路</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 3 A Starter ANTLR Project。</p>
</blockquote>
<h3 id="ANTLR-工具，运行时类库和生成代码"><a href="#ANTLR-工具，运行时类库和生成代码" class="headerlink" title="ANTLR 工具，运行时类库和生成代码"></a>ANTLR 工具，运行时类库和生成代码</h3><p>ANTLR 分为两个重要的部分：ANLTR 工具自身和 ANTLR 运行时（runtime） API。运行 ALTLR 工具会生成能够辨认语法所描述语言的句子的代码（词法分析程序和语法分析程序）；而运行时类库提供了生成代码所需的一系列类与方法，例如 Parser, Lexer 和 token。</p>
<p>我们先对一份语法运行 ANTLR，然后借助 jar 包中的运行时类库（runtime classes in the jar）对生成的代码进行编译。最后，编译得到的应用与运行库结合着运行。</p>
<p>《The Definitive ANTLR 4 Reference》（后文可能简写为《Reference》）给出了一份简单的示例，让我们可以快速了解 ANTLR 所需语法的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Grammers always start with a grammer header. This grammer */</span></div><div class="line"><span class="comment">/** is called ArrayInit and must match the filename: ArrayInit.g4 */</span></div><div class="line">grammar ArrayInit;</div><div class="line"></div><div class="line"><span class="comment">/** A rule called init that that matches comma-separated values between &#123;...&#125; */</span></div><div class="line">init : <span class="string">'&#123;'</span> value (<span class="string">','</span> value)* <span class="string">'&#125;'</span> ;  <span class="comment">// must match at least one value</span></div><div class="line"></div><div class="line"><span class="comment">/** A value can be either a nested array/struct or a simple integer (INT) */</span></div><div class="line">value : init</div><div class="line">      | INT</div><div class="line">      ;</div><div class="line">      </div><div class="line"><span class="comment">// parser rules start with lowercase letters, lexer rules with uppercase</span></div><div class="line">INT :  [<span class="number">0</span>-<span class="number">9</span>]+ ;              <span class="comment">// Define Token INT as one or more digits</span></div><div class="line">WS  :  [ \t\r\n]+ -&gt; skip ;  <span class="comment">// Define whitespace rule, toss it out</span></div></pre></td></tr></table></figure>
<p>之后通过命令行运行<code>antlr4 ArrayInit.g4</code>，ANTLR 为我们生成很多一般需要我们自己手写的文件：</p>
<p><img src="/images/antlr/note1/antlr-generation.jpg"></p>
<p>这些文件的功能如下：</p>
<ul>
<li>ArrayInitParser.java：包含了专用于 ArrayInit 语法的解析器（parser）类的定义。</li>
<li>ArrayInitLexer.java：包含专用的词法分析程序（lexer）类的定义。</li>
<li>ArrayInit.Tokens：对于我们定义的每个 token，ANTLR 分配了一个 token 类型码（token type number）并将这些值保存在 ArrayInit.tokens。因为这个文件的存在，当我们将较大规模的语法分割为各种小型的语法表达时，ANTLR 能够使同种 token 的类型码保持一致。</li>
<li>ArrayInitListener.java, ArrayInitBaseListener.java：ANTLR 生成的解释器会默认根据输入构建一棵树。通过遍历这棵树，一个遍历器可以将事件（回调函数）传递给我们提供的监听者对象（listener object）。ArrayInitListener 是描述我们可以实现的回调函数的接口，而ArrayInitBaseListener 是默认空实现的集合，使我们可以方便的重写（override）那些我们感兴趣的回调函数。通过<code>-visitor</code>命令行参数，ANTLR 也可以为我们生成树的 visitors。</li>
</ul>
<h3 id="测试生成的解析器"><a href="#测试生成的解析器" class="headerlink" title="测试生成的解析器"></a>测试生成的解析器</h3><p>之后，我们通过<code>javac *.java</code>来编译 ANTLR 生成的所有代码。UNIX 系统用户可以将以下代码写入<code>.bash_profile</code>或其他启动脚本，以免每次都要在命令行输入一遍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> CLASSPATH=<span class="string">".:/usr/local/lib/antlr-4.7-complete.jar:<span class="variable">$CLASSPATH</span>"</span></div><div class="line"><span class="built_in">alias</span> antlr4=<span class="string">'java -jar /usr/local/lib/antlr-4.7-complete.jar'</span></div><div class="line"><span class="built_in">alias</span> grun=<span class="string">'java org.antlr.v4.gui.TestRig'</span></div></pre></td></tr></table></figure>
<p>之后就可以通过<code>grun</code>命令来测试生成的解析器了。注意输入要以 EOF（Unix 系统 Ctrl + D，Windows 系统 Ctrl + Z）作为结束。加上<code>-tokens</code>命令行参数，输出的每一行会展示一个单独的 token 及其所有信息：</p>
<p><img src="/images/antlr/note1/grun-the-example1.jpg"></p>
<p><code>-tree</code>会生成一个 Lisp 风格的简单语法分析树：</p>
<p><img src="/images/antlr/note1/grun-the-example2.jpg"></p>
<p>而<code>-gui</code>会生成一个展示语法分析树的 GUI 界面：</p>
<p><img src="/images/antlr/note1/grun-the-example3.jpg"></p>
<p><img src="/images/antlr/note1/grun-the-example4.jpg"></p>
<p>根据我们定义的语法规则，ANTLR 自动生成了这棵语法分析树。之后我们会利用 ANTLR 内置的遍历器触发<code>enterInit()</code>和<code>enterValue()</code>等各种回调函数。</p>
<h3 id="将生成的解析器集成进-Java-程序"><a href="#将生成的解析器集成进-Java-程序" class="headerlink" title="将生成的解析器集成进 Java 程序"></a>将生成的解析器集成进 Java 程序</h3><p>我们来写一个简单的 Java <code>main()</code>方法来集成生成的解析器，并打印出和使用<code>-tree</code>参数一样的语法分析树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import ANTLR's runtime libraries</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// create a CharStream that reads from standard input</span></div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</div><div class="line">        </div><div class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></div><div class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</div><div class="line">        </div><div class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        </div><div class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></div><div class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</div><div class="line">        </div><div class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></div><div class="line">        System.out.println(tree.toStringTree(parser));  <span class="comment">// print LISP-style tree</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果如下。语法错误也可以被报告：</p>
<p><img src="/images/antlr/note1/integrating-test.jpg"></p>
<h3 id="构建语言应用"><a href="#构建语言应用" class="headerlink" title="构建语言应用"></a>构建语言应用</h3><p>我们的目标不仅仅是识别，还想做一些翻译工作。最简单的方法是利用 ANTLR 内置的语法分析树遍历器，这样我们不需要自己去进行树遍历，大大减少了工作量。</p>
<p>我们给 ArrayInit 加一个新需求：将 short 数组<code>{99, 3, 451}</code>翻译为字符串<code>\u0063\u0003\u01c3</code>。实现这个需求，我们只需要继承<code>ArrayInitBaseListener</code>，来实现其中的一些监听器方法。</p>
<p>我们在 ShortToUnicodeString.java 中实现我们的监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Convert short array inits like &#123;1, 2, 3&#125; to "\u0001\u0002\u0003" */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToUnicodeString</span> <span class="keyword">extends</span> <span class="title">ArrayInitBaseListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">'"'</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">'"'</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterValue</span><span class="params">(ArrayInitParser.ValueContext ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> value = Integer.valueOf(ctx.INT().getText());</div><div class="line">        System.out.printf(<span class="string">"\\u%04x"</span>, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们不需要覆盖每一个<code>enter/exit</code>方法，只需要实现我们需要的那些。代码里<code>ctx.INT()</code>代表上下文对象请求已经匹配的整数 INT 的值。记住我们之前提到的，上下文对象会记录根据规则识别词组时产生的所有信息。</p>
<p>接下来，我们要创建一个主程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import ANTLR's runtime libraries</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</div><div class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// create a CharStream that reads from standard input</span></div><div class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</div><div class="line">        </div><div class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></div><div class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</div><div class="line">        </div><div class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></div><div class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</div><div class="line">        </div><div class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></div><div class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</div><div class="line">        </div><div class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></div><div class="line">        </div><div class="line">        <span class="comment">// Create a generic parse tree walker that can trigger callbacks</span></div><div class="line">        ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</div><div class="line">        </div><div class="line">        <span class="comment">// Walk the tree created during the parse, trigger callbacks</span></div><div class="line">        walker.walk(<span class="keyword">new</span> ShortToUnicodeString(), tree);</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比起上一节的主程序，我们多创建了一个树遍历器（<code>ParseTreeWalker walker</code>），并用它来遍历语法分析器返回的语法分析树，它会触发<code>ShortToUnicodeString</code>中的回调方法。</p>
<p>javac 进行编译后就可以使用了：</p>
<p><img src="/images/antlr/note1/translate-test.jpg"></p>
<p>我们可以通过传入不同的监听器来产生完全不同的输出。监听器将语法和我们的语言应用很大程度上解耦了，使语法具有了更大的重用性。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>第一篇笔记到这里就结束了。我们聊了一下我对编译技术的一点看法，并阅读了《The Definitive ANTLR 4 Reference》的前三章。而书的 Part I: Introducing ANTLR and Computer Languages 还剩第四章 A Quick Tour，根据实验课的要求，这一章我会单独写一篇学习笔记，示例与内容也会和书上有一些区别。在这之后我会继续学习解释器构造，并继续写这本书的阅读笔记，敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/dc_726/article/details/45399371" target="_blank" rel="external">Antlr v4入门教程和实例 - 西代零零发 - CSDN博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。&lt;/p&gt;
&lt;p&gt;课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。&lt;/p&gt;
&lt;p&gt;ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。&lt;/p&gt;
&lt;p&gt;更新记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布&lt;/li&gt;
&lt;li&gt;17.09.11 Chapter 3 阅读完毕，增加动手上路章节。&lt;/li&gt;
&lt;li&gt;17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="解释器构造" scheme="http://kyonhuang.top/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="ANTLR" scheme="http://kyonhuang.top/tags/ANTLR/"/>
    
      <category term="编译技术" scheme="http://kyonhuang.top/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="解释器" scheme="http://kyonhuang.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Node 异步 I/O</title>
    <link href="http://kyonhuang.top/async-IO-in-Node/"/>
    <id>http://kyonhuang.top/async-IO-in-Node/</id>
    <published>2017-09-02T12:43:16.000Z</published>
    <updated>2017-09-20T07:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。</p>
<p>Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。</p>
<p>因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。</p>
<p>这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。</p>
<a id="more"></a>
<h2 id="选择异步的原因"><a href="#选择异步的原因" class="headerlink" title="选择异步的原因"></a>选择异步的原因</h2><p>选择异步的原因包括用户体验和资源分配两个方面。</p>
<p>从用户体验的角度分析，浏览器中 JavaScript 在单线程上执行，并且与 UI 渲染共用一个线程。因此采用异步请求将使下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为。</p>
<p>而从资源分配角度来看，当遇到一组互不相关的任务需要完成的场景时，主流选择有以下两种：</p>
<ul>
<li>单线程串行依次执行：容易导致阻塞，硬件资源难以有效利用；</li>
<li>多线程并行：创建线程和执行期线程上下文切换的开销较大，且经常面临锁、状态同步等问题（但多线程在多核 CPU 上能够有效提升 CPU 的利用率）；</li>
</ul>
<p>而 Node 给出的解决方案是：利用<strong>单线程</strong>，远离多线程死锁、状态同步等问题；利用<strong>异步 I/O</strong>，让单线程远离阻塞以更好地利用 CPU。</p>
<p>而为了弥补单线程无法有效利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效利用 CPU 和 I/O。</p>
<h2 id="从操作系统看异步-I-O"><a href="#从操作系统看异步-I-O" class="headerlink" title="从操作系统看异步 I/O"></a>从操作系统看异步 I/O</h2><p>Node 的异步 I/O 不可否认地受到操作系统中异步 I/O 实现的启发。</p>
<p>要强调的是，从计算机内核 I/O 而言，<strong>异步/同步和阻塞/非阻塞实际上是两回事</strong>。</p>
<h3 id="阻塞-非阻塞-I-O"><a href="#阻塞-非阻塞-I-O" class="headerlink" title="阻塞/非阻塞 I/O"></a>阻塞/非阻塞 I/O</h3><p>在调用<strong>阻塞 I/O</strong> 时，应用程序需要等待 I/O 完成时才返回结果。特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束，因此造成 <strong>CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用</strong>。</p>
<p>与阻塞 I/O 完成整个获取数据的过程相比，<strong>非阻塞 I/O</strong> 则<strong>不带数据直接返回</strong>，要获取数据还需要通过<strong>文件描述符</strong>再次读取。非阻塞 I/O 返回之后，CPU 的时间片可以用来处理其他事务。</p>
<p>但由于完整的 I/O 并没有完成，非阻塞 I/O 立即返回的仅仅是当前调用的状态。为了获取完整数据，需要<strong>轮询</strong>这种重复调用以判断操作是否完成的技术。</p>
<p>现存的轮询技术包括 <strong>read</strong>（通过重复调用检查 I/O 状态，性能最低，CPU 一直等待）、<strong>select</strong>（通过对文件描述符上的事件状态进行判断）、<strong>poll</strong>（比 select 有所改进，但性能仍较低）、<strong>epoll</strong>（Linux 下<strong>效率最高</strong>的 I/O 事件通知机制，进入轮询时休眠，直到事件发生将其唤醒）和<strong>kqueue</strong>（与 epoll 类似，仅在 FreeBSD 系统存在）。</p>
<p>虽然轮询技术能够满足了非阻塞 I/O 确保获取完整数据的需求，但应用程序依旧花费了很多时间来等待 I/O 完全返回。等待期间，CPU 要么用于<strong>遍历文件描述符的状态</strong>，要么用于<strong>休眠等待事件发生</strong>。因此，<strong>它仍然只能算是一种同步</strong>。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>在看廖雪峰的 Python 教程的异步 IO 这一章时，在评论区看到一个对于阻塞/非阻塞和同步/异步非常精妙的解释，十分容易理解和记忆，特摘录如下：</p>
<blockquote>
<p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p>
<p>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻</p>
<p>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</p>
<p>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大</p>
<p>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p>
<p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p>
<p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</blockquote>
<h3 id="异步-I-O-的实现"><a href="#异步-I-O-的实现" class="headerlink" title="异步 I/O 的实现"></a>异步 I/O 的实现</h3><p>我们期望的完美异步 I/O 应该是：应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序即可。</p>
<p>Linux 原生提供 AIO 这种符合要求的异步 I/O 方式，但只有 Linux 下有，且其无法利用系统缓存。因此现实情况下，想在单线程场景完美实现异步 I/O 有些难度。</p>
<p>而在<strong>多线程</strong>，通过<strong>让部分线程进行阻塞 I/O 或者非阻塞 I/O 加载轮询技术来完成数据获取，让一个线程进行计算处理，再通过线程间的通信将 I/O 得到的数据进行传递</strong>，可以模拟异步 I/O。</p>
<p>*nix 平台，Node 自行实现了线程池来完成异步 I/O；Windows 平台则采用 IOCP 实现。Node 提供了 libuv 作为抽象封装层，平台兼容性由这一层完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。</p>
<p>Node 在<strong>编译期间判断平台条件</strong>，选择性编译 unix 目录或 win 目录下的源文件到目标程序中。</p>
<ul>
<li>我们常说的“Node 是单线程的”里的“单线程”仅指 <strong>JavaScript 执行在单线程</strong>。而内部完成 I/O 任务的另有线程池，只是 I/O 线程使用的 CPU 较少。</li>
<li>除了用户代码无法并行执行外，所有的 I/O （磁盘 I/O 和网络 I/O 等）可以并行。</li>
</ul>
<h2 id="Node-的异步-I-O"><a href="#Node-的异步-I-O" class="headerlink" title="Node 的异步 I/O"></a>Node 的异步 I/O</h2><p><strong>事件循环</strong>、<strong>观察者</strong>、<strong>请求对象</strong>、<strong>I/O 线程池</strong>一同构成了 Node 异步 I/O 模型的基本要素。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>每执行一次循环体的过程被称为 <strong>Tick</strong>，查看是否有事件待处理，若有则取出事件及相关回调函数。如果存在关联的回调函数，就执行它们。直到没有事件，进入下个循环。</p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>每个事件循环中有一个或者多个观察者，<strong>判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</strong>。</p>
<p>事件循环是一个典型的<strong>生产者/消费者模型</strong>。<em>异步 I/O、网络请求</em>是事件的<em>生产者</em>，事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。<strong>观察者相当于事件池</strong>。</p>
<p>在 Windows 下，这个循环基于 IOCP 创建，而在 *unix 下基于多线程创建。</p>
<h3 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h3><p>请求对象是从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中的重要<strong>中间产物</strong>。所有的状态都保存在这个对象中，包括<strong>送入 I/O 线程池等待执行</strong>以及 I/O 操作完毕后的回调处理。</p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><p>组装好请求对象、送入 I/O 线程池等待执行，构成了异步 I/O 的第一部分。而回调通知是第二部分。</p>
<p>线程池中的 I/O 操作调用完毕后，会调用方法向 IOCP 提交执行状态，并将线程归还线程池。</p>
<p>在每次 Tick 的执行中，I/O 观察者会调用方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。</p>
<p>整个异步 I/O 流程图如下：</p>
<p><img src="/images/async IO model.jpg"></p>
<h2 id="非-I-O-的异步-API"><a href="#非-I-O-的异步-API" class="headerlink" title="非 I/O 的异步 API"></a>非 I/O 的异步 API</h2><p>Node 中还存在一些与 I/O 无关的异步 API：<code>setTimeout()</code>、<code>setInterval()</code>、<code>setImmediate()</code>、<code>process.nextTick()</code>。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><code>setTimeout()</code>和<code>setInterval()</code>与浏览器 API 一致，创建的定时器会被插入到<strong>定时器观察者内部的一个红黑树</strong>中。每次 Tick 执行时，会从该红黑树中<strong>迭代</strong>取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件并执行其回调函数。注意：由于事件循环自身特点，定时器并非精确的。</p>
<h3 id="process-nextTick-amp-setImmediate"><a href="#process-nextTick-amp-setImmediate" class="headerlink" title="process.nextTick() &amp; setImmediate()"></a>process.nextTick() &amp; setImmediate()</h3><p>两者都可用于将回调函数延迟执行，以异步执行一个任务。两者的区别如下：</p>
<ul>
<li><p>优先级：<code>process.nextTick()</code>中回调函数执行优先级要高于<code>setImmediate()</code>，原因在于<strong>事件循环对观察者的检查是有先后顺序的</strong>，idle 观察者（<code>process.nextTick()</code>） &gt; I/O 观察者 &gt; check 观察者（<code>setImmediate()</code>）。</p>
</li>
<li><p>具体实现：<code>process.nextTick()</code>的回调函数保存在一个<em>数组</em>中，<code>setImmediate()</code>保存在<em>链表</em>中。</p>
</li>
<li><p>行为：<code>process.nextTick()</code>在每轮循环中会将数组中的回调函数<em>全部执行</em>完，而<code>setImmediate()</code>在每轮循环中执行链表中的<em>一个</em>回调函数。这样的设计是为了保证每轮循环能够较快地执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。</p>
</li>
</ul>
<h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p>事件驱动的实质：通过<strong>主循环加事件触发</strong>的方式来运行程序。</p>
<p>几种经典的服务器模型各有其优缺点：</p>
<ul>
<li><strong>同步式</strong>：对于同步式的服务，一次只能处理一个请求，并且其他请求都处于等待状态。</li>
<li><strong>每进程/每请求</strong>：为每个请求启动一个进程，这样可以处理多个请求，但因为系统资源有限而不具备扩展性。</li>
<li><strong>每线程/每请求</strong>：为每个请求启动一个线程来处理。扩展性强于每进程/每请求，但由于每个线程都占用一定内存，大并发到来时内存还是会很快用光。</li>
</ul>
<p>Apache 目前还采用每线程/每请求，而 Nginx 采用事件驱动。</p>
<p>Nginx 与 Node 比较：</p>
<ul>
<li>Nginx 采用纯 C 写成，性能较高，但仅适合做 Web 服务器，用于反向代理或负载均衡等服务，在处理具体业务方面欠缺；</li>
<li>Node 是一套高性能平台，没有 Nginx 在 Web 服务器方面那么专业，但场景更大，可以处理各种具体业务。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入浅出Node.js》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。&lt;/p&gt;
&lt;p&gt;Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。&lt;/p&gt;
&lt;p&gt;因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。&lt;/p&gt;
&lt;p&gt;这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS 学习笔记" scheme="http://kyonhuang.top/categories/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://kyonhuang.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="NodeJS" scheme="http://kyonhuang.top/tags/NodeJS/"/>
    
      <category term="异步 I/O" scheme="http://kyonhuang.top/tags/%E5%BC%82%E6%AD%A5-I-O/"/>
    
  </entry>
  
</feed>
